[
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1125,
        "instance_id": "asterinas__asterinas-1125",
        "issue_numbers": [
            "1106"
        ],
        "base_commit": "d04111079cb8edf03d9a58b2bd88d4af4b11543a",
        "patch": "diff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -26,7 +26,7 @@ pub(crate) use ostd::{\n #[macro_export]\n macro_rules! current {\n     () => {\n-        $crate::process::current()\n+        $crate::process::Process::current().unwrap()\n     };\n }\n \ndiff --git a/kernel/aster-nix/src/process/mod.rs b/kernel/aster-nix/src/process/mod.rs\n--- a/kernel/aster-nix/src/process/mod.rs\n+++ b/kernel/aster-nix/src/process/mod.rs\n@@ -23,8 +23,7 @@ pub use credentials::{credentials, credentials_mut, Credentials, Gid, Uid};\n pub use exit::do_exit_group;\n pub use kill::{kill, kill_all, kill_group, tgkill};\n pub use process::{\n-    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid,\n-    Terminal,\n+    ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid, Terminal,\n };\n pub use process_filter::ProcessFilter;\n pub use process_vm::{MAX_ARGV_NUMBER, MAX_ARG_LEN, MAX_ENVP_NUMBER, MAX_ENV_LEN};\ndiff --git a/kernel/aster-nix/src/process/process/mod.rs b/kernel/aster-nix/src/process/process/mod.rs\n--- a/kernel/aster-nix/src/process/process/mod.rs\n+++ b/kernel/aster-nix/src/process/process/mod.rs\n@@ -103,6 +103,15 @@ pub struct Process {\n }\n \n impl Process {\n+    /// Returns the current process.\n+    ///\n+    /// It returns `None` if:\n+    ///  - the function is called in the bootstrap context;\n+    ///  - or if the current task is not associated with a process.\n+    pub fn current() -> Option<Arc<Process>> {\n+        Some(Thread::current()?.as_posix_thread()?.process())\n+    }\n+\n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -1,7 +1,5 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-#![allow(dead_code)]\n-\n use alloc::{boxed::Box, sync::Arc};\n use core::{\n     cell::RefCell,\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -10,7 +8,7 @@ use core::{\n };\n \n use intrusive_collections::{intrusive_adapter, LinkedList, LinkedListAtomicLink};\n-use ostd::{cpu_local, trap::SoftIrqLine, CpuLocal};\n+use ostd::{cpu::local::CpuLocal, cpu_local, trap::SoftIrqLine};\n \n use crate::softirq_id::{TASKLESS_SOFTIRQ_ID, TASKLESS_URGENT_SOFTIRQ_ID};\n \ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -5,7 +5,7 @@ use core::mem;\n use aster_rights::Full;\n use ostd::{\n     mm::{KernelSpace, VmIo, VmReader, VmWriter},\n-    task::current_task,\n+    task::Task,\n };\n \n use crate::{prelude::*, vm::vmar::Vmar};\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -34,14 +34,8 @@ pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space.vm_space().reader(src, copy_len)?;\n     user_reader.read_fallible(dest).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -54,14 +48,8 @@ pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space\n         .vm_space()\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -88,14 +76,8 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space.vm_space().writer(dest, copy_len)?;\n     user_writer.write_fallible(src).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -108,14 +90,8 @@ pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space\n         .vm_space()\ndiff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -122,13 +122,7 @@ SECTIONS\n \n         # These 4 bytes are used to store the CPU ID.\n         . += 4;\n-\n-        # These 4 bytes are used to store the number of preemption locks held.\n-        # The reason is stated in the Rust documentation of\n-        # [`ostd::task::processor::PreemptInfo`].\n-        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n-        . += 4;\n-\n+        \n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -230,7 +230,7 @@ pub fn trace_panic_from_log(qemu_log: File, bin_path: PathBuf) {\n         .spawn()\n         .unwrap();\n     for line in lines.into_iter().rev() {\n-        if line.contains(\"printing stack trace:\") {\n+        if line.contains(\"Printing stack trace:\") {\n             println!(\"[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\");\n             trace_exists = true;\n         }\ndiff --git a/ostd/src/arch/x86/cpu/local.rs b/ostd/src/arch/x86/cpu/local.rs\n--- a/ostd/src/arch/x86/cpu/local.rs\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -23,65 +23,205 @@ pub(crate) fn get_base() -> u64 {\n     FS::read_base().as_u64()\n }\n \n-pub mod preempt_lock_count {\n-    //! We need to increment/decrement the per-CPU preemption lock count using\n-    //! a single instruction. This requirement is stated by\n-    //! [`crate::task::processor::PreemptInfo`].\n-\n-    /// The GDT ensures that the FS segment is initialized to zero on boot.\n-    /// This assertion checks that the base address has been set.\n-    macro_rules! debug_assert_initialized {\n-        () => {\n-            // The compiler may think that [`super::get_base`] has side effects\n-            // so it may not be optimized out. We make sure that it will be\n-            // conditionally compiled only in debug builds.\n-            #[cfg(debug_assertions)]\n-            debug_assert_ne!(super::get_base(), 0);\n-        };\n-    }\n+use crate::cpu::local::single_instr::{\n+    SingleInstructionAddAssign, SingleInstructionBitAndAssign, SingleInstructionBitOrAssign,\n+    SingleInstructionBitXorAssign, SingleInstructionLoad, SingleInstructionStore,\n+    SingleInstructionSubAssign,\n+};\n \n-    /// Increments the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn inc() {\n-        debug_assert_initialized!();\n+/// The GDT ensures that the FS segment is initialized to zero on boot.\n+/// This assertion checks that the base address has been set.\n+macro_rules! debug_assert_initialized {\n+    () => {\n+        // The compiler may think that [`super::get_base`] has side effects\n+        // so it may not be optimized out. We make sure that it will be\n+        // conditionally compiled only in debug builds.\n+        #[cfg(debug_assertions)]\n+        debug_assert_ne!(get_base(), 0);\n+    };\n+}\n+\n+macro_rules! impl_numeric_single_instruction_for {\n+    ($([$typ: ty, $inout_type: ident, $register_format: expr])*) => {$(\n+\n+        impl SingleInstructionAddAssign<$typ> for $typ {\n+            unsafe fn add_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly increments the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"add fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n-    }\n \n-    /// Decrements the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn dec() {\n-        debug_assert_initialized!();\n+        impl SingleInstructionSubAssign<$typ> for $typ {\n+            unsafe fn sub_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"sub fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitAndAssign<$typ> for $typ {\n+            unsafe fn bitand_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"and fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitOrAssign<$typ> for $typ {\n+            unsafe fn bitor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"or fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitXorAssign<$typ> for $typ {\n+            unsafe fn bitxor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"xor fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0\", $register_format, \"}, fs:[{1}]\"),\n+                    out($inout_type) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+    )*};\n+}\n+\n+impl_numeric_single_instruction_for!(\n+    [u64,   reg,    \":r\"]\n+    [usize, reg,    \":r\"]\n+    [u32,   reg,    \":e\"]\n+    [u16,   reg,    \":x\"]\n+    [u8,    reg_byte, \"\"]\n+    [i64,   reg,    \":r\"]\n+    [isize, reg,    \":r\"]\n+    [i32,   reg,    \":e\"]\n+    [i16,   reg,    \":x\"]\n+    [i8,    reg_byte, \"\"]\n+);\n+\n+macro_rules! impl_generic_single_instruction_for {\n+    ($([<$gen_type:ident $(, $more_gen_type:ident)*>, $typ:ty])*) => {$(\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0}, fs:[{1}]\"),\n+                    out(reg) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly decrements the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1}\"),\n+                    in(reg) offset,\n+                    in(reg) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n+    )*}\n+}\n+\n+impl_generic_single_instruction_for!(\n+    [<T>, *const T]\n+    [<T>, *mut T]\n+    [<T, R>, fn(T) -> R]\n+);\n+\n+// In this module, booleans are represented by the least significant bit of a\n+// `u8` type. Other bits must be zero. This definition is compatible with the\n+// Rust reference: <https://doc.rust-lang.org/reference/types/boolean.html>.\n+\n+impl SingleInstructionLoad for bool {\n+    unsafe fn load(offset: *const Self) -> Self {\n+        debug_assert_initialized!();\n+\n+        let val: u8;\n+        core::arch::asm!(\n+            \"mov {0}, fs:[{1}]\",\n+            out(reg_byte) val,\n+            in(reg) offset,\n+            options(nostack, readonly),\n+        );\n+        debug_assert!(val == 1 || val == 0);\n+        val == 1\n     }\n+}\n \n-    /// Gets the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn get() -> u32 {\n+impl SingleInstructionStore for bool {\n+    unsafe fn store(offset: *mut Self, val: Self) {\n         debug_assert_initialized!();\n \n-        let count: u32;\n-        // SAFETY: The inline assembly reads the lock count in one instruction\n-        // without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n-                out(reg) count,\n-                options(nostack, readonly),\n-            );\n-        }\n-        count\n+        let val: u8 = if val { 1 } else { 0 };\n+        core::arch::asm!(\n+            \"mov fs:[{0}], {1}\",\n+            in(reg) offset,\n+            in(reg_byte) val,\n+            options(nostack),\n+        );\n     }\n }\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -73,7 +73,7 @@ pub(crate) fn init_on_bsp() {\n \n     // SAFETY: no CPU local objects have been accessed by this far. And\n     // we are on the BSP.\n-    unsafe { crate::cpu::cpu_local::init_on_bsp() };\n+    unsafe { crate::cpu::local::init_on_bsp() };\n \n     crate::boot::smp::boot_all_aps();\n \ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -2,8 +2,6 @@\n \n //! Handles trap.\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use align_ext::AlignExt;\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -15,25 +13,25 @@ use super::ex_table::ExTable;\n use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, CpuExceptionInfo, PageFaultErrorCode, PAGE_FAULT},\n-    cpu_local,\n+    cpu_local_cell,\n     mm::{\n         kspace::{KERNEL_PAGE_TABLE, LINEAR_MAPPING_BASE_VADDR, LINEAR_MAPPING_VADDR_RANGE},\n         page_prop::{CachePolicy, PageProperty},\n         PageFlags, PrivilegedPageFlags as PrivFlags, MAX_USERSPACE_VADDR, PAGE_SIZE,\n     },\n-    task::current_task,\n+    task::Task,\n     trap::call_irq_callback_functions,\n };\n \n-cpu_local! {\n-    static IS_KERNEL_INTERRUPTED: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IS_KERNEL_INTERRUPTED: bool = false;\n }\n \n /// Returns true if this function is called within the context of an IRQ handler\n /// and the IRQ occurs while the CPU is executing in the kernel mode.\n /// Otherwise, it returns false.\n pub fn is_kernel_interrupted() -> bool {\n-    IS_KERNEL_INTERRUPTED.load(Ordering::Acquire)\n+    IS_KERNEL_INTERRUPTED.load()\n }\n \n /// Only from kernel\ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -64,15 +62,15 @@ extern \"sysv64\" fn trap_handler(f: &mut TrapFrame) {\n             }\n         }\n     } else {\n-        IS_KERNEL_INTERRUPTED.store(true, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(true);\n         call_irq_callback_functions(f, f.trap_num);\n-        IS_KERNEL_INTERRUPTED.store(false, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(false);\n     }\n }\n \n /// Handles page fault from user space.\n fn handle_user_page_fault(f: &mut TrapFrame, page_fault_addr: u64) {\n-    let current_task = current_task().unwrap();\n+    let current_task = Task::current().unwrap();\n     let user_space = current_task\n         .user_space()\n         .expect(\"the user space is missing when a page fault from the user happens.\");\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -115,7 +115,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n \n     // SAFETY: we are on the AP.\n     unsafe {\n-        cpu::cpu_local::init_on_ap(local_apic_id);\n+        cpu::local::init_on_ap(local_apic_id);\n     }\n \n     trap::init();\ndiff --git /dev/null b/ostd/src/cpu/local/cell.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/cell.rs\n@@ -0,0 +1,247 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The implementaion of CPU-local variables that have inner mutability.\n+\n+use core::cell::UnsafeCell;\n+\n+use super::{__cpu_local_end, __cpu_local_start, single_instr::*};\n+use crate::arch;\n+\n+/// Defines an inner-mutable CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocalCell`].\n+///\n+/// It should be noted that if the interrupts or preemption is enabled, two\n+/// operations on the same CPU-local cell variable may access different objects\n+/// since the task may live on different CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::cpu_local_cell;\n+///\n+/// cpu_local_cell! {\n+///     static FOO: u32 = 1;\n+///     pub static BAR: *const usize = core::ptr::null();\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let bar_var: usize = 1;\n+///     BAR.store(&bar_var as *const _);\n+///     // Note that the value of `BAR` here doesn't nessarily equal to the address\n+///     // of `bar_var`, since the task may be preempted and moved to another CPU.\n+///     // You can avoid this by disabling interrupts (and preemption, if needed).\n+///     println!(\"BAR VAL: {:?}\", BAR.load());\n+///\n+///     let _irq_guard = ostd::trap::disable_local_irq();\n+///     println!(\"1st FOO VAL: {:?}\", FOO.load());\n+///     // No suprises here, the two accesses must result in the same value.\n+///     println!(\"2nd FOO VAL: {:?}\", FOO.load());\n+/// }\n+/// ```\n+macro_rules! cpu_local_cell {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocalCell<$t> = {\n+                let val = $init;\n+                // SAFETY: The CPU local variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocalCell::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+pub(crate) use cpu_local_cell;\n+\n+/// Inner mutable CPU-local objects.\n+///\n+/// CPU-local cell objects are only accessible from the current CPU. When\n+/// accessing an underlying object using the same `CpuLocalCell` instance, the\n+/// actually accessed object is always on the current CPU. So in a preemptive\n+/// kernel task, the operated object may change if interrupts are enabled.\n+///\n+/// The inner mutability is provided by single instruction operations, and the\n+/// CPU-local cell objects will not ever be shared between CPUs. So it is safe\n+/// to modify the inner value without any locks.\n+///\n+/// You should only create the CPU-local cell object using the macro\n+/// [`cpu_local_cell!`].\n+///\n+/// For the difference between [`super::CpuLocal`] and [`CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocalCell<T: 'static>(UnsafeCell<T>);\n+\n+impl<T: 'static> CpuLocalCell<T> {\n+    /// Initialize a CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(UnsafeCell::new(val))\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that within the entire execution of this\n+    /// function, no interrupt or preemption can occur. Otherwise, the\n+    /// returned pointer may points to the variable in another CPU.\n+    pub unsafe fn as_ptr_mut(&'static self) -> *mut T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value T\n+// of a cpu-local variable even if `T` is not `Sync`.\n+unsafe impl<T: 'static> Sync for CpuLocalCell<T> {}\n+\n+// Prevent valid instances of CpuLocalCell from being copied to any memory\n+// area outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocalCell<T> {}\n+impl<T: 'static> !Clone for CpuLocalCell<T> {}\n+\n+// In general, it does not make any sense to send instances of CpuLocalCell to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocalCell<T> {}\n+\n+// Accessors for the per-CPU objects whose type implements the single-\n+// instruction operations.\n+\n+impl<T: 'static + SingleInstructionAddAssign<T>> CpuLocalCell<T> {\n+    /// Adds a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn add_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::add_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionSubAssign<T>> CpuLocalCell<T> {\n+    /// Subtracts a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn sub_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::sub_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitAndAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ANDs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitand_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitand_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitOrAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitXorAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise XORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitxor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitxor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionLoad> CpuLocalCell<T> {\n+    /// Gets the value of the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn load(&'static self) -> T {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid.\n+        unsafe { T::load(offset as *const T) }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionStore> CpuLocalCell<T> {\n+    /// Writes a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn store(&'static self, val: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::store(offset as *mut T, val);\n+        }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/cpu/local/cpu_local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/cpu_local.rs\n@@ -0,0 +1,210 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The CPU-local variable implementation.\n+\n+use core::{marker::Sync, ops::Deref};\n+\n+use super::{__cpu_local_end, __cpu_local_start};\n+use crate::{\n+    arch,\n+    trap::{self, DisabledLocalIrqGuard},\n+};\n+\n+/// Defines a CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocal`].\n+///\n+/// You can get the reference to the inner object by calling [`deref`]. But\n+/// it is worth noting that the object is always the one in the original core\n+/// when the reference is created. Use [`CpuLocal::borrow_irq_disabled`] if\n+/// this is not expected, or if the inner type can't be shared across CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::{cpu_local, sync::SpinLock};\n+/// use core::sync::atomic::{AtomicU32, Ordering};\n+///\n+/// cpu_local! {\n+///     static FOO: AtomicU32 = AtomicU32::new(1);\n+///     pub static BAR: SpinLock<usize> = SpinLock::new(2);\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let ref_of_foo = FOO.deref();\n+///     // Note that the value of `FOO` here doesn't necessarily equal to the value\n+///     // of `FOO` of exactly the __current__ CPU. Since that task may be preempted\n+///     // and moved to another CPU since `ref_of_foo` is created.\n+///     let val_of_foo = ref_of_foo.load(Ordering::Relaxed);\n+///     println!(\"FOO VAL: {}\", val_of_foo);\n+///\n+///     let bar_guard = BAR.lock_irq_disabled();\n+///     // Here the value of `BAR` is always the one in the __current__ CPU since\n+///     // interrupts are disabled and we do not explicitly yield execution here.\n+///     let val_of_bar = *bar_guard;\n+///     println!(\"BAR VAL: {}\", val_of_bar);\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! cpu_local {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocal<$t> = {\n+                let val = $init;\n+                // SAFETY: The per-CPU variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocal::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+/// CPU-local objects.\n+///\n+/// CPU-local objects are instanciated once per CPU core. They can be shared to\n+/// other cores. In the context of a preemptible kernel task, when holding the\n+/// reference to the inner object, the object is always the one in the original\n+/// core (when the reference is created), no matter which core the code is\n+/// currently running on.\n+///\n+/// For the difference between [`CpuLocal`] and [`super::CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocal<T: 'static>(T);\n+\n+impl<T: 'static> CpuLocal<T> {\n+    /// Creates a new CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(val)\n+    }\n+\n+    /// Get access to the underlying value with IRQs disabled.\n+    ///\n+    /// By this method, you can borrow a reference to the underlying value\n+    /// even if `T` is not `Sync`. Because that it is per-CPU and IRQs are\n+    /// disabled, no other running tasks can access it.\n+    pub fn borrow_irq_disabled(&'static self) -> CpuLocalDerefGuard<'_, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Created(trap::disable_local()),\n+        }\n+    }\n+\n+    /// Get access to the underlying value with a provided guard.\n+    ///\n+    /// Similar to [`CpuLocal::borrow_irq_disabled`], but you can provide\n+    /// a guard to disable IRQs if you already have one.\n+    pub fn borrow_with<'a>(\n+        &'static self,\n+        guard: &'a DisabledLocalIrqGuard,\n+    ) -> CpuLocalDerefGuard<'a, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Provided(guard),\n+        }\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the reference to `self` is static.\n+    unsafe fn as_ptr(&self) -> *const T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value `T` of a\n+// CPU-local variable if `T` is not `Sync`. We guarentee it by disabling the\n+// reference to the inner value, or turning off preemptions when creating\n+// the reference.\n+unsafe impl<T: 'static> Sync for CpuLocal<T> {}\n+\n+// Prevent valid instances of `CpuLocal` from being copied to any memory areas\n+// outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocal<T> {}\n+impl<T: 'static> !Clone for CpuLocal<T> {}\n+\n+// In general, it does not make any sense to send instances of `CpuLocal` to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocal<T> {}\n+\n+// For `Sync` types, we can create a reference over the inner type and allow\n+// it to be shared across CPUs. So it is sound to provide a `Deref`\n+// implementation. However it is up to the caller if sharing is desired.\n+impl<T: 'static + Sync> Deref for CpuLocal<T> {\n+    type Target = T;\n+\n+    /// Note that the reference to the inner object remains to the same object\n+    /// accessed on the original CPU where the reference is created. If this\n+    /// is not expected, turn off preemptions.\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. It is\n+        // `Sync` so it can be referenced from this task. Here dereferencing\n+        // from non-static instances is not feasible since no one can create\n+        // a non-static instance of `CpuLocal`.\n+        unsafe { &*self.as_ptr() }\n+    }\n+}\n+\n+/// A guard for accessing the CPU-local object.\n+///\n+/// It ensures that the CPU-local object is accessed with IRQs disabled.\n+/// It is created by [`CpuLocal::borrow_irq_disabled`] or\n+/// [`CpuLocal::borrow_with`]. Do not hold this guard for a longtime.\n+#[must_use]\n+pub struct CpuLocalDerefGuard<'a, T: 'static> {\n+    cpu_local: &'static CpuLocal<T>,\n+    _guard: InnerGuard<'a>,\n+}\n+\n+enum InnerGuard<'a> {\n+    #[allow(dead_code)]\n+    Created(DisabledLocalIrqGuard),\n+    #[allow(dead_code)]\n+    Provided(&'a DisabledLocalIrqGuard),\n+}\n+\n+impl<T: 'static> Deref for CpuLocalDerefGuard<'_, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. The IRQs\n+        // are disabled so it can only be referenced from this task.\n+        unsafe { &*self.cpu_local.as_ptr() }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/cpu/local/single_instr.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/single_instr.rs\n@@ -0,0 +1,165 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Extensions for CPU-local types that allows single-instruction operations.\n+//!\n+//! For some per-CPU objects, fetching or modifying the values of them can be\n+//! done in a single instruction. Then we would avoid turning off interrupts\n+//! when accessing them, which incurs non-trivial overhead.\n+//!\n+//! These traits are the architecture-specific interface for single-instruction\n+//! operations. The architecture-specific module can implement these traits for\n+//! common integer types. For architectures that don't support such single-\n+//! instruction operations, we emulate a single-instruction implementation by\n+//! disabling interruptions and preemptions.\n+//!\n+//! Currently we implement some of the [`core::ops`] operations. Bitwise shift\n+//! implementations are missing. Also for less-fundamental types such as\n+//! enumerations or boolean types, the caller can cast it themselves to the\n+//! integer types, for which the operations are implemented.\n+//!\n+//! # Safety\n+//!\n+//! All operations in the provided traits are unsafe, and the caller should\n+//! ensure that the offset is a valid pointer to a static [`CpuLocalCell`]\n+//! object. The offset of the object is relative to the base address of the\n+//! CPU-local storage. These operations are not atomic. Accessing the same\n+//! address from multiple CPUs produces undefined behavior.\n+//!\n+//! [`CpuLocalCell`]: crate::cpu::local::CpuLocalCell\n+\n+/// An interface for architecture-specific single-instruction add operation.\n+pub trait SingleInstructionAddAssign<Rhs = Self> {\n+    /// Adds a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    ///\n+    unsafe fn add_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingAdd + Copy> SingleInstructionAddAssign<T> for T {\n+    default unsafe fn add_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_add(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction subtract operation.\n+pub trait SingleInstructionSubAssign<Rhs = Self> {\n+    /// Subtracts a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn sub_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingSub + Copy> SingleInstructionSubAssign<T> for T {\n+    default unsafe fn sub_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_sub(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise OR.\n+pub trait SingleInstructionBitOrAssign<Rhs = Self> {\n+    /// Bitwise ORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitOr<Output = T> + Copy> SingleInstructionBitOrAssign<T> for T {\n+    default unsafe fn bitor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() | rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise AND.\n+pub trait SingleInstructionBitAndAssign<Rhs = Self> {\n+    /// Bitwise ANDs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitand_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitAnd<Output = T> + Copy> SingleInstructionBitAndAssign<T> for T {\n+    default unsafe fn bitand_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() & rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise XOR.\n+pub trait SingleInstructionBitXorAssign<Rhs = Self> {\n+    /// Bitwise XORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitxor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitXor<Output = T> + Copy> SingleInstructionBitXorAssign<T> for T {\n+    default unsafe fn bitxor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() ^ rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction get operation.\n+pub trait SingleInstructionLoad {\n+    /// Gets the value of the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn load(offset: *const Self) -> Self;\n+}\n+\n+impl<T: Copy> SingleInstructionLoad for T {\n+    default unsafe fn load(offset: *const Self) -> Self {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *const Self;\n+        ptr.read()\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction set operation.\n+pub trait SingleInstructionStore {\n+    /// Writes a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn store(offset: *mut Self, val: Self);\n+}\n+\n+impl<T: Copy> SingleInstructionStore for T {\n+    default unsafe fn store(offset: *mut Self, val: Self) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *mut Self;\n+        ptr.write(val);\n+    }\n+}\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -2,7 +2,7 @@\n \n //! CPU-related definitions.\n \n-pub mod cpu_local;\n+pub mod local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -18,7 +18,7 @@ use bitvec::{\n     slice::IterOnes,\n };\n \n-use crate::{arch::boot::smp::get_num_processors, cpu};\n+use crate::arch::{self, boot::smp::get_num_processors};\n \n /// The number of CPUs. Zero means uninitialized.\n static NUM_CPUS: AtomicU32 = AtomicU32::new(0);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -47,7 +47,7 @@ pub fn num_cpus() -> u32 {\n pub fn this_cpu() -> u32 {\n     // SAFETY: the cpu ID is stored at the beginning of the cpu local area, provided\n     // by the linker script.\n-    unsafe { (cpu::local::get_base() as usize as *mut u32).read() }\n+    unsafe { (arch::cpu::local::get_base() as usize as *mut u32).read() }\n }\n \n /// A subset of all CPUs in the system.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -11,6 +11,7 @@\n #![feature(generic_const_exprs)]\n #![feature(iter_from_coroutine)]\n #![feature(let_chains)]\n+#![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(panic_info_message)]\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -46,7 +47,9 @@ pub mod user;\n pub use ostd_macros::main;\n pub use ostd_pod::Pod;\n \n-pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n+pub use self::{error::Error, prelude::Result};\n+// [`CpuLocalCell`] is easy to be mis-used, so we don't expose it to the users.\n+pub(crate) use crate::cpu::local::cpu_local_cell;\n \n /// Initializes OSTD.\n ///\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -64,7 +67,7 @@ pub fn init() {\n     arch::check_tdx_init();\n \n     // SAFETY: This function is called only once and only on the BSP.\n-    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+    unsafe { cpu::local::early_init_bsp_local_base() };\n \n     mm::heap_allocator::init();\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -48,6 +48,7 @@ use crate::{\n /// A `VmSpace` can also attach a page fault handler, which will be invoked to\n /// handle page faults generated from user space.\n #[allow(clippy::type_complexity)]\n+#[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -6,7 +6,7 @@ use core::ffi::c_void;\n \n use crate::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n-    early_print, early_println,\n+    cpu_local_cell, early_print, early_println,\n };\n \n extern crate cfg_if;\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -35,12 +47,15 @@ pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n             file: info.location().unwrap().file().to_string(),\n             line: info.location().unwrap().line() as usize,\n             col: info.location().unwrap().column() as usize,\n+            resolve_panic: || {\n+                IN_PANIC.store(false);\n+            },\n         };\n         // Throw an exception and expecting it to be caught.\n         begin_panic(Box::new(throw_info.clone()));\n     }\n     early_println!(\"{}\", info);\n-    early_println!(\"printing stack trace:\");\n+    early_println!(\"Printing stack trace:\");\n     print_stack_trace();\n     abort();\n }\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -4,7 +4,7 @@ use alloc::{collections::VecDeque, sync::Arc};\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n \n use super::SpinLock;\n-use crate::task::{add_task, current_task, schedule, Task, TaskStatus};\n+use crate::task::{add_task, schedule, Task, TaskStatus};\n \n // # Explanation on the memory orders\n //\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -209,7 +209,7 @@ impl Waiter {\n     pub fn new_pair() -> (Self, Arc<Waker>) {\n         let waker = Arc::new(Waker {\n             has_woken: AtomicBool::new(false),\n-            task: current_task().unwrap(),\n+            task: Task::current().unwrap(),\n         });\n         let waiter = Self {\n             waker: waker.clone(),\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -10,7 +10,7 @@ mod task;\n \n pub use self::{\n     priority::Priority,\n-    processor::{current_task, disable_preempt, preempt, schedule, DisablePreemptGuard},\n+    processor::{disable_preempt, preempt, schedule, DisablePreemptGuard},\n     scheduler::{add_task, set_scheduler, FifoScheduler, Scheduler},\n     task::{Task, TaskAdapter, TaskContextApi, TaskOptions, TaskStatus},\n };\ndiff --git a/ostd/src/task/priority.rs b/ostd/src/task/priority.rs\n--- a/ostd/src/task/priority.rs\n+++ b/ostd/src/task/priority.rs\n@@ -7,7 +7,7 @@ pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n /// Similar to Linux, a larger value represents a lower priority,\n /// with a range of 0 to 139. Priorities ranging from 0 to 99 are considered real-time,\n /// while those ranging from 100 to 139 are considered normal.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct Priority(u16);\n \n impl Priority {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,59 +1,40 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::{arch, cpu_local};\n-\n-pub struct Processor {\n-    current: Option<Arc<Task>>,\n-    /// A temporary variable used in [`switch_to_task`] to avoid dropping `current` while running\n-    /// as `current`.\n-    prev_task: Option<Arc<Task>>,\n-    idle_task_ctx: TaskContext,\n+use crate::{cpu::local::PREEMPT_LOCK_COUNT, cpu_local_cell};\n+\n+cpu_local_cell! {\n+    /// The `Arc<Task>` (casted by [`Arc::into_raw`]) that is the current task.\n+    static CURRENT_TASK_PTR: *const Task = core::ptr::null();\n+    /// The previous task on the processor before switching to the current task.\n+    /// It is used for delayed resource release since it would be the current\n+    /// task's job to recycle the previous resources.\n+    static PREVIOUS_TASK_PTR: *const Task = core::ptr::null();\n+    /// An unsafe cell to store the context of the bootstrap code.\n+    static BOOTSTRAP_CONTEXT: TaskContext = TaskContext::new();\n }\n \n-impl Processor {\n-    pub const fn new() -> Self {\n-        Self {\n-            current: None,\n-            prev_task: None,\n-            idle_task_ctx: TaskContext::new(),\n-        }\n-    }\n-    fn get_idle_task_ctx_ptr(&mut self) -> *mut TaskContext {\n-        &mut self.idle_task_ctx as *mut _\n-    }\n-    pub fn take_current(&mut self) -> Option<Arc<Task>> {\n-        self.current.take()\n-    }\n-    pub fn current(&self) -> Option<Arc<Task>> {\n-        self.current.as_ref().map(Arc::clone)\n-    }\n-    pub fn set_current_task(&mut self, task: Arc<Task>) {\n-        self.current = Some(task.clone());\n-    }\n-}\n-\n-cpu_local! {\n-    static PROCESSOR: RefCell<Processor> = RefCell::new(Processor::new());\n-}\n-\n-/// Retrieves the current task running on the processor.\n-pub fn current_task() -> Option<Arc<Task>> {\n-    PROCESSOR.borrow_irq_disabled().borrow().current()\n-}\n-\n-pub(crate) fn get_idle_task_ctx_ptr() -> *mut TaskContext {\n-    PROCESSOR\n-        .borrow_irq_disabled()\n-        .borrow_mut()\n-        .get_idle_task_ctx_ptr()\n+/// Retrieves a reference to the current task running on the processor.\n+///\n+/// It returns `None` if the function is called in the bootstrap context.\n+pub(super) fn current_task() -> Option<Arc<Task>> {\n+    let ptr = CURRENT_TASK_PTR.load();\n+    if ptr.is_null() {\n+        return None;\n+    }\n+    // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+    // built with `Arc::into_raw`.\n+    let restored = unsafe { Arc::from_raw(ptr) };\n+    // To let the `CURRENT_TASK_PTR` still own the task, we clone and forget it\n+    // to increment the reference count.\n+    let _ = core::mem::ManuallyDrop::new(restored.clone());\n+    Some(restored)\n }\n \n /// Calls this function to switch to other task by using GLOBAL_SCHEDULER\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -85,36 +66,48 @@ pub fn preempt(task: &Arc<Task>) {\n \n /// Calls this function to switch to other task\n ///\n-/// if current task is none, then it will use the default task context and it will not return to this function again\n-///\n-/// if current task status is exit, then it will not add to the scheduler\n+/// If current task is none, then it will use the default task context and it\n+/// will not return to this function again.\n ///\n-/// before context switch, current task will switch to the next task\n+/// If the current task's status not [`TaskStatus::Runnable`], it will not be\n+/// added to the scheduler.\n fn switch_to_task(next_task: Arc<Task>) {\n-    if !PREEMPT_COUNT.is_preemptive() {\n+    let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n+    if preemt_lock_count != 0 {\n         panic!(\n             \"Calling schedule() while holding {} locks\",\n-            PREEMPT_COUNT.num_locks()\n+            preemt_lock_count\n         );\n     }\n \n-    let current_task_ctx_ptr = match current_task() {\n-        None => get_idle_task_ctx_ptr(),\n-        Some(current_task) => {\n-            let ctx_ptr = current_task.ctx().get();\n+    let irq_guard = crate::trap::disable_local();\n+\n+    let current_task_ptr = CURRENT_TASK_PTR.load();\n+\n+    let current_task_ctx_ptr = if current_task_ptr.is_null() {\n+        // SAFETY: Interrupts are disabled, so the pointer is safe to be fetched.\n+        unsafe { BOOTSTRAP_CONTEXT.as_ptr_mut() }\n+    } else {\n+        // SAFETY: The pointer is not NULL and set as the current task.\n+        let cur_task_arc = unsafe {\n+            let restored = Arc::from_raw(current_task_ptr);\n+            let _ = core::mem::ManuallyDrop::new(restored.clone());\n+            restored\n+        };\n \n-            let mut task_inner = current_task.inner_exclusive_access();\n+        let ctx_ptr = cur_task_arc.ctx().get();\n \n-            debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n-            if task_inner.task_status == TaskStatus::Runnable {\n-                drop(task_inner);\n-                GLOBAL_SCHEDULER.lock_irq_disabled().enqueue(current_task);\n-            } else if task_inner.task_status == TaskStatus::Sleepy {\n-                task_inner.task_status = TaskStatus::Sleeping;\n-            }\n+        let mut task_inner = cur_task_arc.inner_exclusive_access();\n \n-            ctx_ptr\n+        debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n+        if task_inner.task_status == TaskStatus::Runnable {\n+            drop(task_inner);\n+            GLOBAL_SCHEDULER.lock().enqueue(cur_task_arc);\n+        } else if task_inner.task_status == TaskStatus::Sleepy {\n+            task_inner.task_status = TaskStatus::Sleeping;\n         }\n+\n+        ctx_ptr\n     };\n \n     let next_task_ctx_ptr = next_task.ctx().get().cast_const();\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -124,16 +117,21 @@ fn switch_to_task(next_task: Arc<Task>) {\n     }\n \n     // Change the current task to the next task.\n-    {\n-        let processor_guard = PROCESSOR.borrow_irq_disabled();\n-        let mut processor = processor_guard.borrow_mut();\n-\n-        // We cannot directly overwrite `current` at this point. Since we are running as `current`,\n-        // we must avoid dropping `current`. Otherwise, the kernel stack may be unmapped, leading\n-        // to soundness problems.\n-        let old_current = processor.current.replace(next_task);\n-        processor.prev_task = old_current;\n-    }\n+    //\n+    // We cannot directly drop `current` at this point. Since we are running as\n+    // `current`, we must avoid dropping `current`. Otherwise, the kernel stack\n+    // may be unmapped, leading to instant failure.\n+    let old_prev = PREVIOUS_TASK_PTR.load();\n+    PREVIOUS_TASK_PTR.store(current_task_ptr);\n+    CURRENT_TASK_PTR.store(Arc::into_raw(next_task));\n+    // Drop the old-previously running task.\n+    if !old_prev.is_null() {\n+        // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+        // built with `Arc::into_raw`.\n+        drop(unsafe { Arc::from_raw(old_prev) });\n+    }\n+\n+    drop(irq_guard);\n \n     // SAFETY:\n     // 1. `ctx` is only used in `schedule()`. We have exclusive access to both the current task\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -151,53 +149,6 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-\n-/// Currently, it only holds the number of preemption locks held by the\n-/// current CPU. When it has a non-zero value, the CPU cannot call\n-/// [`schedule()`].\n-///\n-/// For per-CPU preemption lock count, we cannot afford two non-atomic\n-/// operations to increment and decrement the count. The [`crate::cpu_local`]\n-/// implementation is free to read the base register and then calculate the\n-/// address of the per-CPU variable using an additional instruction. Interrupts\n-/// can happen between the address calculation and modification to that\n-/// address. If the task is preempted to another CPU by this interrupt, the\n-/// count of the original CPU will be mistakenly modified. To avoid this, we\n-/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n-/// can implement this using one instruction. In other less expressive\n-/// architectures, we may need to disable interrupts.\n-///\n-/// Also, the preemption count is reserved in the `.cpu_local` section\n-/// specified in the linker script. The reason is that we need to access the\n-/// preemption count before we can copy the section for application processors.\n-/// So, the preemption count is not copied from bootstrap processor's section\n-/// as the initialization. Instead it is initialized to zero for application\n-/// processors.\n-struct PreemptInfo {}\n-\n-impl PreemptInfo {\n-    const fn new() -> Self {\n-        Self {}\n-    }\n-\n-    fn increase_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::inc();\n-    }\n-\n-    fn decrease_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::dec();\n-    }\n-\n-    fn is_preemptive(&self) -> bool {\n-        arch::cpu::local::preempt_lock_count::get() == 0\n-    }\n-\n-    fn num_locks(&self) -> usize {\n-        arch::cpu::local::preempt_lock_count::get() as usize\n-    }\n-}\n-\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -210,7 +161,7 @@ impl !Send for DisablePreemptGuard {}\n \n impl DisablePreemptGuard {\n     fn new() -> Self {\n-        PREEMPT_COUNT.increase_num_locks();\n+        PREEMPT_LOCK_COUNT.add_assign(1);\n         Self { _private: () }\n     }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -223,7 +174,7 @@ impl DisablePreemptGuard {\n \n impl Drop for DisablePreemptGuard {\n     fn drop(&mut self) {\n-        PREEMPT_COUNT.decrease_num_locks();\n+        PREEMPT_LOCK_COUNT.sub_assign(1);\n     }\n }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -3,9 +3,9 @@\n // FIXME: the `intrusive_adapter` macro will generate methods without docs.\n // So we temporary allow missing_docs for this module.\n #![allow(missing_docs)]\n-#![allow(dead_code)]\n \n-use core::cell::UnsafeCell;\n+use alloc::{boxed::Box, sync::Arc};\n+use core::{any::Any, cell::UnsafeCell};\n \n use intrusive_collections::{intrusive_adapter, LinkedListAtomicLink};\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -18,7 +18,7 @@ pub(crate) use crate::arch::task::{context_switch, TaskContext};\n use crate::{\n     arch::mm::tlb_flush_addr_range,\n     cpu::CpuSet,\n-    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, PageFlags, Segment, PAGE_SIZE},\n+    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, Paddr, PageFlags, Segment, PAGE_SIZE},\n     prelude::*,\n     sync::{SpinLock, SpinLockGuard},\n     user::UserSpace,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -41,6 +41,7 @@ pub trait TaskContextApi {\n     fn stack_pointer(&self) -> usize;\n }\n \n+#[derive(Debug)]\n pub struct KernelStack {\n     segment: Segment,\n     has_guard_page: bool,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -121,6 +122,7 @@ pub struct Task {\n     link: LinkedListAtomicLink,\n     priority: Priority,\n     // TODO: add multiprocessor support\n+    #[allow(dead_code)]\n     cpu_affinity: CpuSet,\n }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -131,14 +133,17 @@ intrusive_adapter!(pub TaskAdapter = Arc<Task>: Task { link: LinkedListAtomicLin\n // we have exclusive access to the field.\n unsafe impl Sync for Task {}\n \n+#[derive(Debug)]\n pub(crate) struct TaskInner {\n     pub task_status: TaskStatus,\n }\n \n impl Task {\n     /// Gets the current task.\n-    pub fn current() -> Arc<Task> {\n-        current_task().unwrap()\n+    ///\n+    /// It returns `None` if the function is called in the bootstrap context.\n+    pub fn current() -> Option<Arc<Task>> {\n+        current_task()\n     }\n \n     /// Gets inner\ndiff --git a/ostd/src/trap/handler.rs b/ostd/src/trap/handler.rs\n--- a/ostd/src/trap/handler.rs\n+++ b/ostd/src/trap/handler.rs\n@@ -1,17 +1,15 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use trapframe::TrapFrame;\n \n-use crate::{arch::irq::IRQ_LIST, cpu_local};\n+use crate::{arch::irq::IRQ_LIST, cpu_local_cell};\n \n pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: usize) {\n     // For x86 CPUs, interrupts are not re-entrant. Local interrupts will be disabled when\n     // an interrupt handler is called (Unless interrupts are re-enabled in an interrupt handler).\n     //\n     // FIXME: For arch that supports re-entrant interrupts, we may need to record nested level here.\n-    IN_INTERRUPT_CONTEXT.store(true, Ordering::Release);\n+    IN_INTERRUPT_CONTEXT.store(true);\n \n     let irq_line = IRQ_LIST.get().unwrap().get(irq_number).unwrap();\n     let callback_functions = irq_line.callback_list();\ndiff --git a/ostd/src/trap/handler.rs b/ostd/src/trap/handler.rs\n--- a/ostd/src/trap/handler.rs\n+++ b/ostd/src/trap/handler.rs\n@@ -22,20 +20,17 @@ pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: us\n \n     crate::arch::interrupts_ack(irq_number);\n \n-    IN_INTERRUPT_CONTEXT.store(false, Ordering::Release);\n-\n     crate::arch::irq::enable_local();\n     crate::trap::softirq::process_pending();\n+\n+    IN_INTERRUPT_CONTEXT.store(false);\n }\n \n-cpu_local! {\n-    static IN_INTERRUPT_CONTEXT: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IN_INTERRUPT_CONTEXT: bool = false;\n }\n \n /// Returns whether we are in the interrupt context.\n-///\n-/// FIXME: Here only hardware irq is taken into account. According to linux implementation, if\n-/// we are in softirq context, or bottom half is disabled, this function also returns true.\n pub fn in_interrupt_context() -> bool {\n-    IN_INTERRUPT_CONTEXT.load(Ordering::Acquire)\n+    IN_INTERRUPT_CONTEXT.load()\n }\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -2,14 +2,12 @@\n \n //! Software interrupt.\n \n-#![allow(unused_variables)]\n-\n use alloc::boxed::Box;\n-use core::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n+use core::sync::atomic::{AtomicU8, Ordering};\n \n use spin::Once;\n \n-use crate::{cpu_local, task::disable_preempt};\n+use crate::{cpu_local_cell, task::disable_preempt};\n \n /// A representation of a software interrupt (softirq) line.\n ///\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -70,7 +68,7 @@ impl SoftIrqLine {\n     ///\n     /// If this line is not enabled yet, the method has no effect.\n     pub fn raise(&self) {\n-        PENDING_MASK.fetch_or(1 << self.id, Ordering::Release);\n+        PENDING_MASK.bitor_assign(1 << self.id);\n     }\n \n     /// Enables a softirq line by registering its callback.\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -105,24 +103,24 @@ pub(super) fn init() {\n \n static ENABLED_MASK: AtomicU8 = AtomicU8::new(0);\n \n-cpu_local! {\n-    static PENDING_MASK: AtomicU8 = AtomicU8::new(0);\n-    static IS_ENABLED: AtomicBool = AtomicBool::new(true);\n+cpu_local_cell! {\n+    static PENDING_MASK: u8 = 0;\n+    static IS_ENABLED: bool = true;\n }\n \n /// Enables softirq in current processor.\n fn enable_softirq_local() {\n-    IS_ENABLED.store(true, Ordering::Release);\n+    IS_ENABLED.store(true);\n }\n \n /// Disables softirq in current processor.\n fn disable_softirq_local() {\n-    IS_ENABLED.store(false, Ordering::Release);\n+    IS_ENABLED.store(false);\n }\n \n /// Checks whether the softirq is enabled in current processor.\n fn is_softirq_enabled() -> bool {\n-    IS_ENABLED.load(Ordering::Acquire)\n+    IS_ENABLED.load()\n }\n \n /// Processes pending softirqs.\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -136,12 +134,13 @@ pub(crate) fn process_pending() {\n         return;\n     }\n \n-    let preempt_guard = disable_preempt();\n+    let _preempt_guard = disable_preempt();\n     disable_softirq_local();\n \n-    for i in 0..SOFTIRQ_RUN_TIMES {\n+    for _i in 0..SOFTIRQ_RUN_TIMES {\n         let mut action_mask = {\n-            let pending_mask = PENDING_MASK.fetch_and(0, Ordering::Acquire);\n+            let pending_mask = PENDING_MASK.load();\n+            PENDING_MASK.store(0);\n             pending_mask & ENABLED_MASK.load(Ordering::Acquire)\n         };\n \ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -12,6 +12,7 @@ use crate::{cpu::UserContext, mm::VmSpace, prelude::*, task::Task};\n ///\n /// Each user space has a VM address space and allows a task to execute in\n /// user mode.\n+#[derive(Debug)]\n pub struct UserSpace {\n     /// vm space\n     vm_space: Arc<VmSpace>,\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -94,7 +95,7 @@ pub trait UserContextApi {\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\n-///     .expect(\"the current task is associated with a user space\");\n+///     .expect(\"the current task is not associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n ///     // Execute in the user space until some interesting events occur.\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -108,14 +109,14 @@ pub struct UserMode<'a> {\n     context: UserContext,\n }\n \n-// An instance of `UserMode` is bound to the current task. So it cannot be\n+// An instance of `UserMode` is bound to the current task. So it cannot be [`Send`].\n impl<'a> !Send for UserMode<'a> {}\n \n impl<'a> UserMode<'a> {\n     /// Creates a new `UserMode`.\n     pub fn new(user_space: &'a Arc<UserSpace>) -> Self {\n         Self {\n-            current: Task::current(),\n+            current: Task::current().unwrap(),\n             user_space,\n             context: user_space.init_ctx,\n         }\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -136,7 +137,7 @@ impl<'a> UserMode<'a> {\n     where\n         F: FnMut() -> bool,\n     {\n-        debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n+        debug_assert!(Arc::ptr_eq(&self.current, &Task::current().unwrap()));\n         self.context.execute(has_kernel_event)\n     }\n \n",
        "test_patch": "diff --git a/kernel/aster-nix/src/process/process/mod.rs b/kernel/aster-nix/src/process/process/mod.rs\n--- a/kernel/aster-nix/src/process/process/mod.rs\n+++ b/kernel/aster-nix/src/process/process/mod.rs\n@@ -636,15 +645,6 @@ impl Process {\n     }\n }\n \n-pub fn current() -> Arc<Process> {\n-    let current_thread = current_thread!();\n-    if let Some(posix_thread) = current_thread.as_posix_thread() {\n-        posix_thread.process()\n-    } else {\n-        panic!(\"[Internal error]The current thread does not belong to a process\");\n-    }\n-}\n-\n #[cfg(ktest)]\n mod test {\n \ndiff --git a/kernel/aster-nix/src/thread/mod.rs b/kernel/aster-nix/src/thread/mod.rs\n--- a/kernel/aster-nix/src/thread/mod.rs\n+++ b/kernel/aster-nix/src/thread/mod.rs\n@@ -50,13 +50,12 @@ impl Thread {\n         }\n     }\n \n-    /// Returns the current thread, or `None` if the current task is not associated with a thread.\n+    /// Returns the current thread.\n     ///\n-    /// Except for unit tests, all tasks should be associated with threads. This method is useful\n-    /// when writing code that can be called directly by unit tests. If this isn't the case,\n-    /// consider using [`current_thread!`] instead.\n+    /// This function returns `None` if the current task is not associated with\n+    /// a thread, or if called within the bootstrap context.\n     pub fn current() -> Option<Arc<Self>> {\n-        Task::current()\n+        Task::current()?\n             .data()\n             .downcast_ref::<Weak<Thread>>()?\n             .upgrade()\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -72,7 +72,7 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n \n fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n     fn user_task() {\n-        let current = Task::current();\n+        let current = Task::current().unwrap();\n         // Switching between user-kernel space is\n         // performed via the UserMode abstraction.\n         let mut user_mode = {\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -103,6 +103,7 @@ pub struct PanicInfo {\n     pub file: String,\n     pub line: usize,\n     pub col: usize,\n+    pub resolve_panic: fn(),\n }\n \n impl core::fmt::Display for PanicInfo {\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -174,6 +175,7 @@ impl KtestItem {\n                 Ok(()) => Err(KtestError::ShouldPanicButNoPanic),\n                 Err(e) => match e.downcast::<PanicInfo>() {\n                     Ok(s) => {\n+                        (s.resolve_panic)();\n                         if let Some(expected) = self.should_panic.1 {\n                             if s.message == expected {\n                                 Ok(())\ndiff --git a/ostd/src/cpu/cpu_local.rs /dev/null\n--- a/ostd/src/cpu/cpu_local.rs\n+++ /dev/null\n@@ -1,340 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! CPU local storage.\n-//!\n-//! This module provides a mechanism to define CPU-local objects.\n-//!\n-//! This is acheived by placing the CPU-local objects in a special section\n-//! `.cpu_local`. The bootstrap processor (BSP) uses the objects linked in this\n-//! section, and these objects are copied to dynamically allocated local\n-//! storage of each application processors (AP) during the initialization\n-//! process.\n-//!\n-//! Such a mechanism exploits the fact that constant values of non-[`Copy`]\n-//! types can be bitwise copied. For example, a [`Option<T>`] object, though\n-//! being not [`Copy`], have a constant constructor [`Option::None`] that\n-//! produces a value that can be bitwise copied to create a new instance.\n-//! [`alloc::sync::Arc`] however, don't have such a constructor, and thus cannot\n-//! be directly used as a CPU-local object. Wrapping it in a type that has a\n-//! constant constructor, like [`Option<T>`], can make it CPU-local.\n-\n-use alloc::vec::Vec;\n-use core::ops::Deref;\n-\n-use align_ext::AlignExt;\n-\n-use crate::{\n-    arch, cpu,\n-    mm::{\n-        paddr_to_vaddr,\n-        page::{self, meta::KernelMeta, ContPages},\n-        PAGE_SIZE,\n-    },\n-    trap::{disable_local, DisabledLocalIrqGuard},\n-};\n-\n-/// Defines a CPU-local variable.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use crate::cpu_local;\n-/// use core::cell::RefCell;\n-///\n-/// cpu_local! {\n-///     static FOO: RefCell<u32> = RefCell::new(1);\n-///\n-///     #[allow(unused)]\n-///     pub static BAR: RefCell<f32> = RefCell::new(1.0);\n-/// }\n-///\n-/// println!(\"FOO VAL: {:?}\", *FOO.borrow());\n-/// ```\n-#[macro_export]\n-macro_rules! cpu_local {\n-    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n-        $(\n-            #[link_section = \".cpu_local\"]\n-            $(#[$attr])* $vis static $name: $crate::CpuLocal<$t> = {\n-                let val = $init;\n-                // SAFETY: The CPU local variable instantiated is statically\n-                // stored in the special `.cpu_local` section.\n-                unsafe {\n-                    $crate::CpuLocal::__new(val)\n-                }\n-            };\n-        )*\n-    };\n-}\n-\n-/// CPU-local objects.\n-///\n-/// A CPU-local object only gives you immutable references to the underlying value.\n-/// To mutate the value, one can use atomic values (e.g., [`AtomicU32`]) or internally mutable\n-/// objects (e.g., [`RefCell`]).\n-///\n-/// [`AtomicU32`]: core::sync::atomic::AtomicU32\n-/// [`RefCell`]: core::cell::RefCell\n-pub struct CpuLocal<T>(T);\n-\n-// SAFETY: At any given time, only one task can access the inner value T\n-// of a cpu-local variable even if `T` is not `Sync`.\n-unsafe impl<T> Sync for CpuLocal<T> {}\n-\n-// Prevent valid instances of CpuLocal from being copied to any memory\n-// area outside the .cpu_local section.\n-impl<T> !Copy for CpuLocal<T> {}\n-impl<T> !Clone for CpuLocal<T> {}\n-\n-// In general, it does not make any sense to send instances of CpuLocal to\n-// other tasks as they should live on other CPUs to make sending useful.\n-impl<T> !Send for CpuLocal<T> {}\n-\n-// A check to ensure that the CPU-local object is never accessed before the\n-// initialization for all CPUs.\n-#[cfg(debug_assertions)]\n-use core::sync::atomic::{AtomicBool, Ordering};\n-#[cfg(debug_assertions)]\n-static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n-\n-impl<T> CpuLocal<T> {\n-    /// Initialize a CPU-local object.\n-    ///\n-    /// Please do not call this function directly. Instead, use the\n-    /// `cpu_local!` macro.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller should ensure that the object initialized by this\n-    /// function resides in the `.cpu_local` section. Otherwise the\n-    /// behavior is undefined.\n-    #[doc(hidden)]\n-    pub const unsafe fn __new(val: T) -> Self {\n-        Self(val)\n-    }\n-\n-    /// Get access to the underlying value with IRQs disabled.\n-    ///\n-    /// By this method, you can borrow a reference to the underlying value\n-    /// even if `T` is not `Sync`. Because that it is per-CPU and IRQs are\n-    /// disabled, no other running task can access it.\n-    pub fn borrow_irq_disabled(&self) -> CpuLocalDerefGuard<'_, T> {\n-        CpuLocalDerefGuard {\n-            cpu_local: self,\n-            _guard: disable_local(),\n-        }\n-    }\n-\n-    /// Get access to the underlying value through a raw pointer.\n-    ///\n-    /// This function calculates the virtual address of the CPU-local object based on the per-\n-    /// cpu base address and the offset in the BSP.\n-    fn get(&self) -> *const T {\n-        // CPU-local objects should be initialized before being accessed. It should be ensured\n-        // by the implementation of OSTD initialization.\n-        #[cfg(debug_assertions)]\n-        debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n-\n-        let offset = {\n-            let bsp_va = self as *const _ as usize;\n-            let bsp_base = __cpu_local_start as usize;\n-            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n-            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n-\n-            bsp_va - bsp_base as usize\n-        };\n-\n-        let local_base = arch::cpu::local::get_base() as usize;\n-        let local_va = local_base + offset;\n-\n-        // A sanity check about the alignment.\n-        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n-\n-        local_va as *mut T\n-    }\n-}\n-\n-// Considering a preemptive kernel, a CPU-local object may be dereferenced\n-// when another task tries to access it. So, we need to ensure that `T` is\n-// `Sync` before allowing it to be dereferenced.\n-impl<T: Sync> Deref for CpuLocal<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        // SAFETY: it should be properly initialized before accesses.\n-        // And we do not create a mutable reference over it. It is\n-        // `Sync` so it can be referenced from this task.\n-        unsafe { &*self.get() }\n-    }\n-}\n-\n-/// A guard for accessing the CPU-local object.\n-///\n-/// It ensures that the CPU-local object is accessed with IRQs\n-/// disabled. It is created by [`CpuLocal::borrow_irq_disabled`].\n-/// Do not hold this guard for a long time.\n-#[must_use]\n-pub struct CpuLocalDerefGuard<'a, T> {\n-    cpu_local: &'a CpuLocal<T>,\n-    _guard: DisabledLocalIrqGuard,\n-}\n-\n-impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        // SAFETY: it should be properly initialized before accesses.\n-        // And we do not create a mutable reference over it. The IRQs\n-        // are disabled so it can be referenced from this task.\n-        unsafe { &*self.cpu_local.get() }\n-    }\n-}\n-\n-/// Sets the base address of the CPU-local storage for the bootstrap processor.\n-///\n-/// It should be called early to let [`crate::task::disable_preempt`] work,\n-/// which needs to update a CPU-local preempt lock count. Otherwise it may\n-/// panic when calling [`crate::task::disable_preempt`].\n-///\n-/// # Safety\n-///\n-/// It should be called only once and only on the BSP.\n-pub(crate) unsafe fn early_init_bsp_local_base() {\n-    let start_base_va = __cpu_local_start as usize as u64;\n-    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n-    // where accessing the CPU-local objects have defined behaviors.\n-    unsafe {\n-        arch::cpu::local::set_base(start_base_va);\n-    }\n-}\n-\n-/// The BSP initializes the CPU-local areas for APs. Here we use a\n-/// non-disabling preempt version of lock because the [`crate::sync`]\n-/// version needs `cpu_local` to work. Preemption and interrupts are\n-/// disabled in this phase so it is safe to use this lock.\n-static CPU_LOCAL_STORAGES: spin::RwLock<Vec<ContPages<KernelMeta>>> = spin::RwLock::new(Vec::new());\n-\n-/// Initializes the CPU local data for the bootstrap processor (BSP).\n-///\n-/// # Safety\n-///\n-/// This function can only called on the BSP, for once.\n-///\n-/// It must be guaranteed that the BSP will not access local data before\n-/// this function being called, otherwise copying non-constant values\n-/// will result in pretty bad undefined behavior.\n-pub unsafe fn init_on_bsp() {\n-    let bsp_base_va = __cpu_local_start as usize;\n-    let bsp_end_va = __cpu_local_end as usize;\n-\n-    let num_cpus = super::num_cpus();\n-\n-    let mut cpu_local_storages = CPU_LOCAL_STORAGES.write();\n-    for cpu_i in 1..num_cpus {\n-        let ap_pages = {\n-            let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n-            page::allocator::alloc_contiguous(nbytes, |_| KernelMeta::default()).unwrap()\n-        };\n-        let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u8;\n-\n-        // SAFETY: The BSP has not initialized the CPU-local area, so the objects in\n-        // in the `.cpu_local` section can be bitwise bulk copied to the AP's local\n-        // storage. The destination memory is allocated so it is valid to write to.\n-        unsafe {\n-            core::ptr::copy_nonoverlapping(\n-                bsp_base_va as *const u8,\n-                ap_pages_ptr,\n-                bsp_end_va - bsp_base_va,\n-            );\n-        }\n-\n-        // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n-        unsafe {\n-            (ap_pages_ptr as *mut u32).write(cpu_i);\n-        }\n-\n-        // SAFETY: the second 4 bytes is reserved for storing the preemt count.\n-        unsafe {\n-            (ap_pages_ptr as *mut u32).add(1).write(0);\n-        }\n-\n-        cpu_local_storages.push(ap_pages);\n-    }\n-\n-    // Write the CPU ID of BSP to the first 4 bytes of the CPU-local area.\n-    let bsp_cpu_id_ptr = bsp_base_va as *mut u32;\n-    // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n-    unsafe {\n-        bsp_cpu_id_ptr.write(0);\n-    }\n-\n-    cpu::local::set_base(bsp_base_va as u64);\n-\n-    #[cfg(debug_assertions)]\n-    IS_INITIALIZED.store(true, Ordering::Relaxed);\n-}\n-\n-/// Initializes the CPU local data for the application processor (AP).\n-///\n-/// # Safety\n-///\n-/// This function can only called on the AP.\n-pub unsafe fn init_on_ap(cpu_id: u32) {\n-    let rlock = CPU_LOCAL_STORAGES.read();\n-    let ap_pages = rlock.get(cpu_id as usize - 1).unwrap();\n-\n-    let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u32;\n-\n-    debug_assert_eq!(\n-        cpu_id,\n-        // SAFETY: the CPU ID is stored at the beginning of the CPU local area.\n-        unsafe { ap_pages_ptr.read() }\n-    );\n-\n-    // SAFETY: the memory will be dedicated to the AP. And we are on the AP.\n-    unsafe {\n-        cpu::local::set_base(ap_pages_ptr as u64);\n-    }\n-}\n-\n-// These symbols are provided by the linker script.\n-extern \"C\" {\n-    fn __cpu_local_start();\n-    fn __cpu_local_end();\n-}\n-\n-#[cfg(ktest)]\n-mod test {\n-    use core::{\n-        cell::RefCell,\n-        sync::atomic::{AtomicU8, Ordering},\n-    };\n-\n-    use ostd_macros::ktest;\n-\n-    use super::*;\n-\n-    #[ktest]\n-    fn test_cpu_local() {\n-        cpu_local! {\n-            static FOO: RefCell<usize> = RefCell::new(1);\n-            static BAR: AtomicU8 = AtomicU8::new(3);\n-        }\n-        for _ in 0..10 {\n-            let foo_guard = FOO.borrow_irq_disabled();\n-            assert_eq!(*foo_guard.borrow(), 1);\n-            *foo_guard.borrow_mut() = 2;\n-            drop(foo_guard);\n-            for _ in 0..10 {\n-                assert_eq!(BAR.load(Ordering::Relaxed), 3);\n-                BAR.store(4, Ordering::Relaxed);\n-                assert_eq!(BAR.load(Ordering::Relaxed), 4);\n-                BAR.store(3, Ordering::Relaxed);\n-            }\n-            let foo_guard = FOO.borrow_irq_disabled();\n-            assert_eq!(*foo_guard.borrow(), 2);\n-            *foo_guard.borrow_mut() = 1;\n-            drop(foo_guard);\n-        }\n-    }\n-}\ndiff --git /dev/null b/ostd/src/cpu/local/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -0,0 +1,246 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! CPU local storage.\n+//!\n+//! This module provides a mechanism to define CPU-local objects, by the macro\n+//! [`crate::cpu_local!`].\n+//!\n+//! Such a mechanism exploits the fact that constant values of non-[`Copy`]\n+//! types can be bitwise copied. For example, a [`Option<T>`] object, though\n+//! being not [`Copy`], have a constant constructor [`Option::None`] that\n+//! produces a value that can be bitwise copied to create a new instance.\n+//! [`alloc::sync::Arc`] however, don't have such a constructor, and thus cannot\n+//! be directly used as a CPU-local object. Wrapping it in a type that has a\n+//! constant constructor, like [`Option<T>`], can make it CPU-local.\n+//!\n+//! # Implementation\n+//!\n+//! These APIs are implemented by placing the CPU-local objects in a special\n+//! section `.cpu_local`. The bootstrap processor (BSP) uses the objects linked\n+//! in this section, and these objects are copied to dynamically allocated\n+//! local storage of each application processors (AP) during the initialization\n+//! process.\n+\n+// This module also, provide CPU-local cell objects that have inner mutability.\n+//\n+// The difference between CPU-local objects (defined by [`crate::cpu_local!`])\n+// and CPU-local cell objects (defined by [`crate::cpu_local_cell!`]) is that\n+// the CPU-local objects can be shared across CPUs. While through a CPU-local\n+// cell object you can only access the value on the current CPU, therefore\n+// enabling inner mutability without locks.\n+//\n+// The cell-variant is currently not a public API because that it is rather\n+// hard to be used without introducing races. But it is useful for OSTD's\n+// internal implementation.\n+\n+mod cell;\n+mod cpu_local;\n+\n+pub(crate) mod single_instr;\n+\n+use alloc::vec::Vec;\n+\n+use align_ext::AlignExt;\n+pub(crate) use cell::{cpu_local_cell, CpuLocalCell};\n+pub use cpu_local::{CpuLocal, CpuLocalDerefGuard};\n+\n+use crate::{\n+    arch,\n+    mm::{\n+        paddr_to_vaddr,\n+        page::{self, meta::KernelMeta, ContPages},\n+        PAGE_SIZE,\n+    },\n+};\n+\n+// These symbols are provided by the linker script.\n+extern \"C\" {\n+    fn __cpu_local_start();\n+    fn __cpu_local_end();\n+}\n+\n+cpu_local_cell! {\n+    /// The count of the preempt lock.\n+    ///\n+    /// We need to access the preemption count before we can copy the section\n+    /// for application processors. So, the preemption count is not copied from\n+    /// bootstrap processor's section as the initialization. Instead it is\n+    /// initialized to zero for application processors.\n+    pub(crate) static PREEMPT_LOCK_COUNT: u32 = 0;\n+}\n+\n+/// Sets the base address of the CPU-local storage for the bootstrap processor.\n+///\n+/// It should be called early to let [`crate::task::disable_preempt`] work,\n+/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// panic when calling [`crate::task::disable_preempt`].\n+///\n+/// # Safety\n+///\n+/// It should be called only once and only on the BSP.\n+pub(crate) unsafe fn early_init_bsp_local_base() {\n+    let start_base_va = __cpu_local_start as usize as u64;\n+\n+    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n+    // where accessing the CPU-local objects have defined behaviors.\n+    unsafe {\n+        arch::cpu::local::set_base(start_base_va);\n+    }\n+}\n+\n+/// The BSP initializes the CPU-local areas for APs. Here we use a\n+/// non-disabling preempt version of lock because the [`crate::sync`]\n+/// version needs `cpu_local` to work. Preemption and interrupts are\n+/// disabled in this phase so it is safe to use this lock.\n+static CPU_LOCAL_STORAGES: spin::RwLock<Vec<ContPages<KernelMeta>>> = spin::RwLock::new(Vec::new());\n+\n+/// Initializes the CPU local data for the bootstrap processor (BSP).\n+///\n+/// # Safety\n+///\n+/// This function can only called on the BSP, for once.\n+///\n+/// It must be guaranteed that the BSP will not access local data before\n+/// this function being called, otherwise copying non-constant values\n+/// will result in pretty bad undefined behavior.\n+pub unsafe fn init_on_bsp() {\n+    let bsp_base_va = __cpu_local_start as usize;\n+    let bsp_end_va = __cpu_local_end as usize;\n+\n+    let num_cpus = super::num_cpus();\n+\n+    let mut cpu_local_storages = CPU_LOCAL_STORAGES.write();\n+    for cpu_i in 1..num_cpus {\n+        let ap_pages = {\n+            let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n+            page::allocator::alloc_contiguous(nbytes, |_| KernelMeta::default()).unwrap()\n+        };\n+        let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u8;\n+\n+        // SAFETY: The BSP has not initialized the CPU-local area, so the objects in\n+        // in the `.cpu_local` section can be bitwise bulk copied to the AP's local\n+        // storage. The destination memory is allocated so it is valid to write to.\n+        unsafe {\n+            core::ptr::copy_nonoverlapping(\n+                bsp_base_va as *const u8,\n+                ap_pages_ptr,\n+                bsp_end_va - bsp_base_va,\n+            );\n+        }\n+\n+        // SAFETY: bytes `0:4` are reserved for storing CPU ID.\n+        unsafe {\n+            (ap_pages_ptr as *mut u32).write(cpu_i);\n+        }\n+\n+        // SAFETY: the `PREEMPT_LOCK_COUNT` may be dirty on the BSP, so we need\n+        // to ensure that it is initialized to zero for APs. The safety\n+        // requirements are met since the static is defined in the `.cpu_local`\n+        // section and the pointer to that static is the offset in the CPU-\n+        // local area. It is a `usize` so it is safe to be overwritten.\n+        unsafe {\n+            let preempt_count_ptr = &PREEMPT_LOCK_COUNT as *const _ as usize;\n+            let preempt_count_offset = preempt_count_ptr - __cpu_local_start as usize;\n+            let ap_preempt_count_ptr = ap_pages_ptr.add(preempt_count_offset) as *mut usize;\n+            ap_preempt_count_ptr.write(0);\n+        }\n+\n+        // SAFETY: bytes `8:16` are reserved for storing the pointer to the\n+        // current task. We initialize it to null.\n+        unsafe {\n+            (ap_pages_ptr as *mut u64).add(1).write(0);\n+        }\n+\n+        cpu_local_storages.push(ap_pages);\n+    }\n+\n+    // Write the CPU ID of BSP to the first 4 bytes of the CPU-local area.\n+    let bsp_cpu_id_ptr = bsp_base_va as *mut u32;\n+    // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n+    unsafe {\n+        bsp_cpu_id_ptr.write(0);\n+    }\n+\n+    arch::cpu::local::set_base(bsp_base_va as u64);\n+\n+    has_init::set_true();\n+}\n+\n+/// Initializes the CPU local data for the application processor (AP).\n+///\n+/// # Safety\n+///\n+/// This function can only called on the AP.\n+pub unsafe fn init_on_ap(cpu_id: u32) {\n+    let rlock = CPU_LOCAL_STORAGES.read();\n+    let ap_pages = rlock.get(cpu_id as usize - 1).unwrap();\n+\n+    let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u32;\n+\n+    debug_assert_eq!(\n+        cpu_id,\n+        // SAFETY: the CPU ID is stored at the beginning of the CPU local area.\n+        unsafe { ap_pages_ptr.read() }\n+    );\n+\n+    // SAFETY: the memory will be dedicated to the AP. And we are on the AP.\n+    unsafe {\n+        arch::cpu::local::set_base(ap_pages_ptr as u64);\n+    }\n+}\n+\n+mod has_init {\n+    //! This module is used to detect the programming error of using the CPU-local\n+    //! mechanism before it is initialized. Such bugs have been found before and we\n+    //! do not want to repeat this error again. This module is only incurs runtime\n+    //! overhead if debug assertions are enabled.\n+    cfg_if::cfg_if! {\n+        if #[cfg(debug_assertions)] {\n+            use core::sync::atomic::{AtomicBool, Ordering};\n+\n+            static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n+\n+            pub fn assert_true() {\n+                debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n+            }\n+\n+            pub fn set_true() {\n+                IS_INITIALIZED.store(true, Ordering::Relaxed);\n+            }\n+        } else {\n+            pub fn assert_true() {}\n+\n+            pub fn set_true() {}\n+        }\n+    }\n+}\n+\n+#[cfg(ktest)]\n+mod test {\n+    use core::cell::RefCell;\n+\n+    use ostd_macros::ktest;\n+\n+    #[ktest]\n+    fn test_cpu_local() {\n+        crate::cpu_local! {\n+            static FOO: RefCell<usize> = RefCell::new(1);\n+        }\n+        let foo_guard = FOO.borrow_irq_disabled();\n+        assert_eq!(*foo_guard.borrow(), 1);\n+        *foo_guard.borrow_mut() = 2;\n+        assert_eq!(*foo_guard.borrow(), 2);\n+        drop(foo_guard);\n+    }\n+\n+    #[ktest]\n+    fn test_cpu_local_cell() {\n+        crate::cpu_local_cell! {\n+            static BAR: usize = 3;\n+        }\n+        let _guard = crate::trap::disable_local();\n+        assert_eq!(BAR.load(), 3);\n+        BAR.store(4);\n+        assert_eq!(BAR.load(), 4);\n+    }\n+}\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -17,12 +17,24 @@ use unwinding::abi::{\n     _Unwind_GetGR, _Unwind_GetIP,\n };\n \n+cpu_local_cell! {\n+    static IN_PANIC: bool = false;\n+}\n+\n /// The panic handler must be defined in the binary crate or in the crate that the binary\n /// crate explicity declares by `extern crate`. We cannot let the base crate depend on OSTD\n /// due to prismatic dependencies. That's why we export this symbol and state the\n /// panic handler in the binary crate.\n #[export_name = \"__aster_panic_handler\"]\n pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n+    let _irq_guard = crate::trap::disable_local();\n+\n+    if IN_PANIC.load() {\n+        early_println!(\"{}\", info);\n+        early_println!(\"The panic handler panicked when processing the above panic. Aborting.\");\n+        abort();\n+    }\n+\n     // If in ktest, we would like to catch the panics and resume the test.\n     #[cfg(ktest)]\n     {\ndiff --git a/ostd/src/prelude.rs b/ostd/src/prelude.rs\n--- a/ostd/src/prelude.rs\n+++ b/ostd/src/prelude.rs\n@@ -8,7 +8,6 @@\n pub type Result<T> = core::result::Result<T, crate::error::Error>;\n \n pub(crate) use alloc::{boxed::Box, sync::Arc, vec::Vec};\n-pub(crate) use core::any::Any;\n \n #[cfg(ktest)]\n pub use ostd_macros::ktest;\n",
        "problem_statement": "Lockless mutability for current task data.\n**This is currently a work-in-progress RFC**\r\n\r\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nThis RFC plans to introduce a mechanism for implementing lock-less inner mutability of task data that would be only accessible through the current task.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\nIn `aster-nix`, there would be a hell lot of inner mutability patterns using `Mutex` or `SpinLock` in the thread structures, such as `SigMask`, `SigStack` and `sig_context`, etc. They are all implemented with locks. However, they should only be accessed through the current thread. There would be no syncing required. Modifying them from non-current threads should be illegal. Locks are too heavy-weighted for such kind of inner mutability patterns.\r\n\r\nAlso, for shared thread/task data, we access them using `current!` in thread/task contexts. These operations would also require fetching the task from a `cpu_local!` object that incurs heavy type-checking and interrupt/preempt blocking operations. Such jobs can be ignored when the caller is definitely in the current task's contexts. As #1105 points out, even the most simple system call `getpid` would access such task exclusive variables many times. Current implementation would require multiple locking operations and IRQ/preempt guarding operations. Many cycles are wasted doing so.\r\n\r\nWe currently only have per-task data storage that is shared (the implementer should provide `Send + Sync` types). Most of the data that don't need to be shared are also stored here, which would require a lock for inner mutability. In this RFC, I would like to introduce a new kind of data in the `ostd::Task` that is exclusive (not shared, no need to be `Send + Sync`). It would offer a chance to implement the above mentioned per-task storage without locks, boosting the performance by a lot.\r\n\r\n### Proposal\r\n\r\nCurrently we access them via `current!()`, which would return a reference over the current task and it's corresponding data. The data is defined within a structure (either `PosixThread` or `KernelThread` currently).\r\n\r\nIn `aster-nix`, most code are running in the context of a task (other code runs in interrupt contexts). So the code would only have one replica of task local exclusive data that is accessible. Such data would only be accessed by the code in the corresponding task context also. Such kind of data should be safely mutably accessed. OSTD should provide a way to define task-context-global per-task mutable variables that are not visible in interrupt contexts. By doing so, many of the data specific to a task can be implemented lock-less.\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\n#### Task entry point\r\n\r\nThe optimal solution would let the task function receive references to the task data as arguments. Then all the functions that requires the data of the current task would like to receive arguments like so. This is the requirement of a function that should be used as a task entry point:\r\n\r\n```rust\r\n/// The entrypoint function of a task takes 4 arguments:\r\n///  1. the mutable task context,\r\n///  2. the shared task context,\r\n///  3. the reference to the mutable per-task data,\r\n///  4. and the reference to the per-task data.\r\npub trait TaskFn =\r\n    Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n```\r\n\r\nAn example of usage:\r\n\r\n```rust\r\n// In `aster-nix`\r\n\r\nuse ostd::task::{MutTaskInfo, Priority, SharedTaskInfo};\r\nuse crate::thread::{\r\n    MutKernelThreadInfo, MutThreadInfo, SharedKernelThreadInfo, SharedThreadInfo, ThreadExt,\r\n};\r\n\r\nfn init_thread(\r\n    task_ctx_mut: &mut MutTaskInfo,\r\n    task_ctx: &SharedTaskInfo,\r\n    thread_ctx_mut: &mut MutThreadInfo,\r\n    thread_ctx: &SharedThreadInfo,\r\n    kthread_ctx_mut: &mut MutKernelThreadInfo,\r\n    kthread_ctx: &SharedKernelThreadInfo,\r\n) {\r\n    println!(\r\n        \"[kernel] Spawn init thread, tid = {}\",\r\n        thread_ctx.tid\r\n    );\r\n    let initproc = Process::spawn_user_process(\r\n        karg.get_initproc_path().unwrap(),\r\n        karg.get_initproc_argv().to_vec(),\r\n        karg.get_initproc_envp().to_vec(),\r\n    )\r\n    .expect(\"Run init process failed.\");\r\n    // Wait till initproc become zombie.\r\n    while !initproc.is_zombie() {\r\n        // We don't have preemptive scheduler now.\r\n        // The long running init thread should yield its own execution to allow other tasks to go on.\r\n        task_ctx_mut.yield_now();\r\n    }\r\n}\r\n\r\n#[controlled]\r\npub fn run_first_process() -> ! {\r\n    let _thread = thread::new_kernel(init_thread, Priority::normal(), CpuSet::new_full());\r\n}\r\n```\r\n\r\nSuch approach can eliminate the need of neither `current!` nor `current_thread!`, but introduces verbose parameters for the functions. This approach would be implemented by #1108 .\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n#### Context markers\r\n\r\nOf course, the easiest way to block IRQ code from accessing task exclusive local data is to have a global state `IN_INTERRUPT_CONTEXT` and check for this state every time when accessing the task exclusive local variables. This would incur some (but not much) runtime overhead. Such overhead can be eliminated by static analysis, which we would encourage.\r\n\r\nThere would be 3 kind of contexts: the bootstrap context, the task context and the interrupt context. So the code would have $2^3=8$ types of possibilities to run in different contexts. But there are only 4 types that are significant:\r\n\r\n 1. Utility code that could run in all 3 kind of contexts;\r\n 2. Bootstrap code that only runs in the bootstrap context;\r\n 3. The IRQ handler that would only run in the interrupt context;\r\n 4. Task code that would only run in the task context.\r\n\r\nOther code can be regarded as the type 1., since we do not know where would it run (for example, the page table cursor methods).\r\n\r\nCode must be written in functions (except for some really low level bootstrap code, which are all in OSTD). So we can mark functions with the above types, and check if type 1./2./3. functions accessed task local exclusive global variables.\r\n\r\nHere are the rules for function types:\r\n\r\n - All functions that may call 2. should be 2., the root of type 2. function is `ostd::main` and `ostd::ap_entry`;\r\n - all functions that may call 3. should be 3., the root of type 3. functions are send to `IrqLine::on_active`;\r\n - all functions that may call 4. should be 4., the root of type 4. functions are send to `TaskOptions`;\r\n - if a function can be call with multiple types of functions, it is type 1.\r\n\r\nIn this alternative, two tools will be introduced:\r\n\r\n 1. A procedural macro crate `code_context` (re-exported by OSTD) that provides function attributes `#[code_context::task]`, `#[code_context::interrupt]`, `#[code_context::boot]`. If not specified, the function is type 1.;\r\n 2. A tools that uses rustc to check the above rules ([an example](https://github.com/heinzelotto/rust-callgraph/tree/master)). OSDK would run this tool before compilation to reject unsound code.\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n",
        "hints_text": "Let's say we have a function `foo` with `#[code_context::task]` attribute. How would this `foo` function \"receive references to the task data as arguments\"? What would the user code look like?\n> ```rust\r\n> /// The entrypoint function of a task takes 4 arguments:\r\n> ///  1. the mutable task context,\r\n> ///  2. the shared task context,\r\n> ///  3. the reference to the mutable per-task data,\r\n> ///  4. and the reference to the per-task data.\r\n> pub trait TaskFn =\r\n>     Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n> ```\r\n\r\nCould you please change it to `FnOnce`?\r\n\r\nhttps://github.com/asterinas/asterinas/blob/20a856b07fa8210fdd2d46d3feb5087004c27afb/kernel/aster-nix/src/fs/pipe.rs#L233-L235",
        "created_at": "2024-08-03T03:09:32Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1112,
        "instance_id": "asterinas__asterinas-1112",
        "issue_numbers": [
            "1089"
        ],
        "base_commit": "aa84b31634b9c710e04b337c5d1b8fa207f8dbde",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -398,6 +398,12 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"const-assert\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d8298db53081b3a951cadb6e0f4ebbe36def7bcb591a34676708d0d7ac87dd86\"\n+\n [[package]]\n name = \"controlled\"\n version = \"0.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1070,6 +1076,7 @@ dependencies = [\n  \"bitvec\",\n  \"buddy_system_allocator\",\n  \"cfg-if\",\n+ \"const-assert\",\n  \"gimli 0.28.0\",\n  \"iced-x86\",\n  \"id-alloc\",\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -129,17 +129,21 @@ impl VirtQueue {\n             let mut desc = descs.get(i as usize).unwrap().clone();\n             let next_i = i + 1;\n             if next_i != size {\n-                field_ptr!(&desc, Descriptor, next).write(&next_i).unwrap();\n+                field_ptr!(&desc, Descriptor, next)\n+                    .write_once(&next_i)\n+                    .unwrap();\n                 desc.add(1);\n                 descs.push(desc);\n             } else {\n-                field_ptr!(&desc, Descriptor, next).write(&(0u16)).unwrap();\n+                field_ptr!(&desc, Descriptor, next)\n+                    .write_once(&(0u16))\n+                    .unwrap();\n             }\n         }\n \n         let notify = transport.get_notify_ptr(idx).unwrap();\n         field_ptr!(&avail_ring_ptr, AvailRing, flags)\n-            .write(&(0u16))\n+            .write_once(&(0u16))\n             .unwrap();\n         Ok(VirtQueue {\n             descs,\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -177,10 +181,10 @@ impl VirtQueue {\n             let desc = &self.descs[self.free_head as usize];\n             set_dma_buf(&desc.borrow_vm().restrict::<TRights![Write, Dup]>(), *input);\n             field_ptr!(desc, Descriptor, flags)\n-                .write(&DescFlags::NEXT)\n+                .write_once(&DescFlags::NEXT)\n                 .unwrap();\n             last = self.free_head;\n-            self.free_head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+            self.free_head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n         }\n         for output in outputs.iter() {\n             let desc = &mut self.descs[self.free_head as usize];\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -189,17 +193,19 @@ impl VirtQueue {\n                 *output,\n             );\n             field_ptr!(desc, Descriptor, flags)\n-                .write(&(DescFlags::NEXT | DescFlags::WRITE))\n+                .write_once(&(DescFlags::NEXT | DescFlags::WRITE))\n                 .unwrap();\n             last = self.free_head;\n-            self.free_head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+            self.free_head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n         }\n         // set last_elem.next = NULL\n         {\n             let desc = &mut self.descs[last as usize];\n-            let mut flags: DescFlags = field_ptr!(desc, Descriptor, flags).read().unwrap();\n+            let mut flags: DescFlags = field_ptr!(desc, Descriptor, flags).read_once().unwrap();\n             flags.remove(DescFlags::NEXT);\n-            field_ptr!(desc, Descriptor, flags).write(&flags).unwrap();\n+            field_ptr!(desc, Descriptor, flags)\n+                .write_once(&flags)\n+                .unwrap();\n         }\n         self.num_used += (inputs.len() + outputs.len()) as u16;\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -210,7 +216,7 @@ impl VirtQueue {\n                 field_ptr!(&self.avail, AvailRing, ring);\n             let mut ring_slot_ptr = ring_ptr.cast::<u16>();\n             ring_slot_ptr.add(avail_slot as usize);\n-            ring_slot_ptr.write(&head).unwrap();\n+            ring_slot_ptr.write_once(&head).unwrap();\n         }\n         // write barrier\n         fence(Ordering::SeqCst);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -218,7 +224,7 @@ impl VirtQueue {\n         // increase head of avail ring\n         self.avail_idx = self.avail_idx.wrapping_add(1);\n         field_ptr!(&self.avail, AvailRing, idx)\n-            .write(&self.avail_idx)\n+            .write_once(&self.avail_idx)\n             .unwrap();\n \n         fence(Ordering::SeqCst);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -230,7 +236,7 @@ impl VirtQueue {\n         // read barrier\n         fence(Ordering::SeqCst);\n \n-        self.last_used_idx != field_ptr!(&self.used, UsedRing, idx).read().unwrap()\n+        self.last_used_idx != field_ptr!(&self.used, UsedRing, idx).read_once().unwrap()\n     }\n \n     /// The number of free descriptors.\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -247,19 +253,23 @@ impl VirtQueue {\n         loop {\n             let desc = &mut self.descs[head as usize];\n             // Sets the buffer address and length to 0\n-            field_ptr!(desc, Descriptor, addr).write(&(0u64)).unwrap();\n-            field_ptr!(desc, Descriptor, len).write(&(0u32)).unwrap();\n+            field_ptr!(desc, Descriptor, addr)\n+                .write_once(&(0u64))\n+                .unwrap();\n+            field_ptr!(desc, Descriptor, len)\n+                .write_once(&(0u32))\n+                .unwrap();\n             self.num_used -= 1;\n \n-            let flags: DescFlags = field_ptr!(desc, Descriptor, flags).read().unwrap();\n+            let flags: DescFlags = field_ptr!(desc, Descriptor, flags).read_once().unwrap();\n             if flags.contains(DescFlags::NEXT) {\n                 field_ptr!(desc, Descriptor, flags)\n-                    .write(&DescFlags::empty())\n+                    .write_once(&DescFlags::empty())\n                     .unwrap();\n-                head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+                head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n             } else {\n                 field_ptr!(desc, Descriptor, next)\n-                    .write(&origin_free_head)\n+                    .write_once(&origin_free_head)\n                     .unwrap();\n                 break;\n             }\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -280,8 +290,8 @@ impl VirtQueue {\n             ptr.byte_add(offset_of!(UsedRing, ring) as usize + last_used_slot as usize * 8);\n             ptr.cast::<UsedElem>()\n         };\n-        let index = field_ptr!(&element_ptr, UsedElem, id).read().unwrap();\n-        let len = field_ptr!(&element_ptr, UsedElem, len).read().unwrap();\n+        let index = field_ptr!(&element_ptr, UsedElem, id).read_once().unwrap();\n+        let len = field_ptr!(&element_ptr, UsedElem, len).read_once().unwrap();\n \n         self.recycle_descriptors(index as u16);\n         self.last_used_idx = self.last_used_idx.wrapping_add(1);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -304,8 +314,8 @@ impl VirtQueue {\n             ptr.byte_add(offset_of!(UsedRing, ring) as usize + last_used_slot as usize * 8);\n             ptr.cast::<UsedElem>()\n         };\n-        let index = field_ptr!(&element_ptr, UsedElem, id).read().unwrap();\n-        let len = field_ptr!(&element_ptr, UsedElem, len).read().unwrap();\n+        let index = field_ptr!(&element_ptr, UsedElem, id).read_once().unwrap();\n+        let len = field_ptr!(&element_ptr, UsedElem, len).read_once().unwrap();\n \n         if index as u16 != token {\n             return Err(QueueError::WrongToken);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -326,7 +336,7 @@ impl VirtQueue {\n     pub fn should_notify(&self) -> bool {\n         // read barrier\n         fence(Ordering::SeqCst);\n-        let flags = field_ptr!(&self.used, UsedRing, flags).read().unwrap();\n+        let flags = field_ptr!(&self.used, UsedRing, flags).read_once().unwrap();\n         flags & 0x0001u16 == 0u16\n     }\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -353,10 +363,10 @@ fn set_dma_buf<T: DmaBuf>(desc_ptr: &DescriptorPtr, buf: &T) {\n     debug_assert_ne!(buf.len(), 0);\n     let daddr = buf.daddr();\n     field_ptr!(desc_ptr, Descriptor, addr)\n-        .write(&(daddr as u64))\n+        .write_once(&(daddr as u64))\n         .unwrap();\n     field_ptr!(desc_ptr, Descriptor, len)\n-        .write(&(buf.len() as u32))\n+        .write_once(&(buf.len() as u32))\n         .unwrap();\n }\n \ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -7,7 +7,7 @@ use aster_rights_proc::require;\n use inherit_methods_macro::inherit_methods;\n pub use ostd::Pod;\n use ostd::{\n-    mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, VmIo},\n+    mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, PodOnce, VmIo, VmIoOnce},\n     Result,\n };\n pub use typeflags_util::SetContain;\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -324,6 +324,28 @@ impl<T: Pod, M: VmIo, R: TRights> SafePtr<T, M, TRightSet<R>> {\n     }\n }\n \n+impl<T: PodOnce, M: VmIoOnce, R: TRights> SafePtr<T, M, TRightSet<R>> {\n+    /// Reads the value from the pointer using one non-tearing instruction.\n+    ///\n+    /// # Access rights\n+    ///\n+    /// This method requires the `Read` right.\n+    #[require(R > Read)]\n+    pub fn read_once(&self) -> Result<T> {\n+        self.vm_obj.read_once(self.offset)\n+    }\n+\n+    /// Overwrites the value at the pointer using one non-tearing instruction.\n+    ///\n+    /// # Access rights\n+    ///\n+    /// This method requires the `Write` right.\n+    #[require(R > Write)]\n+    pub fn write_once(&self, val: &T) -> Result<()> {\n+        self.vm_obj.write_once(self.offset, val)\n+    }\n+}\n+\n impl<T, M: HasDaddr, R> HasDaddr for SafePtr<T, M, R> {\n     fn daddr(&self) -> Daddr {\n         self.offset + self.vm_obj.daddr()\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -22,6 +22,7 @@ buddy_system_allocator = \"0.9.0\"\n bitflags = \"1.3\"\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n cfg-if = \"1.0\"\n+const-assert = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n id-alloc = { path = \"libs/id-alloc\", version = \"0.1.0\" }\n inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\", version = \"0.1.0\" }\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -13,10 +13,12 @@ use crate::{\n     arch::{iommu, mm::tlb_flush_addr_range},\n     mm::{\n         dma::{dma_type, Daddr, DmaType},\n+        io::VmIoOnce,\n         kspace::{paddr_to_vaddr, KERNEL_PAGE_TABLE},\n         page_prop::CachePolicy,\n-        HasPaddr, Paddr, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n+        HasPaddr, Paddr, PodOnce, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n     },\n+    prelude::*,\n };\n \n /// A coherent (or consistent) DMA mapping,\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -47,7 +49,10 @@ impl DmaCoherent {\n     ///\n     /// The method fails if any part of the given `vm_segment`\n     /// already belongs to a DMA mapping.\n-    pub fn map(vm_segment: Segment, is_cache_coherent: bool) -> Result<Self, DmaError> {\n+    pub fn map(\n+        vm_segment: Segment,\n+        is_cache_coherent: bool,\n+    ) -> core::result::Result<Self, DmaError> {\n         let frame_count = vm_segment.nframes();\n         let start_paddr = vm_segment.start_paddr();\n         if !check_and_insert_dma_mapping(start_paddr, frame_count) {\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -160,15 +165,29 @@ impl Drop for DmaCoherentInner {\n }\n \n impl VmIo for DmaCoherent {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> crate::prelude::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         self.inner.vm_segment.read_bytes(offset, buf)\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> crate::prelude::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         self.inner.vm_segment.write_bytes(offset, buf)\n     }\n }\n \n+impl VmIoOnce for DmaCoherent {\n+    fn read_once<T: PodOnce>(&self, offset: usize) -> Result<T> {\n+        self.inner.vm_segment.reader().skip(offset).read_once()\n+    }\n+\n+    fn write_once<T: PodOnce>(&self, offset: usize, new_val: &T) -> Result<()> {\n+        self.inner\n+            .vm_segment\n+            .writer()\n+            .skip(offset)\n+            .write_once(new_val)\n+    }\n+}\n+\n impl<'a> DmaCoherent {\n     /// Returns a reader to read data from it.\n     pub fn reader(&'a self) -> VmReader<'a> {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -5,6 +5,7 @@\n use core::marker::PhantomData;\n \n use align_ext::AlignExt;\n+use const_assert::{Assert, IsTrue};\n use inherit_methods_macro::inherit_methods;\n \n use crate::{\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -155,7 +156,28 @@ pub trait VmIo: Send + Sync {\n     }\n }\n \n-macro_rules! impl_vmio_pointer {\n+/// A trait that enables reading/writing data from/to a VM object using one non-tearing memory\n+/// load/store.\n+///\n+/// See also [`VmIo`], which enables reading/writing data from/to a VM object without the guarantee\n+/// of using one non-tearing memory load/store.\n+pub trait VmIoOnce {\n+    /// Reads a value of the `PodOnce` type at the specified offset using one non-tearing memory\n+    /// load.\n+    ///\n+    /// Except that the offset is specified explicitly, the semantics of this method is the same as\n+    /// [`VmReader::read_once`].\n+    fn read_once<T: PodOnce>(&self, offset: usize) -> Result<T>;\n+\n+    /// Writes a value of the `PodOnce` type at the specified offset using one non-tearing memory\n+    /// store.\n+    ///\n+    /// Except that the offset is specified explicitly, the semantics of this method is the same as\n+    /// [`VmWriter::write_once`].\n+    fn write_once<T: PodOnce>(&self, offset: usize, new_val: &T) -> Result<()>;\n+}\n+\n+macro_rules! impl_vm_io_pointer {\n     ($typ:ty,$from:tt) => {\n         #[inherit_methods(from = $from)]\n         impl<T: VmIo> VmIo for $typ {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -169,10 +191,25 @@ macro_rules! impl_vmio_pointer {\n     };\n }\n \n-impl_vmio_pointer!(&T, \"(**self)\");\n-impl_vmio_pointer!(&mut T, \"(**self)\");\n-impl_vmio_pointer!(Box<T>, \"(**self)\");\n-impl_vmio_pointer!(Arc<T>, \"(**self)\");\n+impl_vm_io_pointer!(&T, \"(**self)\");\n+impl_vm_io_pointer!(&mut T, \"(**self)\");\n+impl_vm_io_pointer!(Box<T>, \"(**self)\");\n+impl_vm_io_pointer!(Arc<T>, \"(**self)\");\n+\n+macro_rules! impl_vm_io_once_pointer {\n+    ($typ:ty,$from:tt) => {\n+        #[inherit_methods(from = $from)]\n+        impl<T: VmIoOnce> VmIoOnce for $typ {\n+            fn read_once<F: PodOnce>(&self, offset: usize) -> Result<F>;\n+            fn write_once<F: PodOnce>(&self, offset: usize, new_val: &F) -> Result<()>;\n+        }\n+    };\n+}\n+\n+impl_vm_io_once_pointer!(&T, \"(**self)\");\n+impl_vm_io_once_pointer!(&mut T, \"(**self)\");\n+impl_vm_io_once_pointer!(Box<T>, \"(**self)\");\n+impl_vm_io_once_pointer!(Arc<T>, \"(**self)\");\n \n /// A marker structure used for [`VmReader`] and [`VmWriter`],\n /// representing their operated memory scope is in user space.\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -391,6 +428,34 @@ impl<'a> VmReader<'a, KernelSpace> {\n         self.read(&mut writer);\n         Ok(val)\n     }\n+\n+    /// Reads a value of the `PodOnce` type using one non-tearing memory load.\n+    ///\n+    /// If the length of the `PodOnce` type exceeds `self.remain()`, this method will return `Err`.\n+    ///\n+    /// This method will not compile if the `Pod` type is too large for the current architecture\n+    /// and the operation must be tear into multiple memory loads.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if the current position of the reader does not meet the alignment\n+    /// requirements of type `T`.\n+    pub fn read_once<T: PodOnce>(&mut self) -> Result<T> {\n+        if self.remain() < core::mem::size_of::<T>() {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let cursor = self.cursor.cast::<T>();\n+        assert!(cursor.is_aligned());\n+\n+        // SAFETY: We have checked that the number of bytes remaining is at least the size of `T`\n+        // and that the cursor is properly aligned with respect to the type `T`. All other safety\n+        // requirements are the same as for `Self::read`.\n+        let val = unsafe { cursor.read_volatile() };\n+        self.cursor = unsafe { self.cursor.add(core::mem::size_of::<T>()) };\n+\n+        Ok(val)\n+    }\n }\n \n impl<'a> VmReader<'a, UserSpace> {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -461,7 +526,7 @@ impl<'a, Space> VmReader<'a, Space> {\n     /// Skips the first `nbytes` bytes of data.\n     /// The length of remaining data is decreased accordingly.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// If `nbytes` is greater than `self.remain()`, then the method panics.\n     pub fn skip(mut self, nbytes: usize) -> Self {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -553,11 +618,36 @@ impl<'a> VmWriter<'a, KernelSpace> {\n         Ok(())\n     }\n \n+    /// Writes a value of the `PodOnce` type using one non-tearing memory store.\n+    ///\n+    /// If the length of the `PodOnce` type exceeds `self.remain()`, this method will return `Err`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if the current position of the writer does not meet the alignment\n+    /// requirements of type `T`.\n+    pub fn write_once<T: PodOnce>(&mut self, new_val: &T) -> Result<()> {\n+        if self.avail() < core::mem::size_of::<T>() {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let cursor = self.cursor.cast::<T>();\n+        assert!(cursor.is_aligned());\n+\n+        // SAFETY: We have checked that the number of bytes remaining is at least the size of `T`\n+        // and that the cursor is properly aligned with respect to the type `T`. All other safety\n+        // requirements are the same as for `Self::writer`.\n+        unsafe { cursor.cast::<T>().write_volatile(*new_val) };\n+        self.cursor = unsafe { self.cursor.add(core::mem::size_of::<T>()) };\n+\n+        Ok(())\n+    }\n+\n     /// Fills the available space by repeating `value`.\n     ///\n     /// Returns the number of values written.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// The size of the available space must be a multiple of the size of `value`.\n     /// Otherwise, the method would panic.\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -574,7 +664,7 @@ impl<'a> VmWriter<'a, KernelSpace> {\n             // hence the `add` operation and `write` operation are valid and will only manipulate\n             // the memory managed by this writer.\n             unsafe {\n-                (self.cursor as *mut T).add(i).write(value);\n+                (self.cursor as *mut T).add(i).write_volatile(value);\n             }\n         }\n \ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -650,7 +740,7 @@ impl<'a, Space> VmWriter<'a, Space> {\n     /// Skips the first `nbytes` bytes of data.\n     /// The length of available space is decreased accordingly.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// If `nbytes` is greater than `self.avail()`, then the method panics.\n     pub fn skip(mut self, nbytes: usize) -> Self {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -672,3 +762,23 @@ impl<'a> From<&'a mut [u8]> for VmWriter<'a> {\n         unsafe { Self::from_kernel_space(slice.as_mut_ptr(), slice.len()) }\n     }\n }\n+\n+/// A marker trait for POD types that can be read or written with one instruction.\n+///\n+/// We currently rely on this trait to ensure that the memory operation created by\n+/// `ptr::read_volatile` and `ptr::write_volatile` doesn't tear. However, the Rust documentation\n+/// makes no such guarantee, and even the wording in the LLVM LangRef is ambiguous.\n+///\n+/// At this point, we can only _hope_ that this doesn't break in future versions of the Rust or\n+/// LLVM compilers. However, this is unlikely to happen in practice, since the Linux kernel also\n+/// uses \"volatile\" semantics to implement `READ_ONCE`/`WRITE_ONCE`.\n+pub trait PodOnce: Pod {}\n+\n+impl<T: Pod> PodOnce for T where Assert<{ is_pod_once::<T>() }>: IsTrue {}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+const fn is_pod_once<T: Pod>() -> bool {\n+    let size = size_of::<T>();\n+\n+    size == 1 || size == 2 || size == 4 || size == 8\n+}\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -28,7 +28,7 @@ use spin::Once;\n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n     frame::{options::FrameAllocOptions, Frame, Segment},\n-    io::{KernelSpace, UserSpace, VmIo, VmReader, VmWriter},\n+    io::{KernelSpace, PodOnce, UserSpace, VmIo, VmIoOnce, VmReader, VmWriter},\n     page_prop::{CachePolicy, PageFlags, PageProperty},\n     vm_space::VmSpace,\n };\n",
        "test_patch": "diff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -192,7 +211,7 @@ mod test {\n     use alloc::vec;\n \n     use super::*;\n-    use crate::{mm::FrameAllocOptions, prelude::*};\n+    use crate::mm::FrameAllocOptions;\n \n     #[ktest]\n     fn map_with_coherent_device() {\n",
        "problem_statement": "Syscall test at Ext2, MicroVM occasionally fails\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n### To Reproduce\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\nIn CI, the syscall test at Ext2, MicroVM randomly output bad characters and then hang without panicking. There are some runs that seemed irrelevant with the PR modification:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10053473151/job/27786308763?pr=1088\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10021055466/job/27699299104\r\n\r\nThey would pass the syscall test at ramfs (linux boot, normal VM), and then fail at Ext2, MicroVM.\r\n\r\n### Logs\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\r\nThe log would look like this:\r\n\r\n```\r\n[Bn\f\u0000\ufffd731ns] : p\ufffdb\f\u0000\ufffd\ufffd\ufffd\ufffd\u001cl\f\u0000\ufffd\ufffd\ufffd\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000R<\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffd1\ufffd\ufffd\ufffd\ufffd\ufffd\u0000\u0000protected range is not fully mappedp\u0000\u0000\u0000hk\f\u0000\ufffd\ufffd\ufffd\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"} \u0000\r\n```\r\n\n",
        "hints_text": "Another example:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10104476344/job/27943517035?pr=1030\nI found it being reproducible (randomly) locally. And it has nothing to do with Ext2. It seems to be a problem with MicroVM.\nIt is really easy to reproduce but once you need to debug (via printing or gdb), it is really hard to reproduce. It seems that it occurs lesser if the system is running more slowly (LOL).\r\n\r\nI GDBed it with KVM on (can't use breakpoints but can backtrace), I found that it hangs here:\r\n\r\n```\r\n(gdb) bt\r\n#0  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::acquire_lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:111\r\n#1  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:74\r\n#2  0xffffffff882765bd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#3  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#4  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#5  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#6  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#7  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#8  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#9  alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#10 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#11 alloc::string::String::with_capacity () at src/string.rs:492\r\n#12 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#13 0xffffffff8826174f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#14 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#15 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#16 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93d858) at src/logger.rs:37\r\n#17 0xffffffff880e2859 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#18 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#19 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#20 0xffffffff8827db32 in ostd::mm::vm_space::VmSpace::handle_page_fault (self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>, \r\n    info=0xffff8000ba93da00) at src/mm/vm_space.rs:109\r\n#21 ostd::arch::x86::trap::handle_user_page_fault (f=0xffff8000ba93dae0, page_fault_addr=7) at src/arch/x86/trap.rs:86\r\n#22 ostd::arch::x86::trap::trap_handler (f=0xffff8000ba93dae0) at src/arch/x86/trap.rs:54\r\n#23 0xffffffff8829911a in __from_kernel ()\r\n#24 0x0000000000000008 in ?? ()\r\n#25 0x0000000000000000 in ?? ()\r\n```\r\n\r\nhttps://github.com/asterinas/asterinas/issues/1085\r\n\r\nIt seemed, not reliable\nOk, the previous backtrace I offered is definitely resulted by a kernel mode page fault. After restoring the trapframe in GDB I had a backtrace at the state which the page fault happened:\r\n\r\n```\r\n(gdb) bt\r\n#0  core::sync::atomic::atomic_compare_exchange<u8> (dst=0x40, old=0, new=1, success=core::sync::atomic::Ordering::Acquire, failure=core::sync::atomic::Ordering::Relaxed)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3373\r\n#1  core::sync::atomic::AtomicBool::compare_exchange (self=0x40, current=false, new=true, success=core::sync::atomic::Ordering::Acquire, failure=core::sync::atomic::Ordering::Relaxed)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:811\r\n#2  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon:\r\n#3  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon \r\n    self=0x40) at src/sync/spin.rs:111\r\n#4  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon \r\n    self=0x40) at src/sync/spin.rs:74\r\n#5  0xffffffff88275edd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#6  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#7  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#8  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#9  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#10 alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#11 alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#12 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#13 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#14 alloc::string::String::with_capacity () at src/string.rs:492\r\n#15 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#16 0xffffffff8826106f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#17 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#18 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#19 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93dbd8) at src/logger.rs:37\r\n#20 0xffffffff881234d9 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#21 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#22 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#23 0xffffffff8827617b in buddy_system_allocator::linked_list::{impl#5}::next (self=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/linked_list.rs:137\r\n#24 buddy_system_allocator::Heap<32>::dealloc<32> (ptr=..., layout=..., self=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/lib.rs:164\r\n#25 ostd::mm::heap_allocator::{impl#1}::dealloc<32> (self=<optimized out>, ptr=<optimized out>, layout=...) at src/mm/heap_allocator.rs:90\r\n#26 0x080000000000001f in ?? ()\r\n#27 0xffffffff883086b9 in ?? ()\r\n#28 0x0000000000000007 in ?? ()\r\n#29 0xffff8000ba93ddc8 in ?? ()\r\n#30 0xffff80000c389008 in ?? ()\r\n#31 0x0000000000000002 in ?? ()\r\n#32 0x0000000000000000 in ?? ()\r\n```\nAfter user space NULL pointers are checked, I attempted to backtraced the first page fault which leads to a lockout. Here's the stack:\r\n\r\n```\r\n(gdb) bt\r\n#0  0xffffffff8825e56b in buddy_system_allocator::linked_list::{impl#5}::next (self=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/linked_list.rs:137\r\n#1  buddy_system_allocator::Heap<32>::dealloc<32> (ptr=..., layout=..., self=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/lib.rs:164\r\n#2  ostd::mm::heap_allocator::{impl#1}::dealloc<32> (self=<optimized out>, ptr=<optimized out>, layout=...) at src/mm/heap_allocator.rs:90\r\n#3  0x0000000000000020 in ?? ()\r\n#4  0x0000000000000040 in ?? ()\r\n#5  0x0000000000000001 in ?? ()\r\n#6  0xffffffff8825253b in core::alloc::global::GlobalAlloc::realloc<ostd::mm::heap_allocator::LockedHeapWithRescue<32>> (ptr=0xffff80000c8b1460, layout=..., new_size=18446603336431669952, \r\n    self=<optimized out>) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/global.rs:271\r\n#7  ostd::mm::heap_allocator::_::__rust_realloc (ptr=0xffff80000c8b1460, size=0, align=18446603339351457464, new_size=18446603336431669952) at src/mm/heap_allocator.rs:22\r\n#8  alloc::alloc::realloc () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:138\r\n#9  alloc::alloc::Global::grow_impl (ptr=..., old_layout=..., new_layout=..., zeroed=false, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:215\r\n#10 alloc::alloc::{impl#1}::grow (ptr=..., old_layout=..., new_layout=..., self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:268\r\n#11 alloc::raw_vec::finish_grow<alloc::alloc::Global> (new_layout=..., current_memory=..., alloc=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:570\r\n#12 0xffffffff88252628 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::grow_amortized<u8, alloc::alloc::Global> (len=<optimized out>, additional=<optimized out>, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:485\r\n#13 alloc::raw_vec::{impl#2}::reserve::do_reserve_and_handle<u8, alloc::alloc::Global> (slf=0xffff8000ba93fff0, len=<optimized out>, additional=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:349\r\n#14 0xffffffff882722d2 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::reserve<u8, alloc::alloc::Global> (self=<optimized out>, len=<optimized out>, additional=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:355\r\n#15 alloc::vec::Vec<u8, alloc::alloc::Global>::reserve<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, additional=1)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:972\r\n#16 alloc::vec::Vec<u8, alloc::alloc::Global>::append_elements<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, other=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2145\r\n#17 alloc::vec::spec_extend::{impl#4}::spec_extend<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, iterator=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:55\r\n#18 alloc::vec::Vec<u8, alloc::alloc::Global>::extend_from_slice<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, other=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2591\r\n#19 alloc::string::String::push_str () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1067\r\n#20 alloc::string::{impl#58}::write_str (self=0xffff8000ba93fff0, s=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2921\r\n#21 0xffffffff88228d7f in core::fmt::num::imp::fmt_u64 (n=<optimized out>, is_nonnegative=true, f=<optimized out>) at src/fmt/num.rs:278\r\n#22 core::fmt::num::imp::{impl#7}::fmt (self=<optimized out>, f=0x20) at src/fmt/num.rs:324\r\n#23 0xffffffff8822453c in core::fmt::rt::Argument::fmt (self=0xffff8000ba940118, f=0xffff8000ba93ff68) at src/fmt/rt.rs:165\r\n#24 core::fmt::write (output=..., args=...) at src/fmt/mod.rs:1168\r\n#25 0xffffffff88273238 in core::fmt::Formatter::write_fmt (fmt=..., self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1640\r\n#26 core::panic::panic_info::{impl#3}::fmt (self=0xffff8000ba9400b8, formatter=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic/panic_info.rs:180\r\n#27 alloc::string::{impl#32}::to_string<core::panic::panic_info::PanicMessage> (self=0xffff8000ba9400b8)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2562\r\n#28 ostd::panicking::panic_handler (info=0xffff8000ba9400b8) at src/panicking.rs:33\r\n#29 0xffffffff8821c946 in asterinas_osdk_bin::panic (info=0x20) at src/main.rs:11\r\n#30 0xffffffff8822c3bf in core::panicking::panic_fmt (fmt=...) at src/panicking.rs:74\r\n#31 0xffffffff8822c5ef in core::panicking::panic_bounds_check (index=57088, len=2) at src/panicking.rs:276\r\n#32 0xffffffff881f38b5 in core::slice::index::{impl#2}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<aster_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>> (self=57088, slice=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:298\r\n#33 core::slice::index::{impl#1}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<ast--Type <RET> for more, q to quit, c to continue without paging--\r\ner_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>, usize> (self=..., index=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:27\r\n#34 alloc::vec::{impl#14}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<aster_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>, usize, alloc::alloc::Global> (index=57088, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2917\r\n#35 aster_virtio::queue::VirtQueue::recycle_descriptors (self=<optimized out>, head=<optimized out>) at src/queue.rs:248\r\n#36 0xffffffff881f3b90 in aster_virtio::queue::VirtQueue::pop_used (self=0xffffffff88469258 <ostd::mm::heap_allocator::HEAP_SPACE+1032710>) at src/queue.rs:286\r\n#37 0xffffffff8821a0df in aster_virtio::device::console::device::ConsoleDevice::handle_recv_irq (self=0xffffffff88469210 <ostd::mm::heap_allocator::HEAP_SPACE+1032638>)\r\n    at src/device/console/device.rs:134\r\n#38 aster_virtio::device::console::device::{impl#2}::init::{closure#0} () at src/device/console/device.rs:115\r\n#39 0xffffffff8821a4ca in alloc::boxed::{impl#50}::call<(&trapframe::arch::trap::TrapFrame), (dyn core::ops::function::Fn<(&trapframe::arch::trap::TrapFrame), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=<optimized out>, args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2076\r\n#40 aster_virtio::transport::mmio::multiplex::{impl#0}::new::{closure#0} (trap_frame=0xffff8000ba940510) at src/transport/mmio/multiplex.rs:56\r\n#41 0xffffffff88256e0a in alloc::boxed::{impl#50}::call<(&trapframe::arch::trap::TrapFrame), (dyn core::ops::function::Fn<(&trapframe::arch::trap::TrapFrame), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=<optimized out>, args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2076\r\n#42 ostd::arch::x86::irq::CallbackElement::call (self=<optimized out>, element=0xffff8000ba940510) at src/arch/x86/irq.rs:68\r\n#43 ostd::trap::handler::call_irq_callback_functions (trap_frame=0xffff8000ba940510, irq_number=38) at src/trap/handler.rs:19\r\n#44 0xffffffff88255c03 in ostd::arch::x86::trap::trap_handler (f=0x20) at src/arch/x86/trap.rs:68\r\n#45 0xffffffff882966de in __from_kernel ()\r\n#46 0x0000000000000000 in ?? ()\r\n```\nA further dig:\r\n\r\n```\r\n   0xffffffff8825e565 <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+245>:\tmov    %r15,%r10\r\n   0xffffffff8825e568 <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+248>:\tmov    %rsi,%r15\r\n=> 0xffffffff8825e56b <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+251>:\tmov    (%rsi),%r11\r\n```\r\n\r\nThe PF happened at `0xffffffff8825e56b`, but in the trapframe, `$rsi=0xe0`, `$r15=0xe0`, `r10=0xffff80000c8b92a0`, which absolutely makes no sense.\nI've noticed that the issue is connected to the heap allocator. As a result, I think it could be the same problem as issue #1085. Can you try making the changes described in the `Additional context`? However, I'm not sure if this will solve the problem.\r\n\r\nUpdate: The problem described in #1085 does not seem to be related to PF, and may not be the same issue.\nThe root cause is:\r\n\r\n```\r\npanicked at /root/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\nindex out of bounds: the len is 2 but the index is 768\r\n```\r\n\r\nIt only happens randomly in MicroVM.\r\n\r\nSuch a panic results in a failing heap allocation, which in turn causes the kernel to hang.\r\n\r\n@sdww0 Do you have ideas about why the virtio queue driver failed?\n> The root cause is:\r\n> \r\n> ```\r\n> panicked at /root/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\n> index out of bounds: the len is 2 but the index is 768\r\n> ```\r\n> \r\n> It only happens randomly in MicroVM.\r\n> \r\n> Such a panic results in a failing heap allocation, which in turn causes the kernel to hang.\r\n> \r\n> @sdww0 Do you have ideas about why the virtio queue driver failed?\r\n\r\nThe only device that set the queue size to 2 is the console device. I think it is the [send function](https://github.com/asterinas/asterinas/blob/main/kernel/comps/virtio/src/device/console/device.rs#L34) cause this problem when calling `pop_used` (Since Github CI receive no input):\r\n\r\n```rust\r\nimpl AnyConsoleDevice for ConsoleDevice {\r\n    fn send(&self, value: &[u8]) {\r\n        let mut transmit_queue = self.transmit_queue.lock_irq_disabled();\r\n        let mut reader = VmReader::from(value);\r\n\r\n        while reader.remain() > 0 {\r\n            let mut writer = self.send_buffer.writer().unwrap();\r\n            let len = writer.write(&mut reader);\r\n            self.send_buffer.sync(0..len).unwrap();\r\n\r\n            let slice = DmaStreamSlice::new(&self.send_buffer, 0, len);\r\n            transmit_queue.add_dma_buf(&[&slice], &[]).unwrap();\r\n\r\n            if transmit_queue.should_notify() {\r\n                transmit_queue.notify();\r\n            }\r\n            while !transmit_queue.can_pop() {\r\n                spin_loop();\r\n            }\r\n            transmit_queue.pop_used().unwrap();\r\n        }\r\n    }\r\n\r\n    fn register_callback(&self, callback: &'static ConsoleCallback) {\r\n        self.callbacks.write_irq_disabled().push(callback);\r\n    }\r\n}\r\n```\r\n\r\n`send` -> `pop_used` -> `recycle_descriptor` -> `panic`\r\n\n> `send` -> `pop_used` -> `recycle_descriptor` -> `panic`\r\n\r\nThe call chain should be `handle_recv_irq` -> `pop_used` -> `recycle_descriptor` -> `panic`. The call chain can be discovered in https://github.com/asterinas/asterinas/issues/1089#issuecomment-2253719767, which is the backtrace in one failure case.\nHere is another CI failure after https://github.com/asterinas/asterinas/pull/1103:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10146669825/job/28055276772?pr=1109\r\n> panicked at /__w/asterinas/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\nindex out of bounds: the len is 2 but the index is 512\r\nprinting stack trace:\r\n\r\nUnfortunately, the stack traces are still not available.\nhttps://github.com/asterinas/asterinas/actions/runs/10155075478/job/28081230243\r\n\r\nYes the CI reproduced the error. Reopening.\nI checked the assembly code and suspect that https://github.com/asterinas/asterinas/pull/1112 will fix the root cause. At least I can no longer reproduce the problem locally.",
        "created_at": "2024-07-30T04:20:46Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1103,
        "instance_id": "asterinas__asterinas-1103",
        "issue_numbers": [
            "1089"
        ],
        "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60",
        "patch": "diff --git a/docs/src/kernel/advanced-instructions.md b/docs/src/kernel/advanced-instructions.md\n--- a/docs/src/kernel/advanced-instructions.md\n+++ b/docs/src/kernel/advanced-instructions.md\n@@ -93,3 +93,6 @@ Your previous launch configs will be restored after the server is down.\n Press `F5`(Run and Debug) to start a debug session via VS Code. \n Click `Continue`(or, press `F5`) at the fisrt break to resume the paused server instance,\n then it will continue until reaching your first breakpoint. \n+\n+Note that if debugging with KVM enabled, you must use hardware assisted breakpoints. See \"hbreak\" in\n+[the GDB manual](https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html) for details.\ndiff --git a/kernel/aster-nix/src/syscall/read.rs b/kernel/aster-nix/src/syscall/read.rs\n--- a/kernel/aster-nix/src/syscall/read.rs\n+++ b/kernel/aster-nix/src/syscall/read.rs\n@@ -1,5 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use core::cmp::min;\n+\n use super::SyscallReturn;\n use crate::{fs::file_table::FileDesc, prelude::*, util::write_bytes_to_user};\n \ndiff --git a/kernel/aster-nix/src/syscall/read.rs b/kernel/aster-nix/src/syscall/read.rs\n--- a/kernel/aster-nix/src/syscall/read.rs\n+++ b/kernel/aster-nix/src/syscall/read.rs\n@@ -15,8 +17,20 @@ pub fn sys_read(fd: FileDesc, user_buf_addr: Vaddr, buf_len: usize) -> Result<Sy\n         file_table.get_file(fd)?.clone()\n     };\n \n-    let mut read_buf = vec![0u8; buf_len];\n-    let read_len = file.read(&mut read_buf)?;\n-    write_bytes_to_user(user_buf_addr, &mut VmReader::from(read_buf.as_slice()))?;\n+    // According to <https://man7.org/linux/man-pages/man2/read.2.html>, if\n+    // the user specified an empty buffer, we should detect errors by checking\n+    // the file discriptor. If no errors detected, return 0 successfully.\n+    let read_len = if buf_len != 0 {\n+        let mut read_buf = vec![0u8; buf_len];\n+        let read_len = file.read(&mut read_buf)?;\n+        write_bytes_to_user(\n+            user_buf_addr,\n+            &mut VmReader::from(&read_buf[..min(read_len, buf_len)]),\n+        )?;\n+        read_len\n+    } else {\n+        file.read(&mut [])?\n+    };\n+\n     Ok(SyscallReturn::Return(read_len as _))\n }\ndiff --git a/kernel/aster-nix/src/syscall/write.rs b/kernel/aster-nix/src/syscall/write.rs\n--- a/kernel/aster-nix/src/syscall/write.rs\n+++ b/kernel/aster-nix/src/syscall/write.rs\n@@ -20,9 +20,17 @@ pub fn sys_write(fd: FileDesc, user_buf_ptr: Vaddr, user_buf_len: usize) -> Resu\n         file_table.get_file(fd)?.clone()\n     };\n \n-    let mut buffer = vec![0u8; user_buf_len];\n-    read_bytes_from_user(user_buf_ptr, &mut VmWriter::from(buffer.as_mut_slice()))?;\n-    debug!(\"write content = {:?}\", buffer);\n-    let write_len = file.write(&buffer)?;\n+    // According to <https://man7.org/linux/man-pages/man2/write.2.html>, if\n+    // the user specified an empty buffer, we should detect errors by checking\n+    // the file discriptor. If no errors detected, return 0 successfully.\n+    let write_len = if user_buf_len != 0 {\n+        let mut buffer = vec![0u8; user_buf_len];\n+        read_bytes_from_user(user_buf_ptr, &mut VmWriter::from(buffer.as_mut_slice()))?;\n+        debug!(\"write content = {:?}\", buffer);\n+        file.write(&buffer)?\n+    } else {\n+        file.write(&[])?\n+    };\n+\n     Ok(SyscallReturn::Return(write_len as _))\n }\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -15,15 +15,25 @@ pub mod random;\n \n pub use iovec::{copy_iovs_from_user, IoVec};\n \n-/// Reads bytes into the `dest` `VmWriter`\n-/// from the user space of the current process.\n+/// Reads bytes into the destination `VmWriter` from the user space of the\n+/// current process.\n ///\n-/// If the reading is completely successful, returns `Ok`.\n-/// Otherwise, returns `Err`.\n+/// If the reading is completely successful, returns `Ok`. Otherwise, it\n+/// returns `Err`.\n+///\n+/// If the destination `VmWriter` (`dest`) is empty, this function still\n+/// checks if the current task and user space are available. If they are,\n+/// it returns `Ok`.\n ///\n /// TODO: this API can be discarded and replaced with the API of `VmReader`\n /// after replacing all related `buf` usages.\n pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n+    let copy_len = dest.avail();\n+\n+    if copy_len > 0 {\n+        check_vaddr(src)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -32,16 +42,18 @@ pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n         Errno::EFAULT,\n         \"the user space is missing\",\n     ))?;\n-    let copy_len = dest.avail();\n \n     let mut user_reader = user_space.vm_space().reader(src, copy_len)?;\n     user_reader.read_fallible(dest).map_err(|err| err.0)?;\n     Ok(())\n }\n \n-/// Reads a value of `Pod` type\n-/// from the user space of the current process.\n+/// Reads a value typed `Pod` from the user space of the current process.\n pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n+    if core::mem::size_of::<T>() > 0 {\n+        check_vaddr(src)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -57,15 +69,25 @@ pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n     Ok(user_reader.read_val()?)\n }\n \n-/// Writes bytes from the `src` `VmReader`\n-/// to the user space of the current process.\n+/// Writes bytes from the source `VmReader` to the user space of the current\n+/// process.\n+///\n+/// If the writing is completely successful, returns `Ok`. Otherwise, it\n+/// returns `Err`.\n ///\n-/// If the writing is completely successful, returns `Ok`,\n-/// Otherwise, returns `Err`.\n+/// If the source `VmReader` (`src`) is empty, this function still checks if\n+/// the current task and user space are available. If they are, it returns\n+/// `Ok`.\n ///\n /// TODO: this API can be discarded and replaced with the API of `VmWriter`\n /// after replacing all related `buf` usages.\n pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) -> Result<()> {\n+    let copy_len = src.remain();\n+\n+    if copy_len > 0 {\n+        check_vaddr(dest)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -74,7 +96,6 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n         Errno::EFAULT,\n         \"the user space is missing\",\n     ))?;\n-    let copy_len = src.remain();\n \n     let mut user_writer = user_space.vm_space().writer(dest, copy_len)?;\n     user_writer.write_fallible(src).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -83,6 +104,10 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n \n /// Writes `val` to the user space of the current process.\n pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n+    if core::mem::size_of::<T>() > 0 {\n+        check_vaddr(dest)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -107,6 +132,10 @@ pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n /// The original Linux implementation can be found at:\n /// <https://elixir.bootlin.com/linux/v6.0.9/source/lib/strncpy_from_user.c#L28>\n pub fn read_cstring_from_user(addr: Vaddr, max_len: usize) -> Result<CString> {\n+    if max_len > 0 {\n+        check_vaddr(addr)?;\n+    }\n+\n     let current = current!();\n     let vmar = current.root_vmar();\n     read_cstring_from_vmar(vmar, addr, max_len)\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -114,6 +143,10 @@ pub fn read_cstring_from_user(addr: Vaddr, max_len: usize) -> Result<CString> {\n \n /// Read CString from `vmar`. If possible, use `read_cstring_from_user` instead.\n pub fn read_cstring_from_vmar(vmar: &Vmar<Full>, addr: Vaddr, max_len: usize) -> Result<CString> {\n+    if max_len > 0 {\n+        check_vaddr(addr)?;\n+    }\n+\n     let mut buffer: Vec<u8> = Vec::with_capacity(max_len);\n     let mut cur_addr = addr;\n \ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -175,3 +208,24 @@ const fn has_zero(value: usize) -> bool {\n \n     value.wrapping_sub(ONE_BITS) & !value & HIGH_BITS != 0\n }\n+\n+/// Check if the user space pointer is below the lowest userspace address.\n+///\n+/// If a pointer is below the lowest userspace address, it is likely to be a\n+/// NULL pointer. Reading from or writing to a NULL pointer should trigger a\n+/// segmentation fault.\n+///\n+/// If it is not checked here, a kernel page fault will happen and we would\n+/// deny the access in the page fault handler either. It may save a page fault\n+/// in some occasions. More importantly, double page faults may not be handled\n+/// quite well on some platforms.\n+fn check_vaddr(va: Vaddr) -> Result<()> {\n+    if va < crate::vm::vmar::ROOT_VMAR_LOWEST_ADDR {\n+        Err(Error::with_message(\n+            Errno::EFAULT,\n+            \"Bad user space pointer specified\",\n+        ))\n+    } else {\n+        Ok(())\n+    }\n+}\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -123,7 +123,7 @@ impl VmarInner {\n     }\n }\n \n-const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n+pub const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n const ROOT_VMAR_CAP_ADDR: Vaddr = MAX_USERSPACE_VADDR;\n \n impl Interval<usize> for Arc<Vmar_> {\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -3,7 +3,7 @@\n use super::{build::create_base_and_cached_build, util::DEFAULT_TARGET_RELPATH};\n use crate::{\n     cli::GdbServerArgs,\n-    config::{scheme::ActionChoice, unix_args::split_to_kv_array, Config},\n+    config::{scheme::ActionChoice, Config},\n     util::{get_current_crate_info, get_target_directory},\n };\n \ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -41,20 +41,6 @@ pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n         };\n         config.run.qemu.args += &qemu_gdb_args;\n \n-        // FIXME: Disable KVM from QEMU args in debug mode.\n-        // Currently, the QEMU GDB server does not work properly with KVM enabled.\n-        let mut splitted = split_to_kv_array(&config.run.qemu.args);\n-        let args_num = splitted.len();\n-        splitted.retain(|x| !x.contains(\"kvm\"));\n-        if splitted.len() != args_num {\n-            println!(\n-                \"[WARNING] KVM is forced to be disabled in GDB server currently. \\\n-                    Options related with KVM are ignored.\"\n-            );\n-        }\n-\n-        config.run.qemu.args = splitted.join(\" \");\n-\n         // Ensure debug info added when debugging in the release profile.\n         if config.run.build.profile.contains(\"release\") {\n             config\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -2,11 +2,8 @@\n \n //! Panic support.\n \n-use alloc::{boxed::Box, string::ToString};\n use core::ffi::c_void;\n \n-use log::error;\n-\n use crate::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n     early_print, early_println,\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -15,12 +12,9 @@ use crate::{\n extern crate cfg_if;\n extern crate gimli;\n use gimli::Register;\n-use unwinding::{\n-    abi::{\n-        UnwindContext, UnwindReasonCode, _Unwind_Backtrace, _Unwind_FindEnclosingFunction,\n-        _Unwind_GetGR, _Unwind_GetIP,\n-    },\n-    panic::begin_panic,\n+use unwinding::abi::{\n+    UnwindContext, UnwindReasonCode, _Unwind_Backtrace, _Unwind_FindEnclosingFunction,\n+    _Unwind_GetGR, _Unwind_GetIP,\n };\n \n /// The panic handler must be defined in the binary crate or in the crate that the binary\n",
        "test_patch": "diff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -29,17 +23,22 @@ use unwinding::{\n /// panic handler in the binary crate.\n #[export_name = \"__aster_panic_handler\"]\n pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n-    let throw_info = ostd_test::PanicInfo {\n-        message: info.message().to_string(),\n-        file: info.location().unwrap().file().to_string(),\n-        line: info.location().unwrap().line() as usize,\n-        col: info.location().unwrap().column() as usize,\n-    };\n-    // Throw an exception and expecting it to be caught.\n-    begin_panic(Box::new(throw_info.clone()));\n-    // If the exception is not caught (e.g. by ktest) and resumed,\n-    // then print the information and abort.\n-    error!(\"Uncaught panic!\");\n+    // If in ktest, we would like to catch the panics and resume the test.\n+    #[cfg(ktest)]\n+    {\n+        use alloc::{boxed::Box, string::ToString};\n+\n+        use unwinding::panic::begin_panic;\n+\n+        let throw_info = ostd_test::PanicInfo {\n+            message: info.message().to_string(),\n+            file: info.location().unwrap().file().to_string(),\n+            line: info.location().unwrap().line() as usize,\n+            col: info.location().unwrap().column() as usize,\n+        };\n+        // Throw an exception and expecting it to be caught.\n+        begin_panic(Box::new(throw_info.clone()));\n+    }\n     early_println!(\"{}\", info);\n     early_println!(\"printing stack trace:\");\n     print_stack_trace();\n",
        "problem_statement": "Syscall test at Ext2, MicroVM occasionally fails\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n### To Reproduce\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\nIn CI, the syscall test at Ext2, MicroVM randomly output bad characters and then hang without panicking. There are some runs that seemed irrelevant with the PR modification:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10053473151/job/27786308763?pr=1088\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10021055466/job/27699299104\r\n\r\nThey would pass the syscall test at ramfs (linux boot, normal VM), and then fail at Ext2, MicroVM.\r\n\r\n### Logs\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\r\nThe log would look like this:\r\n\r\n```\r\n[Bn\f\u0000\ufffd731ns] : p\ufffdb\f\u0000\ufffd\ufffd\ufffd\ufffd\u001cl\f\u0000\ufffd\ufffd\ufffd\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000R<\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffd1\ufffd\ufffd\ufffd\ufffd\ufffd\u0000\u0000protected range is not fully mappedp\u0000\u0000\u0000hk\f\u0000\ufffd\ufffd\ufffd\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"} \u0000\r\n```\r\n\n",
        "hints_text": "Another example:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10104476344/job/27943517035?pr=1030\nI found it being reproducible (randomly) locally. And it has nothing to do with Ext2. It seems to be a problem with MicroVM.\nIt is really easy to reproduce but once you need to debug (via printing or gdb), it is really hard to reproduce. It seems that it occurs lesser if the system is running more slowly (LOL).\r\n\r\nI GDBed it with KVM on (can't use breakpoints but can backtrace), I found that it hangs here:\r\n\r\n```\r\n(gdb) bt\r\n#0  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::acquire_lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:111\r\n#1  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:74\r\n#2  0xffffffff882765bd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#3  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#4  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#5  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#6  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#7  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#8  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#9  alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#10 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#11 alloc::string::String::with_capacity () at src/string.rs:492\r\n#12 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#13 0xffffffff8826174f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#14 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#15 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#16 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93d858) at src/logger.rs:37\r\n#17 0xffffffff880e2859 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#18 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#19 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#20 0xffffffff8827db32 in ostd::mm::vm_space::VmSpace::handle_page_fault (self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>, \r\n    info=0xffff8000ba93da00) at src/mm/vm_space.rs:109\r\n#21 ostd::arch::x86::trap::handle_user_page_fault (f=0xffff8000ba93dae0, page_fault_addr=7) at src/arch/x86/trap.rs:86\r\n#22 ostd::arch::x86::trap::trap_handler (f=0xffff8000ba93dae0) at src/arch/x86/trap.rs:54\r\n#23 0xffffffff8829911a in __from_kernel ()\r\n#24 0x0000000000000008 in ?? ()\r\n#25 0x0000000000000000 in ?? ()\r\n```\r\n\r\nhttps://github.com/asterinas/asterinas/issues/1085\r\n\r\nIt seemed, not reliable",
        "created_at": "2024-07-26T11:09:27Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 928,
        "instance_id": "asterinas__asterinas-928",
        "issue_numbers": [
            "906"
        ],
        "base_commit": "e210e68920481c911f62f03ade0a780f96e48e24",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -161,13 +161,6 @@ impl PageTableEntryTrait for PageTableEntry {\n         let flags = PageTableFlags::PRESENT.bits()\n             | PageTableFlags::WRITABLE.bits()\n             | PageTableFlags::USER.bits();\n-        #[cfg(feature = \"intel_tdx\")]\n-        let flags = flags\n-            | parse_flags!(\n-                prop.priv_flags.bits(),\n-                PrivFlags::SHARED,\n-                PageTableFlags::SHARED\n-            );\n         Self(paddr & Self::PHYS_ADDR_MASK | flags)\n     }\n \ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -11,15 +11,12 @@ use tdx_guest::{\n };\n use trapframe::TrapFrame;\n \n-use crate::{\n-    arch::mm::PageTableFlags,\n-    mm::{\n-        kspace::KERNEL_PAGE_TABLE,\n-        paddr_to_vaddr,\n-        page_prop::{CachePolicy, PageProperty, PrivilegedPageFlags as PrivFlags},\n-        page_table::PageTableError,\n-        KERNEL_BASE_VADDR, KERNEL_END_VADDR, PAGE_SIZE,\n-    },\n+use crate::mm::{\n+    kspace::{BOOT_PAGE_TABLE, KERNEL_BASE_VADDR, KERNEL_END_VADDR, KERNEL_PAGE_TABLE},\n+    paddr_to_vaddr,\n+    page_prop::{PageProperty, PrivilegedPageFlags as PrivFlags},\n+    page_table::PageTableError,\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -416,16 +413,28 @@ pub unsafe fn unprotect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Pa\n     if gpa & PAGE_MASK != 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags | PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa(\n         (gpa & (!PAGE_MASK)) as u64 | SHARED_MASK,\n         (page_num * PAGE_SIZE) as u64,\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -452,16 +461,28 @@ pub unsafe fn protect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Page\n     if gpa & !PAGE_MASK == 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags - PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa((gpa & PAGE_MASK) as u64, (page_num * PAGE_SIZE) as u64)\n         .map_err(PageConvertError::TdVmcallError)?;\n     for i in 0..page_num {\ndiff --git a/framework/aster-frame/src/arch/x86/trap.rs b/framework/aster-frame/src/arch/x86/trap.rs\n--- a/framework/aster-frame/src/arch/x86/trap.rs\n+++ b/framework/aster-frame/src/arch/x86/trap.rs\n@@ -11,11 +11,7 @@ use tdx_guest::tdcall;\n use trapframe::TrapFrame;\n \n #[cfg(feature = \"intel_tdx\")]\n-use crate::arch::{\n-    cpu::VIRTUALIZATION_EXCEPTION,\n-    mm::PageTableFlags,\n-    tdx_guest::{handle_virtual_exception, TdxTrapFrame},\n-};\n+use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, PageFaultErrorCode, PAGE_FAULT},\n     cpu_local,\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -76,15 +76,15 @@ pub fn init() {\n     boot::init();\n \n     mm::page::allocator::init();\n-    let mut boot_pt = mm::get_boot_pt();\n-    let meta_pages = mm::init_page_meta(&mut boot_pt);\n+    mm::kspace::init_boot_page_table();\n+    mm::kspace::init_kernel_page_table(mm::init_page_meta());\n     mm::misc_init();\n \n     trap::init();\n     arch::after_all_init();\n     bus::init();\n \n-    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\n+    mm::kspace::activate_kernel_page_table();\n \n     invoke_ffi_init_funcs();\n }\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -7,24 +7,27 @@\n //! The kernel memory space is currently managed as follows, if the\n //! address width is 48 bits (with 47 bits kernel space).\n //!\n+//! TODO: the cap of linear mapping (the start of vm alloc) are raised\n+//! to workaround for high IO in TDX. We need actual vm alloc API to have\n+//! a proper fix.\n+//!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n //! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n-//! +-+ <- 0xffff_e100_0000_0000\n-//! | |         For frame metadata, 1 TiB. Mapped frames are untracked.\n-//! +-+ <- 0xffff_e000_0000_0000\n-//! | |\n-//! | |         For vm alloc/io mappings, 32 TiB.\n+//! +-+ <- 0xffff_ff00_0000_0000\n+//! | |         For frame metadata, 1 TiB.\n+//! | |         Mapped frames are untracked.\n+//! +-+ <- 0xffff_fe00_0000_0000\n+//! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\n+//! +-+ <- 0xffff_fd00_0000_0000\n //! | |\n-//! +-+ <- the middle of the higher half (0xffff_c000_0000_0000)\n //! | |\n //! | |\n-//! | |\n-//! | |         For linear mappings, 64 TiB.\n+//! | |         For linear mappings.\n //! | |         Mapped physical addresses are untracked.\n //! | |\n //! | |\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -36,7 +39,7 @@\n //! 39 bits or 57 bits, the memory space just adjust porportionally.\n \n use alloc::vec::Vec;\n-use core::ops::Range;\n+use core::{mem::ManuallyDrop, ops::Range};\n \n use align_ext::AlignExt;\n use log::info;\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -76,12 +82,12 @@ pub fn kernel_loaded_offset() -> usize {\n \n const KERNEL_CODE_BASE_VADDR: usize = 0xffff_ffff_8000_0000 << ADDR_WIDTH_SHIFT;\n \n-const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_e100_0000_0000 << ADDR_WIDTH_SHIFT;\n-const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_e000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_ff00_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_fe00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub(in crate::mm) const FRAME_METADATA_RANGE: Range<Vaddr> =\n     FRAME_METADATA_BASE_VADDR..FRAME_METADATA_CAP_VADDR;\n \n-const VMALLOC_BASE_VADDR: Vaddr = 0xffff_c000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const VMALLOC_BASE_VADDR: Vaddr = 0xffff_fd00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub const VMALLOC_VADDR_RANGE: Range<Vaddr> = VMALLOC_BASE_VADDR..FRAME_METADATA_BASE_VADDR;\n \n /// The base address of the linear mapping of all physical\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -95,9 +101,25 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// The boot page table instance.\n+///\n+/// It is used in the initialization phase before [`KERNEL_PAGE_TABLE`] is activated.\n+/// Since we want dropping the boot page table unsafe, it is wrapped in a [`ManuallyDrop`].\n+pub static BOOT_PAGE_TABLE: SpinLock<Option<ManuallyDrop<BootPageTable>>> = SpinLock::new(None);\n+\n+/// The kernel page table instance.\n+///\n+/// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\n+/// is unlikely to be activated.\n pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingConsts>> =\n     Once::new();\n \n+/// Initializes the boot page table.\n+pub(crate) fn init_boot_page_table() {\n+    let boot_pt = BootPageTable::from_current_pt();\n+    *BOOT_PAGE_TABLE.lock() = Some(ManuallyDrop::new(boot_pt));\n+}\n+\n /// Initializes the kernel page table.\n ///\n /// This function should be called after:\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -106,10 +128,7 @@ pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingC\n ///\n /// This function should be called before:\n ///  - any initializer that modifies the kernel page table.\n-pub fn init_kernel_page_table(\n-    boot_pt: BootPageTable<PageTableEntry, PagingConsts>,\n-    meta_pages: Vec<Range<Paddr>>,\n-) {\n+pub fn init_kernel_page_table(meta_pages: Vec<Range<Paddr>>) {\n     info!(\"Initializing the kernel page table\");\n \n     let regions = crate::boot::memory_regions();\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -201,15 +220,21 @@ pub fn init_kernel_page_table(\n         }\n     }\n \n+    KERNEL_PAGE_TABLE.call_once(|| kpt);\n+}\n+\n+pub fn activate_kernel_page_table() {\n+    let kpt = KERNEL_PAGE_TABLE\n+        .get()\n+        .expect(\"The kernel page table is not initialized yet\");\n     // SAFETY: the kernel page table is initialized properly.\n     unsafe {\n         kpt.first_activate_unchecked();\n         crate::arch::mm::tlb_flush_all_including_global();\n     }\n \n-    KERNEL_PAGE_TABLE.call_once(|| kpt);\n-\n-    // SAFETY: the boot page table is OK to be retired now since\n+    // SAFETY: the boot page table is OK to be dropped now since\n     // the kernel page table is activated.\n-    unsafe { boot_pt.retire() };\n+    let mut boot_pt = BOOT_PAGE_TABLE.lock().take().unwrap();\n+    unsafe { ManuallyDrop::drop(&mut boot_pt) };\n }\ndiff --git a/framework/aster-frame/src/mm/mod.rs b/framework/aster-frame/src/mm/mod.rs\n--- a/framework/aster-frame/src/mm/mod.rs\n+++ b/framework/aster-frame/src/mm/mod.rs\n@@ -131,7 +131,3 @@ pub(crate) fn misc_init() {\n     }\n     FRAMEBUFFER_REGIONS.call_once(|| framebuffer_regions);\n }\n-\n-pub(crate) fn get_boot_pt() -> page_table::boot_pt::BootPageTable {\n-    unsafe { page_table::boot_pt::BootPageTable::from_current_pt() }\n-}\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -53,12 +53,9 @@ use super::Page;\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr,\n-        page::allocator::FRAME_ALLOCATOR,\n-        page_size,\n-        page_table::{boot_pt::BootPageTable, PageTableEntryTrait},\n-        CachePolicy, Paddr, PageFlags, PageProperty, PagingConstsTrait, PagingLevel,\n-        PrivilegedPageFlags, PAGE_SIZE,\n+        kspace::BOOT_PAGE_TABLE, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, page_size,\n+        page_table::PageTableEntryTrait, CachePolicy, Paddr, PageFlags, PageProperty,\n+        PagingConstsTrait, PagingLevel, PrivilegedPageFlags, PAGE_SIZE,\n     },\n };\n \ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -191,7 +188,7 @@ impl PageMeta for KernelMeta {\n /// Initializes the metadata of all physical pages.\n ///\n /// The function returns a list of `Page`s containing the metadata.\n-pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n+pub(crate) fn init() -> Vec<Range<Paddr>> {\n     let max_paddr = {\n         let regions = crate::boot::memory_regions();\n         regions.iter().map(|r| r.base() + r.len()).max().unwrap()\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -207,8 +204,11 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n     let num_pages = max_paddr / page_size::<PagingConsts>(1);\n     let num_meta_pages = (num_pages * size_of::<MetaSlot>()).div_ceil(PAGE_SIZE);\n     let meta_pages = alloc_meta_pages(num_meta_pages);\n-\n     // Map the metadata pages.\n+    let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+    let boot_pt = boot_pt_lock\n+        .as_mut()\n+        .expect(\"boot page table not initialized\");\n     for (i, frame_paddr) in meta_pages.iter().enumerate() {\n         let vaddr = mapping::page_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n         let prop = PageProperty {\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -216,9 +216,9 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n             cache: CachePolicy::Writeback,\n             priv_flags: PrivilegedPageFlags::GLOBAL,\n         };\n-        boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop);\n+        // SAFETY: we are doing the metadata mappings for the kernel.\n+        unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n     }\n-\n     // Now the metadata pages are mapped, we can initialize the metadata.\n     meta_pages\n         .into_iter()\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -10,8 +10,8 @@ use super::{pte_index, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty, PagingConstsTrait, Vaddr,\n-        PAGE_SIZE,\n+        nr_subpage_per_huge, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty,\n+        PagingConstsTrait, Vaddr, PAGE_SIZE,\n     },\n };\n \ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -34,10 +34,7 @@ pub struct BootPageTable<\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     /// Creates a new boot page table from the current page table root physical address.\n-    ///\n-    /// The caller must ensure that the current page table may be set up by the firmware,\n-    /// loader or the setup code.\n-    pub unsafe fn from_current_pt() -> Self {\n+    pub fn from_current_pt() -> Self {\n         let root_paddr = crate::arch::mm::current_page_table_paddr();\n         Self {\n             root_pt: root_paddr / C::BASE_PAGE_SIZE,\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -47,8 +44,16 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     }\n \n     /// Maps a base page to a frame.\n+    ///\n+    /// # Panics\n+    ///\n     /// This function will panic if the page is already mapped.\n-    pub fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n         let mut pt = self.root_pt;\n         let mut level = C::NR_LEVELS;\n         // Walk to the last level of the page table.\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -77,6 +82,67 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { pte_ptr.write(E::new_frame(to * C::BASE_PAGE_SIZE, 1, prop)) };\n     }\n \n+    /// Maps a base page to a frame.\n+    ///\n+    /// This function may split a huge page into base pages, causing page allocations\n+    /// if the original mapping is a huge page.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the page is already mapped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn protect_base_page(\n+        &mut self,\n+        virt_addr: Vaddr,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) {\n+        let mut pt = self.root_pt;\n+        let mut level = C::NR_LEVELS;\n+        // Walk to the last level of the page table.\n+        while level > 1 {\n+            let index = pte_index::<C>(virt_addr, level);\n+            let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+            let pte = unsafe { pte_ptr.read() };\n+            pt = if !pte.is_present() {\n+                panic!(\"protecting an unmapped page in the boot page table\");\n+            } else if pte.is_last(level) {\n+                // Split the huge page.\n+                let frame = self.alloc_frame();\n+                let huge_pa = pte.paddr();\n+                for i in 0..nr_subpage_per_huge::<C>() {\n+                    let nxt_ptr =\n+                        unsafe { (paddr_to_vaddr(frame * C::BASE_PAGE_SIZE) as *mut E).add(i) };\n+                    unsafe {\n+                        nxt_ptr.write(E::new_frame(\n+                            huge_pa + i * C::BASE_PAGE_SIZE,\n+                            level - 1,\n+                            pte.prop(),\n+                        ))\n+                    };\n+                }\n+                unsafe { pte_ptr.write(E::new_pt(frame * C::BASE_PAGE_SIZE)) };\n+                frame\n+            } else {\n+                pte.paddr() / C::BASE_PAGE_SIZE\n+            };\n+            level -= 1;\n+        }\n+        // Do protection in the last level page table.\n+        let index = pte_index::<C>(virt_addr, 1);\n+        let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+        let pte = unsafe { pte_ptr.read() };\n+        if !pte.is_present() {\n+            panic!(\"protecting an unmapped page in the boot page table\");\n+        }\n+        let mut prop = pte.prop();\n+        op(&mut prop);\n+        unsafe { pte_ptr.write(E::new_frame(pte.paddr(), 1, prop)) };\n+    }\n+\n     fn alloc_frame(&mut self) -> FrameNumber {\n         let frame = FRAME_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n         self.frames.push(frame);\n",
        "test_patch": "diff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -52,7 +55,10 @@ use super::{\n     page_table::{boot_pt::BootPageTable, KernelMode, PageTable},\n     MemoryRegionType, Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    sync::SpinLock,\n+};\n \n /// The shortest supported address width is 39 bits. And the literal\n /// values are written for 48 bits address width. Adjust the values\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -85,43 +151,19 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { core::ptr::write_bytes(vaddr, 0, PAGE_SIZE) };\n         frame\n     }\n-\n-    /// Retires this boot-stage page table.\n-    ///\n-    /// Do not drop a boot-stage page table. Instead, retire it.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method can only be called when this boot-stage page table is no longer in use,\n-    /// e.g., after the permanent kernel page table has been activated.\n-    pub unsafe fn retire(mut self) {\n-        // Manually free all heap and frame memory allocated.\n-        let frames = core::mem::take(&mut self.frames);\n-        for frame in frames {\n-            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(frame, 1);\n-        }\n-        // We do not want or need to trigger drop.\n-        core::mem::forget(self);\n-        // FIXME: an empty `Vec` is leaked on the heap here since the drop is not called\n-        // and we have no ways to free it.\n-        // The best solution to recycle the boot-phase page table is to initialize all\n-        // page table page metadata of the boot page table by page walk after the metadata\n-        // pages are mapped. Therefore the boot page table can be recycled or dropped by\n-        // the routines in the [`super::node`] module. There's even without a need of\n-        // `first_activate` concept if the boot page table can be managed by page table\n-        // pages.\n-    }\n }\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for BootPageTable<E, C> {\n     fn drop(&mut self) {\n-        panic!(\"the boot page table is dropped rather than retired.\");\n+        for frame in &self.frames {\n+            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(*frame, 1);\n+        }\n     }\n }\n \n #[cfg(ktest)]\n #[ktest]\n-fn test_boot_pt() {\n+fn test_boot_pt_map_protect() {\n     use super::page_walk;\n     use crate::{\n         arch::mm::{PageTableEntry, PagingConsts},\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -140,20 +182,34 @@ fn test_boot_pt() {\n     let from1 = 0x1000;\n     let to1 = 0x2;\n     let prop1 = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n-    boot_pt.map_base_page(from1, to1, prop1);\n+    unsafe { boot_pt.map_base_page(from1, to1, prop1) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n         Some((to1 * PAGE_SIZE + 1, prop1))\n     );\n+    unsafe { boot_pt.protect_base_page(from1, |prop| prop.flags = PageFlags::RX) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n+        Some((\n+            to1 * PAGE_SIZE + 1,\n+            PageProperty::new(PageFlags::RX, CachePolicy::Writeback)\n+        ))\n+    );\n \n     let from2 = 0x2000;\n     let to2 = 0x3;\n     let prop2 = PageProperty::new(PageFlags::RX, CachePolicy::Uncacheable);\n-    boot_pt.map_base_page(from2, to2, prop2);\n+    unsafe { boot_pt.map_base_page(from2, to2, prop2) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n         Some((to2 * PAGE_SIZE + 2, prop2))\n     );\n-\n-    unsafe { boot_pt.retire() }\n+    unsafe { boot_pt.protect_base_page(from2, |prop| prop.flags = PageFlags::RW) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n+        Some((\n+            to2 * PAGE_SIZE + 2,\n+            PageProperty::new(PageFlags::RW, CachePolicy::Uncacheable)\n+        ))\n+    );\n }\n",
        "problem_statement": "[TDX BUG] The TDX SHARED bit can\u2018t be set in the page table during IOAPIC initialization.\nIn `framework/aster-frame/src/arch/x86/tdx_guest.rs`:\r\n```rust\r\n    trap::init();\r\n    arch::after_all_init();\r\n    bus::init();\r\n\r\n    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\r\n```\r\n\r\nThe kernel page table is initialized and activated in the `init_kernel_page_table` function. This step occurs after ioapic is initialized (via `after_all_init` function).\r\n\r\nHowever, we should set the ioapic MMIO space as shared page in TDX env, this process manipulates the page table, but the page table is not yet activated.\r\n\n",
        "hints_text": "",
        "created_at": "2024-06-12T07:29:38Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 782,
        "instance_id": "asterinas__asterinas-782",
        "issue_numbers": [
            "774",
            "790"
        ],
        "base_commit": "34e9d71fe4501bf4cac4d8263ccb568a814ac4b7",
        "patch": "diff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -55,7 +55,7 @@ use alloc::vec;\n use aster_frame::cpu::UserContext;\n use aster_frame::prelude::*;\n use aster_frame::task::{Task, TaskOptions};\n-use aster_frame::user::{UserEvent, UserMode, UserSpace};\n+use aster_frame::user::{ReturnReason, UserMode, UserSpace};\n use aster_frame::vm::{PageFlags, PAGE_SIZE, Vaddr, VmAllocOptions, VmIo, VmMapOptions, VmSpace};\n \n /// The kernel's boot and initialization process is managed by Asterinas Framework.\ndiff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -116,13 +116,15 @@ fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n \n         loop {\n             // The execute method returns when system\n-            // calls or CPU exceptions occur.\n-            let user_event = user_mode.execute();\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n             // The CPU registers of the user space\n             // can be accessed and manipulated via\n             // the `UserContext` abstraction.\n             let user_context = user_mode.context_mut();\n-            if UserEvent::Syscall == user_event {\n+            if ReturnReason::UserSyscall == return_reason {\n                 handle_syscall(user_context, current.user_space().unwrap());\n             }\n         }\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -23,7 +23,7 @@ use x86_64::registers::rflags::RFlags;\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\n use crate::{\n     trap::call_irq_callback_functions,\n-    user::{UserContextApi, UserContextApiInternal, UserEvent},\n+    user::{ReturnReason, UserContextApi, UserContextApiInternal},\n };\n \n /// Returns the number of CPUs.\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -257,11 +257,15 @@ impl UserContext {\n }\n \n impl UserContextApiInternal for UserContext {\n-    fn execute(&mut self) -> crate::user::UserEvent {\n+    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         // set interrupt flag so that in user mode it can receive external interrupts\n         // set ID flag which means cpu support CPUID instruction\n         self.user_context.general.rflags |= (RFlags::INTERRUPT_FLAG | RFlags::ID).bits() as usize;\n \n+        let return_reason: ReturnReason;\n         const SYSCALL_TRAPNUM: u16 = 0x100;\n \n         let mut user_preemption = UserPreemption::new();\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -281,31 +285,36 @@ impl UserContextApiInternal for UserContext {\n                         || exception.typ == CpuExceptionType::Fault\n                         || exception.typ == CpuExceptionType::Trap\n                     {\n+                        return_reason = ReturnReason::UserException;\n                         break;\n                     }\n                 }\n                 None => {\n                     if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\n+                        return_reason = ReturnReason::UserSyscall;\n                         break;\n                     }\n                 }\n             };\n             call_irq_callback_functions(&self.as_trap_frame());\n+            if has_kernel_event() {\n+                return_reason = ReturnReason::KernelEvent;\n+                break;\n+            }\n \n             user_preemption.might_preempt();\n         }\n \n         crate::arch::irq::enable_local();\n-        if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\n+        if return_reason == ReturnReason::UserException {\n             self.cpu_exception_info = CpuExceptionInfo {\n                 page_fault_addr: unsafe { x86::controlregs::cr2() },\n                 id: self.user_context.trap_num,\n                 error_code: self.user_context.error_code,\n             };\n-            UserEvent::Exception\n-        } else {\n-            UserEvent::Syscall\n         }\n+\n+        return_reason\n     }\n \n     fn as_trap_frame(&self) -> trapframe::TrapFrame {\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -51,7 +51,9 @@ impl UserSpace {\n /// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n-    fn execute(&mut self) -> UserEvent;\n+    fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool;\n \n     /// Use the information inside CpuContext to build a trapframe\n     fn as_trap_frame(&self) -> TrapFrame;\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -93,9 +95,9 @@ pub trait UserContextApi {\n ///     .expect(\"the current task is associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n-///     // Execute in the user space until some interesting user event occurs\n-///     let user_event = user_mode.execute();\n-///     todo!(\"handle the user event, e.g., syscall\");\n+///     // Execute in the user space until some interesting events occur.\n+///     let return_reason = user_mode.execute(|| false);\n+///     todo!(\"handle the event, e.g., syscall\");\n /// }\n /// ```\n pub struct UserMode<'a> {\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -118,17 +120,22 @@ impl<'a> UserMode<'a> {\n \n     /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\n     ///\n-    /// The method returns for one of three possible reasons indicated by `UserEvent`.\n-    /// 1. The user invokes a system call;\n-    /// 2. The user triggers an exception;\n-    /// 3. The user triggers a fault.\n+    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\n+    /// 1. A system call is issued by the user space;\n+    /// 2. A CPU exception is triggered by the user space;\n+    /// 3. A kernel event is pending, as indicated by the given closure.\n     ///\n-    /// After handling the user event and updating the user-mode CPU context,\n+    /// After handling whatever user or kernel events that\n+    /// cause the method to return\n+    /// and updating the user-mode CPU context,\n     /// this method can be invoked again to go back to the user space.\n-    pub fn execute(&mut self) -> UserEvent {\n+    pub fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         self.user_space.vm_space().activate();\n         debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n-        self.context.execute()\n+        self.context.execute(has_kernel_event)\n     }\n \n     /// Returns an immutable reference the user-mode CPU context.\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -143,14 +150,13 @@ impl<'a> UserMode<'a> {\n }\n \n #[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n-/// A user event is what brings back the control of the CPU back from\n-/// the user space to the kernel space.\n-///\n-/// Note that hardware interrupts are not considered user events as they\n-/// are triggered by devices and not visible to user programs.\n-/// To handle interrupts, one should register callback funtions for\n-/// IRQ lines (`IrqLine`).\n-pub enum UserEvent {\n-    Syscall,\n-    Exception,\n+/// A reason as to why the control of the CPU is returned from\n+/// the user space to the kernel.\n+pub enum ReturnReason {\n+    /// A system call is issued by the user space.\n+    UserSyscall,\n+    /// A CPU exception is triggered by the user space.\n+    UserException,\n+    /// A kernel event is pending\n+    KernelEvent,\n }\ndiff --git a/kernel/aster-nix/src/thread/kernel_thread.rs b/kernel/aster-nix/src/thread/kernel_thread.rs\n--- a/kernel/aster-nix/src/thread/kernel_thread.rs\n+++ b/kernel/aster-nix/src/thread/kernel_thread.rs\n@@ -44,6 +44,8 @@ impl KernelThreadExt for Thread {\n             let weal_thread = thread_ref.clone();\n             let task = TaskOptions::new(thread_fn)\n                 .data(weal_thread)\n+                .priority(thread_options.priority)\n+                .cpu_affinity(thread_options.cpu_affinity)\n                 .build()\n                 .unwrap();\n             let status = ThreadStatus::Init;\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -1,20 +1,27 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_frame::{\n-    cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n-    user::{UserContextApi, UserEvent, UserMode, UserSpace},\n+    user::{ReturnReason, UserContextApi, UserMode, UserSpace},\n };\n \n use super::Thread;\n use crate::{\n-    cpu::LinuxAbi, prelude::*, process::signal::handle_pending_signal, syscall::handle_syscall,\n+    cpu::LinuxAbi,\n+    prelude::*,\n+    process::{posix_thread::PosixThreadExt, signal::handle_pending_signal},\n+    syscall::handle_syscall,\n     thread::exception::handle_exception,\n };\n \n /// create new task with userspace and parent process\n pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n     fn user_task_entry() {\n+        fn has_pending_signal(current_thread: &Arc<Thread>) -> bool {\n+            let posix_thread = current_thread.as_posix_thread().unwrap();\n+            posix_thread.has_pending_signal()\n+        }\n+\n         let current_thread = current_thread!();\n         let current_task = current_thread.task();\n         let user_space = current_task\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -34,11 +41,17 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             user_mode.context().syscall_ret()\n         );\n \n+        #[allow(clippy::redundant_closure)]\n+        let has_kernel_event_fn = || has_pending_signal(&current_thread);\n         loop {\n-            let user_event = user_mode.execute();\n+            let return_reason = user_mode.execute(has_kernel_event_fn);\n             let context = user_mode.context_mut();\n             // handle user event:\n-            handle_user_event(user_event, context);\n+            match return_reason {\n+                ReturnReason::UserException => handle_exception(context),\n+                ReturnReason::UserSyscall => handle_syscall(context),\n+                ReturnReason::KernelEvent => {}\n+            };\n             // should be do this comparison before handle signal?\n             if current_thread.status().is_exited() {\n                 break;\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -68,10 +81,3 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         .build()\n         .expect(\"spawn task failed\")\n }\n-\n-fn handle_user_event(user_event: UserEvent, context: &mut UserContext) {\n-    match user_event {\n-        UserEvent::Syscall => handle_syscall(context),\n-        UserEvent::Exception => handle_exception(context),\n-    }\n-}\ndiff --git /dev/null b/regression/apps/alarm/alarm.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/alarm/alarm.c\n@@ -0,0 +1,11 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#include <unistd.h>\n+\n+int main()\n+{\n+\talarm(3);\n+\twhile (1) {\n+\t}\n+\treturn 0;\n+}\n",
        "test_patch": "diff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -10,6 +10,7 @@ REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n \n # These test apps are sorted by name\n TEST_APPS := \\\n+\talarm \\\n \tclone3 \\\n \teventfd2 \\\n \texecve \\\ndiff --git /dev/null b/regression/apps/alarm/Makefile\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/alarm/Makefile\n@@ -0,0 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n+include ../test_common.mk\n+\n+EXTRA_C_FLAGS := -static\n",
        "problem_statement": "Deliver POSIX signals for busy-loop user code\n## Problem\r\n\r\nCurrently, the POSIX signals are handled in the main loop of user tasks, after `UserMode::execute` returns.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            \r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n            \r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            // POSIX signals are handled here!\r\n            handle_pending_signal(context).unwrap();\r\n            \r\n            // ...\r\n        }\r\n    }\r\n    \r\n    TaskOptions::new(user_task_entry)\r\n        .data(thread_ref)\r\n        .user_space(Some(user_space))\r\n        .build()\r\n        .expect(\"spawn task failed\")\r\n}\r\n```\r\n\r\nThis means that if `UserMode::execute` does not returns, then the kernel has no chance to handle signals. Consider the following simple user program in C.\r\n\r\n```rust\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\n\r\nOf course. The `SIGALRM` shall never be delivered to the process by Asterinas as the kernel can only handles POSIX signals when the user code requests system calls.\r\n\r\n## Analysis\r\n\r\nTo figure out a solution, let's dig into the `UserMode::execute` function, which calls `UserContext::execute` to do the real job.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n    \r\n    loop {\r\n        self.user_context.run();\r\n        match CpuException::to_cpu_exception(self.user_context.trap_num as u16) {\r\n            Some(exception) => {\r\n                if exception.typ == CpuExceptionType::FaultOrTrap\r\n                    || exception.typ == CpuExceptionType::Fault\r\n                    || exception.typ == CpuExceptionType::Trap\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            None => {\r\n                if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        call_irq_callback_functions(&self.as_trap_frame());\r\n    }\r\n\r\n    if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\r\n        // ...\r\n        \r\n        UserEvent::Exception\r\n    } else {\r\n        UserEvent::Syscall\r\n    }\r\n}\r\n```\r\n\r\nIf the periodic timer interrupt is triggered while the CPU is running in the user mode, then `self.user_context.run()` returns and the interrupt is handled by the `call_irq_callback_functions` function.\r\n\r\nSo the control of the CPU does return to the kernel at regular intervals. However, a significant issue arises with the `UserContext::execute` method from the Asterinas Framework\u2014it lacks awareness and handling of POSIX signals, and appropriately so.\r\n\r\n## Solution\r\n\r\n### Major changes to `aster-frame`\r\n\r\nSo this issue proposes to extend the API of the `UserMode::execute` method as well as that of `UserContext::execute` so that the two methods would return the control of the CPU to its caller (e.g., the `aster-nix` crate) if there are pending events (e.g., POSIX signals).\r\n\r\nThe new interface is as shown below.\r\n\r\n```rust\r\nimpl<'a> UserMode<'a> {\r\n    /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\r\n    ///\r\n    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\r\n    /// 1. A system call is issued by the user space;\r\n    /// 2. A CPU exception is triggered by the user space;\r\n    /// 3. A kernel event is pending, as indicated by the given closure.\r\n    ///\r\n    /// After handling whatever user or kernel events that \r\n    /// cause the method to return\r\n    /// and updating the user-mode CPU context,\r\n    /// this method can be invoked again to go back to the user space.\r\n    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason \r\n    where\r\n        F: FnMut() -> bool,\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nThe new `ReturnReason` replaces the old `UserEvent`.\r\n\r\n```rust\r\n/// A reason as to why the control of the CPU is returned from\r\n/// the user space to the kernel.\r\n#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\r\npub enum ReturnReason {\r\n    /// A system call is issued by the user space.\r\n    UserSyscall,\r\n    /// A CPU exception is triggered by the user space.\r\n    UserException,\r\n    /// A kernel event is pending \r\n    KernelEvent,\r\n}\r\n```\r\n\r\n### Major changes to `aster-nix`\r\n\r\nThe main loop of a user task is modifed to utilize the extended interface of `UserMode::execute`.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n\r\n    fn user_task_entry() {\r\n        let has_kernel_events_fn = {\r\n            let current = current!();\r\n            let current_thread = current_thread!();\r\n            || {\r\n                current.has_pending_signals()\r\n            }\r\n        };\r\n        \r\n        loop {\r\n            let return_reason = user_mode.execute(has_kernel_events_fn);\r\n            let context = user_mode.context_mut();\r\n            match user_event {\r\n                ReturnReason::UserSyscall => handle_syscall(context),\r\n                ReturnReason::UserException => handle_exception(context),\r\n                _ =>,\r\n            }\r\n\r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            handle_pending_signal(context).unwrap();\r\n            // ...\r\n        }\r\n    }\r\n\r\n    // ...\r\n}\r\n```\r\n\n`ThreadOptions` is not fully used while creating new kernel thread\nHere is the `aster-nix::thread::kernel_thread::ThreadOptions`.\r\n```rust\r\n/// Options to create or spawn a new thread.\r\npub struct ThreadOptions {\r\n    func: Option<Box<dyn Fn() + Send + Sync>>,\r\n    priority: Priority,\r\n    cpu_affinity: CpuSet,\r\n}\r\n```\r\nIt has fields representing priority and cpu affinity. But when we create new kernel thread in the code below,\r\n```rust\r\nfn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\r\n        let task_fn = thread_options.take_func();\r\n        let thread_fn = move || {\r\n            task_fn();\r\n            let current_thread = current_thread!();\r\n            // ensure the thread is exit\r\n            current_thread.exit();\r\n        };\r\n        let tid = allocate_tid();\r\n        let thread = Arc::new_cyclic(|thread_ref| {\r\n            let weal_thread = thread_ref.clone();\r\n            let task = TaskOptions::new(thread_fn)\r\n                .data(weal_thread)\r\n                .build()\r\n                .unwrap();\r\n            let status = ThreadStatus::Init;\r\n            let kernel_thread = KernelThread;\r\n            Thread::new(tid, task, kernel_thread, status)\r\n        });\r\n        thread_table::add_thread(thread.clone());\r\n        thread\r\n    }\r\n```\r\nwe never use this two fields to construct `TaskOptions`, therefore the bound task is always of default configuration. \r\n\r\nOne problem caused by this issue is that all `Worker`s in `WORKERPOOL_HIGH_PRI` are of normal priority instead of real-time priority, which is incorrect and can cause starvation in some specific cases.\n",
        "hints_text": "I made some modification in #782 to enable timely delivery of POSIX signals based on the solution you proposed. But as to this specific MRE that you mentioned,\r\n```c\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\nI'm afraid that's not enough. \r\n\r\nUnder current implementation of alarm syscall, the actual callback, in which we enqueue the `SIGALRM` to corresponding `posix_thread`'s `sig_queues`, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed. \n> Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted to the work queue? \r\n\r\nBut I'm not sure whether we need to trigger preemtion before handling irq or after handling irq.\n> > Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n> \r\n> @jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted the the work queue?\r\n\r\nWill the `Usermode::execute` in `user_task_entry` ever return once we enter the `while(1)` busy-looping?\r\n\r\n\n> Will the Usermode::execute in user_task_entry ever return once we enter the while(1) busy-looping?\r\n\r\nCurrently, it won't. Maybe the `has_kernel_events_fn` should also check whether there are any pending workitems, and if any, `Usermode.execute` should also return to `aster-nix` to enable workqueue thread run. \r\n\r\nI'm not sure whether it's suitable to do so. \n> However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420 The following small change should be enough to address the issue you raised.\r\n\r\n### The change\r\n\r\nThe `aster_frame::task::preempt` function should be made private and called internally in `UserMode::execute`. This way, the Framework ensures that the user-kernel switching is always a preemption point.\r\n\r\n### The rationale\r\n\r\nPreemptive scheduling, as opposite to cooperative scheduling, is by definition transparent to the tasks that are subject to scheduling. In other words, Asterinas Framework must enforce preemption, without cooperation from the users of Asterinas Framework.\r\n\r\nBut in our current implementation, the `preempt` method from `aster-frame` is explicitly called by its user.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n\r\n            // ...\r\n\r\n            // a preemption point after handling user event.\r\n            preempt();\r\n        }\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\nThe proposed change can address this problem.\r\n\nThanks for your advice.\r\n\r\nI have some question about how the `WorkQueue` mechanism works after we submit some `WorkItem`s. If I understood  correctly, the `Monitor` of `WorkerPool` should be scheduled to run first and the `Monitor` will `wake_worker` or `add_worker`, then we should wait for the running worker to be scheduled and the `Worker` will pick a  `WorkItem` to run if there is any. \r\n\r\nIf that is the case, how can a `Monitor` of `normal` priority `preempt` a running thread in current `PriorityScheduler`? Calling `schedule` instead of `preempt` may be a workaround, though logically incorrect (because the user loop should not explicitly give up cpu).\nUpdate:\r\n\r\nWhen I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nAfter fixing that issue, the `SIGALRM` signal can finally be correctly enqueued. I expected that the `while(1)` thread would be rescheduled to run and the signal would be handled in next timer interrupt. The `while(1)` did get on the cpu. However, this time the `UserContext::run` never returned. I'm not that familiar with this part and need to dig in more to find out what happened.\n> When I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nGood point \ud83d\udc4d \n@jellllly420 Good job on spotting the bug. Could you try to fix it?",
        "created_at": "2024-04-23T16:18:28Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1018,
        "instance_id": "asterinas__asterinas-1018",
        "issue_numbers": [
            "1009"
        ],
        "base_commit": "8a9c012249d36c54712030c41388d20a608939f5",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -84,7 +84,6 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -141,7 +140,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"ringbuf\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -185,7 +183,6 @@ dependencies = [\n  \"lru\",\n  \"ostd\",\n  \"paste\",\n- \"pod\",\n  \"rand\",\n  \"ringbuf\",\n  \"smoltcp\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -238,7 +235,6 @@ dependencies = [\n  \"aster-rights-proc\",\n  \"inherit-methods-macro\",\n  \"ostd\",\n- \"pod\",\n  \"typeflags-util\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -261,7 +257,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\n  \"typeflags-util\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -277,7 +272,7 @@ dependencies = [\n  \"component\",\n  \"id-alloc\",\n  \"ostd\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -760,9 +755,9 @@ dependencies = [\n \n [[package]]\n name = \"intrusive-collections\"\n-version = \"0.9.5\"\n+version = \"0.9.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f4f90afb01281fdeffb0f8e082d230cbe4f888f837cc90759696b858db1a700\"\n+checksum = \"b694dc9f70c3bda874626d2aed13b780f137aab435f4e9814121955cf706122e\"\n dependencies = [\n  \"memoffset\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -891,7 +879,7 @@ dependencies = [\n  \"uart_16550\",\n  \"uefi\",\n  \"uefi-services\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xmas-elf 0.8.0\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -950,9 +938,9 @@ checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.8.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1\"\n+checksum = \"488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a\"\n dependencies = [\n  \"autocfg\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1113,13 +1101,13 @@ dependencies = [\n  \"unwinding\",\n  \"volatile\",\n  \"x86\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xarray\",\n ]\n \n [[package]]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1139,24 +1152,6 @@ version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n \n-[[package]]\n-name = \"pod\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"pod-derive\",\n-]\n-\n-[[package]]\n-name = \"pod-derive\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n [[package]]\n name = \"polonius-the-crab\"\n version = \"0.2.1\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1276,6 +1271,15 @@ dependencies = [\n  \"bitflags 1.3.2\",\n ]\n \n+[[package]]\n+name = \"raw-cpuid\"\n+version = \"11.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e29830cbb1290e404f24c73af91c5d8d631ce7e128691e9477556b540cd01ecd\"\n+dependencies = [\n+ \"bitflags 2.4.1\",\n+]\n+\n [[package]]\n name = \"ringbuf\"\n version = \"0.3.3\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1358,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.13.1\"\n+version = \"1.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n \n [[package]]\n name = \"smoltcp\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1462,8 +1466,8 @@ dependencies = [\n  \"bitflags 1.3.2\",\n  \"iced-x86\",\n  \"lazy_static\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 10.7.0\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1539,13 +1543,12 @@ dependencies = [\n \n [[package]]\n name = \"trapframe\"\n-version = \"0.9.0\"\n-source = \"git+https://github.com/asterinas/trapframe-rs?rev=4739428#4739428fd51685c74e6e88e73e5f04cb89f465ee\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"105000258ba41c463b63403c9341c55a298f35f6137b1cca08c10f0409ef8d3a\"\n dependencies = [\n- \"log\",\n- \"pod\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 11.0.2\",\n+ \"x86_64 0.15.1\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1723,7 +1726,7 @@ checksum = \"2781db97787217ad2a2845c396a5efe286f87467a5810836db6d74926e94a385\"\n dependencies = [\n  \"bit_field\",\n  \"bitflags 1.3.2\",\n- \"raw-cpuid\",\n+ \"raw-cpuid 10.7.0\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1738,6 +1741,18 @@ dependencies = [\n  \"volatile\",\n ]\n \n+[[package]]\n+name = \"x86_64\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4bc79523af8abf92fb1a970c3e086c5a343f6bcc1a0eb890f575cbb3b45743df\"\n+dependencies = [\n+ \"bit_field\",\n+ \"bitflags 2.4.1\",\n+ \"rustversion\",\n+ \"volatile\",\n+]\n+\n [[package]]\n name = \"xarray\"\n version = \"0.1.0\"\ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\n--- a/kernel/aster-nix/Cargo.toml\n+++ b/kernel/aster-nix/Cargo.toml\n@@ -6,9 +6,7 @@ edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-ostd = { path = \"../../ostd\" }\n align_ext = { path = \"../../ostd/libs/align_ext\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n aster-input = { path = \"../comps/input\" }\n aster-block = { path = \"../comps/block\" }\n aster-network = { path = \"../comps/network\" }\ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\n--- a/kernel/aster-nix/Cargo.toml\n+++ b/kernel/aster-nix/Cargo.toml\n@@ -17,6 +15,7 @@ aster-time = { path = \"../comps/time\" }\n aster-virtio = { path = \"../comps/virtio\" }\n aster-rights = { path = \"../libs/aster-rights\" }\n controlled = { path = \"../libs/comp-sys/controlled\" }\n+ostd = { path = \"../../ostd\" }\n typeflags = { path = \"../libs/typeflags\" }\n typeflags-util = { path = \"../libs/typeflags-util\" }\n aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/aster-nix/src/arch/x86/cpu.rs\n--- a/kernel/aster-nix/src/arch/x86/cpu.rs\n+++ b/kernel/aster-nix/src/arch/x86/cpu.rs\n@@ -1,6 +1,9 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use ostd::cpu::UserContext;\n+use ostd::{\n+    cpu::{RawGeneralRegs, UserContext},\n+    Pod,\n+};\n \n use crate::cpu::LinuxAbi;\n \ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/aster-nix/src/arch/x86/cpu.rs\n--- a/kernel/aster-nix/src/arch/x86/cpu.rs\n+++ b/kernel/aster-nix/src/arch/x86/cpu.rs\n@@ -36,3 +39,64 @@ impl LinuxAbi for UserContext {\n         self.fsbase()\n     }\n }\n+\n+/// General-purpose registers.\n+#[derive(Debug, Clone, Copy, Pod, Default)]\n+#[repr(C)]\n+pub struct GpRegs {\n+    pub rax: usize,\n+    pub rbx: usize,\n+    pub rcx: usize,\n+    pub rdx: usize,\n+    pub rsi: usize,\n+    pub rdi: usize,\n+    pub rbp: usize,\n+    pub rsp: usize,\n+    pub r8: usize,\n+    pub r9: usize,\n+    pub r10: usize,\n+    pub r11: usize,\n+    pub r12: usize,\n+    pub r13: usize,\n+    pub r14: usize,\n+    pub r15: usize,\n+    pub rip: usize,\n+    pub rflags: usize,\n+    pub fsbase: usize,\n+    pub gsbase: usize,\n+}\n+\n+macro_rules! copy_gp_regs {\n+    ($src: ident, $dst: ident) => {\n+        $dst.rax = $src.rax;\n+        $dst.rbx = $src.rax;\n+        $dst.rcx = $src.rcx;\n+        $dst.rdx = $src.rdx;\n+        $dst.rsi = $src.rsi;\n+        $dst.rdi = $src.rdi;\n+        $dst.rbp = $src.rbp;\n+        $dst.rsp = $src.rsp;\n+        $dst.r8 = $src.r8;\n+        $dst.r9 = $src.r9;\n+        $dst.r10 = $src.r10;\n+        $dst.r11 = $src.r11;\n+        $dst.r12 = $src.r12;\n+        $dst.r13 = $src.r13;\n+        $dst.r14 = $src.r14;\n+        $dst.r15 = $src.r15;\n+        $dst.rip = $src.rip;\n+        $dst.rflags = $src.rflags;\n+        $dst.fsbase = $src.fsbase;\n+        $dst.gsbase = $src.gsbase;\n+    };\n+}\n+\n+impl GpRegs {\n+    pub fn copy_to_raw(&self, dst: &mut RawGeneralRegs) {\n+        copy_gp_regs!(self, dst);\n+    }\n+\n+    pub fn copy_from_raw(&mut self, src: &RawGeneralRegs) {\n+        copy_gp_regs!(src, self);\n+    }\n+}\ndiff --git a/kernel/aster-nix/src/fs/exfat/super_block.rs b/kernel/aster-nix/src/fs/exfat/super_block.rs\n--- a/kernel/aster-nix/src/fs/exfat/super_block.rs\n+++ b/kernel/aster-nix/src/fs/exfat/super_block.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use pod::Pod;\n+use ostd::Pod;\n \n use super::constants::{EXFAT_FIRST_CLUSTER, EXFAT_RESERVED_CLUSTERS, MEDIA_FAILURE, VOLUME_DIRTY};\n use crate::prelude::*;\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -19,8 +19,8 @@ pub(crate) use log::{debug, error, info, log_enabled, trace, warn};\n pub(crate) use ostd::{\n     mm::{Vaddr, VmReader, VmWriter, PAGE_SIZE},\n     sync::{Mutex, MutexGuard, RwLock, RwMutex, SpinLock, SpinLockGuard},\n+    Pod,\n };\n-pub(crate) use pod::Pod;\n \n /// return current process\n #[macro_export]\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/aster-nix/src/process/signal/c_types.rs\n--- a/kernel/aster-nix/src/process/signal/c_types.rs\n+++ b/kernel/aster-nix/src/process/signal/c_types.rs\n@@ -6,10 +6,10 @@\n use core::mem::{self, size_of};\n \n use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n-use ostd::cpu::GeneralRegs;\n \n use super::sig_num::SigNum;\n use crate::{\n+    arch::cpu::GpRegs,\n     prelude::*,\n     process::{Pid, Uid},\n };\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/aster-nix/src/process/signal/c_types.rs\n--- a/kernel/aster-nix/src/process/signal/c_types.rs\n+++ b/kernel/aster-nix/src/process/signal/c_types.rs\n@@ -206,7 +206,7 @@ pub struct mcontext_t {\n #[derive(Debug, Clone, Copy, Pod, Default)]\n #[repr(C)]\n pub struct SignalCpuContext {\n-    pub gp_regs: GeneralRegs,\n+    pub gp_regs: GpRegs,\n     pub fpregs_on_heap: u64,\n     pub fpregs: Vaddr, // *mut FpRegs,\n }\ndiff --git a/kernel/aster-nix/src/process/signal/mod.rs b/kernel/aster-nix/src/process/signal/mod.rs\n--- a/kernel/aster-nix/src/process/signal/mod.rs\n+++ b/kernel/aster-nix/src/process/signal/mod.rs\n@@ -166,7 +166,11 @@ pub fn handle_user_signal(\n         uc_sigmask: mask.as_u64(),\n         ..Default::default()\n     };\n-    ucontext.uc_mcontext.inner.gp_regs = *context.general_regs();\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_from_raw(context.general_regs());\n     let mut sig_context = posix_thread.sig_context().lock();\n     if let Some(sig_context_addr) = *sig_context {\n         ucontext.uc_link = sig_context_addr;\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigreturn.rs b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n--- a/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n+++ b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n@@ -38,7 +38,11 @@ pub fn sys_rt_sigreturn(context: &mut UserContext) -> Result<SyscallReturn> {\n     } else {\n         *sig_context = Some(ucontext.uc_link);\n     };\n-    *context.general_regs_mut() = ucontext.uc_mcontext.inner.gp_regs;\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_to_raw(context.general_regs_mut());\n     // unblock sig mask\n     let sig_mask = ucontext.uc_sigmask;\n     posix_thread.sig_mask().lock().unblock(sig_mask);\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/aster-nix/src/vdso.rs\n--- a/kernel/aster-nix/src/vdso.rs\n+++ b/kernel/aster-nix/src/vdso.rs\n@@ -23,8 +23,8 @@ use aster_util::coeff::Coeff;\n use ostd::{\n     mm::{Frame, VmIo, PAGE_SIZE},\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::{\ndiff --git a/kernel/comps/block/Cargo.toml b/kernel/comps/block/Cargo.toml\n--- a/kernel/comps/block/Cargo.toml\n+++ b/kernel/comps/block/Cargo.toml\n@@ -8,7 +8,6 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ostd = { path = \"../../../ostd\" }\n align_ext = { path = \"../../../ostd/libs/align_ext\" }\n aster-util = { path = \"../../libs/aster-util\" }\ndiff --git a/kernel/comps/block/src/id.rs b/kernel/comps/block/src/id.rs\n--- a/kernel/comps/block/src/id.rs\n+++ b/kernel/comps/block/src/id.rs\n@@ -5,7 +5,7 @@ use core::{\n     ops::{Add, Sub},\n };\n \n-use pod::Pod;\n+use ostd::Pod;\n use static_assertions::const_assert;\n \n /// The block index used in the filesystem.\ndiff --git a/kernel/comps/network/Cargo.toml b/kernel/comps/network/Cargo.toml\n--- a/kernel/comps/network/Cargo.toml\n+++ b/kernel/comps/network/Cargo.toml\n@@ -15,7 +15,6 @@ component = { path = \"../../libs/comp-sys/component\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n log = \"0.4\"\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n smoltcp = { version = \"0.9.1\", default-features = false, features = [\"alloc\", \"log\", \"medium-ethernet\", \"medium-ip\", \"proto-dhcpv4\", \"proto-ipv4\", \"proto-igmp\", \"socket-icmp\", \"socket-udp\", \"socket-tcp\", \"socket-raw\", \"socket-dhcpv4\"] }\n spin = \"0.9.4\"\ndiff --git a/kernel/comps/network/src/buffer.rs b/kernel/comps/network/src/buffer.rs\n--- a/kernel/comps/network/src/buffer.rs\n+++ b/kernel/comps/network/src/buffer.rs\n@@ -8,8 +8,8 @@ use ostd::{\n         Daddr, DmaDirection, DmaStream, FrameAllocOptions, HasDaddr, VmReader, VmWriter, PAGE_SIZE,\n     },\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::dma_pool::{DmaPool, DmaSegment};\ndiff --git a/kernel/comps/network/src/lib.rs b/kernel/comps/network/src/lib.rs\n--- a/kernel/comps/network/src/lib.rs\n+++ b/kernel/comps/network/src/lib.rs\n@@ -15,11 +15,10 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, string::String, sync::Arc, vec::Vec};\n use core::{any::Any, fmt::Debug};\n \n-use aster_util::safe_ptr::Pod;\n pub use buffer::{RxBuffer, TxBuffer, RX_BUFFER_POOL, TX_BUFFER_POOL};\n use component::{init_component, ComponentInitError};\n pub use dma_pool::DmaSegment;\n-use ostd::sync::SpinLock;\n+use ostd::{sync::SpinLock, Pod};\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/kernel/comps/virtio/Cargo.toml b/kernel/comps/virtio/Cargo.toml\n--- a/kernel/comps/virtio/Cargo.toml\n+++ b/kernel/comps/virtio/Cargo.toml\n@@ -19,7 +19,6 @@ aster-rights = { path = \"../../libs/aster-rights\" }\n id-alloc = { path = \"../../../ostd/libs/id-alloc\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/kernel/comps/virtio/src/device/block/device.rs b/kernel/comps/virtio/src/device/block/device.rs\n--- a/kernel/comps/virtio/src/device/block/device.rs\n+++ b/kernel/comps/virtio/src/device/block/device.rs\n@@ -15,8 +15,8 @@ use ostd::{\n     mm::{DmaDirection, DmaStream, DmaStreamSlice, FrameAllocOptions, VmIo},\n     sync::SpinLock,\n     trap::TrapFrame,\n+    Pod,\n };\n-use pod::Pod;\n \n use super::{BlockFeatures, VirtioBlockConfig};\n use crate::{\ndiff --git a/kernel/comps/virtio/src/device/block/mod.rs b/kernel/comps/virtio/src/device/block/mod.rs\n--- a/kernel/comps/virtio/src/device/block/mod.rs\n+++ b/kernel/comps/virtio/src/device/block/mod.rs\n@@ -5,8 +5,7 @@ pub mod device;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/console/config.rs b/kernel/comps/virtio/src/device/console/config.rs\n--- a/kernel/comps/virtio/src/device/console/config.rs\n+++ b/kernel/comps/virtio/src/device/console/config.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/input/mod.rs b/kernel/comps/virtio/src/device/input/mod.rs\n--- a/kernel/comps/virtio/src/device/input/mod.rs\n+++ b/kernel/comps/virtio/src/device/input/mod.rs\n@@ -28,8 +28,7 @@\n \n pub mod device;\n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/config.rs b/kernel/comps/virtio/src/device/network/config.rs\n--- a/kernel/comps/virtio/src/device/network/config.rs\n+++ b/kernel/comps/virtio/src/device/network/config.rs\n@@ -3,8 +3,7 @@\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/header.rs b/kernel/comps/virtio/src/device/network/header.rs\n--- a/kernel/comps/virtio/src/device/network/header.rs\n+++ b/kernel/comps/virtio/src/device/network/header.rs\n@@ -2,7 +2,7 @@\n \n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n pub const VIRTIO_NET_HDR_LEN: usize = core::mem::size_of::<VirtioNetHdr>();\n \ndiff --git a/kernel/comps/virtio/src/device/socket/config.rs b/kernel/comps/virtio/src/device/socket/config.rs\n--- a/kernel/comps/virtio/src/device/socket/config.rs\n+++ b/kernel/comps/virtio/src/device/socket/config.rs\n@@ -2,8 +2,7 @@\n \n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/socket/device.rs b/kernel/comps/virtio/src/device/socket/device.rs\n--- a/kernel/comps/virtio/src/device/socket/device.rs\n+++ b/kernel/comps/virtio/src/device/socket/device.rs\n@@ -6,8 +6,7 @@ use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n use aster_network::{RxBuffer, TxBuffer};\n use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n-use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame};\n-use pod::Pod;\n+use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame, Pod};\n \n use super::{\n     config::{VirtioVsockConfig, VsockFeatures},\ndiff --git a/kernel/comps/virtio/src/device/socket/header.rs b/kernel/comps/virtio/src/device/socket/header.rs\n--- a/kernel/comps/virtio/src/device/socket/header.rs\n+++ b/kernel/comps/virtio/src/device/socket/header.rs\n@@ -27,7 +27,7 @@\n //\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n use super::error::{self, SocketError};\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -15,9 +15,8 @@ use log::debug;\n use ostd::{\n     io_mem::IoMem,\n     mm::{DmaCoherent, FrameAllocOptions},\n-    offset_of,\n+    offset_of, Pod,\n };\n-use pod::Pod;\n \n use crate::{dma_buf::DmaBuf, transport::VirtioTransport};\n \ndiff --git a/kernel/comps/virtio/src/transport/mmio/layout.rs b/kernel/comps/virtio/src/transport/mmio/layout.rs\n--- a/kernel/comps/virtio/src/transport/mmio/layout.rs\n+++ b/kernel/comps/virtio/src/transport/mmio/layout.rs\n@@ -2,7 +2,7 @@\n \n use core::fmt::Debug;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n #[derive(Clone, Copy, Pod)]\n #[repr(C)]\ndiff --git a/kernel/comps/virtio/src/transport/pci/common_cfg.rs b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use super::capability::VirtioPciCapabilityData;\n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/kernel/libs/aster-util/Cargo.toml b/kernel/libs/aster-util/Cargo.toml\n--- a/kernel/libs/aster-util/Cargo.toml\n+++ b/kernel/libs/aster-util/Cargo.toml\n@@ -7,7 +7,6 @@ edition = \"2021\"\n \n [dependencies]\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n typeflags-util = { path = \"../typeflags-util\" }\n aster-rights-proc = { path = \"../aster-rights-proc\" }\n aster-rights = { path = \"../aster-rights\" }\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -5,11 +5,11 @@ use core::{fmt::Debug, marker::PhantomData};\n use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n use aster_rights_proc::require;\n use inherit_methods_macro::inherit_methods;\n+pub use ostd::Pod;\n use ostd::{\n     mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, VmIo},\n     Result,\n };\n-pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \n /// Safe pointers.\ndiff --git a/kernel/libs/aster-util/src/union_read_ptr.rs b/kernel/libs/aster-util/src/union_read_ptr.rs\n--- a/kernel/libs/aster-util/src/union_read_ptr.rs\n+++ b/kernel/libs/aster-util/src/union_read_ptr.rs\n@@ -2,7 +2,7 @@\n \n use core::marker::PhantomData;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n /// This ptr is designed to read union field safely.\n /// Write to union field is safe operation. While reading union field is UB.\ndiff --git a/kernel/libs/int-to-c-enum/Cargo.toml b/kernel/libs/int-to-c-enum/Cargo.toml\n--- a/kernel/libs/int-to-c-enum/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/Cargo.toml\n@@ -2,11 +2,15 @@\n name = \"int-to-c-enum\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+readme = \"README.md\"\n+description = \"TryFromInt - A convenient derive macro for converting an integer to an enum\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-int-to-c-enum-derive = { path = \"derive\", optional = true }\n+int-to-c-enum-derive = { path = \"derive\", optional = true, version = \"0.1.0\"}\n \n [features]\n default = [\"derive\"]\ndiff --git a/kernel/libs/int-to-c-enum/derive/Cargo.toml b/kernel/libs/int-to-c-enum/derive/Cargo.toml\n--- a/kernel/libs/int-to-c-enum/derive/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/derive/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"int-to-c-enum-derive\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"int-to-c-enum's proc macros\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -157,10 +157,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    // FIXME: Uses a fixed tag instaed of relies on remote branch\n-    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n-    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // Remember to upgrade this version if new version of linux-bzimage-setup is released.\n+    const LINUX_BZIMAGE_SETUP_VERSION: &str = \"0.1.0\";\n+    cmd.arg(\"--version\").arg(LINUX_BZIMAGE_SETUP_VERSION);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\ndiff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -7,7 +7,7 @@ use crate::{\n     config::manifest::ProjectType,\n     error::Errno,\n     error_msg,\n-    util::{aster_crate_dep, cargo_new_lib, get_cargo_metadata},\n+    util::{cargo_new_lib, get_cargo_metadata, ostd_dep},\n };\n \n pub fn execute_new_command(args: &NewArgs) {\ndiff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -40,7 +40,7 @@ fn add_manifest_dependencies(cargo_metadata: &serde_json::Value, crate_name: &st\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let ostd_dep = toml::Table::from_str(&aster_crate_dep(\"ostd\")).unwrap();\n+    let ostd_dep = toml::Table::from_str(&ostd_dep()).unwrap();\n     dependencies.as_table_mut().unwrap().extend(ostd_dep);\n \n     let content = toml::to_string(&manifest).unwrap();\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -12,18 +12,12 @@ use crate::{error::Errno, error_msg};\n \n use quote::ToTokens;\n \n-/// FIXME: We should publish the asterinas crates to a public registry\n-/// and use the published version in the generated Cargo.toml.\n-pub const ASTER_GIT_LINK: &str = \"https://github.com/asterinas/asterinas\";\n-/// Make sure it syncs with the builder dependency in Cargo.toml.\n-/// We cannot use `include_str!(\"../../VERSION\")` here\n-/// because `cargo publish` does not allow using files outside of the crate directory.\n-pub const ASTER_GIT_TAG: &str = concat!(\"v\", env!(\"CARGO_PKG_VERSION\"));\n-pub fn aster_crate_dep(crate_name: &str) -> String {\n-    format!(\n-        \"{} = {{ git = \\\"{}\\\", tag = \\\"{}\\\" }}\",\n-        crate_name, ASTER_GIT_LINK, ASTER_GIT_TAG\n-    )\n+/// The version of OSTD on crates.io.\n+///\n+/// OSTD shares the same version with OSDK, so just use the version of OSDK here.\n+pub const OSTD_VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n+pub fn ostd_dep() -> String {\n+    format!(\"ostd = {{ version = \\\"{}\\\" }}\", OSTD_VERSION)\n }\n \n fn cargo() -> Command {\ndiff --git a/ostd/libs/id-alloc/Cargo.toml b/ostd/libs/id-alloc/Cargo.toml\n--- a/ostd/libs/id-alloc/Cargo.toml\n+++ b/ostd/libs/id-alloc/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"id-alloc\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"An id allocator implemented by the bitmap\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/boot-params/Cargo.toml b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n--- a/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-boot-params\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The Boot Parameters for Linux Boot Protocol\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-bzimage-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The linux bzImage setup binary\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n [[bin]]\n name = \"linux-bzimage-setup\"\ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -11,7 +14,7 @@ path = \"src/main.rs\"\n \n [dependencies]\n cfg-if = \"1.0.0\"\n-linux-boot-params = { path = \"../boot-params\" }\n+linux-boot-params = { path = \"../boot-params\", version = \"0.1.0\" }\n uart_16550 = \"0.3.0\"\n xmas-elf = \"0.8.0\"\n \ndiff --git a/ostd/libs/ostd-macros/Cargo.toml b/ostd/libs/ostd-macros/Cargo.toml\n--- a/ostd/libs/ostd-macros/Cargo.toml\n+++ b/ostd/libs/ostd-macros/Cargo.toml\n@@ -1,7 +1,10 @@\n [package]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n edition = \"2021\"\n+description = \"OSTD's proc macros\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -11,7 +11,9 @@ use syn::{parse_macro_input, Expr, Ident, ItemFn};\n ///\n /// # Example\n ///\n-/// ```norun\n+/// ```ignore\n+/// #![no_std]\n+///\n /// use ostd::prelude::*;\n ///\n /// #[ostd::main]\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -16,7 +16,8 @@ use bitvec::{\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\n use tdx_guest::tdcall;\n-use trapframe::{GeneralRegs, UserContext as RawUserContext};\n+pub use trapframe::GeneralRegs as RawGeneralRegs;\n+use trapframe::UserContext as RawUserContext;\n use x86_64::registers::{\n     rflags::RFlags,\n     segmentation::{Segment64, FS},\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -131,7 +132,7 @@ pub struct CpuExceptionInfo {\n }\n \n #[cfg(feature = \"intel_tdx\")]\n-impl TdxTrapFrame for GeneralRegs {\n+impl TdxTrapFrame for RawGeneralRegs {\n     fn rax(&self) -> usize {\n         self.rax\n     }\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -258,12 +259,12 @@ impl UserPreemption {\n \n impl UserContext {\n     /// Returns a reference to the general registers.\n-    pub fn general_regs(&self) -> &GeneralRegs {\n+    pub fn general_regs(&self) -> &RawGeneralRegs {\n         &self.user_context.general\n     }\n \n     /// Returns a mutable reference to the general registers\n-    pub fn general_regs_mut(&mut self) -> &mut GeneralRegs {\n+    pub fn general_regs_mut(&mut self) -> &mut RawGeneralRegs {\n         &mut self.user_context.general\n     }\n \ndiff --git a/ostd/src/arch/x86/iommu/context_table.rs b/ostd/src/arch/x86/iommu/context_table.rs\n--- a/ostd/src/arch/x86/iommu/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/context_table.rs\n@@ -6,7 +6,6 @@ use alloc::collections::BTreeMap;\n use core::mem::size_of;\n \n use log::warn;\n-use pod::Pod;\n \n use super::second_stage::{DeviceMode, PageTableEntry, PagingConsts};\n use crate::{\ndiff --git a/ostd/src/arch/x86/iommu/context_table.rs b/ostd/src/arch/x86/iommu/context_table.rs\n--- a/ostd/src/arch/x86/iommu/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/context_table.rs\n@@ -17,6 +16,7 @@ use crate::{\n         page_table::PageTableError,\n         Frame, FrameAllocOptions, Paddr, PageFlags, PageTable, VmIo, PAGE_SIZE,\n     },\n+    Pod,\n };\n \n /// Bit 0 is `Present` bit, indicating whether this entry is present.\ndiff --git a/ostd/src/arch/x86/iommu/second_stage.rs b/ostd/src/arch/x86/iommu/second_stage.rs\n--- a/ostd/src/arch/x86/iommu/second_stage.rs\n+++ b/ostd/src/arch/x86/iommu/second_stage.rs\n@@ -4,12 +4,13 @@\n \n use core::ops::Range;\n \n-use pod::Pod;\n-\n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n-    page_table::{PageTableEntryTrait, PageTableMode},\n-    Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n+        page_table::{PageTableEntryTrait, PageTableMode},\n+        Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+    },\n+    Pod,\n };\n \n /// The page table used by iommu maps the device address\ndiff --git a/ostd/src/arch/x86/mm/mod.rs b/ostd/src/arch/x86/mm/mod.rs\n--- a/ostd/src/arch/x86/mm/mod.rs\n+++ b/ostd/src/arch/x86/mm/mod.rs\n@@ -5,14 +5,16 @@\n use alloc::fmt;\n use core::ops::Range;\n \n-use pod::Pod;\n pub(crate) use util::__memcpy_fallible;\n use x86_64::{instructions::tlb, structures::paging::PhysFrame, VirtAddr};\n \n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n-    page_table::PageTableEntryTrait,\n-    Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n+        page_table::PageTableEntryTrait,\n+        Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+    },\n+    Pod,\n };\n \n mod util;\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -6,7 +6,6 @@ pub mod cpu_local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\n-        pub use trapframe::GeneralRegs;\n         pub use crate::arch::x86::cpu::*;\n     }\n }\ndiff --git a/ostd/src/io_mem.rs b/ostd/src/io_mem.rs\n--- a/ostd/src/io_mem.rs\n+++ b/ostd/src/io_mem.rs\n@@ -4,11 +4,9 @@\n \n use core::{mem::size_of, ops::Range};\n \n-use pod::Pod;\n-\n use crate::{\n     mm::{kspace::LINEAR_MAPPING_BASE_VADDR, paddr_to_vaddr, HasPaddr, Paddr, Vaddr, VmIo},\n-    Error, Result,\n+    Error, Pod, Result,\n };\n \n /// I/O memory.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -44,6 +44,7 @@ pub mod trap;\n pub mod user;\n \n pub use ostd_macros::main;\n+pub use ostd_pod::Pod;\n \n pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n \ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -6,7 +6,6 @@ use core::marker::PhantomData;\n \n use align_ext::AlignExt;\n use inherit_methods_macro::inherit_methods;\n-use pod::Pod;\n \n use crate::{\n     arch::mm::__memcpy_fallible,\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -15,7 +14,7 @@ use crate::{\n         MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    Error,\n+    Error, Pod,\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -2,14 +2,15 @@\n \n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n-use pod::Pod;\n-\n use super::{\n     nr_subpage_per_huge, paddr_to_vaddr,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    Pod,\n+};\n \n mod node;\n use node::*;\n",
        "test_patch": "diff --git a/.github/workflows/publish_api_docs.yml /dev/null\n--- a/.github/workflows/publish_api_docs.yml\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-name: Update API docs\n-\n-on:\n-  # Scheduled events for nightly API docs\n-  schedule:\n-    # UTC 00:00 everyday\n-    - cron: \"0 0 * * *\"\n-  # Events for API docs of new release\n-  push:\n-    branches:\n-      - main\n-    paths:\n-      - VERSION\n-\n-jobs:\n-  build_and_upload:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 15\n-    container: asterinas/asterinas:0.6.2\n-\n-    steps:\n-      - uses: actions/checkout@v2\n-        with:\n-          repository: 'asterinas/asterinas'\n-          path: 'asterinas'\n-\n-      - name: Build & Upload Nightly API Docs\n-        if: github.event_name == 'schedule'\n-        env:\n-          API_DOCS_NIGHTLY_PUBLISH_KEY: ${{ secrets.API_DOCS_NIGHTLY_PUBLISH_KEY }}\n-        run: |\n-          KEY_FILE=./api_docs_nightly_publish_key\n-          echo \"$API_DOCS_NIGHTLY_PUBLISH_KEY\\n\" > ${KEY_FILE}\n-          bash asterinas/tools/github_workflows/build_and_upload_api_docs.sh nightly ${KEY_FILE} \n-\n-      - name: Build & Upload Release API Docs\n-        if: github.event_name == 'push'\n-        env:\n-          API_DOCS_PUBLISH_KEY: ${{ secrets.API_DOCS_PUBLISH_KEY }}\n-        run: |\n-          KEY_FILE=./api_docs_publish_key\n-          echo \"$API_DOCS_PUBLISH_KEY\\n\" > ${KEY_FILE}\n-          bash asterinas/tools/github_workflows/build_and_upload_api_docs.sh release ${KEY_FILE} \ndiff --git a/.github/workflows/publish_osdk.yml /dev/null\n--- a/.github/workflows/publish_osdk.yml\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-name: Publish OSDK\n-\n-on:\n-  pull_request:\n-    paths:\n-      - VERSION\n-      - osdk/Cargo.toml\n-  push:\n-    branches:\n-      - main\n-    paths: \n-      - VERSION\n-\n-jobs:\n-  osdk-publish:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 10\n-    container: asterinas/asterinas:0.6.2\n-    steps:\n-      - uses: actions/checkout@v4\n-\n-      - name: Check Publish\n-        # On pull request, set `--dry-run` to check whether OSDK can publish\n-        if: github.event_name == 'pull_request'\n-        run: |\n-          cd osdk\n-          cargo publish --dry-run\n-        \n-      - name: Publish\n-        # On push, OSDK will be published\n-        if: github.event_name == 'push'\n-        env:\n-          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n-        run: |\n-          cd osdk\n-          cargo publish --token ${REGISTRY_TOKEN}\ndiff --git /dev/null b/.github/workflows/publish_osdk_and_ostd.yml\nnew file mode 100644\n--- /dev/null\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -0,0 +1,69 @@\n+name: Publish OSDK and OSTD\n+\n+on:\n+  pull_request:\n+    paths:\n+      - VERSION\n+      - ostd/**\n+      - osdk/**\n+  push:\n+    branches:\n+      - main\n+    paths: \n+      - VERSION\n+\n+jobs:\n+  osdk-publish:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 10\n+    container: asterinas/asterinas:0.6.2\n+    steps:\n+      - uses: actions/checkout@v4\n+\n+      - name: Check Publish OSDK\n+        # On pull request, set `--dry-run` to check whether OSDK can publish\n+        if: github.event_name == 'pull_request'\n+        run: |\n+          cd osdk\n+          cargo publish --dry-run\n+        \n+      - name: Publish OSDK\n+        # On push, OSDK will be published\n+        if: github.event_name == 'push'\n+        env:\n+          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+        run: |\n+          cd osdk\n+          cargo publish --token ${REGISTRY_TOKEN}\n+\n+  ostd-publish:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 10\n+    container: asterinas/asterinas:0.6.2\n+    strategy:\n+      matrix:\n+        # All supported targets, this array should keep consistent with\n+        # `package.metadata.docs.rs.targets` in `ostd/Cargo.toml`\n+        target: ['x86_64-unknown-none']\n+    steps:\n+      - uses: actions/checkout@v4\n+\n+      - name: Check Publish OSTD\n+        # On pull request, set `--dry-run` to check whether OSDK can publish\n+        if: github.event_name == 'pull_request'\n+        run: |\n+          cd ostd\n+          cargo publish --target ${{ matrix.target }} --dry-run\n+          cargo doc --target ${{ matrix.target }}\n+      \n+      - name: Publish OSTD\n+        if: github.event_name == 'push'\n+        env:\n+          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+        # Using any target that OSTD supports for publishing is ok.\n+        # Here we use the same target as \n+        # `package.metadata.docs.rs.default-target` in `ostd/Cargo.toml`.\n+        run: |\n+          cd ostd\n+          cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n+      \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -795,13 +790,6 @@ checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n name = \"keyable-arc\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"ktest\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"owo-colors\",\n-]\n-\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1094,7 +1082,6 @@ dependencies = [\n  \"inherit-methods-macro\",\n  \"int-to-c-enum\",\n  \"intrusive-collections\",\n- \"ktest\",\n  \"lazy_static\",\n  \"linux-boot-params\",\n  \"log\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1103,8 +1090,9 @@ dependencies = [\n  \"num-derive\",\n  \"num-traits\",\n  \"ostd-macros\",\n+ \"ostd-pod\",\n+ \"ostd-test\",\n  \"owo-colors\",\n- \"pod\",\n  \"rsdp\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1127,6 +1115,31 @@ dependencies = [\n  \"syn 2.0.49\",\n ]\n \n+[[package]]\n+name = \"ostd-pod\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be401cae1e046a810574078b64e35924f5f\"\n+dependencies = [\n+ \"ostd-pod-derive\",\n+]\n+\n+[[package]]\n+name = \"ostd-pod-derive\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be401cae1e046a810574078b64e35924f5f\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"ostd-test\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"owo-colors\",\n+]\n+\n [[package]]\n name = \"owo-colors\"\n version = \"3.5.0\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -8,7 +8,7 @@ members = [\n     \"ostd/libs/linux-bzimage/builder\",\n     \"ostd/libs/linux-bzimage/boot-params\",\n     \"ostd/libs/linux-bzimage/setup\",\n-    \"ostd/libs/ktest\",\n+    \"ostd/libs/ostd-test\",\n     \"kernel\",\n     \"kernel/aster-nix\",\n     \"kernel/comps/block\",\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -91,8 +91,8 @@ NON_OSDK_CRATES := \\\n \tostd/libs/id-alloc \\\n \tostd/libs/linux-bzimage/builder \\\n \tostd/libs/linux-bzimage/boot-params \\\n-\tostd/libs/ktest \\\n \tostd/libs/ostd-macros \\\n+\tostd/libs/ostd-test \\\n \tkernel/libs/cpio-decoder \\\n \tkernel/libs/int-to-c-enum \\\n \tkernel/libs/int-to-c-enum/derive \\\ndiff --git a/docs/src/ostd/README.md b/docs/src/ostd/README.md\n--- a/docs/src/ostd/README.md\n+++ b/docs/src/ostd/README.md\n@@ -39,9 +39,7 @@ To explore how these APIs come into play,\n see [the example of a 100-line kernel in safe Rust](a-100-line-kernel.md).\n \n The OSTD APIs have been extensively documented.\n-You can access the comprehensive API documentation for each release by visiting the [API docs](https://asterinas.github.io/api-docs).\n-Additionally, you can refer to the latest nightly version API documentation at [API docs nightly](https://asterinas.github.io/api-docs-nightly),\n-which remains in sync with the latest changes in the main branch.\n+You can access the comprehensive API documentation by visiting the [docs.rs](https://docs.rs/ostd/latest/ostd).\n \n ## Four Requirements Satisfied\n \ndiff --git a/osdk/tests/util/mod.rs b/osdk/tests/util/mod.rs\n--- a/osdk/tests/util/mod.rs\n+++ b/osdk/tests/util/mod.rs\n@@ -88,7 +88,7 @@ pub fn add_member_to_workspace(workspace: impl AsRef<Path>, new_member: &str) {\n }\n \n /// Makes crates created by `cargo ostd new` depends on ostd locally,\n-/// instead of ostd from local branch.\n+/// instead of ostd from remote source(git repo/crates.io).\n ///\n /// Each crate created by `cargo ostd new` should add this patch.\n pub fn depends_on_local_ostd(manifest_path: impl AsRef<Path>) {\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -2,41 +2,48 @@\n name = \"ostd\"\n version = \"0.6.2\"\n edition = \"2021\"\n+description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n+license = \"MPL-2.0\"\n+readme = \"README.md\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n+# Settings for publishing docs in docs.rs\n+[package.metadata.docs.rs]\n+default-target = \"x86_64-unknown-none\"\n+targets = [\"x86_64-unknown-none\"]\n+\n [dependencies]\n-align_ext = { path = \"libs/align_ext\" }\n-ostd-macros = { path = \"libs/ostd-macros\" }\n+align_ext = { path = \"libs/align_ext\", version = \"0.1.0\" }\n+array-init = \"2.0\"\n bit_field = \"0.10.1\"\n+buddy_system_allocator = \"0.9.0\"\n bitflags = \"1.3\"\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-linux-boot-params = { path = \"libs/linux-bzimage/boot-params\" }\n-buddy_system_allocator = \"0.9.0\"\n cfg-if = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-xarray = { git = \"https://github.com/asterinas/xarray\", rev = \"72a4067\" }\n-int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\" }\n-# instrusive-collections of version 0.9.6 fails to compile with current rust toolchain,\n-# So we set a fixed version 0.9.5 for this crate\n-intrusive-collections = { version = \"=0.9.5\", features = [\"nightly\"] }\n-array-init = \"2.0\"\n-ktest = { path = \"libs/ktest\" }\n-id-alloc = { path = \"libs/id-alloc\" }\n+id-alloc = { path = \"libs/id-alloc\", version = \"0.1.0\" }\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\", version = \"0.1.0\" }\n+int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\", version = \"0.1.0\" }\n+intrusive-collections = { version = \"0.9.6\", features = [\"nightly\"] }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n+linux-boot-params = { path = \"libs/linux-bzimage/boot-params\", version = \"0.1.0\" }\n log = \"0.4\"\n num = { version = \"0.4\", default-features = false }\n num-derive = { version = \"0.4\", default-features = false }\n num-traits = { version = \"0.2\", default-features = false }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n+ostd-macros = { path = \"libs/ostd-macros\", version = \"0.1.4\" }\n+ostd-test = { path = \"libs/ostd-test\", version = \"0.1.0\" }\n+owo-colors = { version = \"3\", optional = true }\n+ostd-pod = { git = \"https://github.com/asterinas/ostd-pod\", rev = \"c4644be\", version = \"0.1.1\" }\n spin = \"0.9.4\"\n static_assertions = \"1.1.0\"\n tdx-guest = { version = \"0.1.5\", optional = true }\n-trapframe = { git = \"https://github.com/asterinas/trapframe-rs\", rev = \"4739428\" }\n+trapframe = \"0.10.0\"\n unwinding = { version = \"0.2.2\", default-features = false, features = [\"fde-gnu-eh-frame-hdr\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n-owo-colors = { version = \"3\", optional = true }\n+xarray = { git = \"https://github.com/asterinas/xarray\", rev = \"72a4067\", version = \"0.1.0\" }\n \n [target.x86_64-unknown-none.dependencies]\n x86_64 = \"0.14.2\"\ndiff --git a/ostd/README.md b/ostd/README.md\n--- a/ostd/README.md\n+++ b/ostd/README.md\n@@ -18,12 +18,4 @@ Asterinas OSTD offers the following key values.\n \n ## OSTD APIs\n \n-TODO\n-\n-## Implementation status\n-\n-TODO\n-\n-## Roadmap and plan\n-\n-TODO\n\\ No newline at end of file\n+See [API docs](https://docs.rs/ostd/latest/ostd).\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -44,7 +46,7 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n /// For crates other than ostd,\n /// this macro can be used in the following form.\n ///\n-/// ```norun\n+/// ```ignore\n /// use ostd::prelude::*;\n ///\n /// #[ktest]\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -56,7 +58,7 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n /// For ostd crate itself,\n /// this macro can be used in the form\n ///\n-/// ```norun\n+/// ```ignore\n /// use crate::prelude::*;\n ///\n /// #[ktest]\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -144,10 +146,10 @@ pub fn ktest(_attr: TokenStream, item: TokenStream) -> TokenStream {\n             #[cfg(ktest)]\n             #[used]\n             #[link_section = \".ktest_array\"]\n-            static #fn_ktest_item_name: ktest::KtestItem = ktest::KtestItem::new(\n+            static #fn_ktest_item_name: ostd_test::KtestItem = ostd_test::KtestItem::new(\n                 #fn_name,\n                 (#should_panic, #expectation_tokens),\n-                ktest::KtestItemInfo {\n+                ostd_test::KtestItemInfo {\n                     module_path: module_path!(),\n                     fn_name: stringify!(#fn_name),\n                     package: #package_name,\ndiff --git a/ostd/libs/ktest/Cargo.toml b/ostd/libs/ostd-test/Cargo.toml\n--- a/ostd/libs/ktest/Cargo.toml\n+++ b/ostd/libs/ostd-test/Cargo.toml\n@@ -1,7 +1,10 @@\n [package]\n-name = \"ktest\"\n+name = \"ostd-test\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The kernel mode testing framework of OSTD\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/ktest/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ktest/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -1,20 +1,20 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! # The kernel mode testing framework of Asterinas.\n+//! # The kernel mode testing framework of OSTD.\n //!\n-//! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\n+//! `ostd-test` stands for kernel-mode testing framework for OSTD. Its goal is to provide a\n //! `cargo test`-like experience for any `#![no_std]` bare metal crates.\n //!\n-//! In Asterinas, all the tests written in the source tree of the crates will be run\n+//! In OSTD, all the tests written in the source tree of the crates will be run\n //! immediately after the initialization of `ostd`. Thus you can use any\n //! feature provided by the frame including the heap allocator, etc.\n //!\n-//! By all means, ktest is an individule crate that only requires:\n+//! By all means, ostd-test is an individule crate that only requires:\n //!  - a custom linker script section `.ktest_array`,\n //!  - and an alloc implementation.\n //!\n-//! And the frame happens to provide both of them. Thus, any crates depending\n-//! on the frame can use ktest without any extra dependency.\n+//! And the OSTD happens to provide both of them. Thus, any crates depending\n+//! on the OSTD can use ostd-test without any extra dependency.\n //!\n //! ## Usage\n //!\ndiff --git a/ostd/libs/ktest/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ktest/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -43,7 +43,7 @@\n //! }\n //! ```\n //!\n-//! Any crates using the ktest framework should be linked with ostd.\n+//! Any crates using the ostd-test framework should be linked with ostd.\n //!\n //! ```toml\n //! # Cargo.toml\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -156,7 +156,7 @@ fn run_ktests(test_whitelist: Option<&[&str]>, crate_whitelist: Option<&[&str]>)\n     let fn_catch_unwind = &(unwinding::panic::catch_unwind::<(), fn()>\n         as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>);\n \n-    use ktest::runner::{run_ktests, KtestResult};\n+    use ostd_test::runner::{run_ktests, KtestResult};\n     match run_ktests(\n         &crate::console::early_print,\n         fn_catch_unwind,\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -123,5 +124,5 @@ mod test {\n /// The module re-exports everything from the ktest crate\n #[cfg(ktest)]\n pub mod ktest {\n-    pub use ktest::*;\n+    pub use ostd_test::*;\n }\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -29,7 +29,7 @@ use unwinding::{\n /// panic handler in the binary crate.\n #[export_name = \"__aster_panic_handler\"]\n pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n-    let throw_info = ktest::PanicInfo {\n+    let throw_info = ostd_test::PanicInfo {\n         message: info.message().to_string(),\n         file: info.location().unwrap().file().to_string(),\n         line: info.location().unwrap().line() as usize,\ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -293,7 +293,6 @@ impl fmt::Debug for AtomicBits {\n #[cfg(ktest)]\n mod test {\n     use super::*;\n-    use crate::prelude::*;\n \n     #[ktest]\n     fn new() {\n",
        "problem_statement": "Tracking issue for publishing OSTD to crates.io\n# Description\r\n\r\nThis issue tracks the issue of publishing OSTD to `crates.io`\r\n\r\n- [x] Publishing all dependent crates of OSTD to `crates.io`\r\n  - [x] align_ext ([v0.1.0](https://crates.io/crates/align_ext))\r\n  - [x] ostd-macros([v0.1.1](https://crates.io/crates/ostd-macros))\r\n  - [x] linux-boot-params([v0.1.0](https://crates.io/crates/linux-boot-params))\r\n  - [x] inherit-methods-macro([v0.1.0](https://crates.io/crates/inherit-methods-macro))\r\n  - [x] xarray([v0.1.0](https://crates.io/crates/xarray))\r\n  - [x] int-to-c-enum([v0.1.0](https://crates.io/crates/int-to-c-enum))\r\n  - [x] ktest(renamed as `ostd-test`, [v0.1.0](https://crates.io/crates/ostd-test))\r\n  - [x] id-alloc([v0.1.0](https://crates.io/crates/id-alloc))\r\n  - [x] pod(renamed as `pod-rs`, [v0.1.1](https://crates.io/crates/pod-rs))\r\n  - [x] trapframe([v0.9.0](https://crates.io/crates/trapframe) works, just without our patch to speed)\r\n  - [x] unwinding([v0.2.2](https://crates.io/crates/unwinding) works)\r\n- [x] Publish OSTD itself to `crate.io`\r\n- [x] Publish API documentation of OSTD to `docs.rs`\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2024-07-03T08:57:04Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 990,
        "instance_id": "asterinas__asterinas-990",
        "issue_numbers": [
            "944"
        ],
        "base_commit": "4844e7ca7ca6d78896a51a71487a6fdfe9ca6654",
        "patch": "diff --git a/kernel/aster-nix/src/sched/priority_scheduler.rs b/kernel/aster-nix/src/sched/priority_scheduler.rs\n--- a/kernel/aster-nix/src/sched/priority_scheduler.rs\n+++ b/kernel/aster-nix/src/sched/priority_scheduler.rs\n@@ -1,56 +1,234 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use intrusive_collections::LinkedList;\n-use ostd::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n+use ostd::{\n+    cpu::{num_cpus, this_cpu},\n+    task::{\n+        scheduler::{inject_scheduler, EnqueueFlags, LocalRunQueue, Scheduler, UpdateFlags},\n+        AtomicCpuId, Priority, Task,\n+    },\n+};\n \n use crate::prelude::*;\n \n pub fn init() {\n-    let preempt_scheduler = Box::new(PreemptScheduler::new());\n-    let scheduler = Box::<PreemptScheduler>::leak(preempt_scheduler);\n-    set_scheduler(scheduler);\n+    let preempt_scheduler = Box::new(PreemptScheduler::default());\n+    let scheduler = Box::<PreemptScheduler<Task>>::leak(preempt_scheduler);\n+    inject_scheduler(scheduler);\n }\n \n-/// The preempt scheduler\n+/// The preempt scheduler.\n ///\n-/// Real-time tasks are placed in the `real_time_tasks` queue and\n+/// Real-time tasks are placed in the `real_time_entities` queue and\n /// are always prioritized during scheduling.\n-/// Normal tasks are placed in the `normal_tasks` queue and are only\n+/// Normal tasks are placed in the `normal_entities` queue and are only\n /// scheduled for execution when there are no real-time tasks.\n-struct PreemptScheduler {\n-    /// Tasks with a priority of less than 100 are regarded as real-time tasks.\n-    real_time_tasks: SpinLock<LinkedList<TaskAdapter>>,\n-    /// Tasks with a priority greater than or equal to 100 are regarded as normal tasks.\n-    normal_tasks: SpinLock<LinkedList<TaskAdapter>>,\n+struct PreemptScheduler<T: PreemptSchedInfo> {\n+    rq: Vec<SpinLock<PreemptRunQueue<T>>>,\n }\n \n-impl PreemptScheduler {\n+impl<T: PreemptSchedInfo> PreemptScheduler<T> {\n+    fn new(nr_cpus: u32) -> Self {\n+        let mut rq = Vec::with_capacity(nr_cpus as usize);\n+        for _ in 0..nr_cpus {\n+            rq.push(SpinLock::new(PreemptRunQueue::new()));\n+        }\n+        Self { rq }\n+    }\n+\n+    /// Selects a cpu for task to run on.\n+    fn select_cpu(&self, _runnable: &Arc<T>) -> u32 {\n+        // FIXME: adopt more reasonable policy once we fully enable SMP.\n+        0\n+    }\n+}\n+\n+impl<T: Sync + Send + PreemptSchedInfo> Scheduler<T> for PreemptScheduler<T> {\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32> {\n+        let mut still_in_rq = false;\n+        let target_cpu = {\n+            let mut cpu_id = self.select_cpu(&runnable);\n+            if let Err(task_cpu_id) = runnable.cpu().set_if_is_none(cpu_id) {\n+                debug_assert!(flags != EnqueueFlags::Spawn);\n+                still_in_rq = true;\n+                cpu_id = task_cpu_id;\n+            }\n+\n+            cpu_id\n+        };\n+\n+        let mut rq = self.rq[target_cpu as usize].lock_irq_disabled();\n+        if still_in_rq && let Err(_) = runnable.cpu().set_if_is_none(target_cpu) {\n+            return None;\n+        }\n+        let entity = PreemptSchedEntity::new(runnable);\n+        if entity.is_real_time() {\n+            rq.real_time_entities.push_back(entity);\n+        } else {\n+            rq.normal_entities.push_back(entity);\n+        }\n+\n+        Some(target_cpu)\n+    }\n+\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>)) {\n+        let local_rq: &PreemptRunQueue<T> = &self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>)) {\n+        let local_rq: &mut PreemptRunQueue<T> =\n+            &mut self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+}\n+\n+impl Default for PreemptScheduler<Task> {\n+    fn default() -> Self {\n+        Self::new(num_cpus())\n+    }\n+}\n+\n+struct PreemptRunQueue<T: PreemptSchedInfo> {\n+    current: Option<PreemptSchedEntity<T>>,\n+    real_time_entities: VecDeque<PreemptSchedEntity<T>>,\n+    normal_entities: VecDeque<PreemptSchedEntity<T>>,\n+}\n+\n+impl<T: PreemptSchedInfo> PreemptRunQueue<T> {\n     pub fn new() -> Self {\n         Self {\n-            real_time_tasks: SpinLock::new(LinkedList::new(TaskAdapter::new())),\n-            normal_tasks: SpinLock::new(LinkedList::new(TaskAdapter::new())),\n+            current: None,\n+            real_time_entities: VecDeque::new(),\n+            normal_entities: VecDeque::new(),\n         }\n     }\n }\n \n-impl Scheduler for PreemptScheduler {\n-    fn enqueue(&self, task: Arc<Task>) {\n-        if task.is_real_time() {\n-            self.real_time_tasks.lock_irq_disabled().push_back(task);\n-        } else {\n-            self.normal_tasks.lock_irq_disabled().push_back(task);\n+impl<T: Sync + Send + PreemptSchedInfo> LocalRunQueue<T> for PreemptRunQueue<T> {\n+    fn current(&self) -> Option<&Arc<T>> {\n+        self.current.as_ref().map(|entity| &entity.runnable)\n+    }\n+\n+    fn update_current(&mut self, flags: UpdateFlags) -> bool {\n+        match flags {\n+            UpdateFlags::Tick => {\n+                let Some(ref mut current_entity) = self.current else {\n+                    return false;\n+                };\n+                current_entity.tick()\n+                    || (!current_entity.is_real_time() && !self.real_time_entities.is_empty())\n+            }\n+            _ => true,\n         }\n     }\n \n-    fn dequeue(&self) -> Option<Arc<Task>> {\n-        if !self.real_time_tasks.lock_irq_disabled().is_empty() {\n-            self.real_time_tasks.lock_irq_disabled().pop_front()\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>> {\n+        let next_entity = if !self.real_time_entities.is_empty() {\n+            self.real_time_entities.pop_front()\n         } else {\n-            self.normal_tasks.lock_irq_disabled().pop_front()\n+            self.normal_entities.pop_front()\n+        }?;\n+        if let Some(prev_entity) = self.current.replace(next_entity) {\n+            if prev_entity.is_real_time() {\n+                self.real_time_entities.push_back(prev_entity);\n+            } else {\n+                self.normal_entities.push_back(prev_entity);\n+            }\n         }\n+\n+        Some(&self.current.as_ref().unwrap().runnable)\n     }\n \n-    fn should_preempt(&self, task: &Arc<Task>) -> bool {\n-        !task.is_real_time() && !self.real_time_tasks.lock_irq_disabled().is_empty()\n+    fn dequeue_current(&mut self) -> Option<Arc<T>> {\n+        self.current.take().map(|entity| {\n+            let runnable = entity.runnable;\n+            runnable.cpu().set_to_none();\n+\n+            runnable\n+        })\n+    }\n+}\n+\n+struct PreemptSchedEntity<T: PreemptSchedInfo> {\n+    runnable: Arc<T>,\n+    time_slice: TimeSlice,\n+}\n+\n+impl<T: PreemptSchedInfo> PreemptSchedEntity<T> {\n+    fn new(runnable: Arc<T>) -> Self {\n+        Self {\n+            runnable,\n+            time_slice: TimeSlice::default(),\n+        }\n+    }\n+\n+    fn is_real_time(&self) -> bool {\n+        self.runnable.is_real_time()\n+    }\n+\n+    fn tick(&mut self) -> bool {\n+        self.time_slice.elapse()\n+    }\n+}\n+\n+impl<T: PreemptSchedInfo> Clone for PreemptSchedEntity<T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            runnable: self.runnable.clone(),\n+            time_slice: self.time_slice,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct TimeSlice {\n+    elapsed_ticks: u32,\n+}\n+\n+impl TimeSlice {\n+    const DEFAULT_TIME_SLICE: u32 = 100;\n+\n+    pub const fn new() -> Self {\n+        TimeSlice { elapsed_ticks: 0 }\n+    }\n+\n+    pub fn elapse(&mut self) -> bool {\n+        self.elapsed_ticks = (self.elapsed_ticks + 1) % Self::DEFAULT_TIME_SLICE;\n+\n+        self.elapsed_ticks == 0\n+    }\n+}\n+\n+impl Default for TimeSlice {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl PreemptSchedInfo for Task {\n+    type PRIORITY = Priority;\n+\n+    const REAL_TIME_TASK_PRIORITY: Self::PRIORITY = Priority::new(100);\n+\n+    fn priority(&self) -> Self::PRIORITY {\n+        self.priority()\n+    }\n+\n+    fn cpu(&self) -> &AtomicCpuId {\n+        self.cpu()\n+    }\n+}\n+\n+trait PreemptSchedInfo {\n+    type PRIORITY: Ord + PartialOrd + Eq + PartialEq;\n+\n+    const REAL_TIME_TASK_PRIORITY: Self::PRIORITY;\n+\n+    fn priority(&self) -> Self::PRIORITY;\n+\n+    fn cpu(&self) -> &AtomicCpuId;\n+\n+    fn is_real_time(&self) -> bool {\n+        self.priority() < Self::REAL_TIME_TASK_PRIORITY\n     }\n }\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -1,7 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use ostd::{\n-    task::{preempt, Task, TaskOptions},\n+    task::{Task, TaskOptions},\n     user::{ReturnReason, UserContextApi, UserMode, UserSpace},\n };\n \ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -84,8 +84,6 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n                 debug!(\"exit due to signal\");\n                 break;\n             }\n-            // a preemption point after handling user event.\n-            preempt(current_task);\n         }\n         debug!(\"exit user loop\");\n     }\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n--- a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n@@ -7,11 +7,7 @@ use core::{\n     time::Duration,\n };\n \n-use ostd::{\n-    cpu::CpuSet,\n-    sync::WaitQueue,\n-    task::{add_task, Priority},\n-};\n+use ostd::{cpu::CpuSet, sync::WaitQueue, task::Priority};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\n use crate::{\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n--- a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n@@ -81,7 +77,7 @@ impl LocalWorkerPool {\n     fn add_worker(&self) {\n         let worker = Worker::new(self.parent.clone(), self.cpu_id);\n         self.workers.lock_irq_disabled().push_back(worker.clone());\n-        add_task(worker.bound_thread().task().clone());\n+        worker.bound_thread().run();\n     }\n \n     fn remove_worker(&self) {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -17,6 +17,7 @@ use trapframe::UserContext as RawUserContext;\n use x86_64::registers::rflags::RFlags;\n \n use crate::{\n+    task::scheduler,\n     trap::call_irq_callback_functions,\n     user::{ReturnReason, UserContextApi, UserContextApiInternal},\n };\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -50,32 +51,6 @@ pub struct CpuExceptionInfo {\n     pub page_fault_addr: usize,\n }\n \n-/// User Preemption.\n-pub struct UserPreemption {\n-    count: u32,\n-}\n-\n-impl UserPreemption {\n-    const PREEMPTION_INTERVAL: u32 = 100;\n-\n-    /// Creates a new instance of `UserPreemption`.\n-    #[allow(clippy::new_without_default)]\n-    pub const fn new() -> Self {\n-        UserPreemption { count: 0 }\n-    }\n-\n-    /// Checks if preemption might occur and takes necessary actions.\n-    pub fn might_preempt(&mut self) {\n-        self.count = (self.count + 1) % Self::PREEMPTION_INTERVAL;\n-\n-        if self.count == 0 {\n-            crate::arch::irq::enable_local();\n-            crate::task::schedule();\n-            crate::arch::irq::disable_local();\n-        }\n-    }\n-}\n-\n impl UserContext {\n     /// Returns a reference to the general registers.\n     pub fn general_regs(&self) -> &RawGeneralRegs {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -115,9 +90,9 @@ impl UserContextApiInternal for UserContext {\n         let return_reason: ReturnReason;\n         const SYSCALL_TRAPNUM: u16 = 0x100;\n \n-        let mut user_preemption = UserPreemption::new();\n         // return when it is syscall or cpu exception type is Fault or Trap.\n         loop {\n+            scheduler::might_preempt();\n             self.user_context.run();\n             match CpuException::to_cpu_exception(self.user_context.trap_num as u16) {\n                 Some(exception) => {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -146,8 +121,6 @@ impl UserContextApiInternal for UserContext {\n                 return_reason = ReturnReason::KernelEvent;\n                 break;\n             }\n-\n-            user_preemption.might_preempt();\n         }\n \n         crate::arch::irq::enable_local();\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -129,7 +129,7 @@ pub fn call_ostd_main() -> ! {\n     unsafe {\n         use alloc::boxed::Box;\n \n-        use crate::task::{set_scheduler, FifoScheduler, Scheduler, TaskOptions};\n+        use crate::task::TaskOptions;\n \n         crate::init();\n         // The whitelists that will be generated by OSDK runner as static consts.\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -59,20 +59,10 @@ extern \"C\" {\n     fn __cpu_local_end();\n }\n \n-cpu_local_cell! {\n-    /// The count of the preempt lock.\n-    ///\n-    /// We need to access the preemption count before we can copy the section\n-    /// for application processors. So, the preemption count is not copied from\n-    /// bootstrap processor's section as the initialization. Instead it is\n-    /// initialized to zero for application processors.\n-    pub(crate) static PREEMPT_LOCK_COUNT: u32 = 0;\n-}\n-\n /// Sets the base address of the CPU-local storage for the bootstrap processor.\n ///\n /// It should be called early to let [`crate::task::disable_preempt`] work,\n-/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// which needs to update a CPU-local preemption info. Otherwise it may\n /// panic when calling [`crate::task::disable_preempt`].\n ///\n /// # Safety\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -133,24 +123,6 @@ pub unsafe fn init_on_bsp() {\n             (ap_pages_ptr as *mut u32).write(cpu_i);\n         }\n \n-        // SAFETY: the `PREEMPT_LOCK_COUNT` may be dirty on the BSP, so we need\n-        // to ensure that it is initialized to zero for APs. The safety\n-        // requirements are met since the static is defined in the `.cpu_local`\n-        // section and the pointer to that static is the offset in the CPU-\n-        // local area. It is a `usize` so it is safe to be overwritten.\n-        unsafe {\n-            let preempt_count_ptr = &PREEMPT_LOCK_COUNT as *const _ as usize;\n-            let preempt_count_offset = preempt_count_ptr - __cpu_local_start as usize;\n-            let ap_preempt_count_ptr = ap_pages_ptr.add(preempt_count_offset) as *mut usize;\n-            ap_preempt_count_ptr.write(0);\n-        }\n-\n-        // SAFETY: bytes `8:16` are reserved for storing the pointer to the\n-        // current task. We initialize it to null.\n-        unsafe {\n-            (ap_pages_ptr as *mut u64).add(1).write(0);\n-        }\n-\n         cpu_local_storages.push(ap_pages);\n     }\n \ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -4,7 +4,7 @@ use alloc::{collections::VecDeque, sync::Arc};\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n \n use super::SpinLock;\n-use crate::task::{add_task, schedule, Task, TaskStatus};\n+use crate::task::{scheduler, Task};\n \n // # Explanation on the memory orders\n //\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -255,36 +255,15 @@ impl Waker {\n         if self.has_woken.swap(true, Ordering::Release) {\n             return false;\n         }\n-\n-        let mut task = self.task.inner_exclusive_access();\n-        match task.task_status {\n-            TaskStatus::Sleepy => {\n-                task.task_status = TaskStatus::Runnable;\n-            }\n-            TaskStatus::Sleeping => {\n-                task.task_status = TaskStatus::Runnable;\n-\n-                // Avoid holding the lock when doing `add_task`\n-                drop(task);\n-                add_task(self.task.clone());\n-            }\n-            _ => (),\n-        }\n+        scheduler::unpark_target(self.task.clone());\n \n         true\n     }\n \n     fn do_wait(&self) {\n-        while !self.has_woken.swap(false, Ordering::Acquire) {\n-            let mut task = self.task.inner_exclusive_access();\n-            // After holding the lock, check again to avoid races\n-            if self.has_woken.swap(false, Ordering::Acquire) {\n-                break;\n-            }\n-            task.task_status = TaskStatus::Sleepy;\n-            drop(task);\n-\n-            schedule();\n+        let has_woken = &self.has_woken;\n+        while !has_woken.swap(false, Ordering::Acquire) {\n+            scheduler::park_current(has_woken);\n         }\n     }\n \ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -2,15 +2,13 @@\n \n //! Tasks are the unit of code execution.\n \n-mod priority;\n+mod preempt;\n mod processor;\n-mod scheduler;\n+pub mod scheduler;\n #[allow(clippy::module_inception)]\n mod task;\n \n pub use self::{\n-    priority::Priority,\n-    processor::{disable_preempt, preempt, schedule, DisablePreemptGuard},\n-    scheduler::{add_task, set_scheduler, FifoScheduler, Scheduler},\n-    task::{Task, TaskAdapter, TaskContextApi, TaskOptions, TaskStatus},\n+    preempt::{disable_preempt, DisablePreemptGuard},\n+    task::{AtomicCpuId, Priority, Task, TaskAdapter, TaskContextApi, TaskOptions},\n };\ndiff --git /dev/null b/ostd/src/task/preempt/cpu_local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/cpu_local.rs\n@@ -0,0 +1,61 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module maintains preemption-related information for the curren task\n+//! on a CPU with a single 32-bit, CPU-local integer value.\n+//!\n+//! * Bits from 0 to 30 represents an unsigned counter called `guard_count`,\n+//!   which is the number of `DisablePreemptGuard` instances held by the\n+//!   current CPU;\n+//! * Bit 31 is set to `!need_preempt`, where `need_preempt` is a boolean value\n+//!   that will be set by the scheduler when it decides that the current task\n+//!   _needs_ to be preempted.\n+//!\n+//! Thus, the current task on a CPU _should_ be preempted if and only if this\n+//! integer is equal to zero.\n+//!\n+//! The initial value of this integer is equal to `1 << 31`.\n+//!\n+//! This module provides a set of functions to access and manipulate\n+//! `guard_count` and `need_preempt`.\n+\n+use crate::cpu_local_cell;\n+\n+/// Returns whether the current task _should_ be preempted or not.\n+///\n+/// `should_preempt() == need_preempt() && get_guard_count() == 0`.\n+pub(in crate::task) fn should_preempt() -> bool {\n+    PREEMPT_INFO.load() == 0\n+}\n+\n+#[allow(dead_code)]\n+pub(in crate::task) fn need_preempt() -> bool {\n+    PREEMPT_INFO.load() & NEED_PREEMPT_MASK == 0\n+}\n+\n+pub(in crate::task) fn set_need_preempt() {\n+    PREEMPT_INFO.bitand_assign(!NEED_PREEMPT_MASK);\n+}\n+\n+pub(in crate::task) fn clear_need_preempt() {\n+    PREEMPT_INFO.bitor_assign(NEED_PREEMPT_MASK);\n+}\n+\n+pub(in crate::task) fn get_guard_count() -> u32 {\n+    PREEMPT_INFO.load() & GUARD_COUNT_MASK\n+}\n+\n+pub(in crate::task) fn inc_guard_count() {\n+    PREEMPT_INFO.add_assign(1);\n+}\n+\n+pub(in crate::task) fn dec_guard_count() {\n+    debug_assert!(get_guard_count() > 0);\n+    PREEMPT_INFO.sub_assign(1);\n+}\n+\n+cpu_local_cell! {\n+    static PREEMPT_INFO: u32 = NEED_PREEMPT_MASK;\n+}\n+\n+const NEED_PREEMPT_MASK: u32 = 1 << 31;\n+const GUARD_COUNT_MASK: u32 = (1 << 31) - 1;\ndiff --git /dev/null b/ostd/src/task/preempt/guard.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/guard.rs\n@@ -0,0 +1,35 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+/// A guard for disable preempt.\n+#[clippy::has_significant_drop]\n+#[must_use]\n+pub struct DisablePreemptGuard {\n+    // This private field prevents user from constructing values of this type directly.\n+    _private: (),\n+}\n+\n+impl !Send for DisablePreemptGuard {}\n+\n+impl DisablePreemptGuard {\n+    fn new() -> Self {\n+        super::cpu_local::inc_guard_count();\n+        Self { _private: () }\n+    }\n+\n+    /// Transfer this guard to a new guard.\n+    /// This guard must be dropped after this function.\n+    pub fn transfer_to(&self) -> Self {\n+        disable_preempt()\n+    }\n+}\n+\n+impl Drop for DisablePreemptGuard {\n+    fn drop(&mut self) {\n+        super::cpu_local::dec_guard_count();\n+    }\n+}\n+\n+/// Disables preemption.\n+pub fn disable_preempt() -> DisablePreemptGuard {\n+    DisablePreemptGuard::new()\n+}\ndiff --git /dev/null b/ostd/src/task/preempt/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/mod.rs\n@@ -0,0 +1,6 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+pub(super) mod cpu_local;\n+mod guard;\n+\n+pub use self::guard::{disable_preempt, DisablePreemptGuard};\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -3,11 +3,10 @@\n use alloc::sync::Arc;\n \n use super::{\n-    scheduler::{fetch_task, GLOBAL_SCHEDULER},\n-    task::{context_switch, TaskContext},\n-    Task, TaskStatus,\n+    preempt::cpu_local,\n+    task::{context_switch, Task, TaskContext},\n };\n-use crate::{cpu::local::PREEMPT_LOCK_COUNT, cpu_local_cell};\n+use crate::cpu_local_cell;\n \n cpu_local_cell! {\n     /// The `Arc<Task>` (casted by [`Arc::into_raw`]) that is the current task.\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -37,51 +36,21 @@ pub(super) fn current_task() -> Option<Arc<Task>> {\n     Some(restored)\n }\n \n-/// Calls this function to switch to other task by using GLOBAL_SCHEDULER\n-pub fn schedule() {\n-    if let Some(task) = fetch_task() {\n-        switch_to_task(task);\n-    }\n-}\n-\n-/// Preempts the `task`.\n-///\n-/// TODO: This interface of this method is error prone.\n-/// The method takes an argument for the current task to optimize its efficiency,\n-/// but the argument provided by the caller may not be the current task, really.\n-/// Thus, this method should be removed or reworked in the future.\n-pub fn preempt(task: &Arc<Task>) {\n-    // TODO: Refactor `preempt` and `schedule`\n-    // after the Atomic mode and `might_break` is enabled.\n-    let mut scheduler = GLOBAL_SCHEDULER.lock_irq_disabled();\n-    if !scheduler.should_preempt(task) {\n-        return;\n-    }\n-    let Some(next_task) = scheduler.dequeue() else {\n-        return;\n-    };\n-    drop(scheduler);\n-    switch_to_task(next_task);\n-}\n-\n /// Calls this function to switch to other task\n ///\n /// If current task is none, then it will use the default task context and it\n /// will not return to this function again.\n ///\n-/// If the current task's status not [`TaskStatus::Runnable`], it will not be\n-/// added to the scheduler.\n-///\n /// # Panics\n ///\n /// This function will panic if called while holding preemption locks or with\n /// local IRQ disabled.\n-fn switch_to_task(next_task: Arc<Task>) {\n-    let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n-    if preemt_lock_count != 0 {\n+pub(super) fn switch_to_task(next_task: Arc<Task>) {\n+    let guard_count = cpu_local::get_guard_count();\n+    if guard_count != 0 {\n         panic!(\n-            \"Calling schedule() while holding {} locks\",\n-            preemt_lock_count\n+            \"Switching task with preemption disabled (nesting depth: {})\",\n+            guard_count\n         );\n     }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -93,7 +62,6 @@ fn switch_to_task(next_task: Arc<Task>) {\n     let irq_guard = crate::trap::disable_local();\n \n     let current_task_ptr = CURRENT_TASK_PTR.load();\n-\n     let current_task_ctx_ptr = if current_task_ptr.is_null() {\n         // SAFETY: Interrupts are disabled, so the pointer is safe to be fetched.\n         unsafe { BOOTSTRAP_CONTEXT.as_ptr_mut() }\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -104,24 +72,12 @@ fn switch_to_task(next_task: Arc<Task>) {\n             let _ = core::mem::ManuallyDrop::new(restored.clone());\n             restored\n         };\n-\n         let ctx_ptr = cur_task_arc.ctx().get();\n \n-        let mut task_inner = cur_task_arc.inner_exclusive_access();\n-\n-        debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n-        if task_inner.task_status == TaskStatus::Runnable {\n-            drop(task_inner);\n-            GLOBAL_SCHEDULER.lock().enqueue(cur_task_arc);\n-        } else if task_inner.task_status == TaskStatus::Sleepy {\n-            task_inner.task_status = TaskStatus::Sleeping;\n-        }\n-\n         ctx_ptr\n     };\n \n     let next_task_ctx_ptr = next_task.ctx().get().cast_const();\n-\n     if let Some(next_user_space) = next_task.user_space() {\n         next_user_space.vm_space().activate();\n     }\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -144,7 +100,7 @@ fn switch_to_task(next_task: Arc<Task>) {\n     drop(irq_guard);\n \n     // SAFETY:\n-    // 1. `ctx` is only used in `schedule()`. We have exclusive access to both the current task\n+    // 1. `ctx` is only used in `reschedule()`. We have exclusive access to both the current task\n     //    context and the next task context.\n     // 2. The next task context is a valid task context.\n     unsafe {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -158,37 +114,3 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // next task. Not dropping is just fine because the only consequence is that we delay the drop\n     // to the next task switching.\n }\n-\n-/// A guard for disable preempt.\n-#[clippy::has_significant_drop]\n-#[must_use]\n-pub struct DisablePreemptGuard {\n-    // This private field prevents user from constructing values of this type directly.\n-    _private: (),\n-}\n-\n-impl !Send for DisablePreemptGuard {}\n-\n-impl DisablePreemptGuard {\n-    fn new() -> Self {\n-        PREEMPT_LOCK_COUNT.add_assign(1);\n-        Self { _private: () }\n-    }\n-\n-    /// Transfer this guard to a new guard.\n-    /// This guard must be dropped after this function.\n-    pub fn transfer_to(&self) -> Self {\n-        disable_preempt()\n-    }\n-}\n-\n-impl Drop for DisablePreemptGuard {\n-    fn drop(&mut self) {\n-        PREEMPT_LOCK_COUNT.sub_assign(1);\n-    }\n-}\n-\n-/// Disables preemption.\n-pub fn disable_preempt() -> DisablePreemptGuard {\n-    DisablePreemptGuard::new()\n-}\ndiff --git a/ostd/src/task/scheduler.rs /dev/null\n--- a/ostd/src/task/scheduler.rs\n+++ /dev/null\n@@ -1,107 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-#![allow(dead_code)]\n-\n-use alloc::collections::VecDeque;\n-\n-use crate::{prelude::*, sync::SpinLock, task::Task};\n-\n-static DEFAULT_SCHEDULER: FifoScheduler = FifoScheduler::new();\n-pub(crate) static GLOBAL_SCHEDULER: SpinLock<GlobalScheduler> = SpinLock::new(GlobalScheduler {\n-    scheduler: &DEFAULT_SCHEDULER,\n-});\n-\n-/// A scheduler for tasks.\n-///\n-/// An implementation of scheduler can attach scheduler-related information\n-/// with the `TypeMap` returned from `task.data()`.\n-pub trait Scheduler: Sync + Send {\n-    /// Enqueues a task to the scheduler.\n-    fn enqueue(&self, task: Arc<Task>);\n-\n-    /// Dequeues a task from the scheduler.\n-    fn dequeue(&self) -> Option<Arc<Task>>;\n-\n-    /// Tells whether the given task should be preempted by other tasks in the queue.\n-    fn should_preempt(&self, task: &Arc<Task>) -> bool;\n-}\n-\n-pub struct GlobalScheduler {\n-    scheduler: &'static dyn Scheduler,\n-}\n-\n-impl GlobalScheduler {\n-    pub const fn new(scheduler: &'static dyn Scheduler) -> Self {\n-        Self { scheduler }\n-    }\n-\n-    /// dequeue a task using scheduler\n-    /// require the scheduler is not none\n-    pub fn dequeue(&mut self) -> Option<Arc<Task>> {\n-        self.scheduler.dequeue()\n-    }\n-    /// enqueue a task using scheduler\n-    /// require the scheduler is not none\n-    pub fn enqueue(&mut self, task: Arc<Task>) {\n-        self.scheduler.enqueue(task)\n-    }\n-\n-    pub fn should_preempt(&self, task: &Arc<Task>) -> bool {\n-        self.scheduler.should_preempt(task)\n-    }\n-}\n-/// Sets the global task scheduler.\n-///\n-/// This must be called before invoking `Task::spawn`.\n-pub fn set_scheduler(scheduler: &'static dyn Scheduler) {\n-    let mut global_scheduler = GLOBAL_SCHEDULER.lock_irq_disabled();\n-    // When setting a new scheduler, the old scheduler should be empty\n-    assert!(global_scheduler.dequeue().is_none());\n-    global_scheduler.scheduler = scheduler;\n-}\n-\n-pub fn fetch_task() -> Option<Arc<Task>> {\n-    GLOBAL_SCHEDULER.lock_irq_disabled().dequeue()\n-}\n-\n-/// Adds a task to the global scheduler.\n-pub fn add_task(task: Arc<Task>) {\n-    GLOBAL_SCHEDULER.lock_irq_disabled().enqueue(task);\n-}\n-\n-/// A simple FIFO (First-In-First-Out) task scheduler.\n-pub struct FifoScheduler {\n-    /// A thread-safe queue to hold tasks waiting to be executed.\n-    task_queue: SpinLock<VecDeque<Arc<Task>>>,\n-}\n-\n-impl FifoScheduler {\n-    /// Creates a new instance of `FifoScheduler`.\n-    pub const fn new() -> Self {\n-        FifoScheduler {\n-            task_queue: SpinLock::new(VecDeque::new()),\n-        }\n-    }\n-}\n-\n-impl Default for FifoScheduler {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl Scheduler for FifoScheduler {\n-    /// Enqueues a task to the end of the queue.\n-    fn enqueue(&self, task: Arc<Task>) {\n-        self.task_queue.lock_irq_disabled().push_back(task);\n-    }\n-    /// Dequeues a task from the front of the queue, if any.\n-    fn dequeue(&self) -> Option<Arc<Task>> {\n-        self.task_queue.lock_irq_disabled().pop_front()\n-    }\n-    /// In this simple implementation, task preemption is not supported.\n-    /// Once a task starts running, it will continue to run until completion.\n-    fn should_preempt(&self, _task: &Arc<Task>) -> bool {\n-        false\n-    }\n-}\ndiff --git /dev/null b/ostd/src/task/scheduler/fifo_scheduler.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/scheduler/fifo_scheduler.rs\n@@ -0,0 +1,125 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use alloc::{boxed::Box, collections::VecDeque, sync::Arc, vec::Vec};\n+\n+use super::{inject_scheduler, EnqueueFlags, LocalRunQueue, Scheduler, UpdateFlags};\n+use crate::{\n+    cpu::{num_cpus, this_cpu},\n+    sync::SpinLock,\n+    task::{AtomicCpuId, Task},\n+};\n+\n+pub fn init() {\n+    let fifo_scheduler = Box::new(FifoScheduler::default());\n+    let scheduler = Box::<FifoScheduler<Task>>::leak(fifo_scheduler);\n+    inject_scheduler(scheduler);\n+}\n+\n+/// A simple FIFO (First-In-First-Out) task scheduler.\n+struct FifoScheduler<T: FifoSchedInfo> {\n+    /// A thread-safe queue to hold tasks waiting to be executed.\n+    rq: Vec<SpinLock<FifoRunQueue<T>>>,\n+}\n+\n+impl<T: FifoSchedInfo> FifoScheduler<T> {\n+    /// Creates a new instance of `FifoScheduler`.\n+    fn new(nr_cpus: u32) -> Self {\n+        let mut rq = Vec::new();\n+        for _ in 0..nr_cpus {\n+            rq.push(SpinLock::new(FifoRunQueue::new()));\n+        }\n+        Self { rq }\n+    }\n+\n+    fn select_cpu(&self) -> u32 {\n+        // FIXME: adopt more reasonable policy once we fully enable SMP.\n+        0\n+    }\n+}\n+\n+impl<T: FifoSchedInfo + Send + Sync> Scheduler<T> for FifoScheduler<T> {\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32> {\n+        let mut still_in_rq = false;\n+        let target_cpu = {\n+            let mut cpu_id = self.select_cpu();\n+            if let Err(task_cpu_id) = runnable.cpu().set_if_is_none(cpu_id) {\n+                debug_assert!(flags != EnqueueFlags::Spawn);\n+                still_in_rq = true;\n+                cpu_id = task_cpu_id;\n+            }\n+\n+            cpu_id\n+        };\n+\n+        let mut rq = self.rq[target_cpu as usize].lock_irq_disabled();\n+        if still_in_rq && let Err(_) = runnable.cpu().set_if_is_none(target_cpu) {\n+            return None;\n+        }\n+        rq.queue.push_back(runnable);\n+\n+        Some(target_cpu)\n+    }\n+\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>)) {\n+        let local_rq: &FifoRunQueue<T> = &self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>)) {\n+        let local_rq: &mut FifoRunQueue<T> = &mut self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+}\n+\n+struct FifoRunQueue<T: FifoSchedInfo> {\n+    current: Option<Arc<T>>,\n+    queue: VecDeque<Arc<T>>,\n+}\n+\n+impl<T: FifoSchedInfo> FifoRunQueue<T> {\n+    pub const fn new() -> Self {\n+        Self {\n+            current: None,\n+            queue: VecDeque::new(),\n+        }\n+    }\n+}\n+\n+impl<T: FifoSchedInfo> LocalRunQueue<T> for FifoRunQueue<T> {\n+    fn current(&self) -> Option<&Arc<T>> {\n+        self.current.as_ref()\n+    }\n+\n+    fn update_current(&mut self, flags: super::UpdateFlags) -> bool {\n+        !matches!(flags, UpdateFlags::Tick)\n+    }\n+\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>> {\n+        let next_task = self.queue.pop_front()?;\n+        if let Some(prev_task) = self.current.replace(next_task) {\n+            self.queue.push_back(prev_task);\n+        }\n+\n+        self.current.as_ref()\n+    }\n+\n+    fn dequeue_current(&mut self) -> Option<Arc<T>> {\n+        self.current.take().inspect(|task| task.cpu().set_to_none())\n+    }\n+}\n+\n+impl Default for FifoScheduler<Task> {\n+    fn default() -> Self {\n+        Self::new(num_cpus())\n+    }\n+}\n+\n+impl FifoSchedInfo for Task {\n+    fn cpu(&self) -> &AtomicCpuId {\n+        self.cpu()\n+    }\n+}\n+\n+trait FifoSchedInfo {\n+    fn cpu(&self) -> &AtomicCpuId;\n+}\ndiff --git /dev/null b/ostd/src/task/scheduler/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/scheduler/mod.rs\n@@ -0,0 +1,241 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Scheduling subsystem (in-OSTD part).\n+//!\n+//! This module defines what OSTD expects from a scheduling implementation\n+//! and provides useful functions for controlling the execution flow.\n+\n+mod fifo_scheduler;\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+use spin::Once;\n+\n+use super::{preempt::cpu_local, processor, task::Task};\n+use crate::{arch::timer, cpu::this_cpu, prelude::*};\n+\n+/// Injects a scheduler implementation into framework.\n+///\n+/// This function can only be called once and must be called during the initialization of kernel.\n+pub fn inject_scheduler(scheduler: &'static dyn Scheduler<Task>) {\n+    SCHEDULER.call_once(|| scheduler);\n+\n+    timer::register_callback(|| {\n+        SCHEDULER.get().unwrap().local_mut_rq_with(&mut |local_rq| {\n+            if local_rq.update_current(UpdateFlags::Tick) {\n+                cpu_local::set_need_preempt();\n+            }\n+        })\n+    });\n+}\n+\n+static SCHEDULER: Once<&'static dyn Scheduler<Task>> = Once::new();\n+\n+/// A per-CPU task scheduler.\n+pub trait Scheduler<T = Task>: Sync + Send {\n+    /// Enqueues a runnable task.\n+    ///\n+    /// Scheduler developers can perform load-balancing or some accounting work here.\n+    ///\n+    /// If the `current` of a CPU needs to be preempted, this method returns the id of\n+    /// that CPU.\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32>;\n+\n+    /// Gets an immutable access to the local runqueue of the current CPU core.\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>));\n+\n+    /// Gets a mutable access to the local runqueue of the current CPU core.\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>));\n+}\n+\n+/// The _local_ view of a per-CPU runqueue.\n+///\n+/// This local view provides the interface for the runqueue of a CPU core\n+/// to be inspected and manipulated by the code running on this particular CPU core.\n+///\n+/// Conceptually, a local runqueue consists of two parts:\n+/// (1) a priority queue of runnable tasks;\n+/// (2) the current running task.\n+/// The exact definition of \"priority\" is left for the concrete implementation to decide.\n+pub trait LocalRunQueue<T = Task> {\n+    /// Gets the current runnable task.\n+    fn current(&self) -> Option<&Arc<T>>;\n+\n+    /// Updates the current runnable task's scheduling statistics and potentially its\n+    /// position in the queue.\n+    ///\n+    /// If the current runnable task needs to be preempted, the method returns `true`.\n+    fn update_current(&mut self, flags: UpdateFlags) -> bool;\n+\n+    /// Picks the next current runnable task.\n+    ///\n+    /// This method returns the chosen next current runnable task. If there is no\n+    /// candidate for next current runnable task, this method returns `None`.\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>>;\n+\n+    /// Removes the current runnable task from runqueue.\n+    ///\n+    /// This method returns the current runnable task. If there is no current runnable\n+    /// task, this method returns `None`.\n+    fn dequeue_current(&mut self) -> Option<Arc<T>>;\n+}\n+\n+/// Possible triggers of an `enqueue` action.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum EnqueueFlags {\n+    /// Spawn a new task.\n+    Spawn,\n+    /// Wake a sleeping task.\n+    Wake,\n+}\n+\n+/// Possible triggers of an `update_current` action.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum UpdateFlags {\n+    /// Timer interrupt.\n+    Tick,\n+    /// Task waiting.\n+    Wait,\n+    /// Task yielding.\n+    Yield,\n+}\n+\n+/// Preempts the current task.\n+pub(crate) fn might_preempt() {\n+    if !cpu_local::should_preempt() {\n+        return;\n+    }\n+    yield_now();\n+}\n+\n+/// Blocks the current task unless `has_woken` is `true`.\n+pub(crate) fn park_current(has_woken: &AtomicBool) {\n+    let mut current = None;\n+    let mut is_first_try = true;\n+    reschedule(&mut |local_rq: &mut dyn LocalRunQueue| {\n+        if is_first_try {\n+            if has_woken.load(Ordering::Acquire) {\n+                return ReschedAction::DoNothing;\n+            }\n+            current = local_rq.dequeue_current();\n+            local_rq.update_current(UpdateFlags::Wait);\n+        }\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            if Arc::ptr_eq(current.as_ref().unwrap(), next_task) {\n+                return ReschedAction::DoNothing;\n+            }\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            is_first_try = false;\n+            ReschedAction::Retry\n+        }\n+    });\n+}\n+\n+/// Unblocks a target task.\n+pub(crate) fn unpark_target(runnable: Arc<Task>) {\n+    let need_preempt_info = SCHEDULER\n+        .get()\n+        .unwrap()\n+        .enqueue(runnable, EnqueueFlags::Wake);\n+    if need_preempt_info.is_some() {\n+        let cpu_id = need_preempt_info.unwrap();\n+        // FIXME: send IPI to set remote CPU's need_preempt if needed.\n+        if cpu_id == this_cpu() {\n+            cpu_local::set_need_preempt();\n+        }\n+    }\n+}\n+\n+/// Enqueues a newly built task.\n+///\n+/// Note that the new task is not guranteed to run at once.\n+pub(super) fn run_new_task(runnable: Arc<Task>) {\n+    // FIXME: remove this check for `SCHEDULER`.\n+    // Currently OSTD cannot know whether its user has injected a scheduler.\n+    if !SCHEDULER.is_completed() {\n+        fifo_scheduler::init();\n+    }\n+\n+    let need_preempt_info = SCHEDULER\n+        .get()\n+        .unwrap()\n+        .enqueue(runnable, EnqueueFlags::Spawn);\n+    if need_preempt_info.is_some() {\n+        let cpu_id = need_preempt_info.unwrap();\n+        // FIXME: send IPI to set remote CPU's need_preempt if needed.\n+        if cpu_id == this_cpu() {\n+            cpu_local::set_need_preempt();\n+        }\n+    }\n+\n+    might_preempt();\n+}\n+\n+/// Dequeues the current task from its runqueue.\n+///\n+/// This should only be called if the current is to exit.\n+pub(super) fn exit_current() {\n+    reschedule(&mut |local_rq: &mut dyn LocalRunQueue| {\n+        let _ = local_rq.dequeue_current();\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            ReschedAction::Retry\n+        }\n+    })\n+}\n+\n+/// Yields execution.\n+pub(super) fn yield_now() {\n+    reschedule(&mut |local_rq| {\n+        local_rq.update_current(UpdateFlags::Yield);\n+\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            ReschedAction::DoNothing\n+        }\n+    })\n+}\n+\n+/// Do rescheduling by acting on the scheduling decision (`ReschedAction`) made by a\n+/// user-given closure.\n+///\n+/// The closure makes the scheduling decision by taking the local runqueue has its input.\n+fn reschedule<F>(f: &mut F)\n+where\n+    F: FnMut(&mut dyn LocalRunQueue) -> ReschedAction,\n+{\n+    let next_task = loop {\n+        let mut action = ReschedAction::DoNothing;\n+        SCHEDULER.get().unwrap().local_mut_rq_with(&mut |rq| {\n+            action = f(rq);\n+        });\n+\n+        match action {\n+            ReschedAction::DoNothing => {\n+                return;\n+            }\n+            ReschedAction::Retry => {\n+                continue;\n+            }\n+            ReschedAction::SwitchTo(next_task) => {\n+                break next_task;\n+            }\n+        };\n+    };\n+\n+    cpu_local::clear_need_preempt();\n+    processor::switch_to_task(next_task);\n+}\n+\n+/// Possible actions of a rescheduling.\n+enum ReschedAction {\n+    /// Keep running current task and do nothing.\n+    DoNothing,\n+    /// Loop until finding a task to swap out the current.\n+    Retry,\n+    /// Switch to target task.\n+    SwitchTo(Arc<Task>),\n+}\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -4,22 +4,23 @@\n // So we temporary allow missing_docs for this module.\n #![allow(missing_docs)]\n \n-use alloc::{boxed::Box, sync::Arc};\n-use core::{any::Any, cell::UnsafeCell};\n+mod priority;\n+\n+use core::{\n+    any::Any,\n+    cell::UnsafeCell,\n+    sync::atomic::{AtomicU32, Ordering},\n+};\n \n use intrusive_collections::{intrusive_adapter, LinkedListAtomicLink};\n+pub use priority::Priority;\n \n-use super::{\n-    add_task,\n-    priority::Priority,\n-    processor::{current_task, schedule},\n-};\n+use super::{processor::current_task, scheduler};\n pub(crate) use crate::arch::task::{context_switch, TaskContext};\n use crate::{\n     cpu::CpuSet,\n     mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, Paddr, PageFlags, Segment, PAGE_SIZE},\n     prelude::*,\n-    sync::{SpinLock, SpinLockGuard},\n     user::UserSpace,\n };\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -103,6 +104,41 @@ impl Drop for KernelStack {\n     }\n }\n \n+/// An atomic CPUID container.\n+pub struct AtomicCpuId(AtomicU32);\n+\n+impl AtomicCpuId {\n+    /// The null value of CPUID.\n+    ///\n+    /// An `AtomicCpuId` with `AtomicCpuId::NONE` as its inner value is empty.\n+    const NONE: u32 = u32::MAX;\n+\n+    fn new(cpu_id: u32) -> Self {\n+        Self(AtomicU32::new(cpu_id))\n+    }\n+\n+    /// Sets the inner value of an `AtomicCpuId` if it's empty.\n+    ///\n+    /// The return value is a result indicating whether the new value was written\n+    /// and containing the previous value.\n+    pub fn set_if_is_none(&self, cpu_id: u32) -> core::result::Result<u32, u32> {\n+        self.0\n+            .compare_exchange(Self::NONE, cpu_id, Ordering::Relaxed, Ordering::Relaxed)\n+    }\n+\n+    /// Sets the inner value of an `AtomicCpuId` to `AtomicCpuId::NONE`, i.e. makes\n+    /// an `AtomicCpuId` empty.\n+    pub fn set_to_none(&self) {\n+        self.0.store(Self::NONE, Ordering::Relaxed);\n+    }\n+}\n+\n+impl Default for AtomicCpuId {\n+    fn default() -> Self {\n+        Self::new(Self::NONE)\n+    }\n+}\n+\n /// A task that executes a function to the end.\n ///\n /// Each task is associated with per-task data and an optional user space.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -112,11 +148,11 @@ pub struct Task {\n     func: Box<dyn Fn() + Send + Sync>,\n     data: Box<dyn Any + Send + Sync>,\n     user_space: Option<Arc<UserSpace>>,\n-    task_inner: SpinLock<TaskInner>,\n     ctx: UnsafeCell<TaskContext>,\n     /// kernel stack, note that the top is SyscallFrame/TrapFrame\n     kstack: KernelStack,\n     link: LinkedListAtomicLink,\n+    cpu: AtomicCpuId,\n     priority: Priority,\n     // TODO: add multiprocessor support\n     #[allow(dead_code)]\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -130,11 +166,6 @@ intrusive_adapter!(pub TaskAdapter = Arc<Task>: Task { link: LinkedListAtomicLin\n // we have exclusive access to the field.\n unsafe impl Sync for Task {}\n \n-#[derive(Debug)]\n-pub(crate) struct TaskInner {\n-    pub task_status: TaskStatus,\n-}\n-\n impl Task {\n     /// Gets the current task.\n     ///\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -143,11 +174,6 @@ impl Task {\n         current_task()\n     }\n \n-    /// Gets inner\n-    pub(crate) fn inner_exclusive_access(&self) -> SpinLockGuard<TaskInner> {\n-        self.task_inner.lock_irq_disabled()\n-    }\n-\n     pub(super) fn ctx(&self) -> &UnsafeCell<TaskContext> {\n         &self.ctx\n     }\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -157,18 +183,14 @@ impl Task {\n     /// Note that this method cannot be simply named \"yield\" as the name is\n     /// a Rust keyword.\n     pub fn yield_now() {\n-        schedule();\n+        scheduler::yield_now()\n     }\n \n     /// Runs the task.\n+    ///\n+    /// BUG: This method highly depends on the current scheduling policy.\n     pub fn run(self: &Arc<Self>) {\n-        add_task(self.clone());\n-        schedule();\n-    }\n-\n-    /// Returns the task status.\n-    pub fn status(&self) -> TaskStatus {\n-        self.task_inner.lock_irq_disabled().task_status\n+        scheduler::run_new_task(self.clone());\n     }\n \n     /// Returns the task data.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -185,6 +207,16 @@ impl Task {\n         }\n     }\n \n+    // Returns the cpu of this task.\n+    pub fn cpu(&self) -> &AtomicCpuId {\n+        &self.cpu\n+    }\n+\n+    /// Returns the priority.\n+    pub fn priority(&self) -> Priority {\n+        self.priority\n+    }\n+\n     /// Exits the current task.\n     ///\n     /// The task `self` must be the task that is currently running.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -192,13 +224,10 @@ impl Task {\n     /// **NOTE:** If there is anything left on the stack, it will be forgotten. This behavior may\n     /// lead to resource leakage.\n     fn exit(self: Arc<Self>) -> ! {\n-        self.inner_exclusive_access().task_status = TaskStatus::Exited;\n-\n         // `current_task()` still holds a strong reference, so nothing is destroyed at this point,\n         // neither is the kernel stack.\n         drop(self);\n-\n-        schedule();\n+        scheduler::exit_current();\n         unreachable!()\n     }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -208,19 +237,6 @@ impl Task {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-/// The status of a task.\n-pub enum TaskStatus {\n-    /// The task is runnable.\n-    Runnable,\n-    /// The task is running in the foreground but will sleep when it goes to the background.\n-    Sleepy,\n-    /// The task is sleeping in the background.\n-    Sleeping,\n-    /// The task has exited.\n-    Exited,\n-}\n-\n /// Options to create or spawn a new task.\n pub struct TaskOptions {\n     func: Option<Box<dyn Fn() + Send + Sync>>,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -236,13 +252,12 @@ impl TaskOptions {\n     where\n         F: Fn() + Send + Sync + 'static,\n     {\n-        let cpu_affinity = CpuSet::new_full();\n         Self {\n             func: Some(Box::new(func)),\n             data: None,\n             user_space: None,\n             priority: Priority::normal(),\n-            cpu_affinity,\n+            cpu_affinity: CpuSet::new_full(),\n         }\n     }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -300,11 +315,9 @@ impl TaskOptions {\n             func: self.func.unwrap(),\n             data: self.data.unwrap(),\n             user_space: self.user_space,\n-            task_inner: SpinLock::new(TaskInner {\n-                task_status: TaskStatus::Runnable,\n-            }),\n             ctx: UnsafeCell::new(TaskContext::default()),\n             kstack: KernelStack::new_with_guard_page()?,\n+            cpu: AtomicCpuId::default(),\n             link: LinkedListAtomicLink::new(),\n             priority: self.priority,\n             cpu_affinity: self.cpu_affinity,\ndiff --git a/ostd/src/task/priority.rs b/ostd/src/task/task/priority.rs\n--- a/ostd/src/task/priority.rs\n+++ b/ostd/src/task/task/priority.rs\n@@ -7,7 +7,7 @@ pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n /// Similar to Linux, a larger value represents a lower priority,\n /// with a range of 0 to 139. Priorities ranging from 0 to 99 are considered real-time,\n /// while those ranging from 100 to 139 are considered normal.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd)]\n pub struct Priority(u16);\n \n impl Priority {\n",
        "test_patch": "diff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -137,10 +137,6 @@ pub fn call_ostd_main() -> ! {\n             static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n             static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n         }\n-        // Set the global scheduler a FIFO scheduler.\n-        let simple_scheduler = Box::new(FifoScheduler::new());\n-        let static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\n-        set_scheduler(static_scheduler);\n \n         let test_task = move || {\n             run_ktests(KTEST_TEST_WHITELIST, KTEST_CRATE_WHITELIST);\n",
        "problem_statement": "RFC: The new scheduling API of Asterinas Framework\n## Introduction\r\n\r\nThis RFC proposes a new set of API for the scheduling subsystem of Asterinas Framework. The new API aims at enabling the Framework users to implement advanced scheduler algorithms such as Linux's CFS and support multiple schedulers such as Linux's scheduling classes.\r\n\r\n## Background\r\n\r\nWhile Asterinas Framework grows out of Asterinas, it is intended to serve as a general OS development framework that may be used to build OS kernels with different characteristics, including different scheduling policies and algorithms.\r\n\r\nThe current scheduler API is summarized below.\r\n\r\n```rust\r\n/// Set the global task scheduler.\r\n///\r\n/// This must be called before invoking `Task::spawn`.\r\npub fn set_scheduler(scheduler: &'static dyn Scheduler) {\r\n    GLOBAL_SCHEDULER.lock_irq_disabled().scheduler = Some(scheduler);\r\n}\r\n\r\n/// A scheduler for tasks.\r\n///\r\n/// An implementation of scheduler can attach scheduler-related information\r\n/// with the `TypeMap` returned from `task.data()`.\r\npub trait Scheduler: Sync + Send {\r\n    /// Enqueues a task to the scheduler.\r\n    fn enqueue(&self, task: Arc<Task>);\r\n\r\n    /// Dequeues a task from the scheduler.\r\n    fn dequeue(&self) -> Option<Arc<Task>>;\r\n\r\n    /// Tells whether the given task should be preempted by other tasks in the queue.\r\n    fn should_preempt(&self, task: &Arc<Task>) -> bool;\r\n}\r\n```\r\n\r\nThe drawbacks of the current design are:\r\n\r\n* No API to do time accounting\r\n* No SMP support\r\n* Unable to do unit testing\r\n\r\n## Proposal\r\n\r\nWe now provide a high-level overview of the new API and its usage.\r\n\r\n### Initialization\r\n\r\nUpon initialization, the kernel (e.g., `aster-nix`) injects a task scheduler into the Framework (i.e., `aster-frame`).\r\n\r\n```rust\r\n/// Injects a task scheduler into the Framework.\r\n///\r\n/// # Panics\r\n///\r\n/// This function can only be called once and \r\n/// should only be done at the initialization state of the kernel.\r\npub fn inject_scheduler(scheduler: &'static dyn Scheduler) { ... }\r\n\r\n/// Abstracts a task scheduler.\r\npub trait Scheduler<T = Task> {\r\n    /// Enqueue a runnable task.\r\n    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<QueueReceipt>;\r\n\r\n    /// Get an immutable access to the local runqueue of the current CPU core.\r\n    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>));\r\n\r\n    /// Get a mutable access to the local runqueue of the current CPU core.\r\n    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>));\r\n\r\n    /// Get the runqueue of a particular CPU core.\r\n    fn rq(&self, cpu: CpuId) -> &Arc<dyn RunQueue>;\r\n}\r\n```\r\n\r\nThis abstract scheduler maintains a local runqueue represented by `RunQueue` and `LocalRunqueue` for each CPU core.\r\n\r\n```rust\r\n/// The _remote_ view of a per-CPU runqueue.\r\n///\r\n/// This remote view provides the interface for the runqueue of a CPU core\r\n/// to be inspected by the code running on an another CPU core.\r\npub trait RunQueue: Sync + Send {\r\n    /// Returns whether there are any runnable tasks managed by the scheduler.\r\n    fn is_empty(&self) -> bool;\r\n\r\n    /// Returns whether the number of runnable tasks managed by the scheduler.\r\n    fn len(&self) -> usize;\r\n}\r\n\r\n/// The _local_ view of a per-CPU runqueue.\r\n///\r\n/// This local view provides the interface for the runqueue of a CPU core\r\n/// to be inspected and manipulated by the code running on this particular CPU core.\r\n///\r\n/// Conceptually, a local runqueue consists of two parts:\r\n/// (1) a priority queue of runnable tasks;\r\n/// (2) the current running task.\r\n/// The exact definition of \"priority\" is left for the concrete implementation to decide.\r\npub trait LocalRunQueue<T = Task>: RunQueue {\r\n    /// Update the current runnable task's time statistics and \r\n    /// potentially its position in the queue.\r\n    fn update_current(&mut self, flags: UpdateFlags) -> bool;\r\n\r\n    /// Dequeue the current runnable task.\r\n    ///\r\n    /// The current task should be dequeued if it needs to go to sleep or has exited.\r\n    fn dequeue_current(&mut self) -> Option<Arc<T>>;\r\n\r\n    /// Pick the next current runnable task, returning the new currenet.\r\n    ///\r\n    /// If there is no runnable task, the method returns `None`.\r\n    fn pick_next_current(&mut self) -> Option<&Arc<T>>;\r\n\r\n    /// Gets the current task.\r\n    ///\r\n    /// The current task is the head of the queue.\r\n    /// If the queue is empty, the method returns `None`.\r\n    fn current(&self) -> Option<&Arc<T>>;\r\n}\r\n```\r\n\r\n### Task spawning\r\n\r\nAfter creating a new task or waking up a sleeping task, calls `Scheduler::enqueue` to put this new runnable task into the scheduler. This `enqueue` method selects a suitable CPU core properly (e.g., by taking into account CPU affinity and load balanacing) and enqueues the new runnable task into the local runqueue of the target CPU core.\r\n\r\n```rust\r\nimpl TaskOptions {\r\n    pub fn spawn(self) -> Result<Arc<Task>> {\r\n        let task = self.build()?;\r\n        task.run();\r\n        Ok(task)\r\n    }\r\n}\r\n\r\nimpl Task {\r\n    pub fn run(self: &Arc<Self>) {\r\n        sched::spawn_task(self);\r\n    }\r\n}\r\n```\r\n\r\nThe `sched::spawn_task` function calls the `enqueue` method of the injected scheduler singleton.\r\n\r\n```rust\r\npub(crate) fn spawn_task(task: &Arc<Task>) {\r\n    let should_reschedule = SCHEDULER.enqueue(task, EnqueueFlags::Spawn);\r\n    if !should_reschedule {\r\n        return;\r\n    }\r\n\r\n    reschedule(|local_rq| {\r\n        let Some(next_current) = local_rq.pick_next_current() else {\r\n            return ReschedAction::DoNothing;\r\n        };\r\n\r\n        ReschedAction::SwitchTo(next_current.clone())\r\n    });\r\n}\r\n```\r\n\r\nThe `sched::reschedule` function do the rescheduling according to the rescheduling action returned by the given closure. \r\n\r\n```rust\r\npub(crate) ReschedAction {\r\n    DoNothing,\r\n    Retry,\r\n    SwitchTo(Arc<Task>),\r\n}\r\n\r\npub(crate) fn reschedule<F>(f: F) \r\n    F: Fn(&mut dyn LocalRunQueue) -> ReschedAction\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n### Yielding\r\n\r\n```rust\r\nimpl Task {\r\n    pub fn yield_now() {\r\n        sched::reschedule(|local_rq| {\r\n            let should_pick_next = local_rq.update_current(UpdateFlags::YIELD);\r\n            if !should_pick_next {\r\n                return ReschedAction::DoNothing;\r\n            }\r\n\r\n            let Some(next_current) = local_rq.pick_next_current() else {\r\n                return ReschedAction::DoNothing;\r\n            };\r\n\r\n            ReschedAction::SwitchTo(next_current.clone())\r\n        });\r\n    }\r\n}\r\n````\r\n\r\n### Sleeping\r\n\r\n```rust\r\nimpl Waker {\r\n    fn do_wait(&self) {\r\n        while !self.has_woken.load(Ordering::Acquire) {\r\n            let mut task = self.task.inner_exclusive_access();\r\n            // After holding the lock, check again to avoid races\r\n            if self.has_woken.load(Ordering::Acquire) {\r\n                break;\r\n            }\r\n            task.task_status = TaskStatus::Sleepy;\r\n            drop(task);\r\n\r\n            sched::reschedule(|local_rq| {\r\n                let should_pick_next = local_rq.update_current(UpdateFlags::WAIT);\r\n                local_rq.dequeue_current();\r\n\r\n                let Some(next_current) = local_rq.pick_next_current() else {\r\n                    return ReschedAction::Retry;\r\n                };\r\n\r\n                ReschedAction::SwitchTo(next_current.clone())\r\n            });\r\n        }\r\n\r\n        self.has_woken.store(false, Ordering::Release);\r\n    }\r\n}\r\n```\r\n\r\n### Preemption\r\n\r\nPeriodically (e.g., on system timer interrupts), a CPU to get its local runqueue using `Scheduler::local_mut_rq_with` to do time accounting for the current task.\r\n\r\n```rust\r\nfn do_timer_interrupt(...) {\r\n    SCHEDULER.local_rq_with(|local_rq| {\r\n        let should_preempt = local_rq.update_current(SchedEvent::Tick);\r\n        if should_preempt {\r\n            local_rq.current().set_should_preempt(true);    \r\n        }\r\n    });\r\n}\r\n```\r\n\r\nOn the next most convenient timing, the current task can be preempted by doing this.\r\n\r\n```rust\r\nfn might_preempt(current: &Arc<Task>) {\r\n    if !current.should_preempt() {\r\n        return;\r\n    }\r\n\r\n    current.set_should_preempt(false);\r\n\r\n    sched::reschedule(|local_rq| {\r\n        let Some(next_current) = local_rq.pick_next_current() else {\r\n            return ReschedAction::DoNothing;\r\n        };\r\n\r\n        Resched::SwitchTo(next_current.clone())\r\n    });\r\n}\r\n```\r\n\r\n## Detailed Design\r\n\r\nMore details need to be worked out, but I don't have the time to do so...\r\n\r\n\n",
        "hints_text": "From my point of view, I suggest removing the `RunQueue` trait and the `fn rq(&self, cpu: CpuId) -> &Arc<dyn RunQueue>` method _if_ we cannot figure out any real use cases for them in the Asterinas framework.\r\n\r\nWe can easily add them in the future if we find them useful in some way, but at least for the use cases listed in this RFC, they are not useful.\r\n\r\nThe local and remote views of run queues make sense to me, but they do not outweigh the fact that we should not add code or APIs whose usefulness cannot be justified.",
        "created_at": "2024-06-28T06:42:22Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 954,
        "instance_id": "asterinas__asterinas-954",
        "issue_numbers": [
            "871"
        ],
        "base_commit": "cd2b305fa890bca9c4374ccd83c9ccb24bf8dda3",
        "patch": "diff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -158,7 +158,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n     cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // FIXME: Uses a fixed tag instaed of relies on remote branch\n+    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n+    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\n",
        "test_patch": "diff --git a/docs/src/ostd/a-100-line-kernel.md b/docs/src/ostd/a-100-line-kernel.md\n--- a/docs/src/ostd/a-100-line-kernel.md\n+++ b/docs/src/ostd/a-100-line-kernel.md\n@@ -7,23 +7,7 @@ we will show a new kernel in about 100 lines of safe Rust.\n Our new kernel will be able to run the following Hello World program.\n \n ```s\n-.global _start                      # entry point\n-.section .text                      # code section\n-_start:\n-    mov     $1, %rax                # syscall number of write\n-    mov     $1, %rdi                # stdout\n-    mov     $message, %rsi          # address of message         \n-    mov     $message_end, %rdx\n-    sub     %rsi, %rdx              # calculate message len\n-    syscall\n-    mov     $60, %rax               # syscall number of exit, move it to rax\n-    mov     $0, %rdi                # exit code, move it to rdi\n-    syscall  \n-\n-.section .rodata                    # read only data section\n-message:\n-    .ascii  \"Hello, world\\n\"\n-message_end:\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S}}\n ```\n \n The assembly program above can be compiled with the following command.\ndiff --git a/docs/src/ostd/a-100-line-kernel.md b/docs/src/ostd/a-100-line-kernel.md\n--- a/docs/src/ostd/a-100-line-kernel.md\n+++ b/docs/src/ostd/a-100-line-kernel.md\n@@ -42,131 +26,5 @@ Comments are added\n to highlight how the APIs of Asterinas OSTD enable safe kernel development.\n \n ```rust\n-#![no_std]\n-\n-extern crate alloc;\n-\n-use align_ext::AlignExt;\n-use core::str;\n-\n-use alloc::sync::Arc;\n-use alloc::vec;\n-\n-use ostd::cpu::UserContext;\n-use ostd::prelude::*;\n-use ostd::task::{Task, TaskOptions};\n-use ostd::user::{ReturnReason, UserMode, UserSpace};\n-use ostd::mm::{PageFlags, PAGE_SIZE, Vaddr, FrameAllocOptions, VmIo, VmMapOptions, VmSpace};\n-\n-/// The kernel's boot and initialization process is managed by Asterinas OSTD.\n-/// After the process is done, the kernel's execution environment\n-/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n-/// labeled as `#[ostd::main]` will be called.\n-#[ostd::main]\n-pub fn main() {\n-    let program_binary = include_bytes!(\"../hello_world\");\n-    let user_space = create_user_space(program_binary);\n-    let user_task = create_user_task(Arc::new(user_space));\n-    user_task.run();\n-}\n-\n-fn create_user_space(program: &[u8]) -> UserSpace {\n-    let user_pages = {\n-        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n-        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n-        // Phyiscal memory pages can be only accessed\n-        // via the Frame abstraction.\n-        vm_frames.write_bytes(0, program).unwrap();\n-        vm_frames\n-    };\n-    let user_address_space = {\n-        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n-\n-        // The page table of the user space can be\n-        // created and manipulated safely through\n-        // the VmSpace abstraction.\n-        let vm_space = VmSpace::new();\n-        let mut options = VmMapOptions::new();\n-        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n-        vm_space.map(user_pages, &options).unwrap();\n-        vm_space\n-    };\n-    let user_cpu_state = {\n-        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n-\n-        // The user-space CPU states can be initialized\n-        // to arbitrary values via the UserContext\n-        // abstraction.\n-        let mut user_cpu_state = UserContext::default();\n-        user_cpu_state.set_rip(ENTRY_POINT);\n-        user_cpu_state\n-    };\n-    UserSpace::new(user_address_space, user_cpu_state)\n-}\n-\n-fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n-    fn user_task() {\n-        let current = Task::current();\n-        // Switching between user-kernel space is\n-        // performed via the UserMode abstraction.\n-        let mut user_mode = {\n-            let user_space = current.user_space().unwrap();\n-            UserMode::new(user_space)\n-        };\n-\n-        loop {\n-            // The execute method returns when system\n-            // calls or CPU exceptions occur or some\n-            // events specified by the kernel occur.\n-            let return_reason = user_mode.execute(|| false);\n-\n-            // The CPU registers of the user space\n-            // can be accessed and manipulated via\n-            // the `UserContext` abstraction.\n-            let user_context = user_mode.context_mut();\n-            if ReturnReason::UserSyscall == return_reason {\n-                handle_syscall(user_context, current.user_space().unwrap());\n-            }\n-        }\n-    }\n-\n-    // Kernel tasks are managed by OSTD,\n-    // while scheduling algorithms for them can be\n-    // determined by the users of OSTD.\n-    TaskOptions::new(user_task)\n-        .user_space(Some(user_space))\n-        .data(0)\n-        .build()\n-        .unwrap()\n-}\n-\n-fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n-    const SYS_WRITE: usize = 1;\n-    const SYS_EXIT: usize = 60;\n-\n-    match user_context.rax() {\n-        SYS_WRITE => {\n-            // Access the user-space CPU registers safely.\n-            let (_, buf_addr, buf_len) =\n-                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n-            let buf = {\n-                let mut buf = vec![0u8; buf_len];\n-                // Copy data from the user space without\n-                // unsafe pointer dereferencing.\n-                user_space\n-                    .vm_space()\n-                    .read_bytes(buf_addr, &mut buf)\n-                    .unwrap();\n-                buf\n-            };\n-            // Use the console for output safely.\n-            println!(\"{}\", str::from_utf8(&buf).unwrap());\n-            // Manipulate the user-space CPU registers safely.\n-            user_context.set_rax(buf_len);\n-        }\n-        SYS_EXIT => Task::current().exit(),\n-        _ => unimplemented!(),\n-    }\n-}\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs}}\n ```\n-\ndiff --git a/osdk/tests/examples_in_book/mod.rs b/osdk/tests/examples_in_book/mod.rs\n--- a/osdk/tests/examples_in_book/mod.rs\n+++ b/osdk/tests/examples_in_book/mod.rs\n@@ -5,3 +5,4 @@\n mod create_os_projects;\n mod test_and_run_projects;\n mod work_in_workspace;\n+mod write_a_kernel_in_100_lines;\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -1,7 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use std::{\n-    env,\n     fs::{self, OpenOptions},\n     io::Write,\n     path::PathBuf,\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -21,7 +20,6 @@ fn work_in_workspace() {\n     }\n \n     fs::create_dir_all(&workspace_dir).unwrap();\n-    env::set_current_dir(&workspace_dir).unwrap();\n \n     let workspace_toml = include_str!(\"work_in_workspace_templates/Cargo.toml\");\n     fs::write(workspace_dir.join(\"Cargo.toml\"), workspace_toml).unwrap();\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -29,8 +27,14 @@ fn work_in_workspace() {\n     // Create a kernel project and a library project\n     let kernel = \"myos\";\n     let module = \"mylib\";\n-    cargo_osdk(&[\"new\", \"--kernel\", kernel]).ok().unwrap();\n-    cargo_osdk(&[\"new\", module]).ok().unwrap();\n+    cargo_osdk(&[\"new\", \"--kernel\", kernel])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    cargo_osdk(&[\"new\", module])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Add a test function to mylib/src/lib.rs\n     let module_src_path = workspace_dir.join(module).join(\"src\").join(\"lib.rs\");\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -75,13 +79,22 @@ fn work_in_workspace() {\n     .unwrap();\n \n     // Run subcommand build & run\n-    cargo_osdk(&[\"build\"]).ok().unwrap();\n-    let output = cargo_osdk(&[\"run\"]).output().unwrap();\n+    cargo_osdk(&[\"build\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    let output = cargo_osdk(&[\"run\"])\n+        .current_dir(&workspace_dir)\n+        .output()\n+        .unwrap();\n     let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n     assert!(stdout.contains(\"The available memory is\"));\n \n     // Run subcommand test\n-    cargo_osdk(&[\"test\"]).ok().unwrap();\n+    cargo_osdk(&[\"test\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Remove the directory\n     fs::remove_dir_all(&workspace_dir).unwrap();\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\n@@ -0,0 +1,65 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use std::{fs, path::PathBuf, process::Command};\n+\n+use assert_cmd::output::OutputOkExt;\n+\n+use crate::util::{cargo_osdk, depends_on_local_ostd};\n+\n+#[test]\n+fn write_a_kernel_in_100_lines() {\n+    let workdir = \"/tmp\";\n+    let os_name = \"kernel_in_100_lines\";\n+\n+    let os_dir = PathBuf::from(workdir).join(os_name);\n+\n+    if os_dir.exists() {\n+        fs::remove_dir_all(&os_dir).unwrap()\n+    }\n+\n+    // Creates a new kernel project\n+    cargo_osdk(&[\"new\", \"--kernel\", os_name])\n+        .current_dir(&workdir)\n+        .ok()\n+        .unwrap();\n+\n+    // Depends on local OSTD\n+    let manifest_path = os_dir.join(\"Cargo.toml\");\n+    depends_on_local_ostd(manifest_path);\n+\n+    // Copies the kernel content\n+    let kernel_contents = include_str!(\"write_a_kernel_in_100_lines_templates/lib.rs\");\n+    fs::write(os_dir.join(\"src\").join(\"lib.rs\"), kernel_contents).unwrap();\n+\n+    // Copies and compiles the user program\n+    let user_program_contents = include_str!(\"write_a_kernel_in_100_lines_templates/hello.S\");\n+    fs::write(os_dir.join(\"hello.S\"), user_program_contents).unwrap();\n+    Command::new(\"gcc\")\n+        .args(&[\"-static\", \"-nostdlib\", \"hello.S\", \"-o\", \"hello\"])\n+        .current_dir(&os_dir)\n+        .ok()\n+        .unwrap();\n+\n+    // Adds align ext as the dependency\n+    let file_contents = fs::read_to_string(os_dir.join(\"Cargo.toml\")).unwrap();\n+    let mut manifest: toml::Table = toml::from_str(&file_contents).unwrap();\n+    let dependencies = manifest\n+        .get_mut(\"dependencies\")\n+        .unwrap()\n+        .as_table_mut()\n+        .unwrap();\n+    dependencies.insert(\n+        \"align_ext\".to_string(),\n+        toml::Value::String(\"0.1.0\".to_string()),\n+    );\n+\n+    let new_file_content = manifest.to_string();\n+    fs::write(os_dir.join(\"Cargo.toml\"), new_file_content).unwrap();\n+\n+    // Runs the kernel\n+    let output = cargo_osdk(&[\"run\"]).current_dir(&os_dir).ok().unwrap();\n+    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+    println!(\"stdout = {}\", stdout);\n+\n+    fs::remove_dir_all(&os_dir).unwrap();\n+}\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\n@@ -0,0 +1,19 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n+.global _start                      # entry point\n+.section .text                      # code section\n+_start:\n+    mov     $1, %rax                # syscall number of write\n+    mov     $1, %rdi                # stdout\n+    mov     $message, %rsi          # address of message         \n+    mov     $message_end, %rdx\n+    sub     %rsi, %rdx              # calculate message len\n+    syscall\n+    mov     $60, %rax               # syscall number of exit, move it to rax\n+    mov     $0, %rdi                # exit code, move it to rdi\n+    syscall  \n+\n+.section .rodata                    # read only data section\n+message:\n+    .ascii  \"Hello, world\\n\"\n+message_end:\n\\ No newline at end of file\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -0,0 +1,132 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#![no_std]\n+\n+extern crate alloc;\n+\n+use align_ext::AlignExt;\n+use core::str;\n+\n+use alloc::sync::Arc;\n+use alloc::vec;\n+\n+use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n+use ostd::cpu::UserContext;\n+use ostd::mm::{\n+    FrameAllocOptions, PageFlags, Vaddr, VmIo, VmMapOptions, VmSpace, VmWriter, PAGE_SIZE,\n+};\n+use ostd::prelude::*;\n+use ostd::task::{Task, TaskOptions};\n+use ostd::user::{ReturnReason, UserMode, UserSpace};\n+\n+/// The kernel's boot and initialization process is managed by OSTD.\n+/// After the process is done, the kernel's execution environment\n+/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n+/// labeled as `#[ostd::main]` will be called.\n+#[ostd::main]\n+pub fn main() {\n+    let program_binary = include_bytes!(\"../hello\");\n+    let user_space = create_user_space(program_binary);\n+    let user_task = create_user_task(Arc::new(user_space));\n+    user_task.run();\n+}\n+\n+fn create_user_space(program: &[u8]) -> UserSpace {\n+    let user_pages = {\n+        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n+        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n+        // Phyiscal memory pages can be only accessed\n+        // via the Frame abstraction.\n+        vm_frames.write_bytes(0, program).unwrap();\n+        vm_frames\n+    };\n+    let user_address_space = {\n+        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n+\n+        // The page table of the user space can be\n+        // created and manipulated safely through\n+        // the VmSpace abstraction.\n+        let vm_space = VmSpace::new();\n+        let mut options = VmMapOptions::new();\n+        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n+        vm_space.map(user_pages, &options).unwrap();\n+        Arc::new(vm_space)\n+    };\n+    let user_cpu_state = {\n+        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n+\n+        // The user-space CPU states can be initialized\n+        // to arbitrary values via the UserContext\n+        // abstraction.\n+        let mut user_cpu_state = UserContext::default();\n+        user_cpu_state.set_rip(ENTRY_POINT);\n+        user_cpu_state\n+    };\n+    UserSpace::new(user_address_space, user_cpu_state)\n+}\n+\n+fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n+    fn user_task() {\n+        let current = Task::current();\n+        // Switching between user-kernel space is\n+        // performed via the UserMode abstraction.\n+        let mut user_mode = {\n+            let user_space = current.user_space().unwrap();\n+            UserMode::new(user_space)\n+        };\n+\n+        loop {\n+            // The execute method returns when system\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n+            // The CPU registers of the user space\n+            // can be accessed and manipulated via\n+            // the `UserContext` abstraction.\n+            let user_context = user_mode.context_mut();\n+            if ReturnReason::UserSyscall == return_reason {\n+                handle_syscall(user_context, current.user_space().unwrap());\n+            }\n+        }\n+    }\n+\n+    // Kernel tasks are managed by the Framework,\n+    // while scheduling algorithms for them can be\n+    // determined by the users of the Framework.\n+    TaskOptions::new(user_task)\n+        .user_space(Some(user_space))\n+        .data(0)\n+        .build()\n+        .unwrap()\n+}\n+\n+fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n+    const SYS_WRITE: usize = 1;\n+    const SYS_EXIT: usize = 60;\n+\n+    match user_context.rax() {\n+        SYS_WRITE => {\n+            // Access the user-space CPU registers safely.\n+            let (_, buf_addr, buf_len) =\n+                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n+            let buf = {\n+                let mut buf = vec![0u8; buf_len];\n+                // Copy data from the user space without\n+                // unsafe pointer dereferencing.\n+                let current_vm_space = user_space.vm_space();\n+                let mut reader = current_vm_space.reader(buf_addr, buf_len).unwrap();\n+                reader\n+                    .read_fallible(&mut VmWriter::from(&mut buf as &mut [u8]))\n+                    .unwrap();\n+                buf\n+            };\n+            // Use the console for output safely.\n+            println!(\"{}\", str::from_utf8(&buf).unwrap());\n+            // Manipulate the user-space CPU registers safely.\n+            user_context.set_rax(buf_len);\n+        }\n+        SYS_EXIT => exit_qemu(QemuExitCode::Success),\n+        _ => unimplemented!(),\n+    }\n+}\n",
        "problem_statement": "\"[ERROR]: Uncaught panic!\" when running the 100-line kernel example in the asterinas book.\nWhen running the 100-line kernel example in the asterinas book [https://asterinas.github.io/book/framework/a-100-line-kernel.html ](url), the following error is reported:\r\n```\r\nDrive current: -outdev 'stdio:/root/workspace/asterinas/target/osdk/myos-osdk-bin.iso'\r\nMedia current: stdio file, overwriteable\r\nMedia status : is blank\r\nMedia summary: 0 sessions, 0 data blocks, 0 data,  931g free\r\nAdded to ISO image: directory '/'='/tmp/grub.CQmOUp'\r\nxorriso : UPDATE :     341 files added in 1 seconds\r\nAdded to ISO image: directory '/'='/root/workspace/asterinas/target/osdk/iso_root'\r\nxorriso : UPDATE :     346 files added in 1 seconds\r\nxorriso : UPDATE :  0.00% done\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/scheduler.rs:44:24:\r\ncalled `Option::unwrap()` on a `None` value\r\nprinting stack trace:\r\n   1: fn 0xffffffff8809f660 - pc 0xffffffff8809f678 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047820;\r\n\r\n   2: fn 0xffffffff8809f160 - pc 0xffffffff8809f617 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047830;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a80;\r\n\r\n   4: fn 0xffffffff8818f4a0 - pc 0xffffffff8818f4ef / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a90;\r\n\r\n   5: fn 0xffffffff8818f5d0 - pc 0xffffffff8818f615 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047ae0;\r\n\r\n   6: fn 0xffffffff88124fd0 - pc 0xffffffff88125011 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b50;\r\n\r\n   7: fn 0xffffffff8806efa0 - pc 0xffffffff8806efce / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b80;\r\n\r\n   8: fn 0xffffffff8806f0c0 - pc 0xffffffff8806f16e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047bc0;\r\n\r\n   9: fn 0xffffffff8806e450 - pc 0xffffffff8806e462 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c20;\r\n\r\n  10: fn 0xffffffff880489e0 - pc 0xffffffff88048a30 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c30;\r\n\r\n  11: fn 0xffffffff880489d0 - pc 0xffffffff880489db / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f50;\r\n\r\n  12: fn 0xffffffff880a3b00 - pc 0xffffffff880a3b06 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f60;\r\n\r\n  13: fn 0xffffffff8810d3b0 - pc 0xffffffff8810d477 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f70;\r\n\r\n  14: fn                0x0 - pc 0xffffffff880ad052 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88048000;\r\n```\n",
        "hints_text": "It seems that the scheduler is not set. And the guide does not mention that.\r\n\r\n```rust\r\nuse aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\nlet simple_scheduler = Box::new(FifoScheduler::new());\r\nlet static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\nset_scheduler(static_scheduler);\r\n```\r\n\r\nCould you please check if this works? If so you can help us improve the guide!\nThanks. After adding your code into the example, the program runs successfully and outputs \"Hello, world\". However, the below error message follows. Is this normal? \r\n```\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\nHello, world\r\n\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/task.rs:191:9:\r\ninternal error: entered unreachable code\r\nprinting stack trace:\r\n   1: fn 0xffffffff880a1840 - pc 0xffffffff880a1858 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06d0;\r\n\r\n   2: fn 0xffffffff880a1340 - pc 0xffffffff880a17f7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06e0;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0930;\r\n\r\n   4: fn 0xffffffff88191e30 - pc 0xffffffff88191e7f / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0940;\r\n\r\n   5: fn 0xffffffff88191f60 - pc 0xffffffff88191fa5 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0990;\r\n\r\n   6: fn 0xffffffff8806ee80 - pc 0xffffffff8806eef9 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a00;\r\n\r\n   7: fn 0xffffffff88048660 - pc 0xffffffff880489c7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a40;\r\n\r\n   8: fn 0xffffffff880484d0 - pc 0xffffffff8804863c / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0c10;\r\n\r\n   9: fn 0xffffffff88049e60 - pc 0xffffffff88049e6e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0f90;\r\n\r\n  10: fn 0xffffffff880bae20 - pc 0xffffffff880bae36 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fb0;\r\n\r\n  11: fn 0xffffffff8806f710 - pc 0xffffffff8806f774 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fd0;\r\n```\nYes it is normal and the scheduler expect that the main task of the kernel will never return.\r\n\r\nSo a well formed hello world kernel may shut the system down after printing.\r\n\r\nHowever we do not have ACPI shutdown at this moment. Here is a debug fix.\r\n\r\n```rust\r\n#[aster_main]\r\npub fn main() {\r\n    let program_binary = include_bytes!(\"../hello_world\");\r\n    let user_space = create_user_space(program_binary);\r\n    let user_task = create_user_task(Arc::new(user_space));\r\n    user_task.run();\r\n    use aster_frame::arch::qemu::{exit_qemu, QemuExitCode};\r\n    exit_qemu(QemuExitCode::Success);\r\n}\r\n```\r\n\r\n\nOk! Thanks again.\n> It seems that the scheduler is not set. And the guide does not mention that.\r\n> \r\n> ```rust\r\n> use aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\n> let simple_scheduler = Box::new(FifoScheduler::new());\r\n> let static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\n> set_scheduler(static_scheduler);\r\n> ```\r\n> \r\n> Could you please check if this works? If so you can help us improve the guide!\r\n\r\n#748 introduces such a scheduler initialization for `ktest`. Maybe it will be better to set the scheduler in `aster_frame::init()` and it will work for both.",
        "created_at": "2024-06-20T08:52:42Z",
        "version": "0.5"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1750,
        "instance_id": "asterinas__asterinas-1750",
        "issue_numbers": [
            "1561"
        ],
        "base_commit": "cbf7a8545189ce1032049eee4a5e06c0918dccab",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -71,10 +71,11 @@ name = \"aster-bigtcp\"\n version = \"0.1.0\"\n dependencies = [\n  \"bitflags 1.3.2\",\n- \"keyable-arc\",\n+ \"jhash\",\n  \"ostd\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\n+ \"static_assertions\",\n  \"takeable\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -839,6 +840,10 @@ dependencies = [\n  \"either\",\n ]\n \n+[[package]]\n+name = \"jhash\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"json\"\n version = \"0.12.4\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -27,6 +27,7 @@ members = [\n     \"kernel/libs/aster-rights-proc\",\n     \"kernel/libs/aster-util\",\n     \"kernel/libs/aster-bigtcp\",\n+    \"kernel/libs/jhash\",\n     \"kernel/libs/keyable-arc\",\n     \"kernel/libs/typeflags\",\n     \"kernel/libs/typeflags-util\",\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -129,6 +129,7 @@ NON_OSDK_CRATES := \\\n \tkernel/libs/int-to-c-enum/derive \\\n \tkernel/libs/aster-rights \\\n \tkernel/libs/aster-rights-proc \\\n+\tkernel/libs/jhash \\\n \tkernel/libs/keyable-arc \\\n \tkernel/libs/typeflags \\\n \tkernel/libs/typeflags-util \\\ndiff --git a/kernel/libs/aster-bigtcp/Cargo.toml b/kernel/libs/aster-bigtcp/Cargo.toml\n--- a/kernel/libs/aster-bigtcp/Cargo.toml\n+++ b/kernel/libs/aster-bigtcp/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n bitflags = \"1.3\"\n-keyable-arc = { path = \"../keyable-arc\" }\n+jhash = { path = \"../jhash\" }\n ostd = { path = \"../../../ostd\" }\n smoltcp = { git = \"https://github.com/asterinas/smoltcp\", tag = \"r_2024-11-08_f07e5b5\", default-features = false, features = [\n     \"alloc\",\ndiff --git a/kernel/libs/aster-bigtcp/Cargo.toml b/kernel/libs/aster-bigtcp/Cargo.toml\n--- a/kernel/libs/aster-bigtcp/Cargo.toml\n+++ b/kernel/libs/aster-bigtcp/Cargo.toml\n@@ -19,4 +19,5 @@ smoltcp = { git = \"https://github.com/asterinas/smoltcp\", tag = \"r_2024-11-08_f0\n     \"socket-tcp\",\n ] }\n spin = \"0.9.4\"\n+static_assertions = \"1.1.0\"\n takeable = \"0.2.2\"\ndiff --git a/kernel/libs/aster-bigtcp/src/errors.rs b/kernel/libs/aster-bigtcp/src/errors.rs\n--- a/kernel/libs/aster-bigtcp/src/errors.rs\n+++ b/kernel/libs/aster-bigtcp/src/errors.rs\n@@ -10,7 +10,41 @@ pub enum BindError {\n }\n \n pub mod tcp {\n-    pub use smoltcp::socket::tcp::{ConnectError, ListenError, RecvError, SendError};\n+    pub use smoltcp::socket::tcp::{RecvError, SendError};\n+\n+    #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+    pub enum ListenError {\n+        InvalidState,\n+        Unaddressable,\n+        /// The specified address is in use.\n+        AddressInUse,\n+    }\n+\n+    impl From<smoltcp::socket::tcp::ListenError> for ListenError {\n+        fn from(value: smoltcp::socket::tcp::ListenError) -> Self {\n+            match value {\n+                smoltcp::socket::tcp::ListenError::InvalidState => Self::InvalidState,\n+                smoltcp::socket::tcp::ListenError::Unaddressable => Self::Unaddressable,\n+            }\n+        }\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+    pub enum ConnectError {\n+        InvalidState,\n+        Unaddressable,\n+        /// The specified address is in use.\n+        AddressInUse,\n+    }\n+\n+    impl From<smoltcp::socket::tcp::ConnectError> for ConnectError {\n+        fn from(value: smoltcp::socket::tcp::ConnectError) -> Self {\n+            match value {\n+                smoltcp::socket::tcp::ConnectError::InvalidState => Self::InvalidState,\n+                smoltcp::socket::tcp::ConnectError::Unaddressable => Self::Unaddressable,\n+            }\n+        }\n+    }\n }\n \n pub mod udp {\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/common.rs b/kernel/libs/aster-bigtcp/src/iface/common.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/common.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/common.rs\n@@ -1,16 +1,12 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::{\n-    collections::{\n-        btree_map::{BTreeMap, Entry},\n-        btree_set::BTreeSet,\n-    },\n+    collections::btree_map::{BTreeMap, Entry},\n     string::String,\n     sync::Arc,\n     vec::Vec,\n };\n \n-use keyable_arc::KeyableArc;\n use ostd::sync::{LocalIrqDisabled, SpinLock, SpinLockGuard};\n use smoltcp::{\n     iface::{packet::Packet, Context},\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/common.rs b/kernel/libs/aster-bigtcp/src/iface/common.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/common.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/common.rs\n@@ -27,34 +23,25 @@ use super::{\n use crate::{\n     errors::BindError,\n     ext::Ext,\n-    socket::{TcpConnectionBg, TcpListenerBg, UdpSocketBg},\n+    socket::{TcpListenerBg, UdpSocketBg},\n+    socket_table::SocketTable,\n };\n \n pub struct IfaceCommon<E: Ext> {\n     name: String,\n     interface: SpinLock<smoltcp::iface::Interface, LocalIrqDisabled>,\n     used_ports: SpinLock<BTreeMap<u16, usize>, LocalIrqDisabled>,\n-    sockets: SpinLock<SocketSet<E>, LocalIrqDisabled>,\n+    sockets: SpinLock<SocketTable<E>, LocalIrqDisabled>,\n     sched_poll: E::ScheduleNextPoll,\n }\n \n-pub(super) struct SocketSet<E: Ext> {\n-    pub(super) tcp_conn: BTreeSet<KeyableArc<TcpConnectionBg<E>>>,\n-    pub(super) tcp_listen: BTreeSet<KeyableArc<TcpListenerBg<E>>>,\n-    pub(super) udp: BTreeSet<KeyableArc<UdpSocketBg<E>>>,\n-}\n-\n impl<E: Ext> IfaceCommon<E> {\n     pub(super) fn new(\n         name: String,\n         interface: smoltcp::iface::Interface,\n         sched_poll: E::ScheduleNextPoll,\n     ) -> Self {\n-        let sockets = SocketSet {\n-            tcp_conn: BTreeSet::new(),\n-            tcp_listen: BTreeSet::new(),\n-            udp: BTreeSet::new(),\n-        };\n+        let sockets = SocketTable::new();\n \n         Self {\n             name,\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/common.rs b/kernel/libs/aster-bigtcp/src/iface/common.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/common.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/common.rs\n@@ -78,11 +65,17 @@ impl<E: Ext> IfaceCommon<E> {\n     }\n }\n \n+// Lock order: interface -> sockets\n impl<E: Ext> IfaceCommon<E> {\n     /// Acquires the lock to the interface.\n     pub(crate) fn interface(&self) -> SpinLockGuard<smoltcp::iface::Interface, LocalIrqDisabled> {\n         self.interface.lock()\n     }\n+\n+    /// Acquires the lock to the socket table.\n+    pub(crate) fn sockets(&self) -> SpinLockGuard<'_, SocketTable<E>, LocalIrqDisabled> {\n+        self.sockets.lock()\n+    }\n }\n \n const IP_LOCAL_PORT_START: u16 = 32768;\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/common.rs b/kernel/libs/aster-bigtcp/src/iface/common.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/common.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/common.rs\n@@ -152,41 +145,21 @@ impl<E: Ext> IfaceCommon<E> {\n }\n \n impl<E: Ext> IfaceCommon<E> {\n-    pub(crate) fn register_tcp_connection(&self, socket: KeyableArc<TcpConnectionBg<E>>) {\n+    pub(crate) fn register_udp_socket(&self, socket: Arc<UdpSocketBg<E>>) {\n         let mut sockets = self.sockets.lock();\n-        let inserted = sockets.tcp_conn.insert(socket);\n-        debug_assert!(inserted);\n+        sockets.insert_udp_socket(socket);\n     }\n \n-    pub(crate) fn register_tcp_listener(&self, socket: KeyableArc<TcpListenerBg<E>>) {\n+    pub(crate) fn remove_tcp_listener(&self, socket: &Arc<TcpListenerBg<E>>) {\n         let mut sockets = self.sockets.lock();\n-        let inserted = sockets.tcp_listen.insert(socket);\n-        debug_assert!(inserted);\n+        let removed = sockets.remove_listener(socket);\n+        debug_assert!(removed.is_some());\n     }\n \n-    pub(crate) fn register_udp_socket(&self, socket: KeyableArc<UdpSocketBg<E>>) {\n+    pub(crate) fn remove_udp_socket(&self, socket: &Arc<UdpSocketBg<E>>) {\n         let mut sockets = self.sockets.lock();\n-        let inserted = sockets.udp.insert(socket);\n-        debug_assert!(inserted);\n-    }\n-\n-    #[allow(clippy::mutable_key_type)]\n-    fn remove_dead_tcp_connections(sockets: &mut BTreeSet<KeyableArc<TcpConnectionBg<E>>>) {\n-        for socket in sockets.extract_if(|socket| socket.is_dead()) {\n-            TcpConnectionBg::on_dead_events(socket);\n-        }\n-    }\n-\n-    pub(crate) fn remove_tcp_listener(&self, socket: &KeyableArc<TcpListenerBg<E>>) {\n-        let mut sockets = self.sockets.lock();\n-        let removed = sockets.tcp_listen.remove(socket);\n-        debug_assert!(removed);\n-    }\n-\n-    pub(crate) fn remove_udp_socket(&self, socket: &KeyableArc<UdpSocketBg<E>>) {\n-        let mut sockets = self.sockets.lock();\n-        let removed = sockets.udp.remove(socket);\n-        debug_assert!(removed);\n+        let removed = sockets.remove_udp_socket(socket);\n+        debug_assert!(removed.is_some());\n     }\n }\n \ndiff --git a/kernel/libs/aster-bigtcp/src/iface/common.rs b/kernel/libs/aster-bigtcp/src/iface/common.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/common.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/common.rs\n@@ -224,33 +197,37 @@ impl<E: Ext> IfaceCommon<E> {\n             if new_tcp_conns.is_empty() {\n                 break;\n             } else {\n-                sockets.tcp_conn.extend(new_tcp_conns);\n+                new_tcp_conns.into_iter().for_each(|tcp_conn| {\n+                    let res = sockets.insert_connection(tcp_conn);\n+                    debug_assert!(res.is_ok());\n+                });\n             }\n         }\n \n-        Self::remove_dead_tcp_connections(&mut sockets.tcp_conn);\n+        sockets.remove_dead_tcp_connections();\n \n-        sockets.tcp_conn.iter().for_each(|socket| {\n+        for socket in sockets.tcp_listener_iter() {\n             if socket.has_events() {\n                 socket.on_events();\n             }\n-        });\n-        sockets.tcp_listen.iter().for_each(|socket| {\n+        }\n+\n+        for socket in sockets.tcp_conn_iter() {\n             if socket.has_events() {\n                 socket.on_events();\n             }\n-        });\n-        sockets.udp.iter().for_each(|socket| {\n+        }\n+\n+        for socket in sockets.udp_socket_iter() {\n             if socket.has_events() {\n                 socket.on_events();\n             }\n-        });\n+        }\n \n         // Note that only TCP connections can have timers set, so as far as the time to poll is\n         // concerned, we only need to consider TCP connections.\n         sockets\n-            .tcp_conn\n-            .iter()\n+            .tcp_conn_iter()\n             .map(|socket| socket.next_poll_at_ms())\n             .min()\n     }\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use alloc::{vec, vec::Vec};\n+use alloc::{sync::Arc, vec, vec::Vec};\n \n-use keyable_arc::KeyableArc;\n use smoltcp::{\n     iface::{\n         packet::{icmp_reply_payload_len, IpPayload, Packet},\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -16,23 +15,23 @@ use smoltcp::{\n     },\n };\n \n-use super::common::SocketSet;\n use crate::{\n     ext::Ext,\n-    socket::{TcpConnectionBg, TcpListenerBg, TcpProcessResult},\n+    socket::{TcpConnectionBg, TcpProcessResult},\n+    socket_table::{ConnectionKey, ListenerKey, SocketTable},\n };\n \n pub(super) struct PollContext<'a, E: Ext> {\n     iface_cx: &'a mut Context,\n-    sockets: &'a SocketSet<E>,\n-    new_tcp_conns: &'a mut Vec<KeyableArc<TcpConnectionBg<E>>>,\n+    sockets: &'a SocketTable<E>,\n+    new_tcp_conns: &'a mut Vec<Arc<TcpConnectionBg<E>>>,\n }\n \n impl<'a, E: Ext> PollContext<'a, E> {\n     pub(super) fn new(\n         iface_cx: &'a mut Context,\n-        sockets: &'a SocketSet<E>,\n-        new_tcp_conns: &'a mut Vec<KeyableArc<TcpConnectionBg<E>>>,\n+        sockets: &'a SocketTable<E>,\n+        new_tcp_conns: &'a mut Vec<Arc<TcpConnectionBg<E>>>,\n     ) -> Self {\n         Self {\n             iface_cx,\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -158,40 +157,18 @@ impl<E: Ext> PollContext<'_, E> {\n         ip_repr: &IpRepr,\n         tcp_repr: &TcpRepr,\n     ) -> Option<(IpRepr, TcpRepr<'static>)> {\n-        for socket in self\n-            .sockets\n-            .tcp_conn\n-            .iter()\n-            .chain(self.new_tcp_conns.iter())\n-        {\n-            if !socket.can_process(tcp_repr.dst_port) {\n-                continue;\n-            }\n-\n-            match TcpConnectionBg::process(socket, self.iface_cx, ip_repr, tcp_repr) {\n-                TcpProcessResult::NotProcessed => continue,\n-                TcpProcessResult::Processed => return None,\n-                TcpProcessResult::ProcessedWithReply(ip_repr, tcp_repr) => {\n-                    return Some((ip_repr, tcp_repr))\n-                }\n-            }\n-        }\n-\n+        // Process packets that request to create new connections first.\n         if tcp_repr.control == TcpControl::Syn && tcp_repr.ack_number.is_none() {\n-            for socket in self.sockets.tcp_listen.iter() {\n-                if !socket.can_process(tcp_repr.dst_port) {\n-                    continue;\n-                }\n-\n-                let (processed, new_tcp_conn) =\n-                    TcpListenerBg::process(socket, self.iface_cx, ip_repr, tcp_repr);\n+            let listener_key = ListenerKey::new(ip_repr.dst_addr(), tcp_repr.dst_port);\n+            if let Some(listener) = self.sockets.lookup_listener(&listener_key) {\n+                let (processed, new_tcp_conn) = listener.process(self.iface_cx, ip_repr, tcp_repr);\n \n                 if let Some(tcp_conn) = new_tcp_conn {\n                     self.new_tcp_conns.push(tcp_conn);\n                 }\n \n                 match processed {\n-                    TcpProcessResult::NotProcessed => continue,\n+                    TcpProcessResult::NotProcessed => {}\n                     TcpProcessResult::Processed => return None,\n                     TcpProcessResult::ProcessedWithReply(ip_repr, tcp_repr) => {\n                         return Some((ip_repr, tcp_repr))\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -200,6 +177,31 @@ impl<E: Ext> PollContext<'_, E> {\n             }\n         }\n \n+        // Process packets belonging to existing connections second.\n+        let connection_key = ConnectionKey::new(\n+            ip_repr.dst_addr(),\n+            tcp_repr.dst_port,\n+            ip_repr.src_addr(),\n+            tcp_repr.src_port,\n+        );\n+        let connection = if let Some(connection) = self.sockets.lookup_connection(&connection_key) {\n+            Some(connection)\n+        } else {\n+            self.new_tcp_conns\n+                .iter()\n+                .find(|tcp_conn| tcp_conn.connection_key() == &connection_key)\n+        };\n+\n+        if let Some(connection) = connection {\n+            match connection.process(self.iface_cx, ip_repr, tcp_repr) {\n+                TcpProcessResult::NotProcessed => {}\n+                TcpProcessResult::Processed => return None,\n+                TcpProcessResult::ProcessedWithReply(ip_repr, tcp_repr) => {\n+                    return Some((ip_repr, tcp_repr))\n+                }\n+            }\n+        }\n+\n         // \"In no case does receipt of a segment containing RST give rise to a RST in response.\"\n         // See <https://datatracker.ietf.org/doc/html/rfc9293#section-4-1.64>.\n         if tcp_repr.control == TcpControl::Rst {\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -239,7 +241,7 @@ impl<E: Ext> PollContext<'_, E> {\n     fn process_udp(&mut self, ip_repr: &IpRepr, udp_repr: &UdpRepr, udp_payload: &[u8]) -> bool {\n         let mut processed = false;\n \n-        for socket in self.sockets.udp.iter() {\n+        for socket in self.sockets.udp_socket_iter() {\n             if !socket.can_process(udp_repr.dst_port) {\n                 continue;\n             }\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -350,7 +352,7 @@ impl<E: Ext> PollContext<'_, E> {\n \n         // We cannot dispatch packets from `new_tcp_conns` because we cannot borrow an immutable\n         // reference at this point. Instead, we will retry after the entire poll is complete.\n-        for socket in self.sockets.tcp_conn.iter() {\n+        for socket in self.sockets.tcp_conn_iter() {\n             if !socket.need_dispatch(self.iface_cx.now()) {\n                 continue;\n             }\ndiff --git a/kernel/libs/aster-bigtcp/src/iface/poll.rs b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n--- a/kernel/libs/aster-bigtcp/src/iface/poll.rs\n+++ b/kernel/libs/aster-bigtcp/src/iface/poll.rs\n@@ -442,7 +444,7 @@ impl<E: Ext> PollContext<'_, E> {\n         let mut tx_token = Some(tx_token);\n         let mut did_something = false;\n \n-        for socket in self.sockets.udp.iter() {\n+        for socket in self.sockets.udp_socket_iter() {\n             if !socket.need_dispatch(self.iface_cx.now()) {\n                 continue;\n             }\ndiff --git a/kernel/libs/aster-bigtcp/src/lib.rs b/kernel/libs/aster-bigtcp/src/lib.rs\n--- a/kernel/libs/aster-bigtcp/src/lib.rs\n+++ b/kernel/libs/aster-bigtcp/src/lib.rs\n@@ -12,13 +12,14 @@\n \n #![no_std]\n #![deny(unsafe_code)]\n-#![feature(btree_extract_if)]\n+#![feature(extract_if)]\n \n pub mod device;\n pub mod errors;\n pub mod ext;\n pub mod iface;\n pub mod socket;\n+pub mod socket_table;\n pub mod time;\n pub mod wire;\n \ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -1,13 +1,11 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use alloc::{boxed::Box, collections::btree_set::BTreeSet, sync::Arc, vec::Vec};\n+use alloc::{boxed::Box, collections::btree_map::BTreeMap, sync::Arc, vec::Vec};\n use core::{\n-    borrow::Borrow,\n     ops::{Deref, DerefMut},\n     sync::atomic::{AtomicBool, AtomicU64, AtomicU8, Ordering},\n };\n \n-use keyable_arc::KeyableArc;\n use ostd::sync::{LocalIrqDisabled, SpinLock, SpinLockGuard};\n use smoltcp::{\n     iface::Context,\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -15,7 +13,7 @@ use smoltcp::{\n     time::{Duration, Instant},\n     wire::{IpEndpoint, IpRepr, TcpControl, TcpRepr, UdpRepr},\n };\n-use spin::Once;\n+use spin::once::Once;\n use takeable::Takeable;\n \n use super::{\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -25,40 +23,20 @@ use super::{\n     RawTcpSocket, RawUdpSocket, TcpStateCheck,\n };\n use crate::{\n+    errors::tcp::{ConnectError, ListenError},\n     ext::Ext,\n     iface::{BindPortConfig, BoundPort, Iface},\n+    socket_table::{ConnectionKey, ListenerKey},\n };\n \n-pub struct Socket<T: Inner<E>, E: Ext>(Takeable<KeyableArc<SocketBg<T, E>>>);\n-\n-impl<T: Inner<E>, E: Ext> PartialEq for Socket<T, E> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.eq(&other.0)\n-    }\n-}\n-impl<T: Inner<E>, E: Ext> Eq for Socket<T, E> {}\n-impl<T: Inner<E>, E: Ext> PartialOrd for Socket<T, E> {\n-    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-impl<T: Inner<E>, E: Ext> Ord for Socket<T, E> {\n-    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-        self.0.cmp(&other.0)\n-    }\n-}\n-impl<T: Inner<E>, E: Ext> Borrow<KeyableArc<SocketBg<T, E>>> for Socket<T, E> {\n-    fn borrow(&self) -> &KeyableArc<SocketBg<T, E>> {\n-        self.0.as_ref()\n-    }\n-}\n+pub struct Socket<T: Inner<E>, E: Ext>(Takeable<Arc<SocketBg<T, E>>>);\n \n /// [`TcpConnectionInner`] or [`UdpSocketInner`].\n pub trait Inner<E: Ext> {\n     type Observer: SocketEventObserver;\n \n     /// Called by [`Socket::drop`].\n-    fn on_drop(this: &KeyableArc<SocketBg<Self, E>>)\n+    fn on_drop(this: &Arc<SocketBg<Self, E>>)\n     where\n         E: Ext,\n         Self: Sized;\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -85,6 +63,7 @@ pub struct SocketBg<T: Inner<E>, E: Ext> {\n pub struct TcpConnectionInner<E: Ext> {\n     socket: SpinLock<RawTcpSocketExt<E>, LocalIrqDisabled>,\n     is_dead: AtomicBool,\n+    connection_key: ConnectionKey,\n }\n \n struct RawTcpSocketExt<E: Ext> {\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -108,13 +87,13 @@ impl<E: Ext> DerefMut for RawTcpSocketExt<E> {\n }\n \n impl<E: Ext> RawTcpSocketExt<E> {\n-    fn on_new_state(&mut self, this: &KeyableArc<TcpConnectionBg<E>>) -> SocketEvents {\n+    fn on_new_state(&mut self, this: &Arc<TcpConnectionBg<E>>) -> SocketEvents {\n         if self.may_send() && !self.has_connected {\n             self.has_connected = true;\n \n             if let Some(ref listener) = self.listener {\n-                let mut backlog = listener.inner.lock();\n-                if let Some(value) = backlog.connecting.take(this) {\n+                let mut backlog = listener.inner.backlog.lock();\n+                if let Some(value) = backlog.connecting.remove(this.connection_key()) {\n                     backlog.connected.push(value);\n                 }\n                 listener.add_events(SocketEvents::CAN_RECV);\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -139,7 +118,7 @@ impl<E: Ext> RawTcpSocketExt<E> {\n     /// This method must be called after handling network events. However, it is not necessary to\n     /// call this method after handling non-closing user events, because the socket can never be\n     /// dead if it is not closed.\n-    fn update_dead(&self, this: &KeyableArc<TcpConnectionBg<E>>) {\n+    fn update_dead(&self, this: &Arc<TcpConnectionBg<E>>) {\n         if self.state() == smoltcp::socket::tcp::State::Closed {\n             this.inner.is_dead.store(true, Ordering::Relaxed);\n         }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -150,9 +129,9 @@ impl<E: Ext> RawTcpSocketExt<E> {\n             this.inner.is_dead.store(true, Ordering::Relaxed);\n \n             if let Some(ref listener) = self.listener {\n-                let mut backlog = listener.inner.lock();\n+                let mut backlog = listener.inner.backlog.lock();\n                 // This may fail due to race conditions, but it's fine.\n-                let _ = backlog.connecting.remove(this);\n+                let _ = backlog.connecting.remove(&this.inner.connection_key);\n             }\n         }\n     }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -160,6 +139,13 @@ impl<E: Ext> RawTcpSocketExt<E> {\n \n impl<E: Ext> TcpConnectionInner<E> {\n     fn new(socket: Box<RawTcpSocket>, listener: Option<Arc<TcpListenerBg<E>>>) -> Self {\n+        let connection_key = {\n+            // Since the socket is connected, the following unwrap can never fail\n+            let local_endpoint = socket.local_endpoint().unwrap();\n+            let remote_endpoint = socket.remote_endpoint().unwrap();\n+            ConnectionKey::from((local_endpoint, remote_endpoint))\n+        };\n+\n         let socket_ext = RawTcpSocketExt {\n             socket,\n             listener,\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -169,6 +155,7 @@ impl<E: Ext> TcpConnectionInner<E> {\n         TcpConnectionInner {\n             socket: SpinLock::new(socket_ext),\n             is_dead: AtomicBool::new(false),\n+            connection_key,\n         }\n     }\n \ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -197,7 +184,7 @@ impl<E: Ext> TcpConnectionInner<E> {\n impl<E: Ext> Inner<E> for TcpConnectionInner<E> {\n     type Observer = E::TcpEventObserver;\n \n-    fn on_drop(this: &KeyableArc<SocketBg<Self, E>>) {\n+    fn on_drop(this: &Arc<SocketBg<Self, E>>) {\n         let mut socket = this.inner.lock();\n \n         // FIXME: Send RSTs when there is unread data.\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -213,21 +200,33 @@ impl<E: Ext> Inner<E> for TcpConnectionInner<E> {\n pub struct TcpBacklog<E: Ext> {\n     socket: Box<RawTcpSocket>,\n     max_conn: usize,\n-    connecting: BTreeSet<TcpConnection<E>>,\n+    connecting: BTreeMap<ConnectionKey, TcpConnection<E>>,\n     connected: Vec<TcpConnection<E>>,\n }\n \n-pub type TcpListenerInner<E> = SpinLock<TcpBacklog<E>, LocalIrqDisabled>;\n+pub struct TcpListenerInner<E: Ext> {\n+    backlog: SpinLock<TcpBacklog<E>, LocalIrqDisabled>,\n+    listener_key: ListenerKey,\n+}\n+\n+impl<E: Ext> TcpListenerInner<E> {\n+    fn new(backlog: TcpBacklog<E>, listener_key: ListenerKey) -> Self {\n+        Self {\n+            backlog: SpinLock::new(backlog),\n+            listener_key,\n+        }\n+    }\n+}\n \n impl<E: Ext> Inner<E> for TcpListenerInner<E> {\n     type Observer = E::TcpEventObserver;\n \n-    fn on_drop(this: &KeyableArc<SocketBg<Self, E>>) {\n+    fn on_drop(this: &Arc<SocketBg<Self, E>>) {\n         // A TCP listener can be removed immediately.\n         this.bound.iface().common().remove_tcp_listener(this);\n \n         let (connecting, connected) = {\n-            let mut socket = this.inner.lock();\n+            let mut socket = this.inner.backlog.lock();\n             (\n                 core::mem::take(&mut socket.connecting),\n                 core::mem::take(&mut socket.connected),\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -249,7 +248,7 @@ type UdpSocketInner = SpinLock<Box<RawUdpSocket>, LocalIrqDisabled>;\n impl<E: Ext> Inner<E> for UdpSocketInner {\n     type Observer = E::UdpEventObserver;\n \n-    fn on_drop(this: &KeyableArc<SocketBg<Self, E>>) {\n+    fn on_drop(this: &Arc<SocketBg<Self, E>>) {\n         this.inner.lock().close();\n \n         // A UDP socket can be removed immediately.\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -271,7 +270,7 @@ pub(crate) type UdpSocketBg<E> = SocketBg<UdpSocketInner, E>;\n \n impl<T: Inner<E>, E: Ext> Socket<T, E> {\n     pub(crate) fn new(bound: BoundPort<E>, inner: T) -> Self {\n-        Self(Takeable::new(KeyableArc::new(SocketBg {\n+        Self(Takeable::new(Arc::new(SocketBg {\n             bound,\n             inner,\n             observer: Once::new(),\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -280,7 +279,7 @@ impl<T: Inner<E>, E: Ext> Socket<T, E> {\n         })))\n     }\n \n-    pub(crate) fn inner(&self) -> &KeyableArc<SocketBg<T, E>> {\n+    pub(crate) fn inner(&self) -> &Arc<SocketBg<T, E>> {\n         &self.0\n     }\n }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -337,18 +336,30 @@ impl<E: Ext> TcpConnection<E> {\n         remote_endpoint: IpEndpoint,\n         option: &RawTcpOption,\n         observer: E::TcpEventObserver,\n-    ) -> Result<Self, (BoundPort<E>, smoltcp::socket::tcp::ConnectError)> {\n+    ) -> Result<Self, (BoundPort<E>, ConnectError)> {\n+        let Some(local_endpoint) = bound.endpoint() else {\n+            return Err((bound, ConnectError::Unaddressable));\n+        };\n+\n+        let iface = bound.iface().clone();\n+        // We have to lock interface before locking interface\n+        // to avoid dead lock due to inconsistent lock orders.\n+        let mut interface = iface.common().interface();\n+        let mut sockets = iface.common().sockets();\n+\n+        let connection_key = ConnectionKey::from((local_endpoint, remote_endpoint));\n+\n+        if sockets.lookup_connection(&connection_key).is_some() {\n+            return Err((bound, ConnectError::AddressInUse));\n+        }\n+\n         let socket = {\n             let mut socket = new_tcp_socket();\n \n             option.apply(&mut socket);\n \n-            let common = bound.iface().common();\n-            let mut iface = common.interface();\n-\n-            if let Err(err) = socket.connect(iface.context(), remote_endpoint, bound.port()) {\n-                drop(iface);\n-                return Err((bound, err));\n+            if let Err(err) = socket.connect(interface.context(), remote_endpoint, bound.port()) {\n+                return Err((bound, err.into()));\n             }\n \n             socket\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -359,10 +370,8 @@ impl<E: Ext> TcpConnection<E> {\n         let connection = Self::new(bound, inner);\n         connection.0.update_next_poll_at_ms(PollAt::Now);\n         connection.init_observer(observer);\n-        connection\n-            .iface()\n-            .common()\n-            .register_tcp_connection(connection.inner().clone());\n+        let res = sockets.insert_connection(connection.inner().clone());\n+        debug_assert!(res.is_ok());\n \n         Ok(connection)\n     }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -375,7 +384,7 @@ impl<E: Ext> TcpConnection<E> {\n             ConnectState::Connecting\n         } else if socket.has_connected {\n             ConnectState::Connected\n-        } else if KeyableArc::strong_count(self.0.as_ref()) > 1 {\n+        } else if Arc::strong_count(self.0.as_ref()) > 1 {\n             // Now we should return `ConnectState::Refused`. However, when we do this, we must\n             // guarantee that `into_bound_port` can succeed (see the method's doc comments). We can\n             // only guarantee this after we have removed all `Arc<TcpConnectionBg>` in the iface's\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -396,7 +405,7 @@ impl<E: Ext> TcpConnection<E> {\n     /// this connection. We guarantee that this method will always succeed if\n     /// [`Self::connect_state`] returns [`ConnectState::Refused`].\n     pub fn into_bound_port(mut self) -> Option<BoundPort<E>> {\n-        let this: TcpConnectionBg<E> = Arc::into_inner(self.0.take().into())?;\n+        let this: TcpConnectionBg<E> = Arc::into_inner(self.0.take())?;\n         Some(this.bound)\n     }\n \ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -492,36 +501,47 @@ impl<E: Ext> TcpListener<E> {\n         max_conn: usize,\n         option: &RawTcpOption,\n         observer: E::TcpEventObserver,\n-    ) -> Result<Self, (BoundPort<E>, smoltcp::socket::tcp::ListenError)> {\n+    ) -> Result<Self, (BoundPort<E>, ListenError)> {\n         let Some(local_endpoint) = bound.endpoint() else {\n-            return Err((bound, smoltcp::socket::tcp::ListenError::Unaddressable));\n+            return Err((bound, ListenError::Unaddressable));\n         };\n \n+        let iface = bound.iface().clone();\n+        let mut sockets = iface.common().sockets();\n+\n+        let listener_key = ListenerKey::new(local_endpoint.addr, local_endpoint.port);\n+\n+        if sockets.lookup_listener(&listener_key).is_some() {\n+            return Err((bound, ListenError::AddressInUse));\n+        }\n+\n         let socket = {\n             let mut socket = new_tcp_socket();\n \n             option.apply(&mut socket);\n \n             if let Err(err) = socket.listen(local_endpoint) {\n-                return Err((bound, err));\n+                return Err((bound, err.into()));\n             }\n \n             socket\n         };\n \n-        let inner = TcpListenerInner::new(TcpBacklog {\n-            socket,\n-            max_conn,\n-            connecting: BTreeSet::new(),\n-            connected: Vec::new(),\n-        });\n+        let inner = {\n+            let backlog = TcpBacklog {\n+                socket,\n+                max_conn,\n+                connecting: BTreeMap::new(),\n+                connected: Vec::new(),\n+            };\n+\n+            TcpListenerInner::new(backlog, listener_key)\n+        };\n \n         let listener = Self::new(bound, inner);\n         listener.init_observer(observer);\n-        listener\n-            .iface()\n-            .common()\n-            .register_tcp_listener(listener.inner().clone());\n+        let res = sockets.insert_listener(listener.inner().clone());\n+        debug_assert!(res.is_ok());\n \n         Ok(listener)\n     }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -531,7 +551,7 @@ impl<E: Ext> TcpListener<E> {\n     /// Polling the iface is _not_ required after this method succeeds.\n     pub fn accept(&self) -> Option<(TcpConnection<E>, IpEndpoint)> {\n         let accepted = {\n-            let mut backlog = self.0.inner.lock();\n+            let mut backlog = self.0.inner.backlog.lock();\n             backlog.connected.pop()?\n         };\n \ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -551,20 +571,20 @@ impl<E: Ext> TcpListener<E> {\n     ///\n     /// It's the caller's responsibility to deal with race conditions when using this method.\n     pub fn can_accept(&self) -> bool {\n-        !self.0.inner.lock().connected.is_empty()\n+        !self.0.inner.backlog.lock().connected.is_empty()\n     }\n }\n \n impl<E: Ext> RawTcpSetOption for TcpListener<E> {\n     fn set_keep_alive(&self, interval: Option<Duration>) -> NeedIfacePoll {\n-        let mut backlog = self.0.inner.lock();\n+        let mut backlog = self.0.inner.backlog.lock();\n         backlog.socket.set_keep_alive(interval);\n \n         NeedIfacePoll::FALSE\n     }\n \n     fn set_nagle_enabled(&self, enabled: bool) {\n-        let mut backlog = self.0.inner.lock();\n+        let mut backlog = self.0.inner.backlog.lock();\n         backlog.socket.set_nagle_enabled(enabled);\n     }\n }\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -680,17 +700,17 @@ impl<T: Inner<E>, E: Ext> SocketBg<T, E> {\n         }\n     }\n \n-    pub(crate) fn on_dead_events(this: KeyableArc<Self>)\n+    pub(crate) fn on_dead_events(self: Arc<Self>)\n     where\n         T::Observer: Clone,\n     {\n         // This method can only be called to process network events, so we assume we are holding the\n         // poll lock and no race conditions can occur.\n-        let events = this.events.load(Ordering::Relaxed);\n-        this.events.store(0, Ordering::Relaxed);\n+        let events = self.events.load(Ordering::Relaxed);\n+        self.events.store(0, Ordering::Relaxed);\n \n-        let observer = this.observer.get().cloned();\n-        drop(this);\n+        let observer = self.observer.get().cloned();\n+        drop(self);\n \n         // Notify dead events after the `Arc` is dropped to ensure the observer sees this event\n         // with the expected reference count. See `TcpConnection::connect_state` for an example.\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -752,6 +772,16 @@ impl<E: Ext> TcpConnectionBg<E> {\n     pub(crate) fn is_dead(&self) -> bool {\n         self.inner.is_dead()\n     }\n+\n+    pub(crate) const fn connection_key(&self) -> &ConnectionKey {\n+        &self.inner.connection_key\n+    }\n+}\n+\n+impl<E: Ext> TcpListenerBg<E> {\n+    pub(crate) const fn listener_key(&self) -> &ListenerKey {\n+        &self.inner.listener_key\n+    }\n }\n \n impl<T: Inner<E>, E: Ext> SocketBg<T, E> {\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -780,12 +810,12 @@ pub(crate) enum TcpProcessResult {\n impl<E: Ext> TcpConnectionBg<E> {\n     /// Tries to process an incoming packet and returns whether the packet is processed.\n     pub(crate) fn process(\n-        this: &KeyableArc<Self>,\n+        self: &Arc<Self>,\n         cx: &mut Context,\n         ip_repr: &IpRepr,\n         tcp_repr: &TcpRepr,\n     ) -> TcpProcessResult {\n-        let mut socket = this.inner.lock();\n+        let mut socket = self.inner.lock();\n \n         if !socket.accepts(cx, ip_repr, tcp_repr) {\n             return TcpProcessResult::NotProcessed;\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -808,7 +838,7 @@ impl<E: Ext> TcpConnectionBg<E> {\n             && tcp_repr.control == TcpControl::Syn\n             && tcp_repr.ack_number.is_none()\n         {\n-            this.inner.set_dead_timewait(&socket);\n+            self.inner.set_dead_timewait(&socket);\n             return TcpProcessResult::NotProcessed;\n         }\n \ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -823,18 +853,18 @@ impl<E: Ext> TcpConnectionBg<E> {\n         };\n \n         if socket.state() != old_state {\n-            events |= socket.on_new_state(this);\n+            events |= socket.on_new_state(self);\n         }\n \n-        this.add_events(events);\n-        this.update_next_poll_at_ms(socket.poll_at(cx));\n+        self.add_events(events);\n+        self.update_next_poll_at_ms(socket.poll_at(cx));\n \n         result\n     }\n \n     /// Tries to generate an outgoing packet and dispatches the generated packet.\n     pub(crate) fn dispatch<D>(\n-        this: &KeyableArc<Self>,\n+        this: &Arc<Self>,\n         cx: &mut Context,\n         dispatch: D,\n     ) -> Option<(IpRepr, TcpRepr<'static>)>\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -878,12 +908,12 @@ impl<E: Ext> TcpConnectionBg<E> {\n impl<E: Ext> TcpListenerBg<E> {\n     /// Tries to process an incoming packet and returns whether the packet is processed.\n     pub(crate) fn process(\n-        this: &KeyableArc<Self>,\n+        self: &Arc<Self>,\n         cx: &mut Context,\n         ip_repr: &IpRepr,\n         tcp_repr: &TcpRepr,\n-    ) -> (TcpProcessResult, Option<KeyableArc<TcpConnectionBg<E>>>) {\n-        let mut backlog = this.inner.lock();\n+    ) -> (TcpProcessResult, Option<Arc<TcpConnectionBg<E>>>) {\n+        let mut backlog = self.inner.backlog.lock();\n \n         if !backlog.socket.accepts(cx, ip_repr, tcp_repr) {\n             return (TcpProcessResult::NotProcessed, None);\ndiff --git a/kernel/libs/aster-bigtcp/src/socket/bound.rs b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n--- a/kernel/libs/aster-bigtcp/src/socket/bound.rs\n+++ b/kernel/libs/aster-bigtcp/src/socket/bound.rs\n@@ -914,19 +944,19 @@ impl<E: Ext> TcpListenerBg<E> {\n \n         let inner = TcpConnectionInner::new(\n             core::mem::replace(&mut backlog.socket, new_socket),\n-            Some(this.clone().into()),\n+            Some(self.clone()),\n         );\n         let conn = TcpConnection::new(\n-            this.bound\n+            self.bound\n                 .iface()\n-                .bind(BindPortConfig::CanReuse(this.bound.port()))\n+                .bind(BindPortConfig::CanReuse(self.bound.port()))\n                 .unwrap(),\n             inner,\n         );\n         let conn_bg = conn.inner().clone();\n \n-        let inserted = backlog.connecting.insert(conn);\n-        assert!(inserted);\n+        let old_conn = backlog.connecting.insert(*conn_bg.connection_key(), conn);\n+        debug_assert!(old_conn.is_none());\n \n         conn_bg.update_next_poll_at_ms(PollAt::Now);\n \ndiff --git /dev/null b/kernel/libs/aster-bigtcp/src/socket_table.rs\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/libs/aster-bigtcp/src/socket_table.rs\n@@ -0,0 +1,352 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module defines the socket table, which manages all TCP and UDP sockets,\n+//! for efficiently inserting, looking up, and removing sockets.\n+\n+use alloc::{boxed::Box, sync::Arc, vec::Vec};\n+use core::net::Ipv4Addr;\n+\n+use jhash::{jhash_1vals, jhash_3vals};\n+use smoltcp::wire::{IpAddress, IpEndpoint, IpListenEndpoint};\n+use static_assertions::const_assert;\n+\n+use crate::{\n+    ext::Ext,\n+    socket::{TcpConnectionBg, TcpListenerBg, UdpSocketBg},\n+    wire::PortNum,\n+};\n+\n+pub type SocketHash = u32;\n+\n+/// A unique key for identifying a `TcpListener`.\n+///\n+/// Note that two `TcpListener`s cannot listen on the same address\n+/// even if both sockets set SO_REUSEADDR to true,\n+/// so there cannot be multiple listeners with the same `ListenerKey`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) struct ListenerKey {\n+    addr: IpAddress,\n+    port: PortNum,\n+    hash: SocketHash,\n+}\n+\n+impl ListenerKey {\n+    pub(crate) const fn new(addr: IpAddress, port: PortNum) -> Self {\n+        // FIXME: If the socket is listening on an unspecified address (0.0.0.0),\n+        // Linux will get the hash value by port only.\n+        let hash = hash_addr_port(addr, port);\n+        Self { addr, port, hash }\n+    }\n+\n+    pub(crate) const fn hash(&self) -> SocketHash {\n+        self.hash\n+    }\n+}\n+\n+impl From<IpListenEndpoint> for ListenerKey {\n+    fn from(listen_endpoint: IpListenEndpoint) -> Self {\n+        let addr = listen_endpoint\n+            .addr\n+            .unwrap_or(IpAddress::Ipv4(Ipv4Addr::UNSPECIFIED));\n+        let port = listen_endpoint.port;\n+        Self::new(addr, port)\n+    }\n+}\n+\n+/// A unique key for identifying a `TcpConnection`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub(crate) struct ConnectionKey {\n+    local_addr: IpAddress,\n+    local_port: PortNum,\n+    remote_addr: IpAddress,\n+    remote_port: PortNum,\n+    hash: SocketHash,\n+}\n+\n+impl ConnectionKey {\n+    pub(crate) const fn new(\n+        local_addr: IpAddress,\n+        local_port: PortNum,\n+        remote_addr: IpAddress,\n+        remote_port: PortNum,\n+    ) -> Self {\n+        let hash = hash_local_remote(local_addr, local_port, remote_addr, remote_port);\n+        Self {\n+            local_addr,\n+            local_port,\n+            remote_addr,\n+            remote_port,\n+            hash,\n+        }\n+    }\n+\n+    pub(crate) const fn hash(&self) -> SocketHash {\n+        self.hash\n+    }\n+}\n+\n+impl From<(IpEndpoint, IpEndpoint)> for ConnectionKey {\n+    fn from(value: (IpEndpoint, IpEndpoint)) -> Self {\n+        Self::new(value.0.addr, value.0.port, value.1.addr, value.1.port)\n+    }\n+}\n+\n+// FIXME: The following two constants should be randomly-generated at runtime\n+const HASH_SECRET: u32 = 0xdeadbeef;\n+\n+// FIXME: This constant should be a per-net-namespace value\n+const NET_HASHMIX: u32 = 0xbeefdead;\n+\n+const fn hash_local_remote(\n+    local_addr: IpAddress,\n+    local_port: PortNum,\n+    remote_addr: IpAddress,\n+    remote_port: PortNum,\n+) -> SocketHash {\n+    // FIXME: Deal with IPv6 addresses once IPv6 is supported.\n+    let IpAddress::Ipv4(local_ipv4) = local_addr;\n+    let IpAddress::Ipv4(remote_ipv4) = remote_addr;\n+\n+    jhash_3vals(\n+        local_ipv4.to_bits(),\n+        remote_ipv4.to_bits(),\n+        (local_port as u32).wrapping_shl(16) | remote_port as u32,\n+        HASH_SECRET.wrapping_add(NET_HASHMIX),\n+    )\n+}\n+\n+const fn hash_addr_port(addr: IpAddress, port: PortNum) -> SocketHash {\n+    // FIXME: Deal with IPv6 addresses once IPv6 is supported.\n+    let IpAddress::Ipv4(ipv4_addr) = addr;\n+\n+    jhash_1vals(ipv4_addr.to_bits(), NET_HASHMIX) ^ (port as u32)\n+}\n+\n+/// The socket table manages TCP and UDP sockets.\n+///\n+/// Unlike the Linux inet hashtable, which is shared across a single network namespace,\n+/// this table is currently limited to a single interface.\n+///\n+// TODO: Modify the table to be shared across a single network namespace\n+// to support INADDR_ANY (0.0.0.0).\n+pub(crate) struct SocketTable<E: Ext> {\n+    // TODO: Linux has two hashtables for listeners:\n+    // the first is hashed by local address and port,\n+    // the second is hashed by local port only.\n+    // The second table is the only place where sockets listening on INADDR_ANY (0.0.0.0) can exist.\n+    // Since we do not yet support INADDR_ANY, we only have the first table here.\n+    listener_buckets: Box<[ListenerHashBucket<E>]>,\n+    connection_buckets: Box<[ConnectionHashBucket<E>]>,\n+    // Linux does not include UDP sockets in the inet hashtable.\n+    // Here we include UDP sockets in the socket table for simplicity.\n+    // Note that multiple UDP sockets can be bound to the same address,\n+    // so we cannot use (addr, port) as a _unique_ key for UDP sockets.\n+    udp_sockets: Vec<Arc<UdpSocketBg<E>>>,\n+}\n+\n+// On Linux, the number of buckets is determined at runtime based on the available memory.\n+// For simplicity, we use fixed values here.\n+// The bucket count should be a power of 2 to ensure efficient modulo calculations.\n+const LISTENER_BUCKET_COUNT: u32 = 64;\n+const LISTENER_BUCKET_MASK: u32 = LISTENER_BUCKET_COUNT - 1;\n+const CONNECTION_BUCKET_COUNT: u32 = 8192;\n+const CONNECTION_BUCKET_MASK: u32 = CONNECTION_BUCKET_COUNT - 1;\n+\n+const_assert!(LISTENER_BUCKET_COUNT.is_power_of_two());\n+const_assert!(CONNECTION_BUCKET_COUNT.is_power_of_two());\n+\n+impl<E: Ext> SocketTable<E> {\n+    pub(crate) fn new() -> Self {\n+        let listener_buckets = (0..LISTENER_BUCKET_COUNT)\n+            .map(|_| ListenerHashBucket::new())\n+            .collect();\n+\n+        let connection_buckets = (0..CONNECTION_BUCKET_COUNT)\n+            .map(|_| ConnectionHashBucket::new())\n+            .collect();\n+\n+        let udp_sockets = Vec::new();\n+\n+        Self {\n+            listener_buckets,\n+            connection_buckets,\n+            udp_sockets,\n+        }\n+    }\n+\n+    /// Inserts a TCP listener into the table.\n+    ///\n+    /// If a socket with the same [`ListenerKey`] has already been inserted,\n+    /// this method will return an error and the listener will not be inserted.\n+    pub(crate) fn insert_listener(\n+        &mut self,\n+        listener: Arc<TcpListenerBg<E>>,\n+    ) -> Result<(), Arc<TcpListenerBg<E>>> {\n+        let key = listener.listener_key();\n+\n+        let bucket = {\n+            let hash = key.hash();\n+            let bucket_index = hash & LISTENER_BUCKET_MASK;\n+            &mut self.listener_buckets[bucket_index as usize]\n+        };\n+\n+        if bucket\n+            .listeners\n+            .iter()\n+            .any(|tcp_listener| tcp_listener.listener_key() == listener.listener_key())\n+        {\n+            return Err(listener);\n+        }\n+\n+        bucket.listeners.push(listener);\n+        Ok(())\n+    }\n+\n+    pub(crate) fn insert_connection(\n+        &mut self,\n+        connection: Arc<TcpConnectionBg<E>>,\n+    ) -> Result<(), Arc<TcpConnectionBg<E>>> {\n+        let key = connection.connection_key();\n+\n+        let bucket = {\n+            let hash = key.hash();\n+            let bucket_index = hash & CONNECTION_BUCKET_MASK;\n+            &mut self.connection_buckets[bucket_index as usize]\n+        };\n+\n+        if bucket\n+            .connections\n+            .iter()\n+            .any(|tcp_connection| tcp_connection.connection_key() == connection.connection_key())\n+        {\n+            return Err(connection);\n+        }\n+\n+        bucket.connections.push(connection);\n+        Ok(())\n+    }\n+\n+    pub(crate) fn insert_udp_socket(&mut self, udp_socket: Arc<UdpSocketBg<E>>) {\n+        debug_assert!(!self\n+            .udp_sockets\n+            .iter()\n+            .any(|socket| Arc::ptr_eq(socket, &udp_socket)));\n+        self.udp_sockets.push(udp_socket);\n+    }\n+\n+    pub(crate) fn lookup_listener(&self, key: &ListenerKey) -> Option<&Arc<TcpListenerBg<E>>> {\n+        let bucket = {\n+            let hash = key.hash();\n+            let bucket_index = hash & LISTENER_BUCKET_MASK;\n+            &self.listener_buckets[bucket_index as usize]\n+        };\n+\n+        bucket\n+            .listeners\n+            .iter()\n+            .find(|listener| listener.listener_key() == key)\n+    }\n+\n+    pub(crate) fn lookup_connection(\n+        &self,\n+        key: &ConnectionKey,\n+    ) -> Option<&Arc<TcpConnectionBg<E>>> {\n+        let bucket = {\n+            let hash = key.hash();\n+            let bucket_index = hash & CONNECTION_BUCKET_MASK;\n+            &self.connection_buckets[bucket_index as usize]\n+        };\n+\n+        bucket\n+            .connections\n+            .iter()\n+            .find(|connection| connection.connection_key() == key)\n+    }\n+\n+    pub(crate) fn remove_listener(\n+        &mut self,\n+        listener: &TcpListenerBg<E>,\n+    ) -> Option<Arc<TcpListenerBg<E>>> {\n+        let key = listener.listener_key();\n+\n+        let bucket = {\n+            let hash = key.hash();\n+            let bucket_index = hash & LISTENER_BUCKET_MASK;\n+            &mut self.listener_buckets[bucket_index as usize]\n+        };\n+\n+        let index = bucket\n+            .listeners\n+            .iter()\n+            .position(|tcp_listener| tcp_listener.listener_key() == listener.listener_key())?;\n+        Some(bucket.listeners.swap_remove(index))\n+    }\n+\n+    pub(crate) fn remove_udp_socket(\n+        &mut self,\n+        socket: &Arc<UdpSocketBg<E>>,\n+    ) -> Option<Arc<UdpSocketBg<E>>> {\n+        let index = self\n+            .udp_sockets\n+            .iter()\n+            .position(|udp_socket| Arc::ptr_eq(udp_socket, socket))?;\n+        Some(self.udp_sockets.swap_remove(index))\n+    }\n+\n+    pub(crate) fn remove_dead_tcp_connections(&mut self) {\n+        for connection_bucket in self.connection_buckets.iter_mut() {\n+            for tcp_conn in connection_bucket\n+                .connections\n+                .extract_if(|connection| connection.is_dead())\n+            {\n+                tcp_conn.on_dead_events();\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn tcp_listener_iter(&self) -> impl Iterator<Item = &Arc<TcpListenerBg<E>>> {\n+        self.listener_buckets\n+            .iter()\n+            .flat_map(|bucket| bucket.listeners.iter())\n+    }\n+\n+    pub(crate) fn tcp_conn_iter(&self) -> impl Iterator<Item = &Arc<TcpConnectionBg<E>>> {\n+        self.connection_buckets\n+            .iter()\n+            .flat_map(|bucket| bucket.connections.iter())\n+    }\n+\n+    pub(crate) fn udp_socket_iter(&self) -> impl Iterator<Item = &Arc<UdpSocketBg<E>>> {\n+        self.udp_sockets.iter()\n+    }\n+}\n+\n+impl<E: Ext> Default for SocketTable<E> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+struct ListenerHashBucket<E: Ext> {\n+    listeners: Vec<Arc<TcpListenerBg<E>>>,\n+}\n+\n+impl<E: Ext> ListenerHashBucket<E> {\n+    const fn new() -> Self {\n+        Self {\n+            listeners: Vec::new(),\n+        }\n+    }\n+}\n+\n+struct ConnectionHashBucket<E: Ext> {\n+    connections: Vec<Arc<TcpConnectionBg<E>>>,\n+}\n+\n+impl<E: Ext> ConnectionHashBucket<E> {\n+    const fn new() -> Self {\n+        Self {\n+            connections: Vec::new(),\n+        }\n+    }\n+}\ndiff --git /dev/null b/kernel/libs/jhash/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/libs/jhash/Cargo.toml\n@@ -0,0 +1,6 @@\n+[package]\n+name = \"jhash\"\n+version = \"0.1.0\"\n+edition = \"2024\"\n+\n+[dependencies]\ndiff --git a/kernel/src/net/socket/ip/stream/connecting.rs b/kernel/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/src/net/socket/ip/stream/connecting.rs\n@@ -1,6 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_bigtcp::{\n+    errors::tcp::ConnectError,\n     socket::{ConnectState, RawTcpOption, RawTcpSetOption},\n     wire::IpEndpoint,\n };\ndiff --git a/kernel/src/net/socket/ip/stream/connecting.rs b/kernel/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/src/net/socket/ip/stream/connecting.rs\n@@ -30,22 +31,30 @@ impl ConnectingStream {\n         option: &RawTcpOption,\n         observer: StreamObserver,\n     ) -> core::result::Result<Self, (Error, BoundPort)> {\n-        // The only reason this method might fail is because we're trying to connect to an\n-        // unspecified address (i.e. 0.0.0.0). We currently have no support for binding to,\n-        // listening on, or connecting to the unspecified address.\n-        //\n-        // We assume the remote will just refuse to connect, so we return `ECONNREFUSED`.\n         let tcp_conn =\n             match TcpConnection::new_connect(bound_port, remote_endpoint, option, observer) {\n                 Ok(tcp_conn) => tcp_conn,\n+                Err((bound_port, ConnectError::AddressInUse)) => {\n+                    return Err((\n+                        Error::with_message(Errno::EADDRNOTAVAIL, \"connection key conflicts\"),\n+                        bound_port,\n+                    ))\n+                }\n                 Err((bound_port, _)) => {\n+                    // The only reason this method might go to this branch is because\n+                    // we're trying to connect to an unspecified address (i.e. 0.0.0.0).\n+                    // We currently have no support for binding to,\n+                    // listening on, or connecting to the unspecified address.\n+                    //\n+                    // We assume the remote will just refuse to connect,\n+                    // so we return `ECONNREFUSED`.\n                     return Err((\n                         Error::with_message(\n                             Errno::ECONNREFUSED,\n                             \"connecting to an unspecified address is not supported\",\n                         ),\n                         bound_port,\n-                    ))\n+                    ));\n                 }\n             };\n \ndiff --git a/kernel/src/net/socket/ip/stream/init.rs b/kernel/src/net/socket/ip/stream/init.rs\n--- a/kernel/src/net/socket/ip/stream/init.rs\n+++ b/kernel/src/net/socket/ip/stream/init.rs\n@@ -88,7 +88,10 @@ impl InitStream {\n             ));\n         };\n \n-        Ok(ListenStream::new(bound_port, backlog, option, observer))\n+        match ListenStream::new(bound_port, backlog, option, observer) {\n+            Ok(listen_stream) => Ok(listen_stream),\n+            Err((bound_port, error)) => Err((error, Self::Bound(bound_port))),\n+        }\n     }\n \n     pub fn local_endpoint(&self) -> Option<IpEndpoint> {\ndiff --git a/kernel/src/net/socket/ip/stream/listen.rs b/kernel/src/net/socket/ip/stream/listen.rs\n--- a/kernel/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/src/net/socket/ip/stream/listen.rs\n@@ -1,6 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_bigtcp::{\n+    errors::tcp::ListenError,\n     socket::{RawTcpOption, RawTcpSetOption},\n     wire::IpEndpoint,\n };\ndiff --git a/kernel/src/net/socket/ip/stream/listen.rs b/kernel/src/net/socket/ip/stream/listen.rs\n--- a/kernel/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/src/net/socket/ip/stream/listen.rs\n@@ -22,18 +23,20 @@ impl ListenStream {\n         backlog: usize,\n         option: &RawTcpOption,\n         observer: StreamObserver,\n-    ) -> Self {\n+    ) -> core::result::Result<Self, (BoundPort, Error)> {\n         const SOMAXCONN: usize = 4096;\n         let max_conn = SOMAXCONN.min(backlog);\n \n-        let tcp_listener = match TcpListener::new_listen(bound_port, max_conn, option, observer) {\n-            Ok(tcp_listener) => tcp_listener,\n+        match TcpListener::new_listen(bound_port, max_conn, option, observer) {\n+            Ok(tcp_listener) => Ok(Self { tcp_listener }),\n+            Err((bound_port, ListenError::AddressInUse)) => Err((\n+                bound_port,\n+                Error::with_message(Errno::EADDRINUSE, \"listener key conflicts\"),\n+            )),\n             Err((_, err)) => {\n                 unreachable!(\"`new_listen` fails with {:?}, which should not happen\", err)\n             }\n-        };\n-\n-        Self { tcp_listener }\n+        }\n     }\n \n     pub fn try_accept(&self) -> Result<ConnectedStream> {\n",
        "test_patch": "diff --git /dev/null b/kernel/libs/jhash/src/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/libs/jhash/src/lib.rs\n@@ -0,0 +1,339 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module implements hash algorithms developed by Bob Jenkins.\n+//!\n+//! For further information, visit: www.burtleburtle.net/bob/hash/doobs.html\n+//!\n+//! The hash functions in this module facilitate the production of 32-bit values for hash table lookups.\n+//! Although the [Linux kernel's jhash](https://github.com/torvalds/linux/blob/master/include/linux/jhash.h)\n+//! slightly differs from the original version, this module reimplements the Linux kernel's version.\n+//!\n+\n+#![no_std]\n+#![deny(unsafe_code)]\n+\n+/// A randomly chosen initial value\n+const JHASH_INITVAL: u32 = 0xdeadbeef;\n+\n+/// Hashes an arbitrary u8 slices.\n+///\n+/// # Example\n+///\n+/// If you are hashing n slices, do it like this:\n+/// ```rust\n+/// use jhash::jhash_slice;\n+///\n+/// fn hash_slices(slices: &[&[u8]]) -> u32 {\n+///     let mut hash: u32 = 0;\n+///     for slice in slices {\n+///         hash = jhash_slice(slice, hash);\n+///     }\n+///     hash\n+/// }\n+/// ```\n+pub const fn jhash_slice(slice: &[u8], initval: u32) -> u32 {\n+    let mut length = slice.len() as u32;\n+    let mut index: usize = 0;\n+\n+    // Init the internal state\n+    let mut a: u32 = JHASH_INITVAL.wrapping_add(length).wrapping_add(initval);\n+    let mut b: u32 = a;\n+    let mut c: u32 = a;\n+\n+    // Handle the most bytes except last 12 bytes\n+    while length > 12 {\n+        // FIXME: The Linux version uses `u32::from_ne_bytes`.\n+        // Here, we use `from_le_bytes` to ensure consistency\n+        // in results across multiple runs on all machines.\n+        a = a.wrapping_add(u32::from_le_bytes([\n+            slice[index],\n+            slice[index + 1],\n+            slice[index + 2],\n+            slice[index + 3],\n+        ]));\n+        b = b.wrapping_add(u32::from_le_bytes([\n+            slice[index + 4],\n+            slice[index + 5],\n+            slice[index + 6],\n+            slice[index + 7],\n+        ]));\n+        c = c.wrapping_add(u32::from_le_bytes([\n+            slice[index + 8],\n+            slice[index + 9],\n+            slice[index + 10],\n+            slice[index + 11],\n+        ]));\n+        (a, b, c) = jhash_mix(a, b, c);\n+\n+        index += 12;\n+        length -= 12;\n+    }\n+\n+    // Handle the last 12 bytes\n+    if length == 12 {\n+        c = c.wrapping_add((slice[index + 11] as u32) << 24);\n+    }\n+\n+    if length >= 11 {\n+        c = c.wrapping_add((slice[index + 10] as u32) << 16);\n+    }\n+\n+    if length >= 10 {\n+        c = c.wrapping_add((slice[index + 9] as u32) << 8);\n+    }\n+\n+    if length >= 9 {\n+        c = c.wrapping_add(slice[index + 8] as u32);\n+    }\n+\n+    if length >= 8 {\n+        b = b.wrapping_add((slice[index + 7] as u32) << 24);\n+    }\n+\n+    if length >= 7 {\n+        b = b.wrapping_add((slice[index + 6] as u32) << 16);\n+    }\n+\n+    if length >= 6 {\n+        b = b.wrapping_add((slice[index + 5] as u32) << 8);\n+    }\n+\n+    if length >= 5 {\n+        b = b.wrapping_add(slice[index + 4] as u32);\n+    }\n+\n+    if length >= 4 {\n+        a = a.wrapping_add((slice[index + 3] as u32) << 24);\n+    }\n+\n+    if length >= 3 {\n+        a = a.wrapping_add((slice[index + 2] as u32) << 16);\n+    }\n+\n+    if length >= 2 {\n+        a = a.wrapping_add((slice[index + 1] as u32) << 8);\n+    }\n+\n+    if length >= 1 {\n+        a = a.wrapping_add(slice[index] as u32);\n+        return jhash_final(a, b, c);\n+    }\n+\n+    c\n+}\n+\n+/// Hashes exactly three u32 values\n+pub const fn jhash_3vals(a: u32, b: u32, c: u32, initval: u32) -> u32 {\n+    jhash_3vals_inner(\n+        a,\n+        b,\n+        c,\n+        initval.wrapping_add(JHASH_INITVAL).wrapping_add(3 << 2),\n+    )\n+}\n+\n+/// Hashes exactly two u32 values\n+pub const fn jhash_2vals(a: u32, b: u32, initval: u32) -> u32 {\n+    jhash_3vals_inner(\n+        a,\n+        b,\n+        0,\n+        initval.wrapping_add(JHASH_INITVAL).wrapping_add(2 << 2),\n+    )\n+}\n+\n+/// Hashes exactly one u32 value\n+pub const fn jhash_1vals(a: u32, initval: u32) -> u32 {\n+    jhash_3vals_inner(\n+        a,\n+        0,\n+        0,\n+        initval.wrapping_add(JHASH_INITVAL).wrapping_add(1 << 2),\n+    )\n+}\n+\n+/// Hashes an array of u32 values.\n+pub const fn jhash_u32_array(array: &[u32], initval: u32) -> u32 {\n+    let mut length = array.len() as u32;\n+    let mut index = 0;\n+\n+    // Initialize values a, b, and c\n+    let mut a: u32 = JHASH_INITVAL\n+        .wrapping_add(length << 2)\n+        .wrapping_add(initval);\n+    let mut b: u32 = a;\n+    let mut c: u32 = a;\n+\n+    // Process most values except the last three\n+    while length > 3 {\n+        a = a.wrapping_add(array[index]);\n+        b = b.wrapping_add(array[index + 1]);\n+        c = c.wrapping_add(array[index + 2]);\n+        (a, b, c) = jhash_mix(a, b, c);\n+\n+        length -= 3;\n+        index += 3;\n+    }\n+\n+    if length == 3 {\n+        c = c.wrapping_add(array[index + 2]);\n+    }\n+\n+    if length >= 2 {\n+        b = b.wrapping_add(array[index + 1]);\n+    }\n+\n+    if length >= 1 {\n+        a = a.wrapping_add(array[index]);\n+        return jhash_final(a, b, c);\n+    }\n+\n+    c\n+}\n+\n+/// An internal function that handles hashing for 3 u32 values\n+const fn jhash_3vals_inner(mut a: u32, mut b: u32, mut c: u32, initval: u32) -> u32 {\n+    a = a.wrapping_add(initval);\n+    b = b.wrapping_add(initval);\n+    c = c.wrapping_add(initval);\n+\n+    jhash_final(a, b, c)\n+}\n+\n+/// Finalizes the mix of three 32-bit values into a single u32 value\n+const fn jhash_final(mut a: u32, mut b: u32, mut c: u32) -> u32 {\n+    c ^= b;\n+    c = c.wrapping_sub(b.rotate_left(14));\n+\n+    a ^= c;\n+    a = a.wrapping_sub(c.rotate_left(11));\n+\n+    b ^= a;\n+    b = b.wrapping_sub(a.rotate_left(25));\n+\n+    c ^= b;\n+    c = c.wrapping_sub(b.rotate_left(16));\n+\n+    a ^= c;\n+    a = a.wrapping_sub(c.rotate_left(4));\n+\n+    b ^= a;\n+    b = b.wrapping_sub(a.rotate_left(14));\n+\n+    c ^= b;\n+    c.wrapping_sub(b.rotate_left(24))\n+}\n+\n+/// Mixes three 32-bit values in a reversible manner\n+const fn jhash_mix(mut a: u32, mut b: u32, mut c: u32) -> (u32, u32, u32) {\n+    a = a.wrapping_sub(c);\n+    a ^= c.rotate_left(4);\n+    c = c.wrapping_add(b);\n+\n+    b = b.wrapping_sub(a);\n+    b ^= a.rotate_left(6);\n+    a = a.wrapping_add(c);\n+\n+    c = c.wrapping_sub(b);\n+    c ^= b.rotate_left(8);\n+    b = b.wrapping_add(a);\n+\n+    a = a.wrapping_sub(c);\n+    a ^= c.rotate_left(16);\n+    c = c.wrapping_add(b);\n+\n+    b = b.wrapping_sub(a);\n+    b ^= a.rotate_left(19);\n+    a = a.wrapping_add(c);\n+\n+    c = c.wrapping_sub(b);\n+    c ^= b.rotate_left(4);\n+    b = b.wrapping_add(a);\n+\n+    (a, b, c)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    const JHASH_INITVAL: u32 = 0;\n+\n+    #[test]\n+    fn test_jhash_3vals() {\n+        assert_eq!(jhash_3vals(1, 2, 3, JHASH_INITVAL), 2757843189);\n+        assert_eq!(jhash_3vals(4, 5, 6, JHASH_INITVAL), 3701334656);\n+\n+        assert_eq!(jhash_3vals(0, 0, 0, JHASH_INITVAL), 459859287);\n+        assert_eq!(\n+            jhash_3vals(u32::MAX, u32::MAX, u32::MAX, JHASH_INITVAL),\n+            1846109353\n+        );\n+\n+        assert_eq!(jhash_3vals(1, 2, 3, 10), 453614296);\n+        assert_eq!(jhash_3vals(10, 20, 30, 5), 1448556389);\n+    }\n+\n+    #[test]\n+    fn test_jhash_2vals() {\n+        assert_eq!(jhash_2vals(1, 2, JHASH_INITVAL), 2337044857);\n+        assert_eq!(jhash_2vals(3, 4, JHASH_INITVAL), 3842257880);\n+        assert_eq!(jhash_2vals(0, 0, JHASH_INITVAL), 1489077439);\n+        assert_eq!(jhash_2vals(u32::MAX, u32::MAX, JHASH_INITVAL), 1382321797);\n+        assert_eq!(jhash_2vals(1, 2, 10), 1474913524);\n+        assert_eq!(jhash_2vals(10, 20, 5), 1368945286);\n+    }\n+\n+    #[test]\n+    fn test_jhash_1vals() {\n+        assert_eq!(jhash_1vals(1, JHASH_INITVAL), 1923623579);\n+        assert_eq!(jhash_1vals(5, JHASH_INITVAL), 4121471414);\n+        assert_eq!(jhash_1vals(0, JHASH_INITVAL), 76781240);\n+        assert_eq!(jhash_1vals(u32::MAX, JHASH_INITVAL), 2601633627);\n+        assert_eq!(jhash_1vals(1, 10), 1508237099);\n+        assert_eq!(jhash_1vals(10, 5), 2141486731);\n+    }\n+\n+    #[test]\n+    fn test_jhash_u32_array() {\n+        assert_eq!(jhash_u32_array(&[1, 2, 3], JHASH_INITVAL), 2757843189);\n+        assert_eq!(jhash_u32_array(&[4, 5, 6, 7, 8], JHASH_INITVAL), 581654130);\n+        assert_eq!(jhash_u32_array(&[], JHASH_INITVAL), 3735928559);\n+        assert_eq!(jhash_u32_array(&[10], JHASH_INITVAL), 1030482289);\n+        assert_eq!(jhash_u32_array(&[10, 20], JHASH_INITVAL), 363923158);\n+        assert_eq!(\n+            jhash_u32_array(&[0, 1, 2, u32::MAX], JHASH_INITVAL),\n+            3019125658\n+        );\n+        assert_eq!(jhash_u32_array(&[1, 2, 3], 10), 453614296);\n+    }\n+\n+    #[test]\n+    fn test_jhash_slice() {\n+        assert_eq!(jhash_slice(b\"hello world\", JHASH_INITVAL), 1252609637);\n+        assert_eq!(jhash_slice(b\"12345\", JHASH_INITVAL), 729031446);\n+        assert_eq!(jhash_slice(b\"\\n\\t\\r\", JHASH_INITVAL), 483925400);\n+        assert_eq!(jhash_slice(b\"\", JHASH_INITVAL), 3735928559);\n+\n+        let test_slices = &[\n+            b\"12345\".as_slice(),\n+            b\"hello world hello world\",\n+            b\"\\n\",\n+            b\"\",\n+            b\"\\t\\r\\n\",\n+        ];\n+        fn hash_slices(slices: &[&[u8]]) -> u32 {\n+            let mut hash: u32 = 0;\n+            for slice in slices {\n+                hash = jhash_slice(slice, hash);\n+            }\n+            hash\n+        }\n+        assert_eq!(hash_slices(test_slices), 3662697720);\n+        assert_eq!(hash_slices(&test_slices[0..4]), 230550114);\n+        assert_eq!(hash_slices(&test_slices[0..3]), 789588851);\n+        assert_eq!(hash_slices(&test_slices[0..2]), 1101610926);\n+        assert_eq!(hash_slices(&test_slices[0..1]), 729031446);\n+        assert_eq!(hash_slices(&[]), 0);\n+    }\n+}\ndiff --git a/test/apps/network/tcp_err.c b/test/apps/network/tcp_err.c\n--- a/test/apps/network/tcp_err.c\n+++ b/test/apps/network/tcp_err.c\n@@ -478,3 +478,73 @@ FN_TEST(self_connect)\n \tTEST_SUCC(close(sk));\n }\n END_TEST()\n+\n+FN_TEST(listen_at_the_same_address)\n+{\n+\tint sk_listen1;\n+\tint sk_listen2;\n+\n+\tsk_listen1 = TEST_SUCC(socket(PF_INET, SOCK_STREAM, 0));\n+\tsk_listen2 = TEST_SUCC(socket(PF_INET, SOCK_STREAM, 0));\n+\n+\tint reuse_option = 1;\n+\tTEST_SUCC(setsockopt(sk_listen1, SOL_SOCKET, SO_REUSEADDR,\n+\t\t\t     &reuse_option, sizeof(reuse_option)));\n+\tTEST_SUCC(setsockopt(sk_listen2, SOL_SOCKET, SO_REUSEADDR,\n+\t\t\t     &reuse_option, sizeof(reuse_option)));\n+\n+\tsk_addr.sin_port = htons(8889);\n+\tTEST_SUCC(\n+\t\tbind(sk_listen1, (struct sockaddr *)&sk_addr, sizeof(sk_addr)));\n+\tTEST_SUCC(\n+\t\tbind(sk_listen2, (struct sockaddr *)&sk_addr, sizeof(sk_addr)));\n+\n+\tTEST_SUCC(listen(sk_listen1, 3));\n+\tTEST_ERRNO(listen(sk_listen2, 3), EADDRINUSE);\n+\n+\tTEST_SUCC(close(sk_listen1));\n+\tTEST_SUCC(close(sk_listen2));\n+}\n+END_TEST()\n+\n+FN_TEST(bind_and_connect_same_address)\n+{\n+\tint sk_listen;\n+\tint sk_connect1;\n+\tint sk_connect2;\n+\n+\tsk_listen = TEST_SUCC(socket(PF_INET, SOCK_STREAM, 0));\n+\tsk_connect1 = TEST_SUCC(socket(PF_INET, SOCK_STREAM, 0));\n+\tsk_connect2 = TEST_SUCC(socket(PF_INET, SOCK_STREAM, 0));\n+\n+\tint reuse_option = 1;\n+\tTEST_SUCC(setsockopt(sk_connect1, SOL_SOCKET, SO_REUSEADDR,\n+\t\t\t     &reuse_option, sizeof(reuse_option)));\n+\tTEST_SUCC(setsockopt(sk_connect2, SOL_SOCKET, SO_REUSEADDR,\n+\t\t\t     &reuse_option, sizeof(reuse_option)));\n+\n+\tint listen_port = 8890;\n+\tint connect_port = 8891;\n+\tsk_addr.sin_port = htons(listen_port);\n+\tTEST_SUCC(\n+\t\tbind(sk_listen, (struct sockaddr *)&sk_addr, sizeof(sk_addr)));\n+\tsk_addr.sin_port = htons(connect_port);\n+\tTEST_SUCC(bind(sk_connect1, (struct sockaddr *)&sk_addr,\n+\t\t       sizeof(sk_addr)));\n+\tTEST_SUCC(bind(sk_connect2, (struct sockaddr *)&sk_addr,\n+\t\t       sizeof(sk_addr)));\n+\n+\tTEST_SUCC(listen(sk_listen, 3));\n+\n+\tsk_addr.sin_port = htons(listen_port);\n+\tTEST_SUCC(connect(sk_connect1, (struct sockaddr *)&sk_addr,\n+\t\t\t  sizeof(sk_addr)));\n+\tTEST_ERRNO(connect(sk_connect2, (struct sockaddr *)&sk_addr,\n+\t\t\t   sizeof(sk_addr)),\n+\t\t   EADDRNOTAVAIL);\n+\n+\tTEST_SUCC(close(sk_listen));\n+\tTEST_SUCC(close(sk_connect1));\n+\tTEST_SUCC(close(sk_connect2));\n+}\n+END_TEST()\n\\ No newline at end of file\ndiff --git a/tools/format_all.sh b/tools/format_all.sh\n--- a/tools/format_all.sh\n+++ b/tools/format_all.sh\n@@ -32,9 +32,9 @@ fi\n # Format the 100-line kernel demo as well\n KERNEL_DEMO_FILE=\"$WORKSPACE_ROOT/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\"\n if [ \"$CHECK_MODE\" = true ]; then\n-    cargo fmt --check -- $KERNEL_DEMO_FILE\n+    rustfmt --check $KERNEL_DEMO_FILE\n else\n-    cargo fmt -- $KERNEL_DEMO_FILE\n+    rustfmt $KERNEL_DEMO_FILE\n fi\n \n for CRATE in $EXCLUDED_CRATES; do\n",
        "problem_statement": "Network performance bacomes poor when socket number increases\n# Brief\r\n\r\nThe performance of the Asterinas network deteriorates significantly when the number of sockets (or connections) increases. This decline in performance can be observed through nginx benchmarks, which create tens of thousands of connections.\r\n\r\n# Problem\r\n\r\nSmoltcp encounters performance issues when the number of sockets becomes large. It is designed for bare-metal, real-time systems, which typically operate with only a limited number of sockets. As a result, Smoltcp iterates over all sockets to determine whether a socket can handle an incoming packet. This process becomes increasingly inefficient as the number of sockets grows.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/16a319a8ea7a0e04432bba8dfe0c4d0702083e14/kernel/libs/aster-bigtcp/src/iface/poll.rs#L158-L170\r\n\r\nIt is important to note that the number of sockets requiring iteration can be substantial, even when the number of active connections is small:\r\n\r\n- The backlog of sockets can be extensive. Each backlog socket corresponds to a listening socket.\r\n- The number of sockets in the TIME_WAIT state can also be significant. Each TIME_WAIT socket remains active for 10 seconds based on the current implementation.\r\n\r\n# Solution\r\n\r\nWith the introduction of bigtcp as a wrapper for Smoltcp, there may be an opportunity to address this problem within bigtcp. We might consider implementing a mechanism similar to the inet hash table used in Linux for socket lookup. For reference, see: [Linux inet hash table](https://elixir.bootlin.com/linux/v6.0.9/source/include/net/inet_hashtables.h#L292).\n",
        "hints_text": "",
        "created_at": "2024-12-24T07:59:02Z",
        "version": "0.11"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1724,
        "instance_id": "asterinas__asterinas-1724",
        "issue_numbers": [
            "1077"
        ],
        "base_commit": "2f82ca846fc886b9bbdb72399bf017a8b0bedbbe",
        "patch": "diff --git a/kernel/comps/block/src/bio.rs b/kernel/comps/block/src/bio.rs\n--- a/kernel/comps/block/src/bio.rs\n+++ b/kernel/comps/block/src/bio.rs\n@@ -5,7 +5,7 @@ use bitvec::array::BitArray;\n use int_to_c_enum::TryFromInt;\n use ostd::{\n     mm::{\n-        DmaDirection, DmaStream, DmaStreamSlice, FrameAllocOptions, Infallible, Segment, VmIo,\n+        DmaDirection, DmaStream, DmaStreamSlice, FrameAllocOptions, Infallible, USegment, VmIo,\n         VmReader, VmWriter,\n     },\n     sync::{SpinLock, WaitQueue},\ndiff --git a/kernel/comps/block/src/bio.rs b/kernel/comps/block/src/bio.rs\n--- a/kernel/comps/block/src/bio.rs\n+++ b/kernel/comps/block/src/bio.rs\n@@ -426,11 +426,11 @@ impl<'a> BioSegment {\n         let bio_segment_inner = target_pool(direction)\n             .and_then(|pool| pool.alloc(nblocks, offset_within_first_block, len))\n             .unwrap_or_else(|| {\n-                let segment = FrameAllocOptions::new(nblocks)\n-                    .uninit(true)\n-                    .alloc_contiguous()\n+                let segment = FrameAllocOptions::new()\n+                    .zeroed(false)\n+                    .alloc_segment(nblocks)\n                     .unwrap();\n-                let dma_stream = DmaStream::map(segment, direction.into(), false).unwrap();\n+                let dma_stream = DmaStream::map(segment.into(), direction.into(), false).unwrap();\n                 BioSegmentInner {\n                     dma_slice: DmaStreamSlice::new(dma_stream, offset_within_first_block, len),\n                     from_pool: false,\ndiff --git a/kernel/comps/block/src/bio.rs b/kernel/comps/block/src/bio.rs\n--- a/kernel/comps/block/src/bio.rs\n+++ b/kernel/comps/block/src/bio.rs\n@@ -442,9 +442,9 @@ impl<'a> BioSegment {\n         }\n     }\n \n-    /// Constructs a new `BioSegment` with a given `Segment` and the bio direction.\n-    pub fn new_from_segment(segment: Segment, direction: BioDirection) -> Self {\n-        let len = segment.nbytes();\n+    /// Constructs a new `BioSegment` with a given `USegment` and the bio direction.\n+    pub fn new_from_segment(segment: USegment, direction: BioDirection) -> Self {\n+        let len = segment.size();\n         let dma_stream = DmaStream::map(segment, direction.into(), false).unwrap();\n         Self {\n             inner: Arc::new(BioSegmentInner {\ndiff --git a/kernel/comps/block/src/bio.rs b/kernel/comps/block/src/bio.rs\n--- a/kernel/comps/block/src/bio.rs\n+++ b/kernel/comps/block/src/bio.rs\n@@ -560,11 +560,11 @@ impl BioSegmentPool {\n     pub fn new(direction: BioDirection) -> Self {\n         let total_blocks = POOL_DEFAULT_NBLOCKS;\n         let pool = {\n-            let segment = FrameAllocOptions::new(total_blocks)\n-                .uninit(true)\n-                .alloc_contiguous()\n+            let segment = FrameAllocOptions::new()\n+                .zeroed(false)\n+                .alloc_segment(total_blocks)\n                 .unwrap();\n-            DmaStream::map(segment, direction.into(), false).unwrap()\n+            DmaStream::map(segment.into(), direction.into(), false).unwrap()\n         };\n         let manager = SpinLock::new(PoolSlotManager {\n             occupied: BitArray::ZERO,\ndiff --git a/kernel/comps/network/src/buffer.rs b/kernel/comps/network/src/buffer.rs\n--- a/kernel/comps/network/src/buffer.rs\n+++ b/kernel/comps/network/src/buffer.rs\n@@ -34,10 +34,10 @@ impl TxBuffer {\n         let dma_stream = if let Some(stream) = pool.lock().pop_front() {\n             stream\n         } else {\n-            let segment = FrameAllocOptions::new(TX_BUFFER_LEN / PAGE_SIZE)\n-                .alloc_contiguous()\n+            let segment = FrameAllocOptions::new()\n+                .alloc_segment(TX_BUFFER_LEN / PAGE_SIZE)\n                 .unwrap();\n-            DmaStream::map(segment, DmaDirection::ToDevice, false).unwrap()\n+            DmaStream::map(segment.into(), DmaDirection::ToDevice, false).unwrap()\n         };\n \n         let tx_buffer = {\ndiff --git a/kernel/comps/network/src/dma_pool.rs b/kernel/comps/network/src/dma_pool.rs\n--- a/kernel/comps/network/src/dma_pool.rs\n+++ b/kernel/comps/network/src/dma_pool.rs\n@@ -152,9 +152,9 @@ impl DmaPage {\n         pool: Weak<DmaPool>,\n     ) -> Result<Self, ostd::Error> {\n         let dma_stream = {\n-            let segment = FrameAllocOptions::new(1).alloc_contiguous()?;\n+            let segment = FrameAllocOptions::new().alloc_segment(1)?;\n \n-            DmaStream::map(segment, direction, is_cache_coherent)\n+            DmaStream::map(segment.into(), direction, is_cache_coherent)\n                 .map_err(|_| ostd::Error::AccessDenied)?\n         };\n \ndiff --git a/kernel/comps/virtio/src/device/block/device.rs b/kernel/comps/virtio/src/device/block/device.rs\n--- a/kernel/comps/virtio/src/device/block/device.rs\n+++ b/kernel/comps/virtio/src/device/block/device.rs\n@@ -141,13 +141,13 @@ impl DeviceInner {\n         let queue = VirtQueue::new(0, Self::QUEUE_SIZE, transport.as_mut())\n             .expect(\"create virtqueue failed\");\n         let block_requests = {\n-            let vm_segment = FrameAllocOptions::new(1).alloc_contiguous().unwrap();\n-            DmaStream::map(vm_segment, DmaDirection::Bidirectional, false).unwrap()\n+            let segment = FrameAllocOptions::new().alloc_segment(1).unwrap();\n+            DmaStream::map(segment.into(), DmaDirection::Bidirectional, false).unwrap()\n         };\n         assert!(Self::QUEUE_SIZE as usize * REQ_SIZE <= block_requests.nbytes());\n         let block_responses = {\n-            let vm_segment = FrameAllocOptions::new(1).alloc_contiguous().unwrap();\n-            DmaStream::map(vm_segment, DmaDirection::Bidirectional, false).unwrap()\n+            let segment = FrameAllocOptions::new().alloc_segment(1).unwrap();\n+            DmaStream::map(segment.into(), DmaDirection::Bidirectional, false).unwrap()\n         };\n         assert!(Self::QUEUE_SIZE as usize * RESP_SIZE <= block_responses.nbytes());\n \ndiff --git a/kernel/comps/virtio/src/device/block/device.rs b/kernel/comps/virtio/src/device/block/device.rs\n--- a/kernel/comps/virtio/src/device/block/device.rs\n+++ b/kernel/comps/virtio/src/device/block/device.rs\n@@ -261,11 +261,11 @@ impl DeviceInner {\n         };\n         const MAX_ID_LENGTH: usize = 20;\n         let device_id_stream = {\n-            let segment = FrameAllocOptions::new(1)\n-                .uninit(true)\n-                .alloc_contiguous()\n+            let segment = FrameAllocOptions::new()\n+                .zeroed(false)\n+                .alloc_segment(1)\n                 .unwrap();\n-            DmaStream::map(segment, DmaDirection::FromDevice, false).unwrap()\n+            DmaStream::map(segment.into(), DmaDirection::FromDevice, false).unwrap()\n         };\n         let device_id_slice = DmaStreamSlice::new(&device_id_stream, 0, MAX_ID_LENGTH);\n         let outputs = vec![&device_id_slice, &resp_slice];\ndiff --git a/kernel/comps/virtio/src/device/console/device.rs b/kernel/comps/virtio/src/device/console/device.rs\n--- a/kernel/comps/virtio/src/device/console/device.rs\n+++ b/kernel/comps/virtio/src/device/console/device.rs\n@@ -87,13 +87,13 @@ impl ConsoleDevice {\n             SpinLock::new(VirtQueue::new(TRANSMIT0_QUEUE_INDEX, 2, transport.as_mut()).unwrap());\n \n         let send_buffer = {\n-            let vm_segment = FrameAllocOptions::new(1).alloc_contiguous().unwrap();\n-            DmaStream::map(vm_segment, DmaDirection::ToDevice, false).unwrap()\n+            let segment = FrameAllocOptions::new().alloc_segment(1).unwrap();\n+            DmaStream::map(segment.into(), DmaDirection::ToDevice, false).unwrap()\n         };\n \n         let receive_buffer = {\n-            let vm_segment = FrameAllocOptions::new(1).alloc_contiguous().unwrap();\n-            DmaStream::map(vm_segment, DmaDirection::FromDevice, false).unwrap()\n+            let segment = FrameAllocOptions::new().alloc_segment(1).unwrap();\n+            DmaStream::map(segment.into(), DmaDirection::FromDevice, false).unwrap()\n         };\n \n         let device = Arc::new(Self {\ndiff --git a/kernel/comps/virtio/src/device/input/device.rs b/kernel/comps/virtio/src/device/input/device.rs\n--- a/kernel/comps/virtio/src/device/input/device.rs\n+++ b/kernel/comps/virtio/src/device/input/device.rs\n@@ -261,14 +261,14 @@ impl EventTable {\n     fn new(num_events: usize) -> Self {\n         assert!(num_events * mem::size_of::<VirtioInputEvent>() <= PAGE_SIZE);\n \n-        let vm_segment = FrameAllocOptions::new(1).alloc_contiguous().unwrap();\n+        let segment = FrameAllocOptions::new().alloc_segment(1).unwrap();\n \n         let default_event = VirtioInputEvent::default();\n         let iter = iter::repeat(&default_event).take(EVENT_SIZE);\n-        let nr_written = vm_segment.write_vals(0, iter, 0).unwrap();\n+        let nr_written = segment.write_vals(0, iter, 0).unwrap();\n         assert_eq!(nr_written, EVENT_SIZE);\n \n-        let stream = DmaStream::map(vm_segment, DmaDirection::FromDevice, false).unwrap();\n+        let stream = DmaStream::map(segment.into(), DmaDirection::FromDevice, false).unwrap();\n         Self { stream, num_events }\n     }\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -76,7 +76,7 @@ impl VirtQueue {\n         }\n \n         let (descriptor_ptr, avail_ring_ptr, used_ring_ptr) = if transport.is_legacy_version() {\n-            // Currently, we use one Frame to place the descriptors and available rings, one Frame to place used rings\n+            // Currently, we use one UFrame to place the descriptors and available rings, one UFrame to place used rings\n             // because the virtio-mmio legacy required the address to be continuous. The max queue size is 128.\n             if size > 128 {\n                 return Err(QueueError::InvalidArgs);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -89,8 +89,8 @@ impl VirtQueue {\n                 let align_size = VirtioPciLegacyTransport::QUEUE_ALIGN_SIZE;\n                 let total_frames =\n                     VirtioPciLegacyTransport::calc_virtqueue_size_aligned(queue_size) / align_size;\n-                let continue_segment = FrameAllocOptions::new(total_frames)\n-                    .alloc_contiguous()\n+                let continue_segment = FrameAllocOptions::new()\n+                    .alloc_segment(total_frames)\n                     .unwrap();\n \n                 let avial_size = size_of::<u16>() * (3 + queue_size);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -99,12 +99,12 @@ impl VirtQueue {\n                 continue_segment.split(seg1_frames * align_size)\n             };\n             let desc_frame_ptr: SafePtr<Descriptor, DmaCoherent> =\n-                SafePtr::new(DmaCoherent::map(seg1, true).unwrap(), 0);\n+                SafePtr::new(DmaCoherent::map(seg1.into(), true).unwrap(), 0);\n             let mut avail_frame_ptr: SafePtr<AvailRing, DmaCoherent> =\n                 desc_frame_ptr.clone().cast();\n             avail_frame_ptr.byte_add(desc_size);\n             let used_frame_ptr: SafePtr<UsedRing, DmaCoherent> =\n-                SafePtr::new(DmaCoherent::map(seg2, true).unwrap(), 0);\n+                SafePtr::new(DmaCoherent::map(seg2.into(), true).unwrap(), 0);\n             (desc_frame_ptr, avail_frame_ptr, used_frame_ptr)\n         } else {\n             if size > 256 {\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -112,18 +112,27 @@ impl VirtQueue {\n             }\n             (\n                 SafePtr::new(\n-                    DmaCoherent::map(FrameAllocOptions::new(1).alloc_contiguous().unwrap(), true)\n-                        .unwrap(),\n+                    DmaCoherent::map(\n+                        FrameAllocOptions::new().alloc_segment(1).unwrap().into(),\n+                        true,\n+                    )\n+                    .unwrap(),\n                     0,\n                 ),\n                 SafePtr::new(\n-                    DmaCoherent::map(FrameAllocOptions::new(1).alloc_contiguous().unwrap(), true)\n-                        .unwrap(),\n+                    DmaCoherent::map(\n+                        FrameAllocOptions::new().alloc_segment(1).unwrap().into(),\n+                        true,\n+                    )\n+                    .unwrap(),\n                     0,\n                 ),\n                 SafePtr::new(\n-                    DmaCoherent::map(FrameAllocOptions::new(1).alloc_contiguous().unwrap(), true)\n-                        .unwrap(),\n+                    DmaCoherent::map(\n+                        FrameAllocOptions::new().alloc_segment(1).unwrap().into(),\n+                        true,\n+                    )\n+                    .unwrap(),\n                     0,\n                 ),\n             )\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -54,7 +54,7 @@ use ostd::{\n ///\n /// The generic parameter `M` of `SafePtr<_, M, _>` must implement the `VmIo`\n /// trait. The most important `VmIo` types are `Vmar`, `Vmo`, `IoMem`, and\n-/// `Frame`. The blanket implementations of `VmIo` also include pointer-like\n+/// `UFrame`. The blanket implementations of `VmIo` also include pointer-like\n /// types that refer to a `VmIo` type. Some examples are `&Vmo`, `Box<Vmar>`,\n /// and `Arc<IoMem>`.\n ///\ndiff --git a/kernel/libs/aster-util/src/segment_slice.rs b/kernel/libs/aster-util/src/segment_slice.rs\n--- a/kernel/libs/aster-util/src/segment_slice.rs\n+++ b/kernel/libs/aster-util/src/segment_slice.rs\n@@ -2,41 +2,41 @@\n \n // SPDX-License-Identifier: MPL-2.0\n \n-//! Provides [`SegmentSlice`] for quick duplication and slicing over [`Segment`].\n+//! Provides [`SegmentSlice`] for quick duplication and slicing over [`USegment`].\n \n use alloc::sync::Arc;\n use core::ops::Range;\n \n use ostd::{\n     mm::{\n-        FallibleVmRead, FallibleVmWrite, Frame, Infallible, Paddr, Segment, VmIo, VmReader,\n-        VmWriter, PAGE_SIZE,\n+        FallibleVmRead, FallibleVmWrite, Infallible, Paddr, UFrame, USegment, UntypedMem, VmIo,\n+        VmReader, VmWriter, PAGE_SIZE,\n     },\n     Error, Result,\n };\n \n-/// A reference to a slice of a [`Segment`].\n+/// A reference to a slice of a [`USegment`].\n ///\n /// Cloning a [`SegmentSlice`] is cheap, as it only increments one reference\n-/// count. While cloning a [`Segment`] will increment the reference count of\n+/// count. While cloning a [`USegment`] will increment the reference count of\n /// many underlying pages.\n ///\n /// The downside is that the [`SegmentSlice`] requires heap allocation. Also,\n-/// if any [`SegmentSlice`] of the original [`Segment`] is alive, all pages in\n-/// the original [`Segment`], including the pages that are not referenced, will\n+/// if any [`SegmentSlice`] of the original [`USegment`] is alive, all pages in\n+/// the original [`USegment`], including the pages that are not referenced, will\n /// not be freed.\n #[derive(Debug, Clone)]\n pub struct SegmentSlice {\n-    inner: Arc<Segment>,\n+    inner: Arc<USegment>,\n     range: Range<usize>,\n }\n \n impl SegmentSlice {\n-    /// Returns a part of the `Segment`.\n+    /// Returns a part of the `USegment`.\n     ///\n     /// # Panics\n     ///\n-    /// If `range` is not within the range of this `Segment`,\n+    /// If `range` is not within the range of this `USegment`,\n     /// then the method panics.\n     pub fn range(&self, range: Range<usize>) -> Self {\n         let orig_range = &self.range;\ndiff --git a/kernel/libs/aster-util/src/segment_slice.rs b/kernel/libs/aster-util/src/segment_slice.rs\n--- a/kernel/libs/aster-util/src/segment_slice.rs\n+++ b/kernel/libs/aster-util/src/segment_slice.rs\n@@ -124,9 +124,9 @@ impl VmIo for SegmentSlice {\n     }\n }\n \n-impl From<Segment> for SegmentSlice {\n-    fn from(segment: Segment) -> Self {\n-        let range = 0..segment.nbytes() / PAGE_SIZE;\n+impl From<USegment> for SegmentSlice {\n+    fn from(segment: USegment) -> Self {\n+        let range = 0..segment.size() / PAGE_SIZE;\n         Self {\n             inner: Arc::new(segment),\n             range,\ndiff --git a/kernel/libs/aster-util/src/segment_slice.rs b/kernel/libs/aster-util/src/segment_slice.rs\n--- a/kernel/libs/aster-util/src/segment_slice.rs\n+++ b/kernel/libs/aster-util/src/segment_slice.rs\n@@ -134,7 +134,7 @@ impl From<Segment> for SegmentSlice {\n     }\n }\n \n-impl From<SegmentSlice> for Segment {\n+impl From<SegmentSlice> for USegment {\n     fn from(slice: SegmentSlice) -> Self {\n         let start = slice.range.start * PAGE_SIZE;\n         let end = slice.range.end * PAGE_SIZE;\ndiff --git a/kernel/libs/aster-util/src/segment_slice.rs b/kernel/libs/aster-util/src/segment_slice.rs\n--- a/kernel/libs/aster-util/src/segment_slice.rs\n+++ b/kernel/libs/aster-util/src/segment_slice.rs\n@@ -142,8 +142,8 @@ impl From<SegmentSlice> for Segment {\n     }\n }\n \n-impl From<Frame> for SegmentSlice {\n-    fn from(frame: Frame) -> Self {\n-        SegmentSlice::from(Segment::from(frame))\n+impl From<UFrame> for SegmentSlice {\n+    fn from(frame: UFrame) -> Self {\n+        SegmentSlice::from(USegment::from(frame))\n     }\n }\ndiff --git a/kernel/src/device/tdxguest/mod.rs b/kernel/src/device/tdxguest/mod.rs\n--- a/kernel/src/device/tdxguest/mod.rs\n+++ b/kernel/src/device/tdxguest/mod.rs\n@@ -88,11 +88,8 @@ fn handle_get_report(arg: usize) -> Result<i32> {\n     let user_space = CurrentUserSpace::new(&current_task);\n     let user_request: TdxReportRequest = user_space.read_val(arg)?;\n \n-    let vm_segment = FrameAllocOptions::new(2)\n-        .is_contiguous(true)\n-        .alloc_contiguous()\n-        .unwrap();\n-    let dma_coherent = DmaCoherent::map(vm_segment, false).unwrap();\n+    let segment = FrameAllocOptions::new().alloc_segment(2).unwrap();\n+    let dma_coherent = DmaCoherent::map(segment.into(), false).unwrap();\n     dma_coherent\n         .write_bytes(0, &user_request.report_data)\n         .unwrap();\ndiff --git a/kernel/src/fs/exfat/fs.rs b/kernel/src/fs/exfat/fs.rs\n--- a/kernel/src/fs/exfat/fs.rs\n+++ b/kernel/src/fs/exfat/fs.rs\n@@ -12,7 +12,7 @@ use aster_block::{\n };\n use hashbrown::HashMap;\n use lru::LruCache;\n-use ostd::mm::Frame;\n+use ostd::mm::Segment;\n pub(super) use ostd::mm::VmIo;\n \n use super::{\ndiff --git a/kernel/src/fs/exfat/fs.rs b/kernel/src/fs/exfat/fs.rs\n--- a/kernel/src/fs/exfat/fs.rs\n+++ b/kernel/src/fs/exfat/fs.rs\n@@ -25,7 +25,7 @@ use super::{\n use crate::{\n     fs::{\n         exfat::{constants::*, inode::Ino},\n-        utils::{FileSystem, FsFlags, Inode, PageCache, PageCacheBackend, SuperBlock},\n+        utils::{CachePage, FileSystem, FsFlags, Inode, PageCache, PageCacheBackend, SuperBlock},\n     },\n     prelude::*,\n };\ndiff --git a/kernel/src/fs/exfat/fs.rs b/kernel/src/fs/exfat/fs.rs\n--- a/kernel/src/fs/exfat/fs.rs\n+++ b/kernel/src/fs/exfat/fs.rs\n@@ -368,24 +368,28 @@ impl ExfatFS {\n }\n \n impl PageCacheBackend for ExfatFS {\n-    fn read_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn read_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         if self.fs_size() < idx * PAGE_SIZE {\n             return_errno_with_message!(Errno::EINVAL, \"invalid read size\")\n         }\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::FromDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::FromDevice,\n+        );\n         let waiter = self\n             .block_device\n             .read_blocks_async(BlockId::new(idx as u64), bio_segment)?;\n         Ok(waiter)\n     }\n \n-    fn write_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn write_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         if self.fs_size() < idx * PAGE_SIZE {\n             return_errno_with_message!(Errno::EINVAL, \"invalid write size\")\n         }\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::ToDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::ToDevice,\n+        );\n         let waiter = self\n             .block_device\n             .write_blocks_async(BlockId::new(idx as u64), bio_segment)?;\ndiff --git a/kernel/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\n--- a/kernel/src/fs/exfat/inode.rs\n+++ b/kernel/src/fs/exfat/inode.rs\n@@ -13,7 +13,7 @@ use aster_block::{\n     BLOCK_SIZE,\n };\n use aster_rights::Full;\n-use ostd::mm::{Frame, VmIo};\n+use ostd::mm::{Segment, VmIo};\n \n use super::{\n     constants::*,\ndiff --git a/kernel/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\n--- a/kernel/src/fs/exfat/inode.rs\n+++ b/kernel/src/fs/exfat/inode.rs\n@@ -30,8 +30,8 @@ use crate::{\n     fs::{\n         exfat::{dentry::ExfatDentryIterator, fat::ExfatChain, fs::ExfatFS},\n         utils::{\n-            DirentVisitor, Extension, Inode, InodeMode, InodeType, IoctlCmd, Metadata, MknodType,\n-            PageCache, PageCacheBackend,\n+            CachePage, DirentVisitor, Extension, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n+            MknodType, PageCache, PageCacheBackend,\n         },\n     },\n     prelude::*,\ndiff --git a/kernel/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\n--- a/kernel/src/fs/exfat/inode.rs\n+++ b/kernel/src/fs/exfat/inode.rs\n@@ -135,14 +135,16 @@ struct ExfatInodeInner {\n }\n \n impl PageCacheBackend for ExfatInode {\n-    fn read_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn read_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let inner = self.inner.read();\n         if inner.size < idx * PAGE_SIZE {\n             return_errno_with_message!(Errno::EINVAL, \"Invalid read size\")\n         }\n         let sector_id = inner.get_sector_id(idx * PAGE_SIZE / inner.fs().sector_size())?;\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::FromDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::FromDevice,\n+        );\n         let waiter = inner.fs().block_device().read_blocks_async(\n             BlockId::from_offset(sector_id * inner.fs().sector_size()),\n             bio_segment,\ndiff --git a/kernel/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\n--- a/kernel/src/fs/exfat/inode.rs\n+++ b/kernel/src/fs/exfat/inode.rs\n@@ -150,7 +152,7 @@ impl PageCacheBackend for ExfatInode {\n         Ok(waiter)\n     }\n \n-    fn write_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn write_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let inner = self.inner.read();\n         let sector_size = inner.fs().sector_size();\n \ndiff --git a/kernel/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\n--- a/kernel/src/fs/exfat/inode.rs\n+++ b/kernel/src/fs/exfat/inode.rs\n@@ -158,8 +160,10 @@ impl PageCacheBackend for ExfatInode {\n \n         // FIXME: We may need to truncate the file if write_page fails.\n         // To fix this issue, we need to change the interface of the PageCacheBackend trait.\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::ToDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::ToDevice,\n+        );\n         let waiter = inner.fs().block_device().write_blocks_async(\n             BlockId::from_offset(sector_id * inner.fs().sector_size()),\n             bio_segment,\ndiff --git a/kernel/src/fs/ext2/block_group.rs b/kernel/src/fs/ext2/block_group.rs\n--- a/kernel/src/fs/ext2/block_group.rs\n+++ b/kernel/src/fs/ext2/block_group.rs\n@@ -28,7 +28,7 @@ struct BlockGroupImpl {\n impl BlockGroup {\n     /// Loads and constructs a block group.\n     pub fn load(\n-        group_descriptors_segment: &Segment,\n+        group_descriptors_segment: &USegment,\n         idx: usize,\n         block_device: &dyn BlockDevice,\n         super_block: &SuperBlock,\ndiff --git a/kernel/src/fs/ext2/block_group.rs b/kernel/src/fs/ext2/block_group.rs\n--- a/kernel/src/fs/ext2/block_group.rs\n+++ b/kernel/src/fs/ext2/block_group.rs\n@@ -318,20 +318,24 @@ impl Debug for BlockGroup {\n }\n \n impl PageCacheBackend for BlockGroupImpl {\n-    fn read_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn read_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let bid = self.inode_table_bid + idx as Ext2Bid;\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::FromDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::FromDevice,\n+        );\n         self.fs\n             .upgrade()\n             .unwrap()\n             .read_blocks_async(bid, bio_segment)\n     }\n \n-    fn write_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn write_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let bid = self.inode_table_bid + idx as Ext2Bid;\n-        let bio_segment =\n-            BioSegment::new_from_segment(frame.clone().into(), BioDirection::ToDevice);\n+        let bio_segment = BioSegment::new_from_segment(\n+            Segment::from(frame.clone()).into(),\n+            BioDirection::ToDevice,\n+        );\n         self.fs\n             .upgrade()\n             .unwrap()\ndiff --git a/kernel/src/fs/ext2/fs.rs b/kernel/src/fs/ext2/fs.rs\n--- a/kernel/src/fs/ext2/fs.rs\n+++ b/kernel/src/fs/ext2/fs.rs\n@@ -23,7 +23,7 @@ pub struct Ext2 {\n     blocks_per_group: Ext2Bid,\n     inode_size: usize,\n     block_size: usize,\n-    group_descriptors_segment: Segment,\n+    group_descriptors_segment: USegment,\n     self_ref: Weak<Self>,\n }\n \ndiff --git a/kernel/src/fs/ext2/fs.rs b/kernel/src/fs/ext2/fs.rs\n--- a/kernel/src/fs/ext2/fs.rs\n+++ b/kernel/src/fs/ext2/fs.rs\n@@ -42,28 +42,28 @@ impl Ext2 {\n             \"currently only support 4096-byte block size\"\n         );\n \n-        let group_descriptors_segment = {\n+        let group_descriptors_segment: USegment = {\n             let npages = ((super_block.block_groups_count() as usize)\n                 * core::mem::size_of::<RawGroupDescriptor>())\n             .div_ceil(BLOCK_SIZE);\n-            let segment = FrameAllocOptions::new(npages)\n-                .uninit(true)\n-                .alloc_contiguous()?;\n+            let segment = FrameAllocOptions::new()\n+                .zeroed(false)\n+                .alloc_segment(npages)?;\n             let bio_segment =\n-                BioSegment::new_from_segment(segment.clone(), BioDirection::FromDevice);\n+                BioSegment::new_from_segment(segment.clone().into(), BioDirection::FromDevice);\n             match block_device.read_blocks(super_block.group_descriptors_bid(0), bio_segment)? {\n                 BioStatus::Complete => (),\n                 err_status => {\n                     return Err(Error::from(err_status));\n                 }\n             }\n-            segment\n+            segment.into()\n         };\n \n         // Load the block groups information\n         let load_block_groups = |fs: Weak<Ext2>,\n                                  block_device: &dyn BlockDevice,\n-                                 group_descriptors_segment: &Segment|\n+                                 group_descriptors_segment: &USegment|\n          -> Result<Vec<BlockGroup>> {\n             let block_groups_count = super_block.block_groups_count() as usize;\n             let mut block_groups = Vec::with_capacity(block_groups_count);\ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -42,8 +42,10 @@ impl IndirectBlockCache {\n         let fs = self.fs();\n         let load_block = || -> Result<IndirectBlock> {\n             let mut block = IndirectBlock::alloc_uninit()?;\n-            let bio_segment =\n-                BioSegment::new_from_segment(block.frame.clone().into(), BioDirection::FromDevice);\n+            let bio_segment = BioSegment::new_from_segment(\n+                Segment::<()>::from(block.frame.clone()).into(),\n+                BioDirection::FromDevice,\n+            );\n             fs.read_blocks(bid, bio_segment)?;\n             block.state = State::UpToDate;\n             Ok(block)\ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -61,8 +63,10 @@ impl IndirectBlockCache {\n         let fs = self.fs();\n         let load_block = || -> Result<IndirectBlock> {\n             let mut block = IndirectBlock::alloc_uninit()?;\n-            let bio_segment =\n-                BioSegment::new_from_segment(block.frame.clone().into(), BioDirection::FromDevice);\n+            let bio_segment = BioSegment::new_from_segment(\n+                Segment::<()>::from(block.frame.clone()).into(),\n+                BioDirection::FromDevice,\n+            );\n             fs.read_blocks(bid, bio_segment)?;\n             block.state = State::UpToDate;\n             Ok(block)\ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -109,7 +113,7 @@ impl IndirectBlockCache {\n             let (bid, block) = self.cache.pop_lru().unwrap();\n             if block.is_dirty() {\n                 let bio_segment = BioSegment::new_from_segment(\n-                    block.frame.clone().into(),\n+                    Segment::<()>::from(block.frame.clone()).into(),\n                     BioDirection::ToDevice,\n                 );\n                 bio_waiter.concat(self.fs().write_blocks_async(bid, bio_segment)?);\ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -132,7 +136,7 @@ impl IndirectBlockCache {\n /// Represents a single indirect block buffer cached by the `IndirectCache`.\n #[derive(Clone, Debug)]\n pub struct IndirectBlock {\n-    frame: Frame,\n+    frame: Frame<()>,\n     state: State,\n }\n \ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -140,7 +144,7 @@ impl IndirectBlock {\n     /// Allocates an uninitialized block whose bytes are to be populated with\n     /// data loaded from the disk.\n     fn alloc_uninit() -> Result<Self> {\n-        let frame = FrameAllocOptions::new(1).uninit(true).alloc_single()?;\n+        let frame = FrameAllocOptions::new().zeroed(false).alloc_frame()?;\n         Ok(Self {\n             frame,\n             state: State::Uninit,\ndiff --git a/kernel/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\n--- a/kernel/src/fs/ext2/indirect_block_cache.rs\n+++ b/kernel/src/fs/ext2/indirect_block_cache.rs\n@@ -149,7 +153,7 @@ impl IndirectBlock {\n \n     /// Allocates a new block with its bytes initialized to zero.\n     pub fn alloc() -> Result<Self> {\n-        let frame = FrameAllocOptions::new(1).alloc_single()?;\n+        let frame = FrameAllocOptions::new().alloc_frame()?;\n         Ok(Self {\n             frame,\n             state: State::Dirty,\ndiff --git a/kernel/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\n--- a/kernel/src/fs/ext2/inode.rs\n+++ b/kernel/src/fs/ext2/inode.rs\n@@ -1733,7 +1733,7 @@ impl InodeImpl {\n         writer: &mut VmWriter,\n     ) -> Result<BioWaiter>;\n     pub fn read_blocks(&self, bid: Ext2Bid, nblocks: usize, writer: &mut VmWriter) -> Result<()>;\n-    pub fn read_block_async(&self, bid: Ext2Bid, frame: &Frame) -> Result<BioWaiter>;\n+    pub fn read_block_async(&self, bid: Ext2Bid, frame: &CachePage) -> Result<BioWaiter>;\n     pub fn write_blocks_async(\n         &self,\n         bid: Ext2Bid,\ndiff --git a/kernel/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\n--- a/kernel/src/fs/ext2/inode.rs\n+++ b/kernel/src/fs/ext2/inode.rs\n@@ -1741,7 +1741,7 @@ impl InodeImpl {\n         reader: &mut VmReader,\n     ) -> Result<BioWaiter>;\n     pub fn write_blocks(&self, bid: Ext2Bid, nblocks: usize, reader: &mut VmReader) -> Result<()>;\n-    pub fn write_block_async(&self, bid: Ext2Bid, frame: &Frame) -> Result<BioWaiter>;\n+    pub fn write_block_async(&self, bid: Ext2Bid, frame: &CachePage) -> Result<BioWaiter>;\n }\n \n /// Manages the inode blocks and block I/O operations.\ndiff --git a/kernel/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\n--- a/kernel/src/fs/ext2/inode.rs\n+++ b/kernel/src/fs/ext2/inode.rs\n@@ -1789,13 +1789,15 @@ impl InodeBlockManager {\n         }\n     }\n \n-    pub fn read_block_async(&self, bid: Ext2Bid, frame: &Frame) -> Result<BioWaiter> {\n+    pub fn read_block_async(&self, bid: Ext2Bid, frame: &CachePage) -> Result<BioWaiter> {\n         let mut bio_waiter = BioWaiter::new();\n \n         for dev_range in DeviceRangeReader::new(self, bid..bid + 1 as Ext2Bid)? {\n             let start_bid = dev_range.start as Ext2Bid;\n-            let bio_segment =\n-                BioSegment::new_from_segment(frame.clone().into(), BioDirection::FromDevice);\n+            let bio_segment = BioSegment::new_from_segment(\n+                Segment::from(frame.clone()).into(),\n+                BioDirection::FromDevice,\n+            );\n             let waiter = self.fs().read_blocks_async(start_bid, bio_segment)?;\n             bio_waiter.concat(waiter);\n         }\ndiff --git a/kernel/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\n--- a/kernel/src/fs/ext2/inode.rs\n+++ b/kernel/src/fs/ext2/inode.rs\n@@ -1834,13 +1836,15 @@ impl InodeBlockManager {\n         }\n     }\n \n-    pub fn write_block_async(&self, bid: Ext2Bid, frame: &Frame) -> Result<BioWaiter> {\n+    pub fn write_block_async(&self, bid: Ext2Bid, frame: &CachePage) -> Result<BioWaiter> {\n         let mut bio_waiter = BioWaiter::new();\n \n         for dev_range in DeviceRangeReader::new(self, bid..bid + 1 as Ext2Bid)? {\n             let start_bid = dev_range.start as Ext2Bid;\n-            let bio_segment =\n-                BioSegment::new_from_segment(frame.clone().into(), BioDirection::ToDevice);\n+            let bio_segment = BioSegment::new_from_segment(\n+                Segment::from(frame.clone()).into(),\n+                BioDirection::ToDevice,\n+            );\n             let waiter = self.fs().write_blocks_async(start_bid, bio_segment)?;\n             bio_waiter.concat(waiter);\n         }\ndiff --git a/kernel/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\n--- a/kernel/src/fs/ext2/inode.rs\n+++ b/kernel/src/fs/ext2/inode.rs\n@@ -1858,12 +1862,12 @@ impl InodeBlockManager {\n }\n \n impl PageCacheBackend for InodeBlockManager {\n-    fn read_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn read_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let bid = idx as Ext2Bid;\n         self.read_block_async(bid, frame)\n     }\n \n-    fn write_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn write_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         let bid = idx as Ext2Bid;\n         self.write_block_async(bid, frame)\n     }\ndiff --git a/kernel/src/fs/ext2/prelude.rs b/kernel/src/fs/ext2/prelude.rs\n--- a/kernel/src/fs/ext2/prelude.rs\n+++ b/kernel/src/fs/ext2/prelude.rs\n@@ -13,14 +13,16 @@ pub(super) use aster_block::{\n };\n pub(super) use aster_rights::Full;\n pub(super) use ostd::{\n-    mm::{Frame, FrameAllocOptions, Segment, VmIo},\n+    mm::{Frame, FrameAllocOptions, Segment, USegment, VmIo},\n     sync::{RwMutex, RwMutexReadGuard, RwMutexWriteGuard},\n };\n pub(super) use static_assertions::const_assert;\n \n pub(super) use super::utils::{Dirty, IsPowerOf};\n pub(super) use crate::{\n-    fs::utils::{CStr256, DirentVisitor, InodeType, PageCache, PageCacheBackend, Str16, Str64},\n+    fs::utils::{\n+        CStr256, CachePage, DirentVisitor, InodeType, PageCache, PageCacheBackend, Str16, Str64,\n+    },\n     prelude::*,\n     time::UnixTime,\n     vm::vmo::Vmo,\ndiff --git a/kernel/src/fs/ramfs/fs.rs b/kernel/src/fs/ramfs/fs.rs\n--- a/kernel/src/fs/ramfs/fs.rs\n+++ b/kernel/src/fs/ramfs/fs.rs\n@@ -11,7 +11,7 @@ use aster_rights::Full;\n use aster_util::slot_vec::SlotVec;\n use hashbrown::HashMap;\n use ostd::{\n-    mm::{Frame, VmIo},\n+    mm::{UntypedMem, VmIo},\n     sync::{PreemptDisabled, RwLockWriteGuard},\n };\n \ndiff --git a/kernel/src/fs/ramfs/fs.rs b/kernel/src/fs/ramfs/fs.rs\n--- a/kernel/src/fs/ramfs/fs.rs\n+++ b/kernel/src/fs/ramfs/fs.rs\n@@ -23,8 +23,9 @@ use crate::{\n         file_handle::FileLike,\n         named_pipe::NamedPipe,\n         utils::{\n-            CStr256, DirentVisitor, Extension, FallocMode, FileSystem, FsFlags, Inode, InodeMode,\n-            InodeType, IoctlCmd, Metadata, MknodType, PageCache, PageCacheBackend, SuperBlock,\n+            CStr256, CachePage, DirentVisitor, Extension, FallocMode, FileSystem, FsFlags, Inode,\n+            InodeMode, InodeType, IoctlCmd, Metadata, MknodType, PageCache, PageCacheBackend,\n+            SuperBlock,\n         },\n     },\n     prelude::*,\ndiff --git a/kernel/src/fs/ramfs/fs.rs b/kernel/src/fs/ramfs/fs.rs\n--- a/kernel/src/fs/ramfs/fs.rs\n+++ b/kernel/src/fs/ramfs/fs.rs\n@@ -484,7 +485,7 @@ impl RamInode {\n }\n \n impl PageCacheBackend for RamInode {\n-    fn read_page_async(&self, _idx: usize, frame: &Frame) -> Result<BioWaiter> {\n+    fn read_page_async(&self, _idx: usize, frame: &CachePage) -> Result<BioWaiter> {\n         // Initially, any block/page in a RamFs inode contains all zeros\n         frame\n             .writer()\ndiff --git a/kernel/src/fs/ramfs/fs.rs b/kernel/src/fs/ramfs/fs.rs\n--- a/kernel/src/fs/ramfs/fs.rs\n+++ b/kernel/src/fs/ramfs/fs.rs\n@@ -494,7 +495,7 @@ impl PageCacheBackend for RamInode {\n         Ok(BioWaiter::new())\n     }\n \n-    fn write_page_async(&self, _idx: usize, _frame: &Frame) -> Result<BioWaiter> {\n+    fn write_page_async(&self, _idx: usize, _frame: &CachePage) -> Result<BioWaiter> {\n         // do nothing\n         Ok(BioWaiter::new())\n     }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -2,13 +2,20 @@\n \n #![allow(dead_code)]\n \n-use core::{iter, ops::Range};\n+use core::{\n+    iter,\n+    ops::Range,\n+    sync::atomic::{AtomicU8, Ordering},\n+};\n \n use align_ext::AlignExt;\n use aster_block::bio::{BioStatus, BioWaiter};\n use aster_rights::Full;\n use lru::LruCache;\n-use ostd::mm::{Frame, FrameAllocOptions, VmIo};\n+use ostd::{\n+    impl_untyped_frame_meta_for,\n+    mm::{Frame, FrameAllocOptions, UFrame, UntypedMem, VmIo},\n+};\n \n use crate::{\n     prelude::*,\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -242,7 +249,7 @@ impl ReadaheadState {\n     /// Waits for the previous readahead.\n     pub fn wait_for_prev_readahead(\n         &mut self,\n-        pages: &mut MutexGuard<LruCache<usize, Page>>,\n+        pages: &mut MutexGuard<LruCache<usize, CachePage>>,\n     ) -> Result<()> {\n         if matches!(self.waiter.wait(), Some(BioStatus::Complete)) {\n             let Some(window) = &self.ra_window else {\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -250,7 +257,7 @@ impl ReadaheadState {\n             };\n             for idx in window.readahead_range() {\n                 if let Some(page) = pages.get_mut(&idx) {\n-                    page.set_state(PageState::UpToDate);\n+                    page.store_state(PageState::UpToDate);\n                 }\n             }\n             self.waiter.clear();\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -297,20 +304,20 @@ impl ReadaheadState {\n     /// Sends the relevant read request and sets the relevant page in the page cache to `Uninit`.\n     pub fn conduct_readahead(\n         &mut self,\n-        pages: &mut MutexGuard<LruCache<usize, Page>>,\n+        pages: &mut MutexGuard<LruCache<usize, CachePage>>,\n         backend: Arc<dyn PageCacheBackend>,\n     ) -> Result<()> {\n         let Some(window) = &self.ra_window else {\n             return_errno!(Errno::EINVAL)\n         };\n         for async_idx in window.readahead_range() {\n-            let mut async_page = Page::alloc()?;\n-            let pg_waiter = backend.read_page_async(async_idx, async_page.frame())?;\n+            let mut async_page = CachePage::alloc()?;\n+            let pg_waiter = backend.read_page_async(async_idx, &async_page)?;\n             if pg_waiter.nreqs() > 0 {\n                 self.waiter.concat(pg_waiter);\n             } else {\n                 // Some backends (e.g. RamFS) do not issue requests, but fill the page directly.\n-                async_page.set_state(PageState::UpToDate);\n+                async_page.store_state(PageState::UpToDate);\n             }\n             pages.put(async_idx, async_page);\n         }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -324,7 +331,7 @@ impl ReadaheadState {\n }\n \n struct PageCacheManager {\n-    pages: Mutex<LruCache<usize, Page>>,\n+    pages: Mutex<LruCache<usize, CachePage>>,\n     backend: Weak<dyn PageCacheBackend>,\n     ra_state: Mutex<ReadaheadState>,\n }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -360,8 +367,8 @@ impl PageCacheManager {\n         let backend_npages = backend.npages();\n         for idx in page_idx_range.start..page_idx_range.end {\n             if let Some(page) = pages.peek(&idx) {\n-                if *page.state() == PageState::Dirty && idx < backend_npages {\n-                    let waiter = backend.write_page_async(idx, page.frame())?;\n+                if page.load_state() == PageState::Dirty && idx < backend_npages {\n+                    let waiter = backend.write_page_async(idx, page)?;\n                     bio_waiter.concat(waiter);\n                 }\n             }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -376,12 +383,12 @@ impl PageCacheManager {\n             .iter_mut()\n             .filter(|(idx, _)| page_idx_range.contains(*idx))\n         {\n-            page.set_state(PageState::UpToDate);\n+            page.store_state(PageState::UpToDate);\n         }\n         Ok(())\n     }\n \n-    fn ondemand_readahead(&self, idx: usize) -> Result<Frame> {\n+    fn ondemand_readahead(&self, idx: usize) -> Result<UFrame> {\n         let mut pages = self.pages.lock();\n         let mut ra_state = self.ra_state.lock();\n         let backend = self.backend();\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -395,28 +402,28 @@ impl PageCacheManager {\n         // 3. The requested page is on disk, need a sync read operation here.\n         let frame = if let Some(page) = pages.get(&idx) {\n             // Cond 1 & 2.\n-            if let PageState::Uninit = page.state() {\n+            if let PageState::Uninit = page.load_state() {\n                 // Cond 2: We should wait for the previous readahead.\n                 // If there is no previous readahead, an error must have occurred somewhere.\n                 assert!(ra_state.request_number() != 0);\n                 ra_state.wait_for_prev_readahead(&mut pages)?;\n-                pages.get(&idx).unwrap().frame().clone()\n+                pages.get(&idx).unwrap().clone()\n             } else {\n                 // Cond 1.\n-                page.frame().clone()\n+                page.clone()\n             }\n         } else {\n             // Cond 3.\n             // Conducts the sync read operation.\n             let page = if idx < backend.npages() {\n-                let mut page = Page::alloc()?;\n-                backend.read_page(idx, page.frame())?;\n-                page.set_state(PageState::UpToDate);\n+                let mut page = CachePage::alloc()?;\n+                backend.read_page(idx, &page)?;\n+                page.store_state(PageState::UpToDate);\n                 page\n             } else {\n-                Page::alloc_zero()?\n+                CachePage::alloc_zero()?\n             };\n-            let frame = page.frame().clone();\n+            let frame = page.clone();\n             pages.put(idx, page);\n             frame\n         };\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -425,7 +432,7 @@ impl PageCacheManager {\n             ra_state.conduct_readahead(&mut pages, backend)?;\n         }\n         ra_state.set_prev_page(idx);\n-        Ok(frame)\n+        Ok(frame.into())\n     }\n }\n \ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -438,14 +445,14 @@ impl Debug for PageCacheManager {\n }\n \n impl Pager for PageCacheManager {\n-    fn commit_page(&self, idx: usize) -> Result<Frame> {\n+    fn commit_page(&self, idx: usize) -> Result<UFrame> {\n         self.ondemand_readahead(idx)\n     }\n \n     fn update_page(&self, idx: usize) -> Result<()> {\n         let mut pages = self.pages.lock();\n         if let Some(page) = pages.get_mut(&idx) {\n-            page.set_state(PageState::Dirty);\n+            page.store_state(PageState::Dirty);\n         } else {\n             warn!(\"The page {} is not in page cache\", idx);\n         }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -456,12 +463,12 @@ impl Pager for PageCacheManager {\n     fn decommit_page(&self, idx: usize) -> Result<()> {\n         let page_result = self.pages.lock().pop(&idx);\n         if let Some(page) = page_result {\n-            if let PageState::Dirty = page.state() {\n+            if let PageState::Dirty = page.load_state() {\n                 let Some(backend) = self.backend.upgrade() else {\n                     return Ok(());\n                 };\n                 if idx < backend.npages() {\n-                    backend.write_page(idx, page.frame())?;\n+                    backend.write_page(idx, &page)?;\n                 }\n             }\n         }\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -469,78 +476,113 @@ impl Pager for PageCacheManager {\n         Ok(())\n     }\n \n-    fn commit_overwrite(&self, idx: usize) -> Result<Frame> {\n+    fn commit_overwrite(&self, idx: usize) -> Result<UFrame> {\n         if let Some(page) = self.pages.lock().get(&idx) {\n-            return Ok(page.frame.clone());\n+            return Ok(page.clone().into());\n         }\n \n-        let page = Page::alloc_zero()?;\n-        Ok(self.pages.lock().get_or_insert(idx, || page).frame.clone())\n+        let page = CachePage::alloc_zero()?;\n+        Ok(self.pages.lock().get_or_insert(idx, || page).clone().into())\n     }\n }\n \n+/// A page in the page cache.\n+pub type CachePage = Frame<CachePageMeta>;\n+\n+/// Metadata for a page in the page cache.\n #[derive(Debug)]\n-struct Page {\n-    frame: Frame,\n-    state: PageState,\n+pub struct CachePageMeta {\n+    pub state: AtomicPageState,\n+    // TODO: Add a reverse mapping from the page to VMO for eviction.\n }\n \n-impl Page {\n-    pub fn alloc() -> Result<Self> {\n-        let frame = FrameAllocOptions::new(1).uninit(true).alloc_single()?;\n-        Ok(Self {\n-            frame,\n-            state: PageState::Uninit,\n-        })\n+impl_untyped_frame_meta_for!(CachePageMeta);\n+\n+pub trait CachePageExt {\n+    fn metadata(&self) -> &CachePageMeta;\n+\n+    fn alloc() -> Result<CachePage> {\n+        let meta = CachePageMeta {\n+            state: AtomicPageState {\n+                state: AtomicU8::new(PageState::Uninit as u8),\n+            },\n+        };\n+        let page = FrameAllocOptions::new()\n+            .zeroed(false)\n+            .alloc_frame_with(meta)?;\n+        Ok(page)\n     }\n \n-    pub fn alloc_zero() -> Result<Self> {\n-        let frame = FrameAllocOptions::new(1).alloc_single()?;\n-        Ok(Self {\n-            frame,\n-            state: PageState::Dirty,\n-        })\n+    fn alloc_zero() -> Result<CachePage> {\n+        let page = Self::alloc()?;\n+        page.writer().fill(0);\n+        Ok(page)\n     }\n \n-    pub fn frame(&self) -> &Frame {\n-        &self.frame\n+    fn load_state(&self) -> PageState {\n+        self.metadata().state.load(Ordering::Relaxed)\n     }\n \n-    pub fn state(&self) -> &PageState {\n-        &self.state\n+    fn store_state(&mut self, new_state: PageState) {\n+        self.metadata().state.store(new_state, Ordering::Relaxed);\n     }\n+}\n \n-    pub fn set_state(&mut self, new_state: PageState) {\n-        self.state = new_state;\n+impl CachePageExt for CachePage {\n+    fn metadata(&self) -> &CachePageMeta {\n+        self.meta()\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum PageState {\n+#[repr(u8)]\n+pub enum PageState {\n     /// `Uninit` indicates a new allocated page which content has not been initialized.\n     /// The page is available to write, not available to read.\n-    Uninit,\n+    Uninit = 0,\n     /// `UpToDate` indicates a page which content is consistent with corresponding disk content.\n     /// The page is available to read and write.\n-    UpToDate,\n+    UpToDate = 1,\n     /// `Dirty` indicates a page which content has been updated and not written back to underlying disk.\n     /// The page is available to read and write.\n-    Dirty,\n+    Dirty = 2,\n+}\n+\n+/// A page state with atomic operations.\n+#[derive(Debug)]\n+pub struct AtomicPageState {\n+    state: AtomicU8,\n+}\n+\n+impl AtomicPageState {\n+    pub fn load(&self, order: Ordering) -> PageState {\n+        let val = self.state.load(order);\n+        match val {\n+            0 => PageState::Uninit,\n+            1 => PageState::UpToDate,\n+            2 => PageState::Dirty,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    pub fn store(&self, val: PageState, order: Ordering) {\n+        self.state.store(val as u8, order);\n+    }\n }\n \n /// This trait represents the backend for the page cache.\n pub trait PageCacheBackend: Sync + Send {\n     /// Reads a page from the backend asynchronously.\n-    fn read_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter>;\n+    fn read_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter>;\n     /// Writes a page to the backend asynchronously.\n-    fn write_page_async(&self, idx: usize, frame: &Frame) -> Result<BioWaiter>;\n+    fn write_page_async(&self, idx: usize, frame: &CachePage) -> Result<BioWaiter>;\n     /// Returns the number of pages in the backend.\n     fn npages(&self) -> usize;\n }\n \n impl dyn PageCacheBackend {\n     /// Reads a page from the backend synchronously.\n-    fn read_page(&self, idx: usize, frame: &Frame) -> Result<()> {\n+    fn read_page(&self, idx: usize, frame: &CachePage) -> Result<()> {\n         let waiter = self.read_page_async(idx, frame)?;\n         match waiter.wait() {\n             Some(BioStatus::Complete) => Ok(()),\ndiff --git a/kernel/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\n--- a/kernel/src/fs/utils/page_cache.rs\n+++ b/kernel/src/fs/utils/page_cache.rs\n@@ -548,7 +590,7 @@ impl dyn PageCacheBackend {\n         }\n     }\n     /// Writes a page to the backend synchronously.\n-    fn write_page(&self, idx: usize, frame: &Frame) -> Result<()> {\n+    fn write_page(&self, idx: usize, frame: &CachePage) -> Result<()> {\n         let waiter = self.write_page_async(idx, frame)?;\n         match waiter.wait() {\n             Some(BioStatus::Complete) => Ok(()),\ndiff --git a/kernel/src/process/process_vm/init_stack/mod.rs b/kernel/src/process/process_vm/init_stack/mod.rs\n--- a/kernel/src/process/process_vm/init_stack/mod.rs\n+++ b/kernel/src/process/process_vm/init_stack/mod.rs\n@@ -20,7 +20,7 @@ use core::{\n \n use align_ext::AlignExt;\n use aster_rights::Full;\n-use ostd::mm::{vm_space::VmItem, VmIo, VmSpace, MAX_USERSPACE_VADDR};\n+use ostd::mm::{vm_space::VmItem, UntypedMem, VmIo, VmSpace, MAX_USERSPACE_VADDR};\n \n use self::aux_vec::{AuxKey, AuxVec};\n use crate::{\ndiff --git a/kernel/src/process/program_loader/elf/load_elf.rs b/kernel/src/process/program_loader/elf/load_elf.rs\n--- a/kernel/src/process/program_loader/elf/load_elf.rs\n+++ b/kernel/src/process/program_loader/elf/load_elf.rs\n@@ -306,7 +306,7 @@ fn map_segment_vmo(\n             new_frame\n         };\n         let head_idx = segment_offset / PAGE_SIZE;\n-        segment_vmo.replace(new_frame, head_idx)?;\n+        segment_vmo.replace(new_frame.into(), head_idx)?;\n     }\n \n     // Tail padding.\ndiff --git a/kernel/src/process/program_loader/elf/load_elf.rs b/kernel/src/process/program_loader/elf/load_elf.rs\n--- a/kernel/src/process/program_loader/elf/load_elf.rs\n+++ b/kernel/src/process/program_loader/elf/load_elf.rs\n@@ -324,7 +324,7 @@ fn map_segment_vmo(\n         };\n \n         let tail_idx = (segment_offset + tail_padding_offset) / PAGE_SIZE;\n-        segment_vmo.replace(new_frame, tail_idx).unwrap();\n+        segment_vmo.replace(new_frame.into(), tail_idx).unwrap();\n     }\n \n     let perms = parse_segment_perm(program_header.flags);\ndiff --git a/kernel/src/util/ring_buffer.rs b/kernel/src/util/ring_buffer.rs\n--- a/kernel/src/util/ring_buffer.rs\n+++ b/kernel/src/util/ring_buffer.rs\n@@ -8,12 +8,12 @@ use core::{\n \n use align_ext::AlignExt;\n use inherit_methods_macro::inherit_methods;\n-use ostd::mm::{FrameAllocOptions, Segment, VmIo};\n+use ostd::mm::{FrameAllocOptions, Segment, UntypedMem, VmIo};\n \n use super::{MultiRead, MultiWrite};\n use crate::prelude::*;\n \n-/// A lock-free SPSC FIFO ring buffer backed by a [`Segment`].\n+/// A lock-free SPSC FIFO ring buffer backed by a [`Segment<()>`].\n ///\n /// The ring buffer supports `push`/`pop` any `T: Pod` items, also\n /// supports `write`/`read` any bytes data based on [`VmReader`]/[`VmWriter`].\ndiff --git a/kernel/src/util/ring_buffer.rs b/kernel/src/util/ring_buffer.rs\n--- a/kernel/src/util/ring_buffer.rs\n+++ b/kernel/src/util/ring_buffer.rs\n@@ -46,7 +46,7 @@ use crate::prelude::*;\n /// }\n /// ```\n pub struct RingBuffer<T> {\n-    segment: Segment,\n+    segment: Segment<()>,\n     capacity: usize,\n     tail: AtomicUsize,\n     head: AtomicUsize,\ndiff --git a/kernel/src/util/ring_buffer.rs b/kernel/src/util/ring_buffer.rs\n--- a/kernel/src/util/ring_buffer.rs\n+++ b/kernel/src/util/ring_buffer.rs\n@@ -78,9 +78,9 @@ impl<T> RingBuffer<T> {\n             \"capacity must be a power of two\"\n         );\n         let nframes = capacity.saturating_mul(Self::T_SIZE).align_up(PAGE_SIZE) / PAGE_SIZE;\n-        let segment = FrameAllocOptions::new(nframes)\n-            .uninit(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .zeroed(false)\n+            .alloc_segment(nframes)\n             .unwrap();\n         Self {\n             segment,\ndiff --git a/kernel/src/vdso.rs b/kernel/src/vdso.rs\n--- a/kernel/src/vdso.rs\n+++ b/kernel/src/vdso.rs\n@@ -21,7 +21,7 @@ use aster_rights::Rights;\n use aster_time::{read_monotonic_time, Instant};\n use aster_util::coeff::Coeff;\n use ostd::{\n-    mm::{Frame, VmIo, PAGE_SIZE},\n+    mm::{UFrame, VmIo, PAGE_SIZE},\n     sync::SpinLock,\n     Pod,\n };\ndiff --git a/kernel/src/vdso.rs b/kernel/src/vdso.rs\n--- a/kernel/src/vdso.rs\n+++ b/kernel/src/vdso.rs\n@@ -199,9 +199,9 @@ struct Vdso {\n     data: SpinLock<VdsoData>,\n     /// The VMO of the entire VDSO, including the library text and the VDSO data.\n     vmo: Arc<Vmo>,\n-    /// The `Frame` that contains the VDSO data. This frame is contained in and\n+    /// The `UFrame` that contains the VDSO data. This frame is contained in and\n     /// will not be removed from the VDSO VMO.\n-    data_frame: Frame,\n+    data_frame: UFrame,\n }\n \n /// A `SpinLock` for the `seq` field in `VdsoData`.\ndiff --git a/kernel/src/vm/util.rs b/kernel/src/vm/util.rs\n--- a/kernel/src/vm/util.rs\n+++ b/kernel/src/vm/util.rs\n@@ -1,12 +1,14 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use ostd::mm::{Frame, FrameAllocOptions};\n+use ostd::mm::{Frame, FrameAllocOptions, UFrame, UntypedMem};\n \n use crate::prelude::*;\n \n-/// Creates a new `Frame` and initializes it with the contents of the `src`.\n-pub fn duplicate_frame(src: &Frame) -> Result<Frame> {\n-    let new_frame = FrameAllocOptions::new(1).uninit(true).alloc_single()?;\n-    new_frame.copy_from(src);\n+/// Creates a new `Frame<()>` and initializes it with the contents of the `src`.\n+///\n+/// Note that it only duplicates the contents not the metadata.\n+pub fn duplicate_frame(src: &UFrame) -> Result<Frame<()>> {\n+    let new_frame = FrameAllocOptions::new().zeroed(false).alloc_frame()?;\n+    new_frame.writer().write(&mut src.reader());\n     Ok(new_frame)\n }\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -8,8 +8,8 @@ use core::{\n \n use align_ext::AlignExt;\n use ostd::mm::{\n-    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags,\n-    PageProperty, VmSpace,\n+    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, FrameAllocOptions, PageFlags, PageProperty,\n+    UFrame, VmSpace,\n };\n \n use super::interval_set::Interval;\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -186,7 +186,7 @@ impl VmMapping {\n                 } else {\n                     let new_frame = duplicate_frame(&frame)?;\n                     prop.flags |= new_flags;\n-                    cursor.map(new_frame, prop);\n+                    cursor.map(new_frame.into(), prop);\n                 }\n             }\n             VmItem::NotMapped { .. } => {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -216,17 +216,17 @@ impl VmMapping {\n         Ok(())\n     }\n \n-    fn prepare_page(&self, page_fault_addr: Vaddr, write: bool) -> Result<(Frame, bool)> {\n+    fn prepare_page(&self, page_fault_addr: Vaddr, write: bool) -> Result<(UFrame, bool)> {\n         let mut is_readonly = false;\n         let Some(vmo) = &self.vmo else {\n-            return Ok((FrameAllocOptions::new(1).alloc_single()?, is_readonly));\n+            return Ok((FrameAllocOptions::new().alloc_frame()?.into(), is_readonly));\n         };\n \n         let page_offset = page_fault_addr.align_down(PAGE_SIZE) - self.map_to_addr;\n         let Ok(page) = vmo.get_committed_frame(page_offset) else {\n             if !self.is_shared {\n                 // The page index is outside the VMO. This is only allowed in private mapping.\n-                return Ok((FrameAllocOptions::new(1).alloc_single()?, is_readonly));\n+                return Ok((FrameAllocOptions::new().alloc_frame()?.into(), is_readonly));\n             } else {\n                 return_errno_with_message!(\n                     Errno::EFAULT,\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -237,7 +237,7 @@ impl VmMapping {\n \n         if !self.is_shared && write {\n             // Write access to private VMO-backed mapping. Performs COW directly.\n-            Ok((duplicate_frame(&page)?, is_readonly))\n+            Ok((duplicate_frame(&page)?.into(), is_readonly))\n         } else {\n             // Operations to shared mapping or read access to private VMO-backed mapping.\n             // If read access to private VMO-backed mapping triggers a page fault,\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -264,7 +264,7 @@ impl VmMapping {\n \n         let vm_perms = self.perms - VmPerms::WRITE;\n         let mut cursor = vm_space.cursor_mut(&(start_addr..end_addr))?;\n-        let operate = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n+        let operate = move |commit_fn: &mut dyn FnMut() -> Result<UFrame>| {\n             if let VmItem::NotMapped { .. } = cursor.query().unwrap() {\n                 // We regard all the surrounding pages as accessed, no matter\n                 // if it is really so. Then the hardware won't bother to update\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -432,7 +432,7 @@ impl MappedVmo {\n     ///\n     /// If the VMO has not committed a frame at this index, it will commit\n     /// one first and return it.\n-    fn get_committed_frame(&self, page_offset: usize) -> Result<Frame> {\n+    fn get_committed_frame(&self, page_offset: usize) -> Result<UFrame> {\n         debug_assert!(page_offset < self.range.len());\n         debug_assert!(page_offset % PAGE_SIZE == 0);\n         self.vmo.commit_page(self.range.start + page_offset)\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -444,7 +444,7 @@ impl MappedVmo {\n     /// perform other operations.\n     fn operate_on_range<F>(&self, range: &Range<usize>, operate: F) -> Result<()>\n     where\n-        F: FnMut(&mut dyn FnMut() -> Result<Frame>) -> Result<()>,\n+        F: FnMut(&mut dyn FnMut() -> Result<UFrame>) -> Result<()>,\n     {\n         debug_assert!(range.start < self.range.len());\n         debug_assert!(range.end <= self.range.len());\ndiff --git a/kernel/src/vm/vmo/dyn_cap.rs b/kernel/src/vm/vmo/dyn_cap.rs\n--- a/kernel/src/vm/vmo/dyn_cap.rs\n+++ b/kernel/src/vm/vmo/dyn_cap.rs\n@@ -3,14 +3,14 @@\n use core::ops::Range;\n \n use aster_rights::{Rights, TRights};\n-use ostd::mm::{Frame, VmIo};\n+use ostd::mm::{UFrame, VmIo};\n \n use super::{CommitFlags, Vmo, VmoRightsOp};\n use crate::prelude::*;\n \n impl Vmo<Rights> {\n     /// Commits a page at specific offset\n-    pub fn commit_page(&self, offset: usize) -> Result<Frame> {\n+    pub fn commit_page(&self, offset: usize) -> Result<UFrame> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.commit_page(offset)\n     }\ndiff --git a/kernel/src/vm/vmo/dyn_cap.rs b/kernel/src/vm/vmo/dyn_cap.rs\n--- a/kernel/src/vm/vmo/dyn_cap.rs\n+++ b/kernel/src/vm/vmo/dyn_cap.rs\n@@ -39,7 +39,7 @@ impl Vmo<Rights> {\n     /// perform other operations.\n     pub(in crate::vm) fn operate_on_range<F>(&self, range: &Range<usize>, operate: F) -> Result<()>\n     where\n-        F: FnMut(&mut dyn FnMut() -> Result<Frame>) -> Result<()>,\n+        F: FnMut(&mut dyn FnMut() -> Result<UFrame>) -> Result<()>,\n     {\n         self.check_rights(Rights::WRITE)?;\n         self.0\ndiff --git a/kernel/src/vm/vmo/dyn_cap.rs b/kernel/src/vm/vmo/dyn_cap.rs\n--- a/kernel/src/vm/vmo/dyn_cap.rs\n+++ b/kernel/src/vm/vmo/dyn_cap.rs\n@@ -112,7 +112,7 @@ impl Vmo<Rights> {\n     /// # Access rights\n     ///\n     /// The method requires the Write right.\n-    pub fn replace(&self, page: Frame, page_idx: usize) -> Result<()> {\n+    pub fn replace(&self, page: UFrame, page_idx: usize) -> Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.replace(page, page_idx)\n     }\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -11,7 +11,7 @@ use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::{\n     collections::xarray::{CursorMut, XArray},\n-    mm::{Frame, FrameAllocOptions, VmReader, VmWriter},\n+    mm::{FrameAllocOptions, UFrame, UntypedMem, VmReader, VmWriter},\n };\n \n use crate::prelude::*;\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -66,8 +66,8 @@ pub use pager::Pager;\n /// # Implementation\n ///\n /// `Vmo` provides high-level APIs for address space management by wrapping\n-/// around its low-level counterpart [`ostd::mm::Frame`].\n-/// Compared with `Frame`,\n+/// around its low-level counterpart [`ostd::mm::UFrame`].\n+/// Compared with `UFrame`,\n /// `Vmo` is easier to use (by offering more powerful APIs) and\n /// harder to misuse (thanks to its nature of being capability).\n #[derive(Debug)]\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -125,12 +125,12 @@ bitflags! {\n     }\n }\n \n-/// `Pages` is the struct that manages the `Frame`s stored in `Vmo_`.\n+/// `Pages` is the struct that manages the `UFrame`s stored in `Vmo_`.\n pub(super) enum Pages {\n     /// `Pages` that cannot be resized. This kind of `Pages` will have a constant size.\n-    Nonresizable(Mutex<XArray<Frame>>, usize),\n+    Nonresizable(Mutex<XArray<UFrame>>, usize),\n     /// `Pages` that can be resized and have a variable size.\n-    Resizable(Mutex<(XArray<Frame>, usize)>),\n+    Resizable(Mutex<(XArray<UFrame>, usize)>),\n }\n \n impl Clone for Pages {\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -149,7 +149,7 @@ impl Clone for Pages {\n impl Pages {\n     fn with<R, F>(&self, func: F) -> R\n     where\n-        F: FnOnce(&mut XArray<Frame>, usize) -> R,\n+        F: FnOnce(&mut XArray<UFrame>, usize) -> R,\n     {\n         match self {\n             Self::Nonresizable(pages, size) => func(&mut pages.lock(), *size),\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -201,28 +201,28 @@ impl CommitFlags {\n }\n \n impl Vmo_ {\n-    /// Prepares a new `Frame` for the target index in pages, returns this new frame.\n-    fn prepare_page(&self, page_idx: usize) -> Result<Frame> {\n+    /// Prepares a new `UFrame` for the target index in pages, returns this new frame.\n+    fn prepare_page(&self, page_idx: usize) -> Result<UFrame> {\n         match &self.pager {\n-            None => Ok(FrameAllocOptions::new(1).alloc_single()?),\n+            None => Ok(FrameAllocOptions::new().alloc_frame()?.into()),\n             Some(pager) => pager.commit_page(page_idx),\n         }\n     }\n \n-    /// Prepares a new `Frame` for the target index in the VMO, returns this new frame.\n-    fn prepare_overwrite(&self, page_idx: usize) -> Result<Frame> {\n+    /// Prepares a new `UFrame` for the target index in the VMO, returns this new frame.\n+    fn prepare_overwrite(&self, page_idx: usize) -> Result<UFrame> {\n         if let Some(pager) = &self.pager {\n             pager.commit_overwrite(page_idx)\n         } else {\n-            Ok(FrameAllocOptions::new(1).alloc_single()?)\n+            Ok(FrameAllocOptions::new().alloc_frame()?.into())\n         }\n     }\n \n     fn commit_with_cursor(\n         &self,\n-        cursor: &mut CursorMut<'_, Frame>,\n+        cursor: &mut CursorMut<'_, UFrame>,\n         commit_flags: CommitFlags,\n-    ) -> Result<Frame> {\n+    ) -> Result<UFrame> {\n         let new_page = {\n             if let Some(committed_page) = cursor.load() {\n                 // Fast path: return the page directly.\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -241,7 +241,7 @@ impl Vmo_ {\n \n     /// Commits the page corresponding to the target offset in the VMO and return that page.\n     /// If the current offset has already been committed, the page will be returned directly.\n-    pub fn commit_page(&self, offset: usize) -> Result<Frame> {\n+    pub fn commit_page(&self, offset: usize) -> Result<UFrame> {\n         let page_idx = offset / PAGE_SIZE;\n         self.pages.with(|pages, size| {\n             if offset >= size {\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -279,7 +279,7 @@ impl Vmo_ {\n         commit_flags: CommitFlags,\n     ) -> Result<()>\n     where\n-        F: FnMut(&mut dyn FnMut() -> Result<Frame>) -> Result<()>,\n+        F: FnMut(&mut dyn FnMut() -> Result<UFrame>) -> Result<()>,\n     {\n         self.pages.with(|pages, size| {\n             if range.end > size {\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -315,7 +315,7 @@ impl Vmo_ {\n         let read_range = offset..(offset + read_len);\n         let mut read_offset = offset % PAGE_SIZE;\n \n-        let read = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n+        let read = move |commit_fn: &mut dyn FnMut() -> Result<UFrame>| {\n             let frame = commit_fn()?;\n             frame.reader().skip(read_offset).read_fallible(writer)?;\n             read_offset = 0;\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -331,7 +331,7 @@ impl Vmo_ {\n         let write_range = offset..(offset + write_len);\n         let mut write_offset = offset % PAGE_SIZE;\n \n-        let mut write = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n+        let mut write = move |commit_fn: &mut dyn FnMut() -> Result<UFrame>| {\n             let frame = commit_fn()?;\n             frame.writer().skip(write_offset).write_fallible(reader)?;\n             write_offset = 0;\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -401,7 +401,7 @@ impl Vmo_ {\n         Ok(())\n     }\n \n-    fn decommit_pages(&self, pages: &mut XArray<Frame>, range: Range<usize>) -> Result<()> {\n+    fn decommit_pages(&self, pages: &mut XArray<UFrame>, range: Range<usize>) -> Result<()> {\n         let page_idx_range = get_page_idx_range(&range);\n         let mut cursor = pages.cursor_mut(page_idx_range.start as u64);\n         for page_idx in page_idx_range {\ndiff --git a/kernel/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\n--- a/kernel/src/vm/vmo/mod.rs\n+++ b/kernel/src/vm/vmo/mod.rs\n@@ -426,7 +426,7 @@ impl Vmo_ {\n         self.flags\n     }\n \n-    fn replace(&self, page: Frame, page_idx: usize) -> Result<()> {\n+    fn replace(&self, page: UFrame, page_idx: usize) -> Result<()> {\n         self.pages.with(|pages, size| {\n             if page_idx >= size / PAGE_SIZE {\n                 return_errno_with_message!(Errno::EINVAL, \"the page index is outside of the vmo\");\ndiff --git a/kernel/src/vm/vmo/options.rs b/kernel/src/vm/vmo/options.rs\n--- a/kernel/src/vm/vmo/options.rs\n+++ b/kernel/src/vm/vmo/options.rs\n@@ -8,7 +8,7 @@ use align_ext::AlignExt;\n use aster_rights::{Rights, TRightSet, TRights};\n use ostd::{\n     collections::xarray::XArray,\n-    mm::{Frame, FrameAllocOptions},\n+    mm::{FrameAllocOptions, UFrame, USegment},\n };\n \n use super::{Pager, Pages, Vmo, VmoFlags};\ndiff --git a/kernel/src/vm/vmo/options.rs b/kernel/src/vm/vmo/options.rs\n--- a/kernel/src/vm/vmo/options.rs\n+++ b/kernel/src/vm/vmo/options.rs\n@@ -137,16 +137,14 @@ fn alloc_vmo_(size: usize, flags: VmoFlags, pager: Option<Arc<dyn Pager>>) -> Re\n     })\n }\n \n-fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<XArray<Frame>> {\n+fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<XArray<UFrame>> {\n     if flags.contains(VmoFlags::CONTIGUOUS) {\n         // if the vmo is continuous, we need to allocate frames for the vmo\n         let frames_num = size / PAGE_SIZE;\n-        let frames = FrameAllocOptions::new(frames_num)\n-            .is_contiguous(true)\n-            .alloc()?;\n+        let segment: USegment = FrameAllocOptions::new().alloc_segment(frames_num)?.into();\n         let mut committed_pages = XArray::new();\n         let mut cursor = committed_pages.cursor_mut(0);\n-        for frame in frames {\n+        for frame in segment {\n             cursor.store(frame);\n             cursor.next();\n         }\ndiff --git a/kernel/src/vm/vmo/pager.rs b/kernel/src/vm/vmo/pager.rs\n--- a/kernel/src/vm/vmo/pager.rs\n+++ b/kernel/src/vm/vmo/pager.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use ostd::mm::Frame;\n+use ostd::mm::UFrame;\n \n use crate::prelude::*;\n \ndiff --git a/kernel/src/vm/vmo/pager.rs b/kernel/src/vm/vmo/pager.rs\n--- a/kernel/src/vm/vmo/pager.rs\n+++ b/kernel/src/vm/vmo/pager.rs\n@@ -26,7 +26,7 @@ pub trait Pager: Send + Sync {\n     /// whatever frame that may or may not be the same as the last time.\n     ///\n     /// It is up to the pager to decide the range of valid indices.\n-    fn commit_page(&self, idx: usize) -> Result<Frame>;\n+    fn commit_page(&self, idx: usize) -> Result<UFrame>;\n \n     /// Notify the pager that the frame at a specified index has been updated.\n     ///\ndiff --git a/kernel/src/vm/vmo/pager.rs b/kernel/src/vm/vmo/pager.rs\n--- a/kernel/src/vm/vmo/pager.rs\n+++ b/kernel/src/vm/vmo/pager.rs\n@@ -54,5 +54,5 @@ pub trait Pager: Send + Sync {\n     /// Ask the pager to provide a frame at a specified index.\n     /// Notify the pager that the frame will be fully overwritten soon, so pager can\n     /// choose not to initialize it.\n-    fn commit_overwrite(&self, idx: usize) -> Result<Frame>;\n+    fn commit_overwrite(&self, idx: usize) -> Result<UFrame>;\n }\ndiff --git a/kernel/src/vm/vmo/static_cap.rs b/kernel/src/vm/vmo/static_cap.rs\n--- a/kernel/src/vm/vmo/static_cap.rs\n+++ b/kernel/src/vm/vmo/static_cap.rs\n@@ -4,14 +4,14 @@ use core::ops::Range;\n \n use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n use aster_rights_proc::require;\n-use ostd::mm::{Frame, VmIo};\n+use ostd::mm::{UFrame, VmIo};\n \n use super::{CommitFlags, Vmo, VmoRightsOp};\n use crate::prelude::*;\n \n impl<R: TRights> Vmo<TRightSet<R>> {\n     /// Commits a page at specific offset.\n-    pub fn commit_page(&self, offset: usize) -> Result<Frame> {\n+    pub fn commit_page(&self, offset: usize) -> Result<UFrame> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.commit_page(offset)\n     }\ndiff --git a/kernel/src/vm/vmo/static_cap.rs b/kernel/src/vm/vmo/static_cap.rs\n--- a/kernel/src/vm/vmo/static_cap.rs\n+++ b/kernel/src/vm/vmo/static_cap.rs\n@@ -41,7 +41,7 @@ impl<R: TRights> Vmo<TRightSet<R>> {\n     #[require(R > Write)]\n     pub(in crate::vm) fn operate_on_range<F>(&self, range: &Range<usize>, operate: F) -> Result<()>\n     where\n-        F: FnMut(&mut dyn FnMut() -> Result<Frame>) -> Result<()>,\n+        F: FnMut(&mut dyn FnMut() -> Result<UFrame>) -> Result<()>,\n     {\n         self.0\n             .operate_on_range(range, operate, CommitFlags::empty())\ndiff --git a/kernel/src/vm/vmo/static_cap.rs b/kernel/src/vm/vmo/static_cap.rs\n--- a/kernel/src/vm/vmo/static_cap.rs\n+++ b/kernel/src/vm/vmo/static_cap.rs\n@@ -114,7 +114,7 @@ impl<R: TRights> Vmo<TRightSet<R>> {\n     ///\n     /// The method requires the Write right.\n     #[require(R > Write)]\n-    pub fn replace(&self, page: Frame, page_idx: usize) -> Result<()> {\n+    pub fn replace(&self, page: UFrame, page_idx: usize) -> Result<()> {\n         self.0.replace(page, page_idx)\n     }\n \ndiff --git a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n--- a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n@@ -38,7 +38,7 @@ impl RootEntry {\n \n pub struct RootTable {\n     /// Total 256 bus, each entry is 128 bits.\n-    root_frame: Frame,\n+    root_frame: Frame<()>,\n     // TODO: Use radix tree instead.\n     context_tables: BTreeMap<Paddr, ContextTable>,\n }\ndiff --git a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n--- a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n@@ -57,7 +57,7 @@ impl RootTable {\n \n     pub(super) fn new() -> Self {\n         Self {\n-            root_frame: FrameAllocOptions::new(1).alloc_single().unwrap(),\n+            root_frame: FrameAllocOptions::new().alloc_frame().unwrap(),\n             context_tables: BTreeMap::new(),\n         }\n     }\ndiff --git a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n--- a/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/dma_remapping/context_table.rs\n@@ -236,14 +236,14 @@ pub enum AddressWidth {\n \n pub struct ContextTable {\n     /// Total 32 devices, each device has 8 functions.\n-    entries_frame: Frame,\n+    entries_frame: Frame<()>,\n     page_tables: BTreeMap<Paddr, PageTable<DeviceMode, PageTableEntry, PagingConsts>>,\n }\n \n impl ContextTable {\n     fn new() -> Self {\n         Self {\n-            entries_frame: FrameAllocOptions::new(1).alloc_single().unwrap(),\n+            entries_frame: FrameAllocOptions::new().alloc_frame().unwrap(),\n             page_tables: BTreeMap::new(),\n         }\n     }\ndiff --git a/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs b/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n--- a/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n+++ b/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n@@ -23,7 +23,7 @@ enum ExtendedInterruptMode {\n pub struct IntRemappingTable {\n     size: u16,\n     extended_interrupt_mode: ExtendedInterruptMode,\n-    frames: Segment,\n+    frames: Segment<()>,\n     /// The global allocator for Interrupt remapping entry.\n     allocator: SpinLock<IdAlloc, LocalIrqDisabled>,\n     handles: Vec<Arc<SpinLock<IrtEntryHandle, LocalIrqDisabled>>>,\ndiff --git a/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs b/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n--- a/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n+++ b/ostd/src/arch/x86/iommu/interrupt_remapping/table.rs\n@@ -35,12 +35,11 @@ impl IntRemappingTable {\n         Some(self.handles.get(id).unwrap().clone())\n     }\n \n-    /// Creates an Interrupt Remapping Table with one Frame (default).\n+    /// Creates an Interrupt Remapping Table with one `Segment` (default).\n     pub(super) fn new() -> Self {\n         const DEFAULT_PAGES: usize = 1;\n-        let segment = FrameAllocOptions::new(DEFAULT_PAGES)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment(DEFAULT_PAGES)\n             .unwrap();\n         let entry_number = (DEFAULT_PAGES * PAGE_SIZE / size_of::<u128>()) as u16;\n \ndiff --git a/ostd/src/arch/x86/iommu/invalidate/queue.rs b/ostd/src/arch/x86/iommu/invalidate/queue.rs\n--- a/ostd/src/arch/x86/iommu/invalidate/queue.rs\n+++ b/ostd/src/arch/x86/iommu/invalidate/queue.rs\n@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub struct Queue {\n-    segment: Segment,\n+    segment: Segment<()>,\n     queue_size: usize,\n     tail: usize,\n }\ndiff --git a/ostd/src/arch/x86/iommu/invalidate/queue.rs b/ostd/src/arch/x86/iommu/invalidate/queue.rs\n--- a/ostd/src/arch/x86/iommu/invalidate/queue.rs\n+++ b/ostd/src/arch/x86/iommu/invalidate/queue.rs\n@@ -38,9 +38,8 @@ impl Queue {\n \n     pub(super) fn new() -> Self {\n         const DEFAULT_PAGES: usize = 1;\n-        let segment = FrameAllocOptions::new(DEFAULT_PAGES)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment(DEFAULT_PAGES)\n             .unwrap();\n         Self {\n             segment,\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -10,12 +10,7 @@ use spin::Once;\n use crate::{\n     arch::boot::smp::{bringup_all_aps, get_num_processors},\n     cpu,\n-    mm::{\n-        kspace::KernelMeta,\n-        paddr_to_vaddr,\n-        page::{self, ContPages},\n-        PAGE_SIZE,\n-    },\n+    mm::{frame::Segment, kspace::KernelMeta, paddr_to_vaddr, FrameAllocOptions, PAGE_SIZE},\n     task::Task,\n };\n \ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -25,7 +20,7 @@ const AP_BOOT_STACK_SIZE: usize = PAGE_SIZE * 64;\n \n pub(crate) struct ApBootInfo {\n     /// It holds the boot stack top pointers used by all APs.\n-    pub(crate) boot_stack_array: ContPages<KernelMeta>,\n+    pub(crate) boot_stack_array: Segment<KernelMeta>,\n     /// `per_ap_info` maps each AP's ID to its associated boot information.\n     per_ap_info: BTreeMap<u32, PerApInfo>,\n }\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -33,10 +28,10 @@ pub(crate) struct ApBootInfo {\n struct PerApInfo {\n     is_started: AtomicBool,\n     // TODO: When the AP starts up and begins executing tasks, the boot stack will\n-    // no longer be used, and the `ContPages` can be deallocated (this problem also\n+    // no longer be used, and the `Segment` can be deallocated (this problem also\n     // exists in the boot processor, but the memory it occupies should be returned\n     // to the frame allocator).\n-    boot_stack_pages: ContPages<KernelMeta>,\n+    boot_stack_pages: Segment<KernelMeta>,\n }\n \n static AP_LATE_ENTRY: Once<fn()> = Once::new();\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -63,14 +58,17 @@ pub fn boot_all_aps() {\n     AP_BOOT_INFO.call_once(|| {\n         let mut per_ap_info = BTreeMap::new();\n         // Use two pages to place stack pointers of all APs, thus support up to 1024 APs.\n-        let boot_stack_array =\n-            page::allocator::alloc_contiguous(2 * PAGE_SIZE, |_| KernelMeta::default()).unwrap();\n+        let boot_stack_array = FrameAllocOptions::new()\n+            .zeroed(false)\n+            .alloc_segment_with(2, |_| KernelMeta)\n+            .unwrap();\n         assert!(num_cpus < 1024);\n \n         for ap in 1..num_cpus {\n-            let boot_stack_pages =\n-                page::allocator::alloc_contiguous(AP_BOOT_STACK_SIZE, |_| KernelMeta::default())\n-                    .unwrap();\n+            let boot_stack_pages = FrameAllocOptions::new()\n+                .zeroed(false)\n+                .alloc_segment_with(AP_BOOT_STACK_SIZE / PAGE_SIZE, |_| KernelMeta)\n+                .unwrap();\n             let boot_stack_ptr = paddr_to_vaddr(boot_stack_pages.end_paddr());\n             let stack_array_ptr = paddr_to_vaddr(boot_stack_array.start_paddr()) as *mut u64;\n             // SAFETY: The `stack_array_ptr` is valid and aligned.\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -43,12 +43,7 @@ use spin::Once;\n \n use crate::{\n     arch,\n-    mm::{\n-        kspace::KernelMeta,\n-        paddr_to_vaddr,\n-        page::{self, ContPages},\n-        PAGE_SIZE,\n-    },\n+    mm::{frame::Segment, kspace::KernelMeta, paddr_to_vaddr, FrameAllocOptions, PAGE_SIZE},\n };\n \n // These symbols are provided by the linker script.\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -79,7 +74,7 @@ pub(crate) unsafe fn early_init_bsp_local_base() {\n }\n \n /// The BSP initializes the CPU-local areas for APs.\n-static CPU_LOCAL_STORAGES: Once<Vec<ContPages<KernelMeta>>> = Once::new();\n+static CPU_LOCAL_STORAGES: Once<Vec<Segment<KernelMeta>>> = Once::new();\n \n /// Initializes the CPU local data for the bootstrap processor (BSP).\n ///\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -100,7 +95,10 @@ pub unsafe fn init_on_bsp() {\n     for _ in 1..num_cpus {\n         let ap_pages = {\n             let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n-            page::allocator::alloc_contiguous(nbytes, |_| KernelMeta::default()).unwrap()\n+            FrameAllocOptions::new()\n+                .zeroed(false)\n+                .alloc_segment_with(nbytes / PAGE_SIZE, |_| KernelMeta)\n+                .unwrap()\n         };\n         let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u8;\n \ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -84,7 +84,7 @@ unsafe fn init() {\n     boot::init();\n     logger::init();\n \n-    mm::page::allocator::init();\n+    mm::frame::allocator::init();\n     mm::kspace::init_kernel_page_table(mm::init_page_meta());\n     mm::dma::init();\n \ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -13,7 +13,8 @@ use crate::{\n         io::VmIoOnce,\n         kspace::{paddr_to_vaddr, KERNEL_PAGE_TABLE},\n         page_prop::CachePolicy,\n-        HasPaddr, Infallible, Paddr, PodOnce, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n+        HasPaddr, Infallible, Paddr, PodOnce, USegment, UntypedMem, VmIo, VmReader, VmWriter,\n+        PAGE_SIZE,\n     },\n     prelude::*,\n };\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -38,27 +39,24 @@ pub struct DmaCoherent {\n \n #[derive(Debug)]\n struct DmaCoherentInner {\n-    vm_segment: Segment,\n+    segment: USegment,\n     start_daddr: Daddr,\n     is_cache_coherent: bool,\n }\n \n impl DmaCoherent {\n-    /// Creates a coherent DMA mapping backed by `vm_segment`.\n+    /// Creates a coherent DMA mapping backed by `segment`.\n     ///\n     /// The `is_cache_coherent` argument specifies whether\n     /// the target device that the DMA mapping is prepared for\n     /// can access the main memory in a CPU cache coherent way\n     /// or not.\n     ///\n-    /// The method fails if any part of the given `vm_segment`\n+    /// The method fails if any part of the given `segment`\n     /// already belongs to a DMA mapping.\n-    pub fn map(\n-        vm_segment: Segment,\n-        is_cache_coherent: bool,\n-    ) -> core::result::Result<Self, DmaError> {\n-        let frame_count = vm_segment.nbytes() / PAGE_SIZE;\n-        let start_paddr = vm_segment.start_paddr();\n+    pub fn map(segment: USegment, is_cache_coherent: bool) -> core::result::Result<Self, DmaError> {\n+        let frame_count = segment.size() / PAGE_SIZE;\n+        let start_paddr = segment.start_paddr();\n         if !check_and_insert_dma_mapping(start_paddr, frame_count) {\n             return Err(DmaError::AlreadyMapped);\n         }\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -93,7 +91,7 @@ impl DmaCoherent {\n             DmaType::Iommu => {\n                 for i in 0..frame_count {\n                     let paddr = start_paddr + (i * PAGE_SIZE);\n-                    // SAFETY: the `paddr` is restricted by the `start_paddr` and `frame_count` of the `vm_segment`.\n+                    // SAFETY: the `paddr` is restricted by the `start_paddr` and `frame_count` of the `segment`.\n                     unsafe {\n                         iommu::map(paddr as Daddr, paddr).unwrap();\n                     }\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -103,7 +101,7 @@ impl DmaCoherent {\n         };\n         Ok(Self {\n             inner: Arc::new(DmaCoherentInner {\n-                vm_segment,\n+                segment,\n                 start_daddr,\n                 is_cache_coherent,\n             }),\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -112,7 +110,7 @@ impl DmaCoherent {\n \n     /// Returns the number of bytes in the DMA mapping.\n     pub fn nbytes(&self) -> usize {\n-        self.inner.vm_segment.nbytes()\n+        self.inner.segment.size()\n     }\n }\n \ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -123,16 +121,16 @@ impl HasDaddr for DmaCoherent {\n }\n \n impl Deref for DmaCoherent {\n-    type Target = Segment;\n+    type Target = USegment;\n     fn deref(&self) -> &Self::Target {\n-        &self.inner.vm_segment\n+        &self.inner.segment\n     }\n }\n \n impl Drop for DmaCoherentInner {\n     fn drop(&mut self) {\n-        let frame_count = self.vm_segment.nbytes() / PAGE_SIZE;\n-        let start_paddr = self.vm_segment.start_paddr();\n+        let frame_count = self.segment.size() / PAGE_SIZE;\n+        let start_paddr = self.segment.start_paddr();\n         // Ensure that the addresses used later will not overflow\n         start_paddr.checked_add(frame_count * PAGE_SIZE).unwrap();\n         match dma_type() {\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -173,43 +171,39 @@ impl Drop for DmaCoherentInner {\n \n impl VmIo for DmaCoherent {\n     fn read(&self, offset: usize, writer: &mut VmWriter) -> Result<()> {\n-        self.inner.vm_segment.read(offset, writer)\n+        self.inner.segment.read(offset, writer)\n     }\n \n     fn write(&self, offset: usize, reader: &mut VmReader) -> Result<()> {\n-        self.inner.vm_segment.write(offset, reader)\n+        self.inner.segment.write(offset, reader)\n     }\n }\n \n impl VmIoOnce for DmaCoherent {\n     fn read_once<T: PodOnce>(&self, offset: usize) -> Result<T> {\n-        self.inner.vm_segment.reader().skip(offset).read_once()\n+        self.inner.segment.reader().skip(offset).read_once()\n     }\n \n     fn write_once<T: PodOnce>(&self, offset: usize, new_val: &T) -> Result<()> {\n-        self.inner\n-            .vm_segment\n-            .writer()\n-            .skip(offset)\n-            .write_once(new_val)\n+        self.inner.segment.writer().skip(offset).write_once(new_val)\n     }\n }\n \n impl<'a> DmaCoherent {\n     /// Returns a reader to read data from it.\n     pub fn reader(&'a self) -> VmReader<'a, Infallible> {\n-        self.inner.vm_segment.reader()\n+        self.inner.segment.reader()\n     }\n \n     /// Returns a writer to write data into it.\n     pub fn writer(&'a self) -> VmWriter<'a, Infallible> {\n-        self.inner.vm_segment.writer()\n+        self.inner.segment.writer()\n     }\n }\n \n impl HasPaddr for DmaCoherent {\n     fn paddr(&self) -> Paddr {\n-        self.inner.vm_segment.start_paddr()\n+        self.inner.segment.start_paddr()\n     }\n }\n \ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -11,7 +11,7 @@ use crate::{\n     error::Error,\n     mm::{\n         dma::{dma_type, Daddr, DmaType},\n-        HasPaddr, Infallible, Paddr, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n+        HasPaddr, Infallible, Paddr, USegment, UntypedMem, VmIo, VmReader, VmWriter, PAGE_SIZE,\n     },\n };\n \ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -34,7 +34,7 @@ pub struct DmaStream {\n \n #[derive(Debug)]\n struct DmaStreamInner {\n-    vm_segment: Segment,\n+    segment: USegment,\n     start_daddr: Daddr,\n     /// TODO: remove this field when on x86.\n     #[allow(unused)]\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -55,16 +55,16 @@ pub enum DmaDirection {\n }\n \n impl DmaStream {\n-    /// Establishes DMA stream mapping for a given [`Segment`].\n+    /// Establishes DMA stream mapping for a given [`USegment`].\n     ///\n     /// The method fails if the segment already belongs to a DMA mapping.\n     pub fn map(\n-        vm_segment: Segment,\n+        segment: USegment,\n         direction: DmaDirection,\n         is_cache_coherent: bool,\n     ) -> Result<Self, DmaError> {\n-        let frame_count = vm_segment.nbytes() / PAGE_SIZE;\n-        let start_paddr = vm_segment.start_paddr();\n+        let frame_count = segment.size() / PAGE_SIZE;\n+        let start_paddr = segment.start_paddr();\n         if !check_and_insert_dma_mapping(start_paddr, frame_count) {\n             return Err(DmaError::AlreadyMapped);\n         }\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -88,7 +88,7 @@ impl DmaStream {\n             DmaType::Iommu => {\n                 for i in 0..frame_count {\n                     let paddr = start_paddr + (i * PAGE_SIZE);\n-                    // SAFETY: the `paddr` is restricted by the `start_paddr` and `frame_count` of the `vm_segment`.\n+                    // SAFETY: the `paddr` is restricted by the `start_paddr` and `frame_count` of the `segment`.\n                     unsafe {\n                         iommu::map(paddr as Daddr, paddr).unwrap();\n                     }\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -99,7 +99,7 @@ impl DmaStream {\n \n         Ok(Self {\n             inner: Arc::new(DmaStreamInner {\n-                vm_segment,\n+                segment,\n                 start_daddr,\n                 is_cache_coherent,\n                 direction,\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -107,24 +107,24 @@ impl DmaStream {\n         })\n     }\n \n-    /// Gets the underlying [`Segment`].\n+    /// Gets the underlying [`USegment`].\n     ///\n     /// Usually, the CPU side should not access the memory\n     /// after the DMA mapping is established because\n     /// there is a chance that the device is updating\n     /// the memory. Do this at your own risk.\n-    pub fn vm_segment(&self) -> &Segment {\n-        &self.inner.vm_segment\n+    pub fn segment(&self) -> &USegment {\n+        &self.inner.segment\n     }\n \n     /// Returns the number of frames.\n     pub fn nframes(&self) -> usize {\n-        self.inner.vm_segment.nbytes() / PAGE_SIZE\n+        self.inner.segment.size() / PAGE_SIZE\n     }\n \n     /// Returns the number of bytes.\n     pub fn nbytes(&self) -> usize {\n-        self.inner.vm_segment.nbytes()\n+        self.inner.segment.size()\n     }\n \n     /// Returns the DMA direction.\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -156,7 +156,7 @@ impl DmaStream {\n                 if self.inner.is_cache_coherent {\n                     return Ok(());\n                 }\n-                let start_va = crate::mm::paddr_to_vaddr(self.inner.vm_segment.paddr()) as *const u8;\n+                let start_va = crate::mm::paddr_to_vaddr(self.inner.segment.paddr()) as *const u8;\n                 // TODO: Query the CPU for the cache line size via CPUID, we use 64 bytes as the cache line size here.\n                 for i in _byte_range.step_by(64) {\n                     // TODO: Call the cache line flush command in the corresponding architecture.\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -176,8 +176,8 @@ impl HasDaddr for DmaStream {\n \n impl Drop for DmaStreamInner {\n     fn drop(&mut self) {\n-        let frame_count = self.vm_segment.nbytes() / PAGE_SIZE;\n-        let start_paddr = self.vm_segment.start_paddr();\n+        let frame_count = self.segment.size() / PAGE_SIZE;\n+        let start_paddr = self.segment.start_paddr();\n         // Ensure that the addresses used later will not overflow\n         start_paddr.checked_add(frame_count * PAGE_SIZE).unwrap();\n         match dma_type() {\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -211,7 +211,7 @@ impl VmIo for DmaStream {\n         if self.inner.direction == DmaDirection::ToDevice {\n             return Err(Error::AccessDenied);\n         }\n-        self.inner.vm_segment.read(offset, writer)\n+        self.inner.segment.read(offset, writer)\n     }\n \n     /// Writes data from the buffer.\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -219,7 +219,7 @@ impl VmIo for DmaStream {\n         if self.inner.direction == DmaDirection::FromDevice {\n             return Err(Error::AccessDenied);\n         }\n-        self.inner.vm_segment.write(offset, reader)\n+        self.inner.segment.write(offset, reader)\n     }\n }\n \ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -229,7 +229,7 @@ impl<'a> DmaStream {\n         if self.inner.direction == DmaDirection::ToDevice {\n             return Err(Error::AccessDenied);\n         }\n-        Ok(self.inner.vm_segment.reader())\n+        Ok(self.inner.segment.reader())\n     }\n \n     /// Returns a writer to write data into it.\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -237,13 +237,13 @@ impl<'a> DmaStream {\n         if self.inner.direction == DmaDirection::FromDevice {\n             return Err(Error::AccessDenied);\n         }\n-        Ok(self.inner.vm_segment.writer())\n+        Ok(self.inner.segment.writer())\n     }\n }\n \n impl HasPaddr for DmaStream {\n     fn paddr(&self) -> Paddr {\n-        self.inner.vm_segment.start_paddr()\n+        self.inner.segment.start_paddr()\n     }\n }\n \ndiff --git /dev/null b/ostd/src/mm/frame/meta.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/frame/meta.rs\n@@ -0,0 +1,352 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Metadata management of frames.\n+//!\n+//! You can picture a globally shared, static, gigantic array of metadata\n+//! initialized for each frame. An entry in the array is called a [`MetaSlot`],\n+//! which contains the metadata of a frame. There would be a dedicated small\n+//! \"heap\" space in each slot for dynamic metadata. You can store anything as\n+//! the metadata of a frame as long as it's [`Sync`].\n+//!\n+//! # Implementation\n+//!\n+//! The slots are placed in the metadata pages mapped to a certain virtual\n+//! address in the kernel space. So finding the metadata of a frame often\n+//! comes with no costs since the translation is a simple arithmetic operation.\n+\n+pub(crate) mod mapping {\n+    //! The metadata of each physical page is linear mapped to fixed virtual addresses\n+    //! in [`FRAME_METADATA_RANGE`].\n+\n+    use core::mem::size_of;\n+\n+    use super::MetaSlot;\n+    use crate::mm::{kspace::FRAME_METADATA_RANGE, Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE};\n+\n+    /// Converts a physical address of a base frame to the virtual address of the metadata slot.\n+    pub(crate) const fn frame_to_meta<C: PagingConstsTrait>(paddr: Paddr) -> Vaddr {\n+        let base = FRAME_METADATA_RANGE.start;\n+        let offset = paddr / PAGE_SIZE;\n+        base + offset * size_of::<MetaSlot>()\n+    }\n+\n+    /// Converts a virtual address of the metadata slot to the physical address of the frame.\n+    pub(crate) const fn meta_to_frame<C: PagingConstsTrait>(vaddr: Vaddr) -> Paddr {\n+        let base = FRAME_METADATA_RANGE.start;\n+        let offset = (vaddr - base) / size_of::<MetaSlot>();\n+        offset * PAGE_SIZE\n+    }\n+}\n+\n+use core::{\n+    any::Any,\n+    cell::UnsafeCell,\n+    fmt::Debug,\n+    mem::{size_of, MaybeUninit},\n+    sync::atomic::{AtomicU32, Ordering},\n+};\n+\n+use align_ext::AlignExt;\n+use log::info;\n+use static_assertions::const_assert_eq;\n+\n+use super::{allocator, Segment};\n+use crate::{\n+    arch::mm::PagingConsts,\n+    mm::{\n+        kspace::LINEAR_MAPPING_BASE_VADDR, paddr_to_vaddr, page_size, page_table::boot_pt,\n+        CachePolicy, Infallible, Paddr, PageFlags, PageProperty, PrivilegedPageFlags, Vaddr,\n+        VmReader, PAGE_SIZE,\n+    },\n+    panic::abort,\n+};\n+\n+/// The maximum number of bytes of the metadata of a frame.\n+pub const FRAME_METADATA_MAX_SIZE: usize =\n+    META_SLOT_SIZE - size_of::<bool>() - size_of::<AtomicU32>() - size_of::<FrameMetaVtablePtr>();\n+/// The maximum alignment in bytes of the metadata of a frame.\n+pub const FRAME_METADATA_MAX_ALIGN: usize = align_of::<MetaSlot>();\n+\n+const META_SLOT_SIZE: usize = 64;\n+\n+#[repr(C)]\n+pub(in crate::mm) struct MetaSlot {\n+    /// The metadata of a frame.\n+    ///\n+    /// It is placed at the beginning of a slot because:\n+    ///  - the implementation can simply cast a `*const MetaSlot`\n+    ///    to a `*const AnyFrameMeta` for manipulation;\n+    ///  - if the metadata need special alignment, we can provide\n+    ///    at most `PAGE_METADATA_ALIGN` bytes of alignment;\n+    ///  - the subsequent fields can utilize the padding of the\n+    ///    reference count to save space.\n+    ///\n+    /// Don't access this field with a reference to the slot.\n+    _storage: UnsafeCell<[u8; FRAME_METADATA_MAX_SIZE]>,\n+    /// The reference count of the page.\n+    ///\n+    /// Specifically, the reference count has the following meaning:\n+    ///  - `REF_COUNT_UNUSED`: The page is not in use.\n+    ///  - `0`: The page is being constructed ([`Frame::from_unused`])\n+    ///    or destructured ([`drop_last_in_place`]).\n+    ///  - `1..REF_COUNT_MAX`: The page is in use.\n+    ///  - `REF_COUNT_MAX..REF_COUNT_UNUSED`: Illegal values to\n+    ///    prevent the reference count from overflowing. Otherwise,\n+    ///    overflowing the reference count will cause soundness issue.\n+    ///\n+    /// [`Frame::from_unused`]: super::Frame::from_unused\n+    //\n+    // Other than this field the fields should be `MaybeUninit`.\n+    // See initialization in `alloc_meta_frames`.\n+    pub(super) ref_count: AtomicU32,\n+    /// The virtual table that indicates the type of the metadata.\n+    pub(super) vtable_ptr: UnsafeCell<MaybeUninit<FrameMetaVtablePtr>>,\n+}\n+\n+pub(super) const REF_COUNT_UNUSED: u32 = u32::MAX;\n+const REF_COUNT_MAX: u32 = i32::MAX as u32;\n+\n+type FrameMetaVtablePtr = core::ptr::DynMetadata<dyn AnyFrameMeta>;\n+\n+const_assert_eq!(PAGE_SIZE % META_SLOT_SIZE, 0);\n+const_assert_eq!(size_of::<MetaSlot>(), META_SLOT_SIZE);\n+\n+/// All frame metadata types must implement this trait.\n+///\n+/// If a frame type needs specific drop behavior, it should specify\n+/// when implementing this trait. When we drop the last handle to\n+/// this frame, the `on_drop` method will be called. The `on_drop`\n+/// method is called with the physical address of the frame.\n+///\n+/// # Safety\n+///\n+/// The implemented structure must have a size less than or equal to\n+/// [`FRAME_METADATA_MAX_SIZE`] and an alignment less than or equal to\n+/// [`FRAME_METADATA_MAX_ALIGN`].\n+///\n+/// The implementer of the `on_drop` method should ensure that the frame is\n+/// safe to be read.\n+pub unsafe trait AnyFrameMeta: Any + Send + Sync + Debug + 'static {\n+    /// Called when the last handle to the frame is dropped.\n+    fn on_drop(&mut self, reader: &mut VmReader<Infallible>) {\n+        let _ = reader;\n+    }\n+\n+    /// Whether the metadata's associated frame is untyped.\n+    ///\n+    /// If a type implements [`AnyUFrameMeta`], this should be `true`.\n+    /// Otherwise, it should be `false`.\n+    ///\n+    /// [`AnyUFrameMeta`]: super::untyped::AnyUFrameMeta\n+    fn is_untyped(&self) -> bool {\n+        false\n+    }\n+}\n+\n+/// Makes a structure usable as a frame metadata.\n+///\n+/// Directly implementing [`AnyFrameMeta`] is not safe since the size and alignment\n+/// must be checked. This macro provides a safe way to implement the trait with\n+/// compile-time checks.\n+#[macro_export]\n+macro_rules! impl_frame_meta_for {\n+    // Implement without specifying the drop behavior.\n+    ($t:ty) => {\n+        use static_assertions::const_assert;\n+        const_assert!(size_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_SIZE);\n+        const_assert!(align_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_ALIGN);\n+        // SAFETY: The size and alignment of the structure are checked.\n+        unsafe impl $crate::mm::frame::meta::AnyFrameMeta for $t {}\n+    };\n+}\n+\n+pub use impl_frame_meta_for;\n+\n+impl MetaSlot {\n+    /// Increases the frame reference count by one.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must have already held a reference to the frame.\n+    pub(super) unsafe fn inc_ref_count(&self) {\n+        let last_ref_cnt = self.ref_count.fetch_add(1, Ordering::Relaxed);\n+        debug_assert!(last_ref_cnt != 0 && last_ref_cnt != REF_COUNT_UNUSED);\n+\n+        if last_ref_cnt >= REF_COUNT_MAX {\n+            // This follows the same principle as the `Arc::clone` implementation to prevent the\n+            // reference count from overflowing. See also\n+            // <https://doc.rust-lang.org/std/sync/struct.Arc.html#method.clone>.\n+            abort();\n+        }\n+    }\n+}\n+\n+/// An internal routine in dropping implementations.\n+///\n+/// # Safety\n+///\n+/// The caller should ensure that the pointer points to a frame's metadata slot. The\n+/// frame should have a last handle to the frame, and the frame is about to be dropped,\n+/// as the metadata slot after this operation becomes uninitialized.\n+pub(super) unsafe fn drop_last_in_place(ptr: *mut MetaSlot) {\n+    // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n+    // immutable reference to it is always safe.\n+    let slot = unsafe { &*ptr };\n+\n+    // This should be guaranteed as a safety requirement.\n+    debug_assert_eq!(slot.ref_count.load(Ordering::Relaxed), 0);\n+\n+    let paddr = mapping::meta_to_frame::<PagingConsts>(ptr as Vaddr);\n+\n+    // SAFETY: We have exclusive access to the frame metadata.\n+    let vtable_ptr = unsafe { &mut *slot.vtable_ptr.get() };\n+    // SAFETY: The frame metadata is initialized and valid.\n+    let vtable_ptr = unsafe { vtable_ptr.assume_init_read() };\n+\n+    let meta_ptr: *mut dyn AnyFrameMeta = core::ptr::from_raw_parts_mut(ptr, vtable_ptr);\n+\n+    // SAFETY: The implementer of the frame metadata decides that if the frame\n+    // is safe to be read or not.\n+    let mut reader =\n+        unsafe { VmReader::from_kernel_space(paddr_to_vaddr(paddr) as *const u8, PAGE_SIZE) };\n+\n+    // SAFETY: `ptr` points to the metadata storage which is valid to be mutably borrowed under\n+    // `vtable_ptr` because the metadata is valid, the vtable is correct, and we have the exclusive\n+    // access to the frame metadata.\n+    unsafe {\n+        // Invoke the custom `on_drop` handler.\n+        (*meta_ptr).on_drop(&mut reader);\n+        // Drop the frame metadata.\n+        core::ptr::drop_in_place(meta_ptr);\n+    }\n+\n+    // `Release` pairs with the `Acquire` in `Frame::from_unused` and ensures `drop_in_place` won't\n+    // be reordered after this memory store.\n+    slot.ref_count.store(REF_COUNT_UNUSED, Ordering::Release);\n+\n+    // Deallocate the frame.\n+    // It would return the frame to the allocator for further use. This would be done\n+    // after the release of the metadata to avoid re-allocation before the metadata\n+    // is reset.\n+    allocator::FRAME_ALLOCATOR\n+        .get()\n+        .unwrap()\n+        .lock()\n+        .dealloc(paddr / PAGE_SIZE, 1);\n+}\n+\n+/// The metadata of frames that holds metadata of frames.\n+#[derive(Debug, Default)]\n+pub struct MetaPageMeta {}\n+\n+impl_frame_meta_for!(MetaPageMeta);\n+\n+/// Initializes the metadata of all physical frames.\n+///\n+/// The function returns a list of `Frame`s containing the metadata.\n+pub(crate) fn init() -> Segment<MetaPageMeta> {\n+    let max_paddr = {\n+        let regions = crate::boot::memory_regions();\n+        regions.iter().map(|r| r.base() + r.len()).max().unwrap()\n+    };\n+\n+    info!(\n+        \"Initializing frame metadata for physical memory up to {:x}\",\n+        max_paddr\n+    );\n+\n+    add_temp_linear_mapping(max_paddr);\n+\n+    super::MAX_PADDR.store(max_paddr, Ordering::Relaxed);\n+\n+    let tot_nr_frames = max_paddr / page_size::<PagingConsts>(1);\n+    let (nr_meta_pages, meta_pages) = alloc_meta_frames(tot_nr_frames);\n+\n+    // Map the metadata frames.\n+    boot_pt::with_borrow(|boot_pt| {\n+        for i in 0..nr_meta_pages {\n+            let frame_paddr = meta_pages + i * PAGE_SIZE;\n+            let vaddr = mapping::frame_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n+            let prop = PageProperty {\n+                flags: PageFlags::RW,\n+                cache: CachePolicy::Writeback,\n+                priv_flags: PrivilegedPageFlags::GLOBAL,\n+            };\n+            // SAFETY: we are doing the metadata mappings for the kernel.\n+            unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n+        }\n+    })\n+    .unwrap();\n+\n+    // Now the metadata frames are mapped, we can initialize the metadata.\n+    Segment::from_unused(meta_pages..meta_pages + nr_meta_pages * PAGE_SIZE, |_| {\n+        MetaPageMeta {}\n+    })\n+}\n+\n+fn alloc_meta_frames(tot_nr_frames: usize) -> (usize, Paddr) {\n+    let nr_meta_pages = tot_nr_frames\n+        .checked_mul(size_of::<MetaSlot>())\n+        .unwrap()\n+        .div_ceil(PAGE_SIZE);\n+    let start_paddr = allocator::FRAME_ALLOCATOR\n+        .get()\n+        .unwrap()\n+        .lock()\n+        .alloc(nr_meta_pages)\n+        .unwrap()\n+        * PAGE_SIZE;\n+\n+    let slots = paddr_to_vaddr(start_paddr) as *mut MetaSlot;\n+\n+    // Fill the metadata frames with a byte pattern of `REF_COUNT_UNUSED`.\n+    debug_assert_eq!(REF_COUNT_UNUSED.to_ne_bytes(), [0xff, 0xff, 0xff, 0xff]);\n+    // SAFETY: `slots` and the length is a valid region for the metadata frames\n+    // that are going to be treated as metadata slots. The byte pattern is\n+    // valid as the initial value of the reference count (other fields are\n+    // either not accessed or `MaybeUninit`).\n+    unsafe {\n+        core::ptr::write_bytes(\n+            slots as *mut u8,\n+            0xff,\n+            tot_nr_frames * size_of::<MetaSlot>(),\n+        );\n+    }\n+\n+    (nr_meta_pages, start_paddr)\n+}\n+\n+/// Adds a temporary linear mapping for the metadata frames.\n+///\n+/// We only assume boot page table to contain 4G linear mapping. Thus if the\n+/// physical memory is huge we end up depleted of linear virtual memory for\n+/// initializing metadata.\n+fn add_temp_linear_mapping(max_paddr: Paddr) {\n+    const PADDR4G: Paddr = 0x1_0000_0000;\n+\n+    if max_paddr <= PADDR4G {\n+        return;\n+    }\n+\n+    // TODO: We don't know if the allocator would allocate from low to high or\n+    // not. So we prepare all linear mappings in the boot page table. Hope it\n+    // won't drag the boot performance much.\n+    let end_paddr = max_paddr.align_up(PAGE_SIZE);\n+    let prange = PADDR4G..end_paddr;\n+    let prop = PageProperty {\n+        flags: PageFlags::RW,\n+        cache: CachePolicy::Writeback,\n+        priv_flags: PrivilegedPageFlags::GLOBAL,\n+    };\n+\n+    // SAFETY: we are doing the linear mapping for the kernel.\n+    unsafe {\n+        boot_pt::with_borrow(|boot_pt| {\n+            for paddr in prange.step_by(PAGE_SIZE) {\n+                let vaddr = LINEAR_MAPPING_BASE_VADDR + paddr;\n+                boot_pt.map_base_page(vaddr, paddr / PAGE_SIZE, prop);\n+            }\n+        })\n+        .unwrap();\n+    }\n+}\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -1,91 +1,194 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! Untyped physical memory management.\n+//! Frame (physical memory page) management.\n //!\n-//! A frame is a special page that is _untyped_ memory.\n-//! It is used to store data irrelevant to the integrity of the kernel.\n-//! All pages mapped to the virtual address space of the users are backed by\n-//! frames. Frames, with all the properties of pages, can additionally be safely\n-//! read and written by the kernel or the user.\n-\n-pub mod options;\n-mod segment;\n-\n-use core::mem::ManuallyDrop;\n+//! A frame is an aligned, contiguous range of bytes in physical memory. The\n+//! sizes of base frames and huge frames (that are mapped as \"huge pages\") are\n+//! architecture-dependent. A frame can be mapped to virtual address spaces\n+//! using the page table.\n+//!\n+//! Frames can be accessed through frame handles, namely, [`Frame`]. A frame\n+//! handle is a reference-counted pointer to a frame. When all handles to a\n+//! frame are dropped, the frame is released and can be reused.  Contiguous\n+//! frames are managed with [`Segment`].\n+//!\n+//! There are various kinds of frames. The top-level grouping of frame kinds\n+//! are \"typed\" frames and \"untyped\" frames. Typed frames host Rust objects\n+//! that must follow the visibility, lifetime and borrow rules of Rust, thus\n+//! not being able to be directly manipulated. Untyped frames are raw memory\n+//! that can be manipulated directly. So only untyped frames can be\n+//!  - safely shared to external entities such as device drivers or user-space\n+//!    applications.\n+//!  - or directly manipulated with readers and writers that neglect Rust's\n+//!    \"alias XOR mutability\" rule.\n+//!\n+//! The kind of a frame is determined by the type of its metadata. Untyped\n+//! frames have its metadata type that implements the [`UntypedFrameMeta`]\n+//! trait, while typed frames don't.\n+//!\n+//! Frames can have dedicated metadata, which is implemented in the [`meta`]\n+//! module. The reference count and usage of a frame are stored in the metadata\n+//! as well, leaving the handle only a pointer to the metadata slot. Users\n+//! can create custom metadata types by implementing the [`AnyFrameMeta`] trait.\n+\n+pub mod allocator;\n+pub mod meta;\n+pub mod segment;\n+pub mod untyped;\n+\n+use core::{\n+    marker::PhantomData,\n+    sync::atomic::{AtomicU32, AtomicUsize, Ordering},\n+};\n \n+use meta::{\n+    mapping, AnyFrameMeta, MetaSlot, FRAME_METADATA_MAX_ALIGN, FRAME_METADATA_MAX_SIZE,\n+    REF_COUNT_UNUSED,\n+};\n pub use segment::Segment;\n+use untyped::{AnyUFrameMeta, UFrame};\n \n-use super::{\n-    page::{\n-        meta::{impl_page_meta, MetaSlot},\n-        DynPage, Page,\n-    },\n-    Infallible,\n-};\n-use crate::{\n-    mm::{\n-        io::{FallibleVmRead, FallibleVmWrite, VmIo, VmReader, VmWriter},\n-        paddr_to_vaddr, HasPaddr, Paddr, PAGE_SIZE,\n-    },\n-    Error, Result,\n-};\n+use super::{PagingLevel, PAGE_SIZE};\n+use crate::mm::{Paddr, PagingConsts, Vaddr};\n+\n+static MAX_PADDR: AtomicUsize = AtomicUsize::new(0);\n \n-/// A handle to a physical memory page of untyped memory.\n+/// A smart pointer to a frame.\n ///\n-/// An instance of `Frame` is a handle to a page frame (a physical memory\n-/// page). A cloned `Frame` refers to the same page frame as the original.\n-/// As the original and cloned instances point to the same physical address,  \n-/// they are treated as equal to each other. Behind the scene, a reference\n-/// counter is maintained for each page frame so that when all instances of\n-/// `Frame` that refer to the same page frame are dropped, the page frame\n-/// will be globally freed.\n-#[derive(Debug, Clone)]\n-pub struct Frame {\n-    page: Page<FrameMeta>,\n+/// A frame is a contiguous range of bytes in physical memory. The [`Frame`]\n+/// type is a smart pointer to a frame that is reference-counted.\n+///\n+/// Frames are associated with metadata. The type of the metadata `M` is\n+/// determines the kind of the frame. If `M` implements [`AnyUFrameMeta`], the\n+/// frame is a untyped frame. Otherwise, it is a typed frame.\n+#[derive(Debug)]\n+#[repr(transparent)]\n+pub struct Frame<M: AnyFrameMeta + ?Sized> {\n+    // TODO: We may use a `NonNull<M>` here to make the frame a maybe-fat\n+    // pointer and implement `CoerceUnsized` to avoid `From`s. However this is\n+    // not quite feasible currently because we cannot cast a must-be-fat\n+    // pointer (`*const dyn AnyFrameMeta`) to a maybe-fat pointer (`NonNull<M>`).\n+    ptr: *const MetaSlot,\n+    _marker: PhantomData<M>,\n }\n \n-impl Frame {\n-    /// Returns the physical address of the page frame.\n-    pub fn start_paddr(&self) -> Paddr {\n-        self.page.paddr()\n+unsafe impl<M: AnyFrameMeta + ?Sized> Send for Frame<M> {}\n+\n+unsafe impl<M: AnyFrameMeta + ?Sized> Sync for Frame<M> {}\n+\n+impl<M: AnyFrameMeta> Frame<M> {\n+    /// Gets a [`Frame`] with a specific usage from a raw, unused page.\n+    ///\n+    /// The caller should provide the initial metadata of the page.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if:\n+    ///  - the physical address is out of bound or not aligned;\n+    ///  - the page is already in use.\n+    pub fn from_unused(paddr: Paddr, metadata: M) -> Self {\n+        assert!(paddr % PAGE_SIZE == 0);\n+        assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n+\n+        // Checking unsafe preconditions of the `AnyFrameMeta` trait.\n+        debug_assert!(size_of::<M>() <= FRAME_METADATA_MAX_SIZE);\n+        debug_assert!(align_of::<M>() <= FRAME_METADATA_MAX_ALIGN);\n+\n+        let vaddr = mapping::frame_to_meta::<PagingConsts>(paddr);\n+        let ptr = vaddr as *const MetaSlot;\n+\n+        // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n+        // immutable reference to it is always safe.\n+        let slot = unsafe { &*ptr };\n+\n+        // `Acquire` pairs with the `Release` in `drop_last_in_place` and ensures the metadata\n+        // initialization won't be reordered before this memory compare-and-exchange.\n+        slot.ref_count\n+            .compare_exchange(REF_COUNT_UNUSED, 0, Ordering::Acquire, Ordering::Relaxed)\n+            .expect(\"Frame already in use when trying to get a new handle\");\n+\n+        // SAFETY: We have exclusive access to the page metadata. These fields are mutably\n+        // borrowed only once.\n+        let vtable_ptr = unsafe { &mut *slot.vtable_ptr.get() };\n+        vtable_ptr.write(core::ptr::metadata(&metadata as &dyn AnyFrameMeta));\n+\n+        // SAFETY:\n+        // 1. `ptr` points to the first field of `MetaSlot` (guaranteed by `repr(C)`), which is the\n+        //    metadata storage.\n+        // 2. The size and the alignment of the metadata storage is large enough to hold `M`\n+        //    (guaranteed by the safety requirement of the `AnyFrameMeta` trait).\n+        // 3. We have exclusive access to the metadata storage (guaranteed by the reference count).\n+        unsafe { ptr.cast::<M>().cast_mut().write(metadata) };\n+\n+        // Assuming no one can create a `Frame` instance directly from the page address, `Relaxed`\n+        // is fine here. Otherwise, we should use `Release` to ensure that the metadata\n+        // initialization won't be reordered after this memory store.\n+        slot.ref_count.store(1, Ordering::Relaxed);\n+\n+        Self {\n+            ptr,\n+            _marker: PhantomData,\n+        }\n     }\n \n-    /// Returns the end physical address of the page frame.\n-    pub fn end_paddr(&self) -> Paddr {\n-        self.start_paddr() + PAGE_SIZE\n+    /// Gets the metadata of this page.\n+    pub fn meta(&self) -> &M {\n+        // SAFETY: `self.ptr` points to the metadata storage which is valid to\n+        // be immutably borrowed as `M` because the type is correct, it lives\n+        // under the given lifetime, and no one will mutably borrow the page\n+        // metadata after initialization.\n+        unsafe { &*self.ptr.cast() }\n     }\n+}\n \n-    /// Returns the size of the frame\n-    pub const fn size(&self) -> usize {\n-        self.page.size()\n+impl<M: AnyFrameMeta + ?Sized> Frame<M> {\n+    /// Gets the physical address of the start of the frame.\n+    pub fn start_paddr(&self) -> Paddr {\n+        mapping::meta_to_frame::<PagingConsts>(self.ptr as Vaddr)\n     }\n \n-    /// Returns a raw pointer to the starting virtual address of the frame.\n-    pub fn as_ptr(&self) -> *const u8 {\n-        paddr_to_vaddr(self.start_paddr()) as *const u8\n+    /// Gets the paging level of this page.\n+    ///\n+    /// This is the level of the page table entry that maps the frame,\n+    /// which determines the size of the frame.\n+    ///\n+    /// Currently, the level is always 1, which means the frame is a regular\n+    /// page frame.\n+    pub const fn level(&self) -> PagingLevel {\n+        1\n     }\n \n-    /// Returns a mutable raw pointer to the starting virtual address of the frame.\n-    pub fn as_mut_ptr(&self) -> *mut u8 {\n-        paddr_to_vaddr(self.start_paddr()) as *mut u8\n+    /// Gets the size of this page in bytes.\n+    pub const fn size(&self) -> usize {\n+        PAGE_SIZE\n     }\n \n-    /// Copies the content of `src` to the frame.\n-    pub fn copy_from(&self, src: &Frame) {\n-        if self.paddr() == src.paddr() {\n-            return;\n-        }\n-        // SAFETY: the source and the destination does not overlap.\n-        unsafe {\n-            core::ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.size());\n-        }\n+    /// Gets the dyncamically-typed metadata of this frame.\n+    ///\n+    /// If the type is known at compile time, use [`Frame::meta`] instead.\n+    pub fn dyn_meta(&self) -> &dyn AnyFrameMeta {\n+        let slot = self.slot();\n+\n+        // SAFETY: The page metadata is valid to be borrowed immutably, since it will never be\n+        // borrowed mutably after initialization.\n+        let vtable_ptr = unsafe { &*slot.vtable_ptr.get() };\n+\n+        // SAFETY: The page metadata is initialized and valid.\n+        let vtable_ptr = *unsafe { vtable_ptr.assume_init_ref() };\n+\n+        let meta_ptr: *const dyn AnyFrameMeta = core::ptr::from_raw_parts(self.ptr, vtable_ptr);\n+\n+        // SAFETY: `self.ptr` points to the metadata storage which is valid to be immutably\n+        // borrowed under `vtable_ptr` because the vtable is correct, it lives under the given\n+        // lifetime, and no one will mutably borrow the page metadata after initialization.\n+        unsafe { &*meta_ptr }\n     }\n \n-    /// Get the reference count of the frame.\n+    /// Gets the reference count of the frame.\n     ///\n-    /// It returns the number of all references to the page, including all the\n-    /// existing page handles ([`Frame`]) and all the mappings in the page\n-    /// table that points to the page.\n+    /// It returns the number of all references to the frame, including all the\n+    /// existing frame handles ([`Frame`], [`Frame<dyn AnyFrameMeta>`]), and all\n+    /// the mappings in the page table that points to the frame.\n     ///\n     /// # Safety\n     ///\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -93,147 +196,157 @@ impl Frame {\n     /// reference count can be changed by other threads at any time including\n     /// potentially between calling this method and acting on the result.\n     pub fn reference_count(&self) -> u32 {\n-        self.page.reference_count()\n+        self.ref_count().load(Ordering::Relaxed)\n     }\n-}\n \n-impl From<Page<FrameMeta>> for Frame {\n-    fn from(page: Page<FrameMeta>) -> Self {\n-        Self { page }\n+    fn ref_count(&self) -> &AtomicU32 {\n+        unsafe { &(*self.ptr).ref_count }\n     }\n-}\n-\n-impl TryFrom<DynPage> for Frame {\n-    type Error = DynPage;\n \n-    /// Try converting a [`DynPage`] into the statically-typed [`Frame`].\n+    /// Forgets the handle to the frame.\n     ///\n-    /// If the dynamic page is not used as an untyped page frame, it will\n-    /// return the dynamic page itself as is.\n-    fn try_from(page: DynPage) -> core::result::Result<Self, Self::Error> {\n-        page.try_into().map(|p: Page<FrameMeta>| p.into())\n-    }\n-}\n-\n-impl From<Frame> for Page<FrameMeta> {\n-    fn from(frame: Frame) -> Self {\n-        frame.page\n+    /// This will result in the frame being leaked without calling the custom dropper.\n+    ///\n+    /// A physical address to the frame is returned in case the frame needs to be\n+    /// restored using [`Frame::from_raw`] later. This is useful when some architectural\n+    /// data structures need to hold the frame handle such as the page table.\n+    #[allow(unused)]\n+    pub(in crate::mm) fn into_raw(self) -> Paddr {\n+        let paddr = self.start_paddr();\n+        core::mem::forget(self);\n+        paddr\n     }\n-}\n \n-impl HasPaddr for Frame {\n-    fn paddr(&self) -> Paddr {\n-        self.start_paddr()\n-    }\n-}\n+    /// Restores a forgotten `Frame` from a physical address.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should only restore a `Frame` that was previously forgotten using\n+    /// [`Frame::into_raw`].\n+    ///\n+    /// And the restoring operation should only be done once for a forgotten\n+    /// `Frame`. Otherwise double-free will happen.\n+    ///\n+    /// Also, the caller ensures that the usage of the frame is correct. There's\n+    /// no checking of the usage in this function.\n+    pub(in crate::mm) unsafe fn from_raw(paddr: Paddr) -> Self {\n+        let vaddr = mapping::frame_to_meta::<PagingConsts>(paddr);\n+        let ptr = vaddr as *const MetaSlot;\n \n-impl<'a> Frame {\n-    /// Returns a reader to read data from it.\n-    pub fn reader(&'a self) -> VmReader<'a, Infallible> {\n-        // SAFETY:\n-        // - The memory range points to untyped memory.\n-        // - The frame is alive during the lifetime `'a`.\n-        // - Using `VmReader` and `VmWriter` is the only way to access the frame.\n-        unsafe { VmReader::from_kernel_space(self.as_ptr(), self.size()) }\n+        Self {\n+            ptr,\n+            _marker: PhantomData,\n+        }\n     }\n \n-    /// Returns a writer to write data into it.\n-    pub fn writer(&'a self) -> VmWriter<'a, Infallible> {\n-        // SAFETY:\n-        // - The memory range points to untyped memory.\n-        // - The frame is alive during the lifetime `'a`.\n-        // - Using `VmReader` and `VmWriter` is the only way to access the frame.\n-        unsafe { VmWriter::from_kernel_space(self.as_mut_ptr(), self.size()) }\n+    fn slot(&self) -> &MetaSlot {\n+        // SAFETY: `ptr` points to a valid `MetaSlot` that will never be\n+        // mutably borrowed, so taking an immutable reference to it is safe.\n+        unsafe { &*self.ptr }\n     }\n }\n \n-impl VmIo for Frame {\n-    fn read(&self, offset: usize, writer: &mut VmWriter) -> Result<()> {\n-        let read_len = writer.avail().min(self.size().saturating_sub(offset));\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(read_len).ok_or(Error::Overflow)?;\n-        if max_offset > self.size() {\n-            return Err(Error::InvalidArgs);\n-        }\n-        let len = self\n-            .reader()\n-            .skip(offset)\n-            .read_fallible(writer)\n-            .map_err(|(e, _)| e)?;\n-        debug_assert!(len == read_len);\n-        Ok(())\n-    }\n-\n-    fn write(&self, offset: usize, reader: &mut VmReader) -> Result<()> {\n-        let write_len = reader.remain().min(self.size().saturating_sub(offset));\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(write_len).ok_or(Error::Overflow)?;\n-        if max_offset > self.size() {\n-            return Err(Error::InvalidArgs);\n+impl<M: AnyFrameMeta + ?Sized> Clone for Frame<M> {\n+    fn clone(&self) -> Self {\n+        // SAFETY: We have already held a reference to the frame.\n+        unsafe { self.slot().inc_ref_count() };\n+\n+        Self {\n+            ptr: self.ptr,\n+            _marker: PhantomData,\n         }\n-        let len = self\n-            .writer()\n-            .skip(offset)\n-            .write_fallible(reader)\n-            .map_err(|(e, _)| e)?;\n-        debug_assert!(len == write_len);\n-        Ok(())\n     }\n }\n \n-/// Metadata for a frame.\n-#[derive(Debug, Default)]\n-pub struct FrameMeta {}\n-\n-impl_page_meta!(FrameMeta);\n+impl<M: AnyFrameMeta + ?Sized> Drop for Frame<M> {\n+    fn drop(&mut self) {\n+        let last_ref_cnt = self.slot().ref_count.fetch_sub(1, Ordering::Release);\n+        debug_assert!(last_ref_cnt != 0 && last_ref_cnt != REF_COUNT_UNUSED);\n \n-// Here are implementations for `xarray`.\n+        if last_ref_cnt == 1 {\n+            // A fence is needed here with the same reasons stated in the implementation of\n+            // `Arc::drop`: <https://doc.rust-lang.org/std/sync/struct.Arc.html#method.drop>.\n+            core::sync::atomic::fence(Ordering::Acquire);\n \n-use core::{marker::PhantomData, ops::Deref};\n-\n-/// `FrameRef` is a struct that can work as `&'a Frame`.\n-///\n-/// This is solely useful for [`crate::collections::xarray`].\n-pub struct FrameRef<'a> {\n-    inner: ManuallyDrop<Frame>,\n-    _marker: PhantomData<&'a Frame>,\n+            // SAFETY: this is the last reference and is about to be dropped.\n+            unsafe {\n+                meta::drop_last_in_place(self.ptr as *mut MetaSlot);\n+            }\n+        }\n+    }\n }\n \n-impl Deref for FrameRef<'_> {\n-    type Target = Frame;\n+impl<M: AnyFrameMeta> TryFrom<Frame<dyn AnyFrameMeta>> for Frame<M> {\n+    type Error = Frame<dyn AnyFrameMeta>;\n \n-    fn deref(&self) -> &Self::Target {\n-        &self.inner\n+    /// Tries converting a [`Frame<dyn AnyFrameMeta>`] into the statically-typed [`Frame`].\n+    ///\n+    /// If the usage of the frame is not the same as the expected usage, it will\n+    /// return the dynamic frame itself as is.\n+    fn try_from(dyn_frame: Frame<dyn AnyFrameMeta>) -> Result<Self, Self::Error> {\n+        if (dyn_frame.dyn_meta() as &dyn core::any::Any).is::<M>() {\n+            // SAFETY: The metadata is coerceable and the struct is transmutable.\n+            Ok(unsafe { core::mem::transmute::<Frame<dyn AnyFrameMeta>, Frame<M>>(dyn_frame) })\n+        } else {\n+            Err(dyn_frame)\n+        }\n     }\n }\n \n-// SAFETY: `Frame` is essentially an `*const MetaSlot` that could be used as a `*const` pointer.\n-// The pointer is also aligned to 4.\n-unsafe impl xarray::ItemEntry for Frame {\n-    type Ref<'a>\n-        = FrameRef<'a>\n-    where\n-        Self: 'a;\n+impl<M: AnyFrameMeta> From<Frame<M>> for Frame<dyn AnyFrameMeta> {\n+    fn from(frame: Frame<M>) -> Self {\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        unsafe { core::mem::transmute(frame) }\n+    }\n+}\n \n-    fn into_raw(self) -> *const () {\n-        let ptr = self.page.ptr;\n-        core::mem::forget(self);\n-        ptr as *const ()\n+impl<M: AnyUFrameMeta> From<Frame<M>> for UFrame {\n+    fn from(frame: Frame<M>) -> Self {\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        unsafe { core::mem::transmute(frame) }\n     }\n+}\n \n-    unsafe fn from_raw(raw: *const ()) -> Self {\n-        Self {\n-            page: Page::<FrameMeta> {\n-                ptr: raw as *mut MetaSlot,\n-                _marker: PhantomData,\n-            },\n-        }\n+impl From<UFrame> for Frame<dyn AnyFrameMeta> {\n+    fn from(frame: UFrame) -> Self {\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        unsafe { core::mem::transmute(frame) }\n     }\n+}\n \n-    unsafe fn raw_as_ref<'a>(raw: *const ()) -> Self::Ref<'a> {\n-        Self::Ref {\n-            inner: ManuallyDrop::new(Frame::from_raw(raw)),\n-            _marker: PhantomData,\n+impl TryFrom<Frame<dyn AnyFrameMeta>> for UFrame {\n+    type Error = Frame<dyn AnyFrameMeta>;\n+\n+    /// Tries converting a [`Frame<dyn AnyFrameMeta>`] into [`UFrame`].\n+    ///\n+    /// If the usage of the frame is not the same as the expected usage, it will\n+    /// return the dynamic frame itself as is.\n+    fn try_from(dyn_frame: Frame<dyn AnyFrameMeta>) -> Result<Self, Self::Error> {\n+        if dyn_frame.dyn_meta().is_untyped() {\n+            // SAFETY: The metadata is coerceable and the struct is transmutable.\n+            Ok(unsafe { core::mem::transmute::<Frame<dyn AnyFrameMeta>, UFrame>(dyn_frame) })\n+        } else {\n+            Err(dyn_frame)\n         }\n     }\n }\n+\n+/// Increases the reference count of the frame by one.\n+///\n+/// # Safety\n+///\n+/// The caller should ensure the following conditions:\n+///  1. The physical address must represent a valid frame;\n+///  2. The caller must have already held a reference to the frame.\n+pub(in crate::mm) unsafe fn inc_frame_ref_count(paddr: Paddr) {\n+    debug_assert!(paddr % PAGE_SIZE == 0);\n+    debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n+\n+    let vaddr: Vaddr = mapping::frame_to_meta::<PagingConsts>(paddr);\n+    // SAFETY: `vaddr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking\n+    // an immutable reference to it is always safe.\n+    let slot = unsafe { &*(vaddr as *const MetaSlot) };\n+\n+    // SAFETY: We have already held a reference to the frame.\n+    unsafe { slot.inc_ref_count() };\n+}\ndiff --git a/ostd/src/mm/frame/segment.rs b/ostd/src/mm/frame/segment.rs\n--- a/ostd/src/mm/frame/segment.rs\n+++ b/ostd/src/mm/frame/segment.rs\n@@ -1,178 +1,262 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! A contiguous segment of untyped memory pages.\n+//! A contiguous range of frames.\n \n-use core::ops::Range;\n+use core::{mem::ManuallyDrop, ops::Range};\n \n-use crate::{\n-    mm::{\n-        frame::FrameMeta,\n-        io::{FallibleVmRead, FallibleVmWrite},\n-        page::ContPages,\n-        Frame, HasPaddr, Infallible, Paddr, VmIo, VmReader, VmWriter,\n-    },\n-    Error, Result,\n-};\n+use super::{inc_frame_ref_count, meta::AnyFrameMeta, Frame};\n+use crate::mm::{AnyUFrameMeta, Paddr, PAGE_SIZE};\n \n-/// A contiguous segment of untyped memory pages.\n+/// A contiguous range of homogeneous physical memory frames.\n ///\n-/// A [`Segment`] object is a handle to a contiguous range of untyped memory\n-/// pages, and the underlying pages can be shared among multiple threads.\n-/// [`Segment::slice`] can be used to clone a slice of the segment (also can be\n-/// used to clone the entire range). Reference counts are maintained for each\n-/// page in the segment. So cloning the handle may not be cheap as it\n-/// increments the reference count of all the cloned pages.\n+/// This is a handle to multiple contiguous frames. It will be more lightweight\n+/// than owning an array of frame handles.\n ///\n-/// Other [`Frame`] handles can also refer to the pages in the segment. And\n-/// the segment can be iterated over to get all the frames in it.\n+/// The ownership is achieved by the reference counting mechanism of frames.\n+/// When constructing a [`Segment`], the frame handles are created then\n+/// forgotten, leaving the reference count. When dropping a it, the frame\n+/// handles are restored and dropped, decrementing the reference count.\n ///\n-/// To allocate a segment, use [`crate::mm::FrameAllocator`].\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// let vm_segment = FrameAllocOptions::new(2)\n-///     .is_contiguous(true)\n-///     .alloc_contiguous()?;\n-/// vm_segment.write_bytes(0, buf)?;\n-/// ```\n+/// All the metadata of the frames are homogeneous, i.e., they are of the same\n+/// type.\n #[derive(Debug)]\n-pub struct Segment {\n-    pages: ContPages<FrameMeta>,\n+#[repr(transparent)]\n+pub struct Segment<M: AnyFrameMeta + ?Sized> {\n+    range: Range<Paddr>,\n+    _marker: core::marker::PhantomData<M>,\n }\n \n-impl HasPaddr for Segment {\n-    fn paddr(&self) -> Paddr {\n-        self.pages.start_paddr()\n+/// A contiguous range of homogeneous untyped physical memory frames that have any metadata.\n+///\n+/// In other words, the metadata of the frames are of the same type, and they\n+/// are untyped, but the type of metadata is not known at compile time. An\n+/// [`USegment`] as a parameter accepts any untyped segments.\n+///\n+/// The usage of this frame will not be changed while this object is alive.\n+pub type USegment = Segment<dyn AnyUFrameMeta>;\n+\n+impl<M: AnyFrameMeta + ?Sized> Drop for Segment<M> {\n+    fn drop(&mut self) {\n+        for paddr in self.range.clone().step_by(PAGE_SIZE) {\n+            // SAFETY: for each frame there would be a forgotten handle\n+            // when creating the `Segment` object.\n+            drop(unsafe { Frame::<M>::from_raw(paddr) });\n+        }\n     }\n }\n \n-impl Clone for Segment {\n+impl<M: AnyFrameMeta + ?Sized> Clone for Segment<M> {\n     fn clone(&self) -> Self {\n+        for paddr in self.range.clone().step_by(PAGE_SIZE) {\n+            // SAFETY: for each frame there would be a forgotten handle\n+            // when creating the `Segment` object, so we already have\n+            // reference counts for the frames.\n+            unsafe { inc_frame_ref_count(paddr) };\n+        }\n         Self {\n-            pages: self.pages.clone(),\n+            range: self.range.clone(),\n+            _marker: core::marker::PhantomData,\n         }\n     }\n }\n \n-impl Segment {\n-    /// Returns the start physical address.\n+impl<M: AnyFrameMeta> Segment<M> {\n+    /// Creates a new [`Segment`] from unused frames.\n+    ///\n+    /// The caller must provide a closure to initialize metadata for all the frames.\n+    /// The closure receives the physical address of the frame and returns the\n+    /// metadata, which is similar to [`core::array::from_fn`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// The function panics if:\n+    ///  - the physical address is invalid or not aligned;\n+    ///  - any of the frames are already in use.\n+    pub fn from_unused<F>(range: Range<Paddr>, mut metadata_fn: F) -> Self\n+    where\n+        F: FnMut(Paddr) -> M,\n+    {\n+        for paddr in range.clone().step_by(PAGE_SIZE) {\n+            let _ = ManuallyDrop::new(Frame::<M>::from_unused(paddr, metadata_fn(paddr)));\n+        }\n+        Self {\n+            range,\n+            _marker: core::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+impl<M: AnyFrameMeta + ?Sized> Segment<M> {\n+    /// Gets the start physical address of the contiguous frames.\n     pub fn start_paddr(&self) -> Paddr {\n-        self.pages.start_paddr()\n+        self.range.start\n     }\n \n-    /// Returns the end physical address.\n+    /// Gets the end physical address of the contiguous frames.\n     pub fn end_paddr(&self) -> Paddr {\n-        self.pages.end_paddr()\n+        self.range.end\n     }\n \n-    /// Returns the number of bytes in it.\n-    pub fn nbytes(&self) -> usize {\n-        self.pages.nbytes()\n+    /// Gets the length in bytes of the contiguous frames.\n+    pub fn size(&self) -> usize {\n+        self.range.end - self.range.start\n     }\n \n-    /// Split the segment into two at the given byte offset from the start.\n+    /// Splits the frames into two at the given byte offset from the start.\n     ///\n-    /// The resulting segments cannot be empty. So the byte offset cannot be\n-    /// neither zero nor the length of the segment.\n+    /// The resulting frames cannot be empty. So the offset cannot be neither\n+    /// zero nor the length of the frames.\n     ///\n     /// # Panics\n     ///\n-    /// The function panics if the byte offset is out of bounds, at either ends, or\n+    /// The function panics if the offset is out of bounds, at either ends, or\n     /// not base-page-aligned.\n     pub fn split(self, offset: usize) -> (Self, Self) {\n-        let (left, right) = self.pages.split(offset);\n-        (Self { pages: left }, Self { pages: right })\n+        assert!(offset % PAGE_SIZE == 0);\n+        assert!(0 < offset && offset < self.size());\n+\n+        let old = ManuallyDrop::new(self);\n+        let at = old.range.start + offset;\n+\n+        (\n+            Self {\n+                range: old.range.start..at,\n+                _marker: core::marker::PhantomData,\n+            },\n+            Self {\n+                range: at..old.range.end,\n+                _marker: core::marker::PhantomData,\n+            },\n+        )\n     }\n \n-    /// Get an extra handle to the segment in the byte range.\n+    /// Gets an extra handle to the frames in the byte offset range.\n     ///\n-    /// The sliced byte range in indexed by the offset from the start of the\n-    /// segment. The resulting segment holds extra reference counts.\n+    /// The sliced byte offset range in indexed by the offset from the start of\n+    /// the contiguous frames. The resulting frames holds extra reference counts.\n     ///\n     /// # Panics\n     ///\n-    /// The function panics if the byte range is out of bounds, or if any of\n-    /// the ends of the byte range is not base-page aligned.\n+    /// The function panics if the byte offset range is out of bounds, or if\n+    /// any of the ends of the byte offset range is not base-page aligned.\n     pub fn slice(&self, range: &Range<usize>) -> Self {\n+        assert!(range.start % PAGE_SIZE == 0 && range.end % PAGE_SIZE == 0);\n+        let start = self.range.start + range.start;\n+        let end = self.range.start + range.end;\n+        assert!(start <= end && end <= self.range.end);\n+\n+        for paddr in (start..end).step_by(PAGE_SIZE) {\n+            // SAFETY: We already have reference counts for the frames since\n+            // for each frame there would be a forgotten handle when creating\n+            // the `Segment` object.\n+            unsafe { inc_frame_ref_count(paddr) };\n+        }\n+\n         Self {\n-            pages: self.pages.slice(range),\n+            range: start..end,\n+            _marker: core::marker::PhantomData,\n         }\n     }\n+}\n \n-    /// Gets a [`VmReader`] to read from the segment from the beginning to the end.\n-    pub fn reader(&self) -> VmReader<'_, Infallible> {\n-        let ptr = super::paddr_to_vaddr(self.start_paddr()) as *const u8;\n-        // SAFETY:\n-        // - The memory range points to untyped memory.\n-        // - The segment is alive during the lifetime `'a`.\n-        // - Using `VmReader` and `VmWriter` is the only way to access the segment.\n-        unsafe { VmReader::from_kernel_space(ptr, self.nbytes()) }\n+impl<M: AnyFrameMeta + ?Sized> From<Frame<M>> for Segment<M> {\n+    fn from(frame: Frame<M>) -> Self {\n+        let pa = frame.start_paddr();\n+        let _ = ManuallyDrop::new(frame);\n+        Self {\n+            range: pa..pa + PAGE_SIZE,\n+            _marker: core::marker::PhantomData,\n+        }\n     }\n+}\n+\n+impl<M: AnyFrameMeta + ?Sized> Iterator for Segment<M> {\n+    type Item = Frame<M>;\n \n-    /// Gets a [`VmWriter`] to write to the segment from the beginning to the end.\n-    pub fn writer(&self) -> VmWriter<'_, Infallible> {\n-        let ptr = super::paddr_to_vaddr(self.start_paddr()) as *mut u8;\n-        // SAFETY:\n-        // - The memory range points to untyped memory.\n-        // - The segment is alive during the lifetime `'a`.\n-        // - Using `VmReader` and `VmWriter` is the only way to access the segment.\n-        unsafe { VmWriter::from_kernel_space(ptr, self.nbytes()) }\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.range.start < self.range.end {\n+            // SAFETY: each frame in the range would be a handle forgotten\n+            // when creating the `Segment` object.\n+            let frame = unsafe { Frame::<M>::from_raw(self.range.start) };\n+            self.range.start += PAGE_SIZE;\n+            // The end cannot be non-page-aligned.\n+            debug_assert!(self.range.start <= self.range.end);\n+            Some(frame)\n+        } else {\n+            None\n+        }\n     }\n }\n \n-impl From<Frame> for Segment {\n-    fn from(frame: Frame) -> Self {\n+impl<M: AnyFrameMeta> From<Segment<M>> for Segment<dyn AnyFrameMeta> {\n+    fn from(seg: Segment<M>) -> Self {\n+        let seg = ManuallyDrop::new(seg);\n         Self {\n-            pages: ContPages::from(frame.page),\n+            range: seg.range.clone(),\n+            _marker: core::marker::PhantomData,\n         }\n     }\n }\n \n-impl From<ContPages<FrameMeta>> for Segment {\n-    fn from(pages: ContPages<FrameMeta>) -> Self {\n-        Self { pages }\n-    }\n-}\n+impl<M: AnyFrameMeta> TryFrom<Segment<dyn AnyFrameMeta>> for Segment<M> {\n+    type Error = Segment<dyn AnyFrameMeta>;\n \n-impl VmIo for Segment {\n-    fn read(&self, offset: usize, writer: &mut VmWriter) -> Result<()> {\n-        let read_len = writer.avail();\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(read_len).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n+    fn try_from(seg: Segment<dyn AnyFrameMeta>) -> core::result::Result<Self, Self::Error> {\n+        // SAFETY: for each page there would be a forgotten handle\n+        // when creating the `Segment` object.\n+        let first_frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(seg.range.start) };\n+        let first_frame = ManuallyDrop::new(first_frame);\n+        if !(first_frame.dyn_meta() as &dyn core::any::Any).is::<M>() {\n+            return Err(seg);\n+        }\n+        // Since segments are homogeneous, we can safely assume that the rest\n+        // of the frames are of the same type. We just debug-check here.\n+        #[cfg(debug_assertions)]\n+        {\n+            for paddr in seg.range.clone().step_by(PAGE_SIZE) {\n+                let frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) };\n+                let frame = ManuallyDrop::new(frame);\n+                debug_assert!((frame.dyn_meta() as &dyn core::any::Any).is::<M>());\n+            }\n         }\n-        let len = self\n-            .reader()\n-            .skip(offset)\n-            .read_fallible(writer)\n-            .map_err(|(e, _)| e)?;\n-        debug_assert!(len == read_len);\n-        Ok(())\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        Ok(unsafe { core::mem::transmute::<Segment<dyn AnyFrameMeta>, Segment<M>>(seg) })\n     }\n+}\n \n-    fn write(&self, offset: usize, reader: &mut VmReader) -> Result<()> {\n-        let write_len = reader.remain();\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(reader.remain()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-        let len = self\n-            .writer()\n-            .skip(offset)\n-            .write_fallible(reader)\n-            .map_err(|(e, _)| e)?;\n-        debug_assert!(len == write_len);\n-        Ok(())\n+impl<M: AnyUFrameMeta> From<Segment<M>> for USegment {\n+    fn from(seg: Segment<M>) -> Self {\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        unsafe { core::mem::transmute(seg) }\n     }\n }\n \n-impl Iterator for Segment {\n-    type Item = Frame;\n+impl TryFrom<Segment<dyn AnyFrameMeta>> for USegment {\n+    type Error = Segment<dyn AnyFrameMeta>;\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.pages.next().map(|page| Frame { page })\n+    /// Try converting a [`Segment<dyn AnyFrameMeta>`] into [`USegment`].\n+    ///\n+    /// If the usage of the page is not the same as the expected usage, it will\n+    /// return the dynamic page itself as is.\n+    fn try_from(seg: Segment<dyn AnyFrameMeta>) -> core::result::Result<Self, Self::Error> {\n+        // SAFETY: for each page there would be a forgotten handle\n+        // when creating the `Segment` object.\n+        let first_frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(seg.range.start) };\n+        let first_frame = ManuallyDrop::new(first_frame);\n+        if !first_frame.dyn_meta().is_untyped() {\n+            return Err(seg);\n+        }\n+        // Since segments are homogeneous, we can safely assume that the rest\n+        // of the frames are of the same type. We just debug-check here.\n+        #[cfg(debug_assertions)]\n+        {\n+            for paddr in seg.range.clone().step_by(PAGE_SIZE) {\n+                let frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) };\n+                let frame = ManuallyDrop::new(frame);\n+                debug_assert!(frame.dyn_meta().is_untyped());\n+            }\n+        }\n+        // SAFETY: The metadata is coerceable and the struct is transmutable.\n+        Ok(unsafe { core::mem::transmute::<Segment<dyn AnyFrameMeta>, USegment>(seg) })\n     }\n }\ndiff --git /dev/null b/ostd/src/mm/frame/untyped.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/frame/untyped.rs\n@@ -0,0 +1,197 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Untyped physical memory management.\n+//!\n+//! As detailed in [`crate::mm::frame`], untyped memory can be accessed with\n+//! relaxed rules but we cannot create references to them. This module provides\n+//! the declaration of untyped frames and segments, and the implementation of\n+//! extra functionalities (such as [`VmIo`]) for them.\n+\n+use super::{meta::AnyFrameMeta, Frame, Segment};\n+use crate::{\n+    mm::{\n+        io::{FallibleVmRead, FallibleVmWrite, VmIo, VmReader, VmWriter},\n+        paddr_to_vaddr, Infallible,\n+    },\n+    Error, Result,\n+};\n+\n+/// The metadata of untyped frame.\n+///\n+/// If a structure `M` implements [`AnyUFrameMeta`], it can be used as the\n+/// metadata of a type of untyped frames [`Frame<M>`]. All frames of such type\n+/// will be accessible as untyped memory.\n+pub trait AnyUFrameMeta: AnyFrameMeta {}\n+\n+/// A smart pointer to an untyped frame with any metadata.\n+///\n+/// The metadata of the frame is not known at compile time but the frame must\n+/// be an untyped one. An [`UFrame`] as a parameter accepts any type of\n+/// untyped frame metadata.\n+///\n+/// The usage of this frame will not be changed while this object is alive.\n+pub type UFrame = Frame<dyn AnyUFrameMeta>;\n+\n+/// Makes a structure usable as untyped frame metadata.\n+///\n+/// Directly implementing [`AnyFrameMeta`] is not safe since the size and\n+/// alignment must be checked. This macro provides a safe way to implement both\n+/// [`AnyFrameMeta`] and [`AnyUFrameMeta`] with compile-time checks.\n+///\n+/// If this macro is used for built-in typed frame metadata, it won't compile.\n+#[macro_export]\n+macro_rules! impl_untyped_frame_meta_for {\n+    // Implement without specifying the drop behavior.\n+    ($t:ty) => {\n+        use static_assertions::const_assert;\n+        const_assert!(size_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_SIZE);\n+        const_assert!(align_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_ALIGN);\n+        // SAFETY: The size and alignment of the structure are checked.\n+        unsafe impl $crate::mm::frame::meta::AnyFrameMeta for $t {\n+            fn is_untyped(&self) -> bool {\n+                true\n+            }\n+        }\n+        impl $crate::mm::frame::untyped::AnyUFrameMeta for $t {}\n+    };\n+    // Implement with a customized drop function.\n+    ($t:ty, $body:expr) => {\n+        use static_assertions::const_assert;\n+        const_assert!(size_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_SIZE);\n+        const_assert!(align_of::<$t>() <= $crate::mm::frame::meta::FRAME_METADATA_MAX_ALIGN);\n+        // SAFETY: The size and alignment of the structure are checked.\n+        // Outside OSTD the user cannot implement a `on_drop` method for typed\n+        // frames. And untyped frames can be safely read.\n+        unsafe impl $crate::mm::frame::meta::AnyFrameMeta for $t {\n+            fn on_drop(&mut self, reader: &mut $crate::mm::VmReader<$crate::mm::Infallible>) {\n+                $body\n+            }\n+\n+            fn is_untyped(&self) -> bool {\n+                true\n+            }\n+        }\n+        impl $crate::mm::frame::untyped::AnyUFrameMeta for $t {}\n+    };\n+}\n+\n+// A special case of untyped metadata is the unit type.\n+impl_untyped_frame_meta_for!(());\n+\n+/// A physical memory range that is untyped.\n+///\n+/// Untyped frames or segments can be safely read and written by the kernel or\n+/// the user.\n+pub trait UntypedMem {\n+    /// Borrows a reader that can read the untyped memory.\n+    fn reader(&self) -> VmReader<'_, Infallible>;\n+    /// Borrows a writer that can write the untyped memory.\n+    fn writer(&self) -> VmWriter<'_, Infallible>;\n+}\n+\n+macro_rules! impl_untyped_for {\n+    ($t:ident) => {\n+        impl<UM: AnyUFrameMeta + ?Sized> UntypedMem for $t<UM> {\n+            fn reader(&self) -> VmReader<'_, Infallible> {\n+                let ptr = paddr_to_vaddr(self.start_paddr()) as *const u8;\n+                // SAFETY: Only untyped frames are allowed to be read.\n+                unsafe { VmReader::from_kernel_space(ptr, self.size()) }\n+            }\n+\n+            fn writer(&self) -> VmWriter<'_, Infallible> {\n+                let ptr = paddr_to_vaddr(self.start_paddr()) as *mut u8;\n+                // SAFETY: Only untyped frames are allowed to be written.\n+                unsafe { VmWriter::from_kernel_space(ptr, self.size()) }\n+            }\n+        }\n+\n+        impl<UM: AnyUFrameMeta + ?Sized> VmIo for $t<UM> {\n+            fn read(&self, offset: usize, writer: &mut VmWriter) -> Result<()> {\n+                let read_len = writer.avail().min(self.size().saturating_sub(offset));\n+                // Do bound check with potential integer overflow in mind\n+                let max_offset = offset.checked_add(read_len).ok_or(Error::Overflow)?;\n+                if max_offset > self.size() {\n+                    return Err(Error::InvalidArgs);\n+                }\n+                let len = self\n+                    .reader()\n+                    .skip(offset)\n+                    .read_fallible(writer)\n+                    .map_err(|(e, _)| e)?;\n+                debug_assert!(len == read_len);\n+                Ok(())\n+            }\n+\n+            fn write(&self, offset: usize, reader: &mut VmReader) -> Result<()> {\n+                let write_len = reader.remain().min(self.size().saturating_sub(offset));\n+                // Do bound check with potential integer overflow in mind\n+                let max_offset = offset.checked_add(write_len).ok_or(Error::Overflow)?;\n+                if max_offset > self.size() {\n+                    return Err(Error::InvalidArgs);\n+                }\n+                let len = self\n+                    .writer()\n+                    .skip(offset)\n+                    .write_fallible(reader)\n+                    .map_err(|(e, _)| e)?;\n+                debug_assert!(len == write_len);\n+                Ok(())\n+            }\n+        }\n+    };\n+}\n+\n+impl_untyped_for!(Frame);\n+impl_untyped_for!(Segment);\n+\n+// Here are implementations for `xarray`.\n+\n+use core::{marker::PhantomData, mem::ManuallyDrop, ops::Deref};\n+\n+/// `FrameRef` is a struct that can work as `&'a Frame<m>`.\n+///\n+/// This is solely useful for [`crate::collections::xarray`].\n+pub struct FrameRef<'a, M: AnyUFrameMeta + ?Sized> {\n+    inner: ManuallyDrop<Frame<M>>,\n+    _marker: PhantomData<&'a Frame<M>>,\n+}\n+\n+impl<M: AnyUFrameMeta + ?Sized> Deref for FrameRef<'_, M> {\n+    type Target = Frame<M>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.inner\n+    }\n+}\n+\n+// SAFETY: `Frame` is essentially an `*const MetaSlot` that could be used as a `*const` pointer.\n+// The pointer is also aligned to 4.\n+unsafe impl<M: AnyUFrameMeta + ?Sized> xarray::ItemEntry for Frame<M> {\n+    type Ref<'a>\n+        = FrameRef<'a, M>\n+    where\n+        Self: 'a;\n+\n+    fn into_raw(self) -> *const () {\n+        let ptr = self.ptr;\n+        let _ = ManuallyDrop::new(self);\n+        ptr as *const ()\n+    }\n+\n+    unsafe fn from_raw(raw: *const ()) -> Self {\n+        Self {\n+            ptr: raw as *const _,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    unsafe fn raw_as_ref<'a>(raw: *const ()) -> Self::Ref<'a> {\n+        Self::Ref {\n+            inner: ManuallyDrop::new(Frame {\n+                ptr: raw as *const _,\n+                _marker: PhantomData,\n+            }),\n+            _marker: PhantomData,\n+        }\n+    }\n+}\ndiff --git a/ostd/src/mm/heap_allocator/mod.rs b/ostd/src/mm/heap_allocator/mod.rs\n--- a/ostd/src/mm/heap_allocator/mod.rs\n+++ b/ostd/src/mm/heap_allocator/mod.rs\n@@ -11,7 +11,7 @@ use spin::Once;\n \n use super::paddr_to_vaddr;\n use crate::{\n-    mm::{page::allocator::PAGE_ALLOCATOR, PAGE_SIZE},\n+    mm::{frame::allocator::FRAME_ALLOCATOR, PAGE_SIZE},\n     prelude::*,\n     sync::SpinLock,\n     trap::disable_local,\ndiff --git a/ostd/src/mm/heap_allocator/mod.rs b/ostd/src/mm/heap_allocator/mod.rs\n--- a/ostd/src/mm/heap_allocator/mod.rs\n+++ b/ostd/src/mm/heap_allocator/mod.rs\n@@ -94,7 +94,7 @@ impl LockedHeapWithRescue {\n         };\n \n         let allocation_start = {\n-            let mut page_allocator = PAGE_ALLOCATOR.get().unwrap().lock();\n+            let mut page_allocator = FRAME_ALLOCATOR.get().unwrap().lock();\n             if num_frames >= MIN_NUM_FRAMES {\n                 page_allocator.alloc(num_frames).ok_or(Error::NoMemory)?\n             } else {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -7,11 +7,11 @@\n //! The core virtual memory (VM) access APIs provided by this module are [`VmReader`] and\n //! [`VmWriter`], which allow for writing to or reading from a region of memory _safely_.\n //! `VmReader` and `VmWriter` objects can be constructed from memory regions of either typed memory\n-//! (e.g., `&[u8]`) or untyped memory (e.g, [`Frame`]). Behind the scene, `VmReader` and `VmWriter`\n+//! (e.g., `&[u8]`) or untyped memory (e.g, [`UFrame`]). Behind the scene, `VmReader` and `VmWriter`\n //! must be constructed via their [`from_user_space`] and [`from_kernel_space`] methods, whose\n //! safety depends on whether the given memory regions are _valid_ or not.\n //!\n-//! [`Frame`]: crate::mm::Frame\n+//! [`UFrame`]: crate::mm::UFrame\n //! [`from_user_space`]: `VmReader::from_user_space`\n //! [`from_kernel_space`]: `VmReader::from_kernel_space`\n //!\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -58,7 +58,7 @@ use crate::{\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\n-/// e.g., [`Segment`], [`Vec<Frame>`] and [`Frame`].\n+/// e.g., [`USegment`], [`Vec<UFrame>`] and [`UFrame`].\n ///\n /// # Concurrency\n ///\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -67,8 +67,8 @@ use crate::{\n /// desire predictability or atomicity, the users should add extra mechanism\n /// for such properties.\n ///\n-/// [`Segment`]: crate::mm::Segment\n-/// [`Frame`]: crate::mm::Frame\n+/// [`USegment`]: crate::mm::USegment\n+/// [`UFrame`]: crate::mm::UFrame\n pub trait VmIo: Send + Sync {\n     /// Reads requested data at a specified offset into a given `VmWriter`.\n     ///\ndiff --git a/ostd/src/mm/kspace/kvirt_area.rs b/ostd/src/mm/kspace/kvirt_area.rs\n--- a/ostd/src/mm/kspace/kvirt_area.rs\n+++ b/ostd/src/mm/kspace/kvirt_area.rs\n@@ -11,7 +11,7 @@ use super::{KERNEL_PAGE_TABLE, TRACKED_MAPPED_PAGES_RANGE, VMALLOC_VADDR_RANGE};\n use crate::{\n     cpu::CpuSet,\n     mm::{\n-        page::{meta::PageMeta, DynPage, Page},\n+        frame::{meta::AnyFrameMeta, Frame},\n         page_prop::PageProperty,\n         page_table::PageTableItem,\n         tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\ndiff --git a/ostd/src/mm/kspace/kvirt_area.rs b/ostd/src/mm/kspace/kvirt_area.rs\n--- a/ostd/src/mm/kspace/kvirt_area.rs\n+++ b/ostd/src/mm/kspace/kvirt_area.rs\n@@ -204,10 +204,10 @@ impl<M: AllocatorSelector + 'static> KVirtArea<M> {\n \n impl KVirtArea<Tracked> {\n     /// Maps pages into the kernel virtual area.\n-    pub fn map_pages<T: PageMeta>(\n+    pub fn map_pages<T: AnyFrameMeta>(\n         &mut self,\n         range: Range<Vaddr>,\n-        pages: impl Iterator<Item = Page<T>>,\n+        pages: impl Iterator<Item = Frame<T>>,\n         prop: PageProperty,\n     ) {\n         assert!(self.start() <= range.start && self.end() >= range.end);\ndiff --git a/ostd/src/mm/kspace/kvirt_area.rs b/ostd/src/mm/kspace/kvirt_area.rs\n--- a/ostd/src/mm/kspace/kvirt_area.rs\n+++ b/ostd/src/mm/kspace/kvirt_area.rs\n@@ -232,7 +232,7 @@ impl KVirtArea<Tracked> {\n     ///\n     /// This function returns None if the address is not mapped (`NotMapped`),\n     /// while panics if the address is mapped to a `MappedUntracked` or `PageTableNode` page.\n-    pub fn get_page(&self, addr: Vaddr) -> Option<DynPage> {\n+    pub fn get_page(&self, addr: Vaddr) -> Option<Frame<dyn AnyFrameMeta>> {\n         let query_result = self.query_page(addr);\n         match query_result {\n             PageTableItem::Mapped {\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -47,11 +47,11 @@ use log::info;\n use spin::Once;\n \n use super::{\n-    nr_subpage_per_huge,\n-    page::{\n-        meta::{impl_page_meta, mapping, MetaPageMeta},\n-        ContPages, Page,\n+    frame::{\n+        meta::{impl_frame_meta_for, mapping, MetaPageMeta},\n+        Frame, Segment,\n     },\n+    nr_subpage_per_huge,\n     page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags},\n     page_table::{KernelMode, PageTable},\n     Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE,\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -111,7 +111,7 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n \n /// Returns whether the given address should be mapped as tracked.\n ///\n-/// About what is tracked mapping, see [`crate::mm::page::meta::MapTrackingStatus`].\n+/// About what is tracked mapping, see [`crate::mm::frame::meta::MapTrackingStatus`].\n pub(crate) fn should_map_as_tracked(addr: Vaddr) -> bool {\n     !(LINEAR_MAPPING_VADDR_RANGE.contains(&addr) || VMALLOC_VADDR_RANGE.contains(&addr))\n }\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -131,7 +131,7 @@ pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingC\n ///\n /// This function should be called before:\n ///  - any initializer that modifies the kernel page table.\n-pub fn init_kernel_page_table(meta_pages: ContPages<MetaPageMeta>) {\n+pub fn init_kernel_page_table(meta_pages: Segment<MetaPageMeta>) {\n     info!(\"Initializing the kernel page table\");\n \n     let regions = crate::boot::memory_regions();\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -163,8 +163,8 @@ pub fn init_kernel_page_table(meta_pages: ContPages<MetaPageMeta>) {\n \n     // Map the metadata pages.\n     {\n-        let start_va = mapping::page_to_meta::<PagingConsts>(0);\n-        let from = start_va..start_va + meta_pages.nbytes();\n+        let start_va = mapping::frame_to_meta::<PagingConsts>(0);\n+        let from = start_va..start_va + meta_pages.size();\n         let prop = PageProperty {\n             flags: PageFlags::RW,\n             cache: CachePolicy::Writeback,\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -214,7 +214,7 @@ pub fn init_kernel_page_table(meta_pages: ContPages<MetaPageMeta>) {\n         };\n         let mut cursor = kpt.cursor_mut(&from).unwrap();\n         for frame_paddr in to.step_by(PAGE_SIZE) {\n-            let page = Page::<KernelMeta>::from_unused(frame_paddr, KernelMeta::default());\n+            let page = Frame::<KernelMeta>::from_unused(frame_paddr, KernelMeta);\n             // SAFETY: we are doing mappings for the kernel.\n             unsafe {\n                 let _old = cursor.map(page.into(), prop);\ndiff --git a/ostd/src/mm/kspace/mod.rs b/ostd/src/mm/kspace/mod.rs\n--- a/ostd/src/mm/kspace/mod.rs\n+++ b/ostd/src/mm/kspace/mod.rs\n@@ -249,6 +249,6 @@ pub unsafe fn activate_kernel_page_table() {\n \n /// The metadata of pages that contains the kernel itself.\n #[derive(Debug, Default)]\n-pub struct KernelMeta {}\n+pub struct KernelMeta;\n \n-impl_page_meta!(KernelMeta);\n+impl_frame_meta_for!(KernelMeta);\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -14,7 +14,6 @@ pub(crate) mod heap_allocator;\n mod io;\n pub(crate) mod kspace;\n mod offset;\n-pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n pub mod stat;\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -25,7 +24,12 @@ use core::{fmt::Debug, ops::Range};\n \n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n-    frame::{options::FrameAllocOptions, Frame, Segment},\n+    frame::{\n+        allocator::FrameAllocOptions,\n+        segment::{Segment, USegment},\n+        untyped::{AnyUFrameMeta, UFrame, UntypedMem},\n+        Frame,\n+    },\n     io::{\n         Fallible, FallibleVmRead, FallibleVmWrite, Infallible, PodOnce, VmIo, VmIoOnce, VmReader,\n         VmWriter,\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -34,7 +38,7 @@ pub use self::{\n     vm_space::VmSpace,\n };\n pub(crate) use self::{\n-    kspace::paddr_to_vaddr, page::meta::init as init_page_meta, page_prop::PrivilegedPageFlags,\n+    frame::meta::init as init_page_meta, kspace::paddr_to_vaddr, page_prop::PrivilegedPageFlags,\n     page_table::PageTable,\n };\n use crate::arch::mm::PagingConsts;\ndiff --git a/ostd/src/mm/page/allocator.rs /dev/null\n--- a/ostd/src/mm/page/allocator.rs\n+++ /dev/null\n@@ -1,158 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The physical page memory allocator.\n-//!\n-//! TODO: Decouple it with the frame allocator in [`crate::mm::frame::options`] by\n-//! allocating pages rather untyped memory from this module.\n-\n-use alloc::vec::Vec;\n-\n-use align_ext::AlignExt;\n-use buddy_system_allocator::FrameAllocator;\n-use log::info;\n-use spin::Once;\n-\n-use super::{cont_pages::ContPages, meta::PageMeta, Page};\n-use crate::{\n-    boot::memory_region::MemoryRegionType,\n-    mm::{Paddr, PAGE_SIZE},\n-    sync::SpinLock,\n-};\n-\n-/// FrameAllocator with a counter for allocated memory\n-pub(in crate::mm) struct CountingFrameAllocator {\n-    allocator: FrameAllocator,\n-    total: usize,\n-    allocated: usize,\n-}\n-\n-impl CountingFrameAllocator {\n-    pub fn new(allocator: FrameAllocator, total: usize) -> Self {\n-        CountingFrameAllocator {\n-            allocator,\n-            total,\n-            allocated: 0,\n-        }\n-    }\n-\n-    pub fn alloc(&mut self, count: usize) -> Option<usize> {\n-        match self.allocator.alloc(count) {\n-            Some(value) => {\n-                self.allocated += count * PAGE_SIZE;\n-                Some(value)\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    pub fn dealloc(&mut self, start_frame: usize, count: usize) {\n-        self.allocator.dealloc(start_frame, count);\n-        self.allocated -= count * PAGE_SIZE;\n-    }\n-\n-    pub fn mem_total(&self) -> usize {\n-        self.total\n-    }\n-\n-    pub fn mem_available(&self) -> usize {\n-        self.total - self.allocated\n-    }\n-}\n-\n-pub(in crate::mm) static PAGE_ALLOCATOR: Once<SpinLock<CountingFrameAllocator>> = Once::new();\n-\n-/// Allocate a single page.\n-///\n-/// The metadata of the page is initialized with the given metadata.\n-pub(crate) fn alloc_single<M: PageMeta>(metadata: M) -> Option<Page<M>> {\n-    PAGE_ALLOCATOR\n-        .get()\n-        .unwrap()\n-        .disable_irq()\n-        .lock()\n-        .alloc(1)\n-        .map(|idx| {\n-            let paddr = idx * PAGE_SIZE;\n-            Page::from_unused(paddr, metadata)\n-        })\n-}\n-\n-/// Allocate a contiguous range of pages of a given length in bytes.\n-///\n-/// The caller must provide a closure to initialize metadata for all the pages.\n-/// The closure receives the physical address of the page and returns the\n-/// metadata, which is similar to [`core::array::from_fn`].\n-///\n-/// # Panics\n-///\n-/// The function panics if the length is not base-page-aligned.\n-pub(crate) fn alloc_contiguous<M: PageMeta, F>(len: usize, metadata_fn: F) -> Option<ContPages<M>>\n-where\n-    F: FnMut(Paddr) -> M,\n-{\n-    assert!(len % PAGE_SIZE == 0);\n-    PAGE_ALLOCATOR\n-        .get()\n-        .unwrap()\n-        .disable_irq()\n-        .lock()\n-        .alloc(len / PAGE_SIZE)\n-        .map(|start| {\n-            ContPages::from_unused(start * PAGE_SIZE..start * PAGE_SIZE + len, metadata_fn)\n-        })\n-}\n-\n-/// Allocate pages.\n-///\n-/// The allocated pages are not guaranteed to be contiguous.\n-/// The total length of the allocated pages is `len`.\n-///\n-/// The caller must provide a closure to initialize metadata for all the pages.\n-/// The closure receives the physical address of the page and returns the\n-/// metadata, which is similar to [`core::array::from_fn`].\n-///\n-/// # Panics\n-///\n-/// The function panics if the length is not base-page-aligned.\n-pub(crate) fn alloc<M: PageMeta, F>(len: usize, mut metadata_fn: F) -> Option<Vec<Page<M>>>\n-where\n-    F: FnMut(Paddr) -> M,\n-{\n-    assert!(len % PAGE_SIZE == 0);\n-    let nframes = len / PAGE_SIZE;\n-    let mut allocator = PAGE_ALLOCATOR.get().unwrap().disable_irq().lock();\n-    let mut vector = Vec::new();\n-    for _ in 0..nframes {\n-        let paddr = allocator.alloc(1)? * PAGE_SIZE;\n-        let page = Page::<M>::from_unused(paddr, metadata_fn(paddr));\n-        vector.push(page);\n-    }\n-    Some(vector)\n-}\n-\n-pub(crate) fn init() {\n-    let regions = crate::boot::memory_regions();\n-    let mut total: usize = 0;\n-    let mut allocator = FrameAllocator::<32>::new();\n-    for region in regions.iter() {\n-        if region.typ() == MemoryRegionType::Usable {\n-            // Make the memory region page-aligned, and skip if it is too small.\n-            let start = region.base().align_up(PAGE_SIZE) / PAGE_SIZE;\n-            let region_end = region.base().checked_add(region.len()).unwrap();\n-            let end = region_end.align_down(PAGE_SIZE) / PAGE_SIZE;\n-            if end <= start {\n-                continue;\n-            }\n-            // Add global free pages to the frame allocator.\n-            allocator.add_frame(start, end);\n-            total += (end - start) * PAGE_SIZE;\n-            info!(\n-                \"Found usable region, start:{:x}, end:{:x}\",\n-                region.base(),\n-                region.base() + region.len()\n-            );\n-        }\n-    }\n-    let counting_allocator = CountingFrameAllocator::new(allocator, total);\n-    PAGE_ALLOCATOR.call_once(|| SpinLock::new(counting_allocator));\n-}\ndiff --git a/ostd/src/mm/page/cont_pages.rs /dev/null\n--- a/ostd/src/mm/page/cont_pages.rs\n+++ /dev/null\n@@ -1,191 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! A contiguous range of pages.\n-\n-use alloc::vec::Vec;\n-use core::{mem::ManuallyDrop, ops::Range};\n-\n-use super::{inc_page_ref_count, meta::PageMeta, Page};\n-use crate::mm::{Paddr, PAGE_SIZE};\n-\n-/// A contiguous range of physical memory pages.\n-///\n-/// This is a handle to many contiguous pages. It will be more lightweight\n-/// than owning an array of page handles.\n-///\n-/// The ownership is achieved by the reference counting mechanism of pages.\n-/// When constructing a `ContPages`, the page handles are created then\n-/// forgotten, leaving the reference count. When dropping a it, the page\n-/// handles are restored and dropped, decrementing the reference count.\n-#[derive(Debug)]\n-pub struct ContPages<M: PageMeta> {\n-    range: Range<Paddr>,\n-    _marker: core::marker::PhantomData<M>,\n-}\n-\n-impl<M: PageMeta> Drop for ContPages<M> {\n-    fn drop(&mut self) {\n-        for paddr in self.range.clone().step_by(PAGE_SIZE) {\n-            // SAFETY: for each page there would be a forgotten handle\n-            // when creating the `ContPages` object.\n-            drop(unsafe { Page::<M>::from_raw(paddr) });\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> Clone for ContPages<M> {\n-    fn clone(&self) -> Self {\n-        for paddr in self.range.clone().step_by(PAGE_SIZE) {\n-            // SAFETY: for each page there would be a forgotten handle\n-            // when creating the `ContPages` object, so we already have\n-            // reference counts for the pages.\n-            unsafe { inc_page_ref_count(paddr) };\n-        }\n-        Self {\n-            range: self.range.clone(),\n-            _marker: core::marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> ContPages<M> {\n-    /// Creates a new `ContPages` from unused pages.\n-    ///\n-    /// The caller must provide a closure to initialize metadata for all the pages.\n-    /// The closure receives the physical address of the page and returns the\n-    /// metadata, which is similar to [`core::array::from_fn`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if:\n-    ///  - the physical address is invalid or not aligned;\n-    ///  - any of the pages are already in use.\n-    pub fn from_unused<F>(range: Range<Paddr>, mut metadata_fn: F) -> Self\n-    where\n-        F: FnMut(Paddr) -> M,\n-    {\n-        for paddr in range.clone().step_by(PAGE_SIZE) {\n-            let _ = ManuallyDrop::new(Page::<M>::from_unused(paddr, metadata_fn(paddr)));\n-        }\n-        Self {\n-            range,\n-            _marker: core::marker::PhantomData,\n-        }\n-    }\n-\n-    /// Gets the start physical address of the contiguous pages.\n-    pub fn start_paddr(&self) -> Paddr {\n-        self.range.start\n-    }\n-\n-    /// Gets the end physical address of the contiguous pages.\n-    pub fn end_paddr(&self) -> Paddr {\n-        self.range.end\n-    }\n-\n-    /// Gets the length in bytes of the contiguous pages.\n-    pub fn nbytes(&self) -> usize {\n-        self.range.end - self.range.start\n-    }\n-\n-    /// Splits the pages into two at the given byte offset from the start.\n-    ///\n-    /// The resulting pages cannot be empty. So the offset cannot be neither\n-    /// zero nor the length of the pages.\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if the offset is out of bounds, at either ends, or\n-    /// not base-page-aligned.\n-    pub fn split(self, offset: usize) -> (Self, Self) {\n-        assert!(offset % PAGE_SIZE == 0);\n-        assert!(0 < offset && offset < self.nbytes());\n-\n-        let old = ManuallyDrop::new(self);\n-        let at = old.range.start + offset;\n-\n-        (\n-            Self {\n-                range: old.range.start..at,\n-                _marker: core::marker::PhantomData,\n-            },\n-            Self {\n-                range: at..old.range.end,\n-                _marker: core::marker::PhantomData,\n-            },\n-        )\n-    }\n-\n-    /// Gets an extra handle to the pages in the byte offset range.\n-    ///\n-    /// The sliced byte offset range in indexed by the offset from the start of\n-    /// the contiguous pages. The resulting pages holds extra reference counts.\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if the byte offset range is out of bounds, or if\n-    /// any of the ends of the byte offset range is not base-page aligned.\n-    pub fn slice(&self, range: &Range<usize>) -> Self {\n-        assert!(range.start % PAGE_SIZE == 0 && range.end % PAGE_SIZE == 0);\n-        let start = self.range.start + range.start;\n-        let end = self.range.start + range.end;\n-        assert!(start <= end && end <= self.range.end);\n-\n-        for paddr in (start..end).step_by(PAGE_SIZE) {\n-            // SAFETY: We already have reference counts for the pages since\n-            // for each page there would be a forgotten handle when creating\n-            // the `ContPages` object.\n-            unsafe { inc_page_ref_count(paddr) };\n-        }\n-\n-        Self {\n-            range: start..end,\n-            _marker: core::marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> From<Page<M>> for ContPages<M> {\n-    fn from(page: Page<M>) -> Self {\n-        let pa = page.paddr();\n-        let _ = ManuallyDrop::new(page);\n-        Self {\n-            range: pa..pa + PAGE_SIZE,\n-            _marker: core::marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> From<ContPages<M>> for Vec<Page<M>> {\n-    fn from(pages: ContPages<M>) -> Self {\n-        let vector = pages\n-            .range\n-            .clone()\n-            .step_by(PAGE_SIZE)\n-            .map(|i|\n-            // SAFETY: for each page there would be a forgotten handle\n-            // when creating the `ContPages` object.\n-            unsafe { Page::<M>::from_raw(i) })\n-            .collect();\n-        let _ = ManuallyDrop::new(pages);\n-        vector\n-    }\n-}\n-\n-impl<M: PageMeta> Iterator for ContPages<M> {\n-    type Item = Page<M>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.range.start < self.range.end {\n-            // SAFETY: each page in the range would be a handle forgotten\n-            // when creating the `ContPages` object.\n-            let page = unsafe { Page::<M>::from_raw(self.range.start) };\n-            self.range.start += PAGE_SIZE;\n-            // The end cannot be non-page-aligned.\n-            debug_assert!(self.range.start <= self.range.end);\n-            Some(page)\n-        } else {\n-            None\n-        }\n-    }\n-}\ndiff --git a/ostd/src/mm/page/meta.rs /dev/null\n--- a/ostd/src/mm/page/meta.rs\n+++ /dev/null\n@@ -1,323 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Metadata management of pages.\n-//!\n-//! You can picture a globally shared, static, gigantic array of metadata initialized for each page.\n-//! An entry in the array is called a `MetaSlot`, which contains the metadata of a page. There would\n-//! be a dedicated small \"heap\" space in each slot for dynamic metadata. You can store anything as the\n-//! metadata of a page as long as it's [`Sync`].\n-//!\n-//! In the implementation level, the slots are placed in the metadata pages mapped to a certain virtual\n-//! address. It is faster, simpler, safer and more versatile compared with an actual static array\n-//! implementation.\n-\n-pub mod mapping {\n-    //! The metadata of each physical page is linear mapped to fixed virtual addresses\n-    //! in [`FRAME_METADATA_RANGE`].\n-\n-    use core::mem::size_of;\n-\n-    use super::MetaSlot;\n-    use crate::mm::{kspace::FRAME_METADATA_RANGE, Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE};\n-\n-    /// Converts a physical address of a base page to the virtual address of the metadata slot.\n-    pub const fn page_to_meta<C: PagingConstsTrait>(paddr: Paddr) -> Vaddr {\n-        let base = FRAME_METADATA_RANGE.start;\n-        let offset = paddr / PAGE_SIZE;\n-        base + offset * size_of::<MetaSlot>()\n-    }\n-\n-    /// Converts a virtual address of the metadata slot to the physical address of the page.\n-    pub const fn meta_to_page<C: PagingConstsTrait>(vaddr: Vaddr) -> Paddr {\n-        let base = FRAME_METADATA_RANGE.start;\n-        let offset = (vaddr - base) / size_of::<MetaSlot>();\n-        offset * PAGE_SIZE\n-    }\n-}\n-\n-use core::{\n-    any::Any,\n-    cell::UnsafeCell,\n-    mem::{size_of, MaybeUninit},\n-    sync::atomic::{AtomicU32, Ordering},\n-};\n-\n-use align_ext::AlignExt;\n-use log::info;\n-use static_assertions::const_assert_eq;\n-\n-use super::{allocator, ContPages};\n-use crate::{\n-    arch::mm::PagingConsts,\n-    mm::{\n-        kspace::LINEAR_MAPPING_BASE_VADDR, paddr_to_vaddr, page_size, page_table::boot_pt,\n-        CachePolicy, Paddr, PageFlags, PageProperty, PrivilegedPageFlags, Vaddr, PAGE_SIZE,\n-    },\n-    panic::abort,\n-};\n-\n-/// The maximum number of bytes of the metadata of a page.\n-pub const PAGE_METADATA_MAX_SIZE: usize =\n-    META_SLOT_SIZE - size_of::<AtomicU32>() - size_of::<PageMetaVtablePtr>();\n-/// The maximum alignment in bytes of the metadata of a page.\n-pub const PAGE_METADATA_MAX_ALIGN: usize = align_of::<MetaSlot>();\n-\n-const META_SLOT_SIZE: usize = 64;\n-\n-#[repr(C)]\n-pub(in crate::mm) struct MetaSlot {\n-    /// The metadata of the page.\n-    ///\n-    /// It is placed at the beginning of a slot because:\n-    ///  - the implementation can simply cast a `*const MetaSlot`\n-    ///    to a `*const PageMeta` for manipulation;\n-    ///  - if the metadata need special alignment, we can provide\n-    ///    at most `PAGE_METADATA_ALIGN` bytes of alignment;\n-    ///  - the subsequent fields can utilize the padding of the\n-    ///    reference count to save space.\n-    storage: UnsafeCell<[u8; PAGE_METADATA_MAX_SIZE]>,\n-    /// The reference count of the page.\n-    ///\n-    /// Specifically, the reference count has the following meaning:\n-    /// * `REF_COUNT_UNUSED`: The page is not in use.\n-    /// * `0`: The page is being constructed ([`Page::from_unused`])\n-    ///   or destructured ([`drop_last_in_place`]).\n-    /// * `1..REF_COUNT_MAX`: The page is in use.\n-    /// * `REF_COUNT_MAX..REF_COUNT_UNUSED`: Illegal values to\n-    ///   prevent the reference count from overflowing. Otherwise,\n-    ///   overflowing the reference count will cause soundness issue.\n-    ///\n-    /// [`Page::from_unused`]: super::Page::from_unused\n-    pub(super) ref_count: AtomicU32,\n-    /// The virtual table that indicates the type of the metadata.\n-    pub(super) vtable_ptr: UnsafeCell<MaybeUninit<PageMetaVtablePtr>>,\n-}\n-\n-pub(super) const REF_COUNT_UNUSED: u32 = u32::MAX;\n-const REF_COUNT_MAX: u32 = i32::MAX as u32;\n-\n-type PageMetaVtablePtr = core::ptr::DynMetadata<dyn PageMeta>;\n-\n-const_assert_eq!(PAGE_SIZE % META_SLOT_SIZE, 0);\n-const_assert_eq!(size_of::<MetaSlot>(), META_SLOT_SIZE);\n-\n-/// All page metadata types must implement this trait.\n-///\n-/// If a page type needs specific drop behavior, it should specify\n-/// when implementing this trait. When we drop the last handle to\n-/// this page, the `on_drop` method will be called. The `on_drop`\n-/// method is called with the physical address of the page.\n-///\n-/// # Safety\n-///\n-/// The implemented structure must have a size less than or equal to\n-/// [`PAGE_METADATA_MAX_SIZE`] and an alignment less than or equal to\n-/// [`PAGE_METADATA_MAX_ALIGN`].\n-pub unsafe trait PageMeta: Any + Send + Sync + 'static {\n-    fn on_drop(&mut self, _paddr: Paddr) {}\n-}\n-\n-/// Makes a structure usable as a page metadata.\n-///\n-/// Directly implementing [`PageMeta`] is not safe since the size and alignment\n-/// must be checked. This macro provides a safe way to implement the trait with\n-/// compile-time checks.\n-#[macro_export]\n-macro_rules! impl_page_meta {\n-    ($($t:ty),*) => {\n-        $(\n-            use static_assertions::const_assert;\n-            const_assert!(size_of::<$t>() <= $crate::mm::page::meta::PAGE_METADATA_MAX_SIZE);\n-            const_assert!(align_of::<$t>() <= $crate::mm::page::meta::PAGE_METADATA_MAX_ALIGN);\n-            // SAFETY: The size and alignment of the structure are checked.\n-            unsafe impl $crate::mm::page::meta::PageMeta for $t {}\n-        )*\n-    };\n-}\n-\n-pub use impl_page_meta;\n-\n-impl MetaSlot {\n-    /// Increases the page reference count by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller must have already held a reference to the page.\n-    pub(super) unsafe fn inc_ref_count(&self) {\n-        let last_ref_cnt = self.ref_count.fetch_add(1, Ordering::Relaxed);\n-        debug_assert!(last_ref_cnt != 0 && last_ref_cnt != REF_COUNT_UNUSED);\n-\n-        if last_ref_cnt >= REF_COUNT_MAX {\n-            // This follows the same principle as the `Arc::clone` implementation to prevent the\n-            // reference count from overflowing. See also\n-            // <https://doc.rust-lang.org/std/sync/struct.Arc.html#method.clone>.\n-            abort();\n-        }\n-    }\n-}\n-\n-/// An internal routine in dropping implementations.\n-///\n-/// # Safety\n-///\n-/// The caller should ensure that the pointer points to a page's metadata slot. The\n-/// page should have a last handle to the page, and the page is about to be dropped,\n-/// as the metadata slot after this operation becomes uninitialized.\n-pub(super) unsafe fn drop_last_in_place(ptr: *mut MetaSlot) {\n-    // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n-    // immutable reference to it is always safe.\n-    let slot = unsafe { &*ptr };\n-\n-    // This should be guaranteed as a safety requirement.\n-    debug_assert_eq!(slot.ref_count.load(Ordering::Relaxed), 0);\n-\n-    let paddr = mapping::meta_to_page::<PagingConsts>(ptr as Vaddr);\n-\n-    // SAFETY: We have exclusive access to the page metadata.\n-    let vtable_ptr = unsafe { &mut *slot.vtable_ptr.get() };\n-    // SAFETY: The page metadata is initialized and valid.\n-    let vtable_ptr = unsafe { vtable_ptr.assume_init_read() };\n-\n-    let meta_ptr: *mut dyn PageMeta = core::ptr::from_raw_parts_mut(ptr, vtable_ptr);\n-\n-    // SAFETY: `ptr` points to the metadata storage which is valid to be mutably borrowed under\n-    // `vtable_ptr` because the metadata is valid, the vtable is correct, and we have the exclusive\n-    // access to the page metadata.\n-    unsafe {\n-        // Invoke the custom `on_drop` handler.\n-        (*meta_ptr).on_drop(paddr);\n-        // Drop the page metadata.\n-        core::ptr::drop_in_place(meta_ptr);\n-    }\n-\n-    // `Release` pairs with the `Acquire` in `Page::from_unused` and ensures `drop_in_place` won't\n-    // be reordered after this memory store.\n-    slot.ref_count.store(REF_COUNT_UNUSED, Ordering::Release);\n-\n-    // Deallocate the page.\n-    // It would return the page to the allocator for further use. This would be done\n-    // after the release of the metadata to avoid re-allocation before the metadata\n-    // is reset.\n-    allocator::PAGE_ALLOCATOR\n-        .get()\n-        .unwrap()\n-        .lock()\n-        .dealloc(paddr / PAGE_SIZE, 1);\n-}\n-\n-/// The metadata of pages that holds metadata of pages.\n-#[derive(Debug, Default)]\n-pub struct MetaPageMeta {}\n-\n-impl_page_meta!(MetaPageMeta);\n-\n-/// Initializes the metadata of all physical pages.\n-///\n-/// The function returns a list of `Page`s containing the metadata.\n-pub(crate) fn init() -> ContPages<MetaPageMeta> {\n-    let max_paddr = {\n-        let regions = crate::boot::memory_regions();\n-        regions.iter().map(|r| r.base() + r.len()).max().unwrap()\n-    };\n-\n-    info!(\n-        \"Initializing page metadata for physical memory up to {:x}\",\n-        max_paddr\n-    );\n-\n-    add_temp_linear_mapping(max_paddr);\n-\n-    super::MAX_PADDR.store(max_paddr, Ordering::Relaxed);\n-\n-    let num_pages = max_paddr / page_size::<PagingConsts>(1);\n-    let (num_meta_pages, meta_pages) = alloc_meta_pages(num_pages);\n-\n-    // Map the metadata pages.\n-    boot_pt::with_borrow(|boot_pt| {\n-        for i in 0..num_meta_pages {\n-            let frame_paddr = meta_pages + i * PAGE_SIZE;\n-            let vaddr = mapping::page_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n-            let prop = PageProperty {\n-                flags: PageFlags::RW,\n-                cache: CachePolicy::Writeback,\n-                priv_flags: PrivilegedPageFlags::GLOBAL,\n-            };\n-            // SAFETY: we are doing the metadata mappings for the kernel.\n-            unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n-        }\n-    })\n-    .unwrap();\n-\n-    // Now the metadata pages are mapped, we can initialize the metadata.\n-    ContPages::from_unused(meta_pages..meta_pages + num_meta_pages * PAGE_SIZE, |_| {\n-        MetaPageMeta {}\n-    })\n-}\n-\n-fn alloc_meta_pages(num_pages: usize) -> (usize, Paddr) {\n-    let num_meta_pages = num_pages\n-        .checked_mul(size_of::<MetaSlot>())\n-        .unwrap()\n-        .div_ceil(PAGE_SIZE);\n-    let start_paddr = allocator::PAGE_ALLOCATOR\n-        .get()\n-        .unwrap()\n-        .lock()\n-        .alloc(num_meta_pages)\n-        .unwrap()\n-        * PAGE_SIZE;\n-\n-    let slots = paddr_to_vaddr(start_paddr) as *mut MetaSlot;\n-    for i in 0..num_pages {\n-        // SAFETY: The memory is successfully allocated with `num_pages` slots so the index must be\n-        // within the range.\n-        let slot = unsafe { slots.add(i) };\n-\n-        // SAFETY: The memory is just allocated so we have exclusive access and it's valid for\n-        // writing.\n-        unsafe {\n-            slot.write(MetaSlot {\n-                storage: UnsafeCell::new([0; PAGE_METADATA_MAX_SIZE]),\n-                ref_count: AtomicU32::new(REF_COUNT_UNUSED),\n-                vtable_ptr: UnsafeCell::new(MaybeUninit::uninit()),\n-            });\n-        }\n-    }\n-\n-    (num_meta_pages, start_paddr)\n-}\n-\n-/// Adds a temporary linear mapping for the metadata pages.\n-///\n-/// We only assume boot page table to contain 4G linear mapping. Thus if the\n-/// physical memory is huge we end up depleted of linear virtual memory for\n-/// initializing metadata.\n-fn add_temp_linear_mapping(max_paddr: Paddr) {\n-    const PADDR4G: Paddr = 0x1_0000_0000;\n-\n-    if max_paddr <= PADDR4G {\n-        return;\n-    }\n-\n-    // TODO: We don't know if the allocator would allocate from low to high or\n-    // not. So we prepare all linear mappings in the boot page table. Hope it\n-    // won't drag the boot performance much.\n-    let end_paddr = max_paddr.align_up(PAGE_SIZE);\n-    let prange = PADDR4G..end_paddr;\n-    let prop = PageProperty {\n-        flags: PageFlags::RW,\n-        cache: CachePolicy::Writeback,\n-        priv_flags: PrivilegedPageFlags::GLOBAL,\n-    };\n-\n-    // SAFETY: we are doing the linear mapping for the kernel.\n-    unsafe {\n-        boot_pt::with_borrow(|boot_pt| {\n-            for paddr in prange.step_by(PAGE_SIZE) {\n-                let vaddr = LINEAR_MAPPING_BASE_VADDR + paddr;\n-                boot_pt.map_base_page(vaddr, paddr / PAGE_SIZE, prop);\n-            }\n-        })\n-        .unwrap();\n-    }\n-}\ndiff --git a/ostd/src/mm/page/mod.rs /dev/null\n--- a/ostd/src/mm/page/mod.rs\n+++ /dev/null\n@@ -1,379 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Physical memory page management.\n-//!\n-//! A page is an aligned, contiguous range of bytes in physical memory. The sizes\n-//! of base pages and huge pages are architecture-dependent. A page can be mapped\n-//! to a virtual address using the page table.\n-//!\n-//! Pages can be accessed through page handles, namely, [`Page`]. A page handle\n-//! is a reference-counted handle to a page. When all handles to a page are dropped,\n-//! the page is released and can be reused.\n-//!\n-//! Pages can have dedicated metadata, which is implemented in the [`meta`] module.\n-//! The reference count and usage of a page are stored in the metadata as well, leaving\n-//! the handle only a pointer to the metadata.\n-\n-pub mod allocator;\n-mod cont_pages;\n-pub mod meta;\n-\n-use core::{\n-    any::Any,\n-    marker::PhantomData,\n-    mem::ManuallyDrop,\n-    sync::atomic::{AtomicUsize, Ordering},\n-};\n-\n-pub use cont_pages::ContPages;\n-use meta::{\n-    mapping, MetaSlot, PageMeta, PAGE_METADATA_MAX_ALIGN, PAGE_METADATA_MAX_SIZE, REF_COUNT_UNUSED,\n-};\n-\n-use super::{frame::FrameMeta, Frame, PagingLevel, PAGE_SIZE};\n-use crate::mm::{Paddr, PagingConsts, Vaddr};\n-\n-static MAX_PADDR: AtomicUsize = AtomicUsize::new(0);\n-\n-/// A page with a statically-known usage, whose metadata is represented by `M`.\n-#[derive(Debug)]\n-pub struct Page<M: PageMeta> {\n-    pub(super) ptr: *const MetaSlot,\n-    pub(super) _marker: PhantomData<M>,\n-}\n-\n-unsafe impl<M: PageMeta> Send for Page<M> {}\n-\n-unsafe impl<M: PageMeta> Sync for Page<M> {}\n-\n-impl<M: PageMeta> Page<M> {\n-    /// Get a `Page` handle with a specific usage from a raw, unused page.\n-    ///\n-    /// The caller should provide the initial metadata of the page.\n-    ///\n-    /// # Panics\n-    ///\n-    /// The function panics if:\n-    ///  - the physical address is out of bound or not aligned;\n-    ///  - the page is already in use.\n-    pub fn from_unused(paddr: Paddr, metadata: M) -> Self {\n-        assert!(paddr % PAGE_SIZE == 0);\n-        assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-\n-        // Checking unsafe preconditions of the `PageMeta` trait.\n-        debug_assert!(size_of::<M>() <= PAGE_METADATA_MAX_SIZE);\n-        debug_assert!(align_of::<M>() <= PAGE_METADATA_MAX_ALIGN);\n-\n-        let vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        let ptr = vaddr as *const MetaSlot;\n-\n-        // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n-        // immutable reference to it is always safe.\n-        let slot = unsafe { &*ptr };\n-\n-        // `Acquire` pairs with the `Release` in `drop_last_in_place` and ensures the metadata\n-        // initialization won't be reordered before this memory compare-and-exchange.\n-        slot.ref_count\n-            .compare_exchange(REF_COUNT_UNUSED, 0, Ordering::Acquire, Ordering::Relaxed)\n-            .expect(\"Page already in use when trying to get a new handle\");\n-\n-        // SAFETY: We have exclusive access to the page metadata.\n-        let vtable_ptr = unsafe { &mut *slot.vtable_ptr.get() };\n-        vtable_ptr.write(core::ptr::metadata(&metadata as &dyn PageMeta));\n-\n-        // SAFETY:\n-        // 1. `ptr` points to the first field of `MetaSlot` (guaranteed by `repr(C)`), which is the\n-        //    metadata storage.\n-        // 2. The size and the alignment of the metadata storage is large enough to hold `M`\n-        //    (guaranteed by the safety requirement of the `PageMeta` trait).\n-        // 3. We have exclusive access to the metadata storage (guaranteed by the reference count).\n-        unsafe { ptr.cast::<M>().cast_mut().write(metadata) };\n-\n-        // Assuming no one can create a `Page` instance directly from the page address, `Relaxed`\n-        // is fine here. Otherwise, we should use `Release` to ensure that the metadata\n-        // initialization won't be reordered after this memory store.\n-        slot.ref_count.store(1, Ordering::Relaxed);\n-\n-        Self {\n-            ptr,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Forget the handle to the page.\n-    ///\n-    /// This will result in the page being leaked without calling the custom dropper.\n-    ///\n-    /// A physical address to the page is returned in case the page needs to be\n-    /// restored using [`Page::from_raw`] later. This is useful when some architectural\n-    /// data structures need to hold the page handle such as the page table.\n-    #[allow(unused)]\n-    pub(in crate::mm) fn into_raw(self) -> Paddr {\n-        let paddr = self.paddr();\n-        core::mem::forget(self);\n-        paddr\n-    }\n-\n-    /// Restore a forgotten `Page` from a physical address.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller should only restore a `Page` that was previously forgotten using\n-    /// [`Page::into_raw`].\n-    ///\n-    /// And the restoring operation should only be done once for a forgotten\n-    /// `Page`. Otherwise double-free will happen.\n-    ///\n-    /// Also, the caller ensures that the usage of the page is correct. There's\n-    /// no checking of the usage in this function.\n-    pub(in crate::mm) unsafe fn from_raw(paddr: Paddr) -> Self {\n-        let vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        let ptr = vaddr as *const MetaSlot;\n-\n-        Self {\n-            ptr,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Get the physical address.\n-    pub fn paddr(&self) -> Paddr {\n-        mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\n-    }\n-\n-    /// Get the paging level of this page.\n-    ///\n-    /// This is the level of the page table entry that maps the frame,\n-    /// which determines the size of the frame.\n-    ///\n-    /// Currently, the level is always 1, which means the frame is a regular\n-    /// page frame.\n-    pub const fn level(&self) -> PagingLevel {\n-        1\n-    }\n-\n-    /// Size of this page in bytes.\n-    pub const fn size(&self) -> usize {\n-        PAGE_SIZE\n-    }\n-\n-    /// Get the metadata of this page.\n-    pub fn meta(&self) -> &M {\n-        // SAFETY: `self.ptr` points to the metadata storage which is valid to be immutably\n-        // borrowed as `M` because the type is correct, it lives under the given lifetime, and no\n-        // one will mutably borrow the page metadata after initialization.\n-        unsafe { &*self.ptr.cast() }\n-    }\n-\n-    /// Get the reference count of the page.\n-    ///\n-    /// It returns the number of all references to the page, including all the\n-    /// existing page handles ([`Page`], [`DynPage`]), and all the mappings in the\n-    /// page table that points to the page.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The function is safe to call, but using it requires extra care. The\n-    /// reference count can be changed by other threads at any time including\n-    /// potentially between calling this method and acting on the result.\n-    pub fn reference_count(&self) -> u32 {\n-        self.slot().ref_count.load(Ordering::Relaxed)\n-    }\n-\n-    fn slot(&self) -> &MetaSlot {\n-        // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n-        // immutable reference to it is always safe.\n-        unsafe { &*self.ptr }\n-    }\n-}\n-\n-impl<M: PageMeta> Clone for Page<M> {\n-    fn clone(&self) -> Self {\n-        // SAFETY: We have already held a reference to the page.\n-        unsafe { self.slot().inc_ref_count() };\n-\n-        Self {\n-            ptr: self.ptr,\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> Drop for Page<M> {\n-    fn drop(&mut self) {\n-        let last_ref_cnt = self.slot().ref_count.fetch_sub(1, Ordering::Release);\n-        debug_assert!(last_ref_cnt != 0 && last_ref_cnt != REF_COUNT_UNUSED);\n-\n-        if last_ref_cnt == 1 {\n-            // A fence is needed here with the same reasons stated in the implementation of\n-            // `Arc::drop`: <https://doc.rust-lang.org/std/sync/struct.Arc.html#method.drop>.\n-            core::sync::atomic::fence(Ordering::Acquire);\n-\n-            // SAFETY: this is the last reference and is about to be dropped.\n-            unsafe {\n-                meta::drop_last_in_place(self.ptr as *mut MetaSlot);\n-            }\n-        }\n-    }\n-}\n-\n-/// A page with a dynamically-known usage.\n-///\n-/// It can also be used when the user don't care about the usage of the page.\n-#[derive(Debug)]\n-pub struct DynPage {\n-    ptr: *const MetaSlot,\n-}\n-\n-unsafe impl Send for DynPage {}\n-unsafe impl Sync for DynPage {}\n-\n-impl DynPage {\n-    /// Forget the handle to the page.\n-    ///\n-    /// This is the same as [`Page::into_raw`].\n-    ///\n-    /// This will result in the page being leaked without calling the custom dropper.\n-    ///\n-    /// A physical address to the page is returned in case the page needs to be\n-    /// restored using [`Self::from_raw`] later.\n-    pub(in crate::mm) fn into_raw(self) -> Paddr {\n-        let paddr = self.paddr();\n-        core::mem::forget(self);\n-        paddr\n-    }\n-\n-    /// Restore a forgotten page from a physical address.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The safety concerns are the same as [`Page::from_raw`].\n-    pub(in crate::mm) unsafe fn from_raw(paddr: Paddr) -> Self {\n-        let vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        let ptr = vaddr as *const MetaSlot;\n-\n-        Self { ptr }\n-    }\n-\n-    /// Get the metadata of this page.\n-    pub fn meta(&self) -> &dyn Any {\n-        let slot = self.slot();\n-\n-        // SAFETY: The page metadata is valid to be borrowed immutably, since it will never be\n-        // borrowed mutably after initialization.\n-        let vtable_ptr = unsafe { &*slot.vtable_ptr.get() };\n-\n-        // SAFETY: The page metadata is initialized and valid.\n-        let vtable_ptr = *unsafe { vtable_ptr.assume_init_ref() };\n-\n-        let meta_ptr: *const dyn PageMeta = core::ptr::from_raw_parts(self.ptr, vtable_ptr);\n-\n-        // SAFETY: `self.ptr` points to the metadata storage which is valid to be immutably\n-        // borrowed under `vtable_ptr` because the vtable is correct, it lives under the given\n-        // lifetime, and no one will mutably borrow the page metadata after initialization.\n-        (unsafe { &*meta_ptr }) as &dyn Any\n-    }\n-\n-    /// Get the physical address of the start of the page\n-    pub fn paddr(&self) -> Paddr {\n-        mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\n-    }\n-\n-    /// Get the paging level of this page.\n-    pub fn level(&self) -> PagingLevel {\n-        1\n-    }\n-\n-    /// Size of this page in bytes.\n-    pub fn size(&self) -> usize {\n-        PAGE_SIZE\n-    }\n-\n-    fn slot(&self) -> &MetaSlot {\n-        // SAFETY: `ptr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking an\n-        // immutable reference to it is always safe.\n-        unsafe { &*self.ptr }\n-    }\n-}\n-\n-impl<M: PageMeta> TryFrom<DynPage> for Page<M> {\n-    type Error = DynPage;\n-\n-    /// Try converting a [`DynPage`] into the statically-typed [`Page`].\n-    ///\n-    /// If the usage of the page is not the same as the expected usage, it will\n-    /// return the dynamic page itself as is.\n-    fn try_from(dyn_page: DynPage) -> Result<Self, Self::Error> {\n-        if dyn_page.meta().is::<M>() {\n-            let result = Page {\n-                ptr: dyn_page.ptr,\n-                _marker: PhantomData,\n-            };\n-            let _ = ManuallyDrop::new(dyn_page);\n-            Ok(result)\n-        } else {\n-            Err(dyn_page)\n-        }\n-    }\n-}\n-\n-impl<M: PageMeta> From<Page<M>> for DynPage {\n-    fn from(page: Page<M>) -> Self {\n-        let result = Self { ptr: page.ptr };\n-        let _ = ManuallyDrop::new(page);\n-        result\n-    }\n-}\n-\n-impl From<Frame> for DynPage {\n-    fn from(frame: Frame) -> Self {\n-        Page::<FrameMeta>::from(frame).into()\n-    }\n-}\n-\n-impl Clone for DynPage {\n-    fn clone(&self) -> Self {\n-        // SAFETY: We have already held a reference to the page.\n-        unsafe { self.slot().inc_ref_count() };\n-\n-        Self { ptr: self.ptr }\n-    }\n-}\n-\n-impl Drop for DynPage {\n-    fn drop(&mut self) {\n-        let last_ref_cnt = self.slot().ref_count.fetch_sub(1, Ordering::Release);\n-        debug_assert!(last_ref_cnt != 0 && last_ref_cnt != REF_COUNT_UNUSED);\n-\n-        if last_ref_cnt == 1 {\n-            // A fence is needed here with the same reasons stated in the implementation of\n-            // `Arc::drop`: <https://doc.rust-lang.org/std/sync/struct.Arc.html#method.drop>.\n-            core::sync::atomic::fence(Ordering::Acquire);\n-\n-            // SAFETY: this is the last reference and is about to be dropped.\n-            unsafe {\n-                meta::drop_last_in_place(self.ptr as *mut MetaSlot);\n-            }\n-        }\n-    }\n-}\n-\n-/// Increases the reference count of the page by one.\n-///\n-/// # Safety\n-///\n-/// The caller should ensure the following conditions:\n-///  1. The physical address must represent a valid page;\n-///  2. The caller must have already held a reference to the page.\n-pub(in crate::mm) unsafe fn inc_page_ref_count(paddr: Paddr) {\n-    debug_assert!(paddr % PAGE_SIZE == 0);\n-    debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-\n-    let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-    // SAFETY: `vaddr` points to a valid `MetaSlot` that will never be mutably borrowed, so taking\n-    // an immutable reference to it is always safe.\n-    let slot = unsafe { &*(vaddr as *const MetaSlot) };\n-\n-    // SAFETY: We have already held a reference to the page.\n-    unsafe { slot.inc_ref_count() };\n-}\ndiff --git a/ostd/src/mm/page_table/boot_pt.rs b/ostd/src/mm/page_table/boot_pt.rs\n--- a/ostd/src/mm/page_table/boot_pt.rs\n+++ b/ostd/src/mm/page_table/boot_pt.rs\n@@ -16,8 +16,8 @@ use crate::{\n     cpu::num_cpus,\n     cpu_local_cell,\n     mm::{\n-        nr_subpage_per_huge, paddr_to_vaddr, page::allocator::PAGE_ALLOCATOR, Paddr, PageProperty,\n-        PagingConstsTrait, Vaddr, PAGE_SIZE,\n+        frame::allocator::FRAME_ALLOCATOR, nr_subpage_per_huge, paddr_to_vaddr, Paddr,\n+        PageProperty, PagingConstsTrait, Vaddr, PAGE_SIZE,\n     },\n     sync::SpinLock,\n };\ndiff --git a/ostd/src/mm/page_table/boot_pt.rs b/ostd/src/mm/page_table/boot_pt.rs\n--- a/ostd/src/mm/page_table/boot_pt.rs\n+++ b/ostd/src/mm/page_table/boot_pt.rs\n@@ -221,7 +221,7 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     }\n \n     fn alloc_frame(&mut self) -> FrameNumber {\n-        let frame = PAGE_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n+        let frame = FRAME_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n         self.frames.push(frame);\n         // Zero it out.\n         let vaddr = paddr_to_vaddr(frame * PAGE_SIZE) as *mut u8;\ndiff --git a/ostd/src/mm/page_table/boot_pt.rs b/ostd/src/mm/page_table/boot_pt.rs\n--- a/ostd/src/mm/page_table/boot_pt.rs\n+++ b/ostd/src/mm/page_table/boot_pt.rs\n@@ -233,7 +233,7 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for BootPageTable<E, C> {\n     fn drop(&mut self) {\n         for frame in &self.frames {\n-            PAGE_ALLOCATOR.get().unwrap().lock().dealloc(*frame, 1);\n+            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(*frame, 1);\n         }\n     }\n }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -76,7 +76,9 @@ use super::{\n };\n use crate::{\n     mm::{\n-        kspace::should_map_as_tracked, paddr_to_vaddr, page::DynPage, Paddr, PageProperty, Vaddr,\n+        frame::{meta::AnyFrameMeta, Frame},\n+        kspace::should_map_as_tracked,\n+        paddr_to_vaddr, Paddr, PageProperty, Vaddr,\n     },\n     task::{disable_preempt, DisabledPreemptGuard},\n };\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -89,7 +91,7 @@ pub enum PageTableItem {\n     },\n     Mapped {\n         va: Vaddr,\n-        page: DynPage,\n+        page: Frame<dyn AnyFrameMeta>,\n         prop: PageProperty,\n     },\n     #[allow(dead_code)]\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -231,7 +233,7 @@ where\n                         len: page_size::<C>(level),\n                     });\n                 }\n-                Child::Page(page, prop) => {\n+                Child::Frame(page, prop) => {\n                     return Ok(PageTableItem::Mapped { va, page, prop });\n                 }\n                 Child::Untracked(pa, plevel, prop) => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -400,9 +402,9 @@ where\n         self.0.query()\n     }\n \n-    /// Maps the range starting from the current address to a [`DynPage`].\n+    /// Maps the range starting from the current address to a [`Frame<dyn AnyFrameMeta>`].\n     ///\n-    /// It returns the previously mapped [`DynPage`] if that exists.\n+    /// It returns the previously mapped [`Frame<dyn AnyFrameMeta>`] if that exists.\n     ///\n     /// # Panics\n     ///\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -415,7 +417,11 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n+    pub unsafe fn map(\n+        &mut self,\n+        page: Frame<dyn AnyFrameMeta>,\n+        prop: PageProperty,\n+    ) -> Option<Frame<dyn AnyFrameMeta>> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -437,7 +443,7 @@ where\n                     let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n                     self.0.push_level(pt);\n                 }\n-                Child::Page(_, _) => {\n+                Child::Frame(_, _) => {\n                     panic!(\"Mapping a smaller page in an already mapped huge page\");\n                 }\n                 Child::Untracked(_, _, _) => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -449,11 +455,11 @@ where\n         debug_assert_eq!(self.0.level, page.level());\n \n         // Map the current page.\n-        let old = self.0.cur_entry().replace(Child::Page(page, prop));\n+        let old = self.0.cur_entry().replace(Child::Frame(page, prop));\n         self.0.move_forward();\n \n         match old {\n-            Child::Page(old_page, _) => Some(old_page),\n+            Child::Frame(old_page, _) => Some(old_page),\n             Child::None => None,\n             Child::PageTable(_) => {\n                 todo!(\"Dropping page table nodes while mapping requires TLB flush\")\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -520,7 +526,7 @@ where\n                         let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n                         self.0.push_level(pt);\n                     }\n-                    Child::Page(_, _) => {\n+                    Child::Frame(_, _) => {\n                         panic!(\"Mapping a smaller page in an already mapped huge page\");\n                     }\n                     Child::Untracked(_, _, _) => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -614,7 +620,7 @@ where\n                     Child::None => {\n                         unreachable!(\"Already checked\");\n                     }\n-                    Child::Page(_, _) => {\n+                    Child::Frame(_, _) => {\n                         panic!(\"Removing part of a huge page\");\n                     }\n                     Child::Untracked(_, _, _) => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -631,7 +637,7 @@ where\n             self.0.move_forward();\n \n             return match old {\n-                Child::Page(page, prop) => PageTableItem::Mapped {\n+                Child::Frame(page, prop) => PageTableItem::Mapped {\n                     va: self.0.va,\n                     page,\n                     prop,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -796,7 +802,7 @@ where\n                 Child::Untracked(_, _, _) => {\n                     panic!(\"Copying untracked mappings\");\n                 }\n-                Child::Page(page, mut prop) => {\n+                Child::Frame(page, mut prop) => {\n                     let mapped_page_size = page.size();\n \n                     // Do protection.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -4,7 +4,7 @@ use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n     nr_subpage_per_huge, page_prop::PageProperty, page_size, Paddr, PagingConstsTrait, PagingLevel,\n-    Vaddr,\n+    PodOnce, Vaddr,\n };\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -339,7 +339,7 @@ pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n ///\n /// Note that a default PTE should be a PTE that points to nothing.\n pub trait PageTableEntryTrait:\n-    Clone + Copy + Debug + Default + Pod + Sized + Send + Sync + 'static\n+    Clone + Copy + Debug + Default + Pod + PodOnce + Sized + Send + Sync + 'static\n {\n     /// Create a set of new invalid page table flags that indicates an absent page.\n     ///\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -8,7 +8,7 @@ use super::{MapTrackingStatus, PageTableEntryTrait, RawPageTableNode};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        page::{inc_page_ref_count, DynPage},\n+        frame::{inc_frame_ref_count, meta::AnyFrameMeta, Frame},\n         page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel,\n     },\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -27,7 +27,7 @@ pub(in crate::mm) enum Child<\n     [(); C::NR_LEVELS as usize]:,\n {\n     PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage, PageProperty),\n+    Frame(Frame<dyn AnyFrameMeta>, PageProperty),\n     /// Pages not tracked by handles.\n     Untracked(Paddr, PagingLevel, PageProperty),\n     None,\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -53,7 +53,7 @@ where\n     ) -> bool {\n         match self {\n             Child::PageTable(pt) => node_level == pt.level() + 1,\n-            Child::Page(p, _) => {\n+            Child::Frame(p, _) => {\n                 node_level == p.level() && is_tracked == MapTrackingStatus::Tracked\n             }\n             Child::Untracked(_, level, _) => {\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -78,7 +78,7 @@ where\n                 let pt = ManuallyDrop::new(pt);\n                 E::new_pt(pt.paddr())\n             }\n-            Child::Page(page, prop) => {\n+            Child::Frame(page, prop) => {\n                 let level = page.level();\n                 E::new_page(page.into_raw(), level, prop)\n             }\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -119,8 +119,8 @@ where\n         match is_tracked {\n             MapTrackingStatus::Tracked => {\n                 // SAFETY: The physical address points to a valid page.\n-                let page = unsafe { DynPage::from_raw(paddr) };\n-                Child::Page(page, pte.prop())\n+                let page = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) };\n+                Child::Frame(page, pte.prop())\n             }\n             MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n             MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -150,7 +150,7 @@ where\n         if !pte.is_last(level) {\n             // SAFETY: The physical address is valid and the PTE already owns\n             // the reference to the page.\n-            unsafe { inc_page_ref_count(paddr) };\n+            unsafe { inc_frame_ref_count(paddr) };\n             // SAFETY: The physical address points to a valid page table node\n             // at the given level.\n             return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\ndiff --git a/ostd/src/mm/page_table/node/child.rs b/ostd/src/mm/page_table/node/child.rs\n--- a/ostd/src/mm/page_table/node/child.rs\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -160,10 +160,10 @@ where\n             MapTrackingStatus::Tracked => {\n                 // SAFETY: The physical address is valid and the PTE already owns\n                 // the reference to the page.\n-                unsafe { inc_page_ref_count(paddr) };\n+                unsafe { inc_frame_ref_count(paddr) };\n                 // SAFETY: The physical address points to a valid page.\n-                let page = unsafe { DynPage::from_raw(paddr) };\n-                Child::Page(page, pte.prop())\n+                let page = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) };\n+                Child::Frame(page, pte.prop())\n             }\n             MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n             MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -40,9 +40,9 @@ use super::{nr_subpage_per_huge, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr,\n-        page::{self, inc_page_ref_count, meta::PageMeta, DynPage, Page},\n-        Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n+        frame::{inc_frame_ref_count, meta::AnyFrameMeta, Frame},\n+        paddr_to_vaddr, FrameAllocOptions, Infallible, Paddr, PagingConstsTrait, PagingLevel,\n+        VmReader,\n     },\n };\n \ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -79,7 +79,7 @@ where\n     /// Converts a raw handle to an accessible handle by pertaining the lock.\n     pub(super) fn lock(self) -> PageTableNode<E, C> {\n         let level = self.level;\n-        let page: Page<PageTablePageMeta<E, C>> = self.into();\n+        let page: Frame<PageTablePageMeta<E, C>> = self.into();\n \n         // Acquire the lock.\n         let meta = page.meta();\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -166,7 +166,7 @@ where\n         // SAFETY: We have a reference count to the page and can safely increase the reference\n         // count by one more.\n         unsafe {\n-            inc_page_ref_count(self.paddr());\n+            inc_frame_ref_count(self.paddr());\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -187,7 +187,7 @@ where\n }\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> From<RawPageTableNode<E, C>>\n-    for Page<PageTablePageMeta<E, C>>\n+    for Frame<PageTablePageMeta<E, C>>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -196,7 +196,7 @@ where\n         // SAFETY: The physical address in the raw handle is valid and we are\n         // transferring the ownership to a new handle. No increment of the reference\n         // count is needed.\n-        unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(raw.paddr()) }\n+        unsafe { Frame::<PageTablePageMeta<E, C>>::from_raw(raw.paddr()) }\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -207,7 +207,7 @@ where\n     fn drop(&mut self) {\n         // SAFETY: The physical address in the raw handle is valid. The restored\n         // handle is dropped to decrement the reference count.\n-        drop(unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(self.paddr()) });\n+        drop(unsafe { Frame::<PageTablePageMeta<E, C>>::from_raw(self.paddr()) });\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -225,7 +225,7 @@ pub(super) struct PageTableNode<\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    page: Page<PageTablePageMeta<E, C>>,\n+    page: Frame<PageTablePageMeta<E, C>>,\n }\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -261,13 +261,11 @@ where\n     /// extra unnecessary expensive operation.\n     pub(super) fn alloc(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n         let meta = PageTablePageMeta::new_locked(level, is_tracked);\n-        let page = page::allocator::alloc_single::<PageTablePageMeta<E, C>>(meta).unwrap();\n-\n-        // Zero out the page table node.\n-        let ptr = paddr_to_vaddr(page.paddr()) as *mut u8;\n-        // SAFETY: The page is exclusively owned here. Pointers are valid also.\n-        // We rely on the fact that 0 represents an absent entry to speed up `memset`.\n-        unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n+        let page = FrameAllocOptions::new()\n+            .zeroed(true)\n+            .alloc_frame_with(meta)\n+            .expect(\"Failed to allocate a page table node\");\n+        // The allocated frame is zeroed. Make sure zero is absent PTE.\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n         Self { page }\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -282,7 +280,7 @@ where\n \n         // SAFETY: The provided physical address is valid and the level is\n         // correct. The reference count is not changed.\n-        unsafe { RawPageTableNode::from_raw_parts(this.page.paddr(), this.page.meta().level) }\n+        unsafe { RawPageTableNode::from_raw_parts(this.page.start_paddr(), this.page.meta().level) }\n     }\n \n     /// Gets a raw handle while still preserving the original handle.\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -291,7 +289,7 @@ where\n \n         // SAFETY: The provided physical address is valid and the level is\n         // correct. The reference count is increased by one.\n-        unsafe { RawPageTableNode::from_raw_parts(page.paddr(), page.meta().level) }\n+        unsafe { RawPageTableNode::from_raw_parts(page.start_paddr(), page.meta().level) }\n     }\n \n     /// Gets the number of valid PTEs in the node.\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -311,7 +309,7 @@ where\n     /// The caller must ensure that the index is within the bound.\n     unsafe fn read_pte(&self, idx: usize) -> E {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        let ptr = paddr_to_vaddr(self.page.paddr()) as *const E;\n+        let ptr = paddr_to_vaddr(self.page.start_paddr()) as *const E;\n         // SAFETY: The index is within the bound and the PTE is plain-old-data.\n         unsafe { ptr.add(idx).read() }\n     }\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -331,7 +329,7 @@ where\n     ///     (see [`Child::is_compatible`]).\n     unsafe fn write_pte(&mut self, idx: usize, pte: E) {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        let ptr = paddr_to_vaddr(self.page.paddr()) as *mut E;\n+        let ptr = paddr_to_vaddr(self.page.start_paddr()) as *mut E;\n         // SAFETY: The index is within the bound and the PTE is plain-old-data.\n         unsafe { ptr.add(idx).write(pte) }\n     }\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -407,11 +405,11 @@ where\n \n // SAFETY: The layout of the `PageTablePageMeta` is ensured to be the same for\n // all possible generic parameters. And the layout fits the requirements.\n-unsafe impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageMeta for PageTablePageMeta<E, C>\n+unsafe impl<E: PageTableEntryTrait, C: PagingConstsTrait> AnyFrameMeta for PageTablePageMeta<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    fn on_drop(&mut self, paddr: Paddr) {\n+    fn on_drop(&mut self, reader: &mut VmReader<Infallible>) {\n         let nr_children = self.nr_children.get_mut();\n \n         if *nr_children == 0 {\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -422,14 +420,7 @@ where\n         let is_tracked = self.is_tracked;\n \n         // Drop the children.\n-        for i in 0..nr_subpage_per_huge::<C>() {\n-            // SAFETY: The index is within the bound and PTE is plain-old-data. The\n-            // address is aligned as well. We also have an exclusive access ensured\n-            // by reference counting.\n-            let pte_ptr = unsafe { (paddr_to_vaddr(paddr) as *const E).add(i) };\n-            // SAFETY: The pointer is valid and the PTE is plain-old-data.\n-            let pte = unsafe { pte_ptr.read() };\n-\n+        while let Ok(pte) = reader.read_once::<E>() {\n             // Here if we use directly `Child::from_pte` we would experience a\n             // 50% increase in the overhead of the `drop` function. It seems that\n             // Rust is very conservative about inlining and optimizing dead code\ndiff --git a/ostd/src/mm/page_table/node/mod.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node/mod.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -439,11 +430,11 @@ where\n                 if !pte.is_last(level) {\n                     // SAFETY: The PTE points to a page table node. The ownership\n                     // of the child is transferred to the child then dropped.\n-                    drop(unsafe { Page::<Self>::from_raw(paddr) });\n+                    drop(unsafe { Frame::<Self>::from_raw(paddr) });\n                 } else if is_tracked == MapTrackingStatus::Tracked {\n                     // SAFETY: The PTE points to a tracked page. The ownership\n                     // of the child is transferred to the child then dropped.\n-                    drop(unsafe { DynPage::from_raw(paddr) });\n+                    drop(unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) });\n                 }\n             }\n         }\ndiff --git a/ostd/src/mm/stat/mod.rs b/ostd/src/mm/stat/mod.rs\n--- a/ostd/src/mm/stat/mod.rs\n+++ b/ostd/src/mm/stat/mod.rs\n@@ -2,7 +2,7 @@\n \n //! APIs for memory statistics.\n \n-use crate::mm::page::allocator::PAGE_ALLOCATOR;\n+use crate::mm::frame::allocator::FRAME_ALLOCATOR;\n \n /// Total memory available for any usages in the system (in bytes).\n ///\ndiff --git a/ostd/src/mm/stat/mod.rs b/ostd/src/mm/stat/mod.rs\n--- a/ostd/src/mm/stat/mod.rs\n+++ b/ostd/src/mm/stat/mod.rs\n@@ -10,12 +10,12 @@ use crate::mm::page::allocator::PAGE_ALLOCATOR;\n /// in most occasions. For example, bad memory, kernel statically-allocated\n /// memory or firmware reserved memories do not count.\n pub fn mem_total() -> usize {\n-    PAGE_ALLOCATOR.get().unwrap().lock().mem_total()\n+    FRAME_ALLOCATOR.get().unwrap().lock().mem_total()\n }\n \n /// Current readily available memory (in bytes).\n ///\n /// Such memory can be directly used for allocation without reclaiming.\n pub fn mem_available() -> usize {\n-    PAGE_ALLOCATOR.get().unwrap().lock().mem_available()\n+    FRAME_ALLOCATOR.get().unwrap().lock().mem_available()\n }\ndiff --git a/ostd/src/mm/tlb.rs b/ostd/src/mm/tlb.rs\n--- a/ostd/src/mm/tlb.rs\n+++ b/ostd/src/mm/tlb.rs\n@@ -5,7 +5,10 @@\n use alloc::vec::Vec;\n use core::ops::Range;\n \n-use super::{page::DynPage, Vaddr, PAGE_SIZE};\n+use super::{\n+    frame::{meta::AnyFrameMeta, Frame},\n+    Vaddr, PAGE_SIZE,\n+};\n use crate::{\n     cpu::{CpuSet, PinCurrentCpu},\n     cpu_local,\ndiff --git a/ostd/src/mm/tlb.rs b/ostd/src/mm/tlb.rs\n--- a/ostd/src/mm/tlb.rs\n+++ b/ostd/src/mm/tlb.rs\n@@ -77,7 +80,7 @@ impl<G: PinCurrentCpu> TlbFlusher<G> {\n     /// flushed. Otherwise if the page is recycled for other purposes, the user\n     /// space program can still access the page through the TLB entries. This\n     /// method is designed to be used in such cases.\n-    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: DynPage) {\n+    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: Frame<dyn AnyFrameMeta>) {\n         self.issue_tlb_flush_(op, Some(drop_after_flush));\n     }\n \ndiff --git a/ostd/src/mm/tlb.rs b/ostd/src/mm/tlb.rs\n--- a/ostd/src/mm/tlb.rs\n+++ b/ostd/src/mm/tlb.rs\n@@ -91,7 +94,7 @@ impl<G: PinCurrentCpu> TlbFlusher<G> {\n         self.need_self_flush\n     }\n \n-    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<Frame<dyn AnyFrameMeta>>) {\n         let op = op.optimize_for_large_range();\n \n         // Fast path for single CPU cases.\ndiff --git a/ostd/src/mm/tlb.rs b/ostd/src/mm/tlb.rs\n--- a/ostd/src/mm/tlb.rs\n+++ b/ostd/src/mm/tlb.rs\n@@ -156,7 +159,7 @@ impl TlbFlushOp {\n // Lock ordering: lock FLUSH_OPS before PAGE_KEEPER.\n cpu_local! {\n     static FLUSH_OPS: SpinLock<OpsStack, LocalIrqDisabled> = SpinLock::new(OpsStack::new());\n-    static PAGE_KEEPER: SpinLock<Vec<DynPage>, LocalIrqDisabled> = SpinLock::new(Vec::new());\n+    static PAGE_KEEPER: SpinLock<Vec<Frame<dyn AnyFrameMeta>>, LocalIrqDisabled> = SpinLock::new(Vec::new());\n }\n \n fn do_remote_flush() {\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -22,7 +22,7 @@ use crate::{\n         kspace::KERNEL_PAGE_TABLE,\n         page_table::{self, PageTable, PageTableItem, UserMode},\n         tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\n-        Frame, PageProperty, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n+        PageProperty, UFrame, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n     sync::{PreemptDisabled, RwLock, RwLockReadGuard},\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -40,7 +40,7 @@ use crate::{\n ///\n /// A newly-created `VmSpace` is not backed by any physical memory pages. To\n /// provide memory pages for a `VmSpace`, one can allocate and map physical\n-/// memory ([`Frame`]s) to the `VmSpace` using the cursor.\n+/// memory ([`UFrame`]s) to the `VmSpace` using the cursor.\n ///\n /// A `VmSpace` can also attach a page fault handler, which will be invoked to\n /// handle page faults generated from user space.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -323,7 +323,7 @@ impl CursorMut<'_, '_> {\n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n-    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n+    pub fn map(&mut self, frame: UFrame, prop: PageProperty) {\n         let start_va = self.virt_addr();\n         // SAFETY: It is safe to map untyped memory into the userspace.\n         let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -475,7 +475,7 @@ pub enum VmItem {\n         /// The virtual address of the slot.\n         va: Vaddr,\n         /// The mapped frame.\n-        frame: Frame,\n+        frame: UFrame,\n         /// The property of the slot.\n         prop: PageProperty,\n     },\ndiff --git a/ostd/src/task/kernel_stack.rs b/ostd/src/task/kernel_stack.rs\n--- a/ostd/src/task/kernel_stack.rs\n+++ b/ostd/src/task/kernel_stack.rs\n@@ -1,12 +1,11 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use crate::{\n-    impl_page_meta,\n+    impl_frame_meta_for,\n     mm::{\n         kspace::kvirt_area::{KVirtArea, Tracked},\n-        page::allocator,\n         page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags},\n-        PAGE_SIZE,\n+        FrameAllocOptions, PAGE_SIZE,\n     },\n     prelude::*,\n };\ndiff --git a/ostd/src/task/kernel_stack.rs b/ostd/src/task/kernel_stack.rs\n--- a/ostd/src/task/kernel_stack.rs\n+++ b/ostd/src/task/kernel_stack.rs\n@@ -36,9 +35,9 @@ pub struct KernelStack {\n }\n \n #[derive(Debug, Default)]\n-struct KernelStackMeta {}\n+struct KernelStackMeta;\n \n-impl_page_meta!(KernelStackMeta);\n+impl_frame_meta_for!(KernelStackMeta);\n \n impl KernelStack {\n     /// Generates a kernel stack with guard pages.\ndiff --git a/ostd/src/task/kernel_stack.rs b/ostd/src/task/kernel_stack.rs\n--- a/ostd/src/task/kernel_stack.rs\n+++ b/ostd/src/task/kernel_stack.rs\n@@ -47,13 +46,15 @@ impl KernelStack {\n         let mut new_kvirt_area = KVirtArea::<Tracked>::new(KERNEL_STACK_SIZE + 4 * PAGE_SIZE);\n         let mapped_start = new_kvirt_area.range().start + 2 * PAGE_SIZE;\n         let mapped_end = mapped_start + KERNEL_STACK_SIZE;\n-        let pages = allocator::alloc(KERNEL_STACK_SIZE, |_| KernelStackMeta::default()).unwrap();\n+        let pages = FrameAllocOptions::new()\n+            .zeroed(false)\n+            .alloc_segment_with(KERNEL_STACK_SIZE / PAGE_SIZE, |_| KernelStackMeta)?;\n         let prop = PageProperty {\n             flags: PageFlags::RW,\n             cache: CachePolicy::Writeback,\n             priv_flags: PrivilegedPageFlags::empty(),\n         };\n-        new_kvirt_area.map_pages(mapped_start..mapped_end, pages.iter().cloned(), prop);\n+        new_kvirt_area.map_pages(mapped_start..mapped_end, pages, prop);\n \n         Ok(Self {\n             kvirt_area: new_kvirt_area,\n",
        "test_patch": "diff --git a/kernel/comps/block/src/bio.rs b/kernel/comps/block/src/bio.rs\n--- a/kernel/comps/block/src/bio.rs\n+++ b/kernel/comps/block/src/bio.rs\n@@ -481,8 +481,8 @@ impl<'a> BioSegment {\n \n     /// Returns the inner VM segment.\n     #[cfg(ktest)]\n-    pub fn inner_segment(&self) -> &Segment {\n-        self.inner.dma_slice.stream().vm_segment()\n+    pub fn inner_segment(&self) -> &USegment {\n+        self.inner.dma_slice.stream().segment()\n     }\n \n     /// Returns a reader to read data from it.\ndiff --git a/kernel/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -40,15 +40,15 @@ mod test {\n \n     /// Followings are implementations of memory simulated block device\n     pub const SECTOR_SIZE: usize = 512;\n-    struct ExfatMemoryBioQueue(Segment);\n+    struct ExfatMemoryBioQueue(Segment<()>);\n \n     impl ExfatMemoryBioQueue {\n-        pub fn new(segment: Segment) -> Self {\n+        pub fn new(segment: Segment<()>) -> Self {\n             ExfatMemoryBioQueue(segment)\n         }\n \n         pub fn sectors_count(&self) -> usize {\n-            self.0.nbytes() / SECTOR_SIZE\n+            self.0.size() / SECTOR_SIZE\n         }\n     }\n \ndiff --git a/kernel/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -57,7 +57,7 @@ mod test {\n     }\n \n     impl ExfatMemoryDisk {\n-        pub fn new(segment: Segment) -> Self {\n+        pub fn new(segment: Segment<()>) -> Self {\n             ExfatMemoryDisk {\n                 queue: ExfatMemoryBioQueue::new(segment),\n             }\ndiff --git a/kernel/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -111,20 +111,20 @@ mod test {\n     static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../test/build/exfat.img\");\n \n     /// Read exfat disk image\n-    fn new_vm_segment_from_image() -> Segment {\n-        let vm_segment = FrameAllocOptions::new(EXFAT_IMAGE.len().div_ceil(PAGE_SIZE))\n-            .uninit(true)\n-            .alloc_contiguous()\n+    fn new_vm_segment_from_image() -> Segment<()> {\n+        let segment = FrameAllocOptions::new()\n+            .zeroed(false)\n+            .alloc_segment(EXFAT_IMAGE.len().div_ceil(PAGE_SIZE))\n             .unwrap();\n \n-        vm_segment.write_bytes(0, EXFAT_IMAGE).unwrap();\n-        vm_segment\n+        segment.write_bytes(0, EXFAT_IMAGE).unwrap();\n+        segment\n     }\n \n     // Generate a simulated exfat file system\n     fn load_exfat() -> Arc<ExfatFS> {\n-        let vm_segment = new_vm_segment_from_image();\n-        let disk = ExfatMemoryDisk::new(vm_segment);\n+        let segment = new_vm_segment_from_image();\n+        let disk = ExfatMemoryDisk::new(segment);\n         let mount_option = ExfatMountOptions::default();\n         let fs = ExfatFS::open(Arc::new(disk), mount_option);\n         assert!(fs.is_ok(), \"Fs failed to init:{:?}\", fs.unwrap_err());\ndiff --git a/kernel/src/fs/utils/mod.rs b/kernel/src/fs/utils/mod.rs\n--- a/kernel/src/fs/utils/mod.rs\n+++ b/kernel/src/fs/utils/mod.rs\n@@ -13,7 +13,7 @@ pub use flock::{FlockItem, FlockList, FlockType};\n pub use fs::{FileSystem, FsFlags, SuperBlock};\n pub use inode::{Extension, Inode, InodeMode, InodeType, Metadata, MknodType, Permission};\n pub use ioctl::IoctlCmd;\n-pub use page_cache::{PageCache, PageCacheBackend};\n+pub use page_cache::{CachePage, PageCache, PageCacheBackend};\n pub use random_test::{generate_random_operation, new_fs_in_memory};\n pub use range_lock::{\n     FileRange, RangeLockItem, RangeLockItemBuilder, RangeLockList, RangeLockType, OFFSET_MAX,\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -36,11 +36,11 @@ pub fn main() {\n fn create_user_space(program: &[u8]) -> UserSpace {\n     let nbytes = program.len().align_up(PAGE_SIZE);\n     let user_pages = {\n-        let segment = FrameAllocOptions::new(nbytes / PAGE_SIZE)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment(nbytes / PAGE_SIZE)\n             .unwrap();\n         // Physical memory pages can be only accessed\n-        // via the `Frame` or `Segment` abstraction.\n+        // via the `UFrame` or `USegment` abstraction.\n         segment.write_bytes(0, program).unwrap();\n         segment\n     };\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -54,7 +54,7 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n         let mut cursor = vm_space.cursor_mut(&(MAP_ADDR..MAP_ADDR + nbytes)).unwrap();\n         let map_prop = PageProperty::new(PageFlags::RWX, CachePolicy::Writeback);\n         for frame in user_pages {\n-            cursor.map(frame, map_prop);\n+            cursor.map(frame.into(), map_prop);\n         }\n         drop(cursor);\n         Arc::new(vm_space)\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -222,46 +216,42 @@ mod test {\n \n     #[ktest]\n     fn map_with_coherent_device() {\n-        let vm_segment = FrameAllocOptions::new(1)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(1, |_| ())\n             .unwrap();\n-        let dma_coherent = DmaCoherent::map(vm_segment.clone(), true).unwrap();\n-        assert!(dma_coherent.paddr() == vm_segment.paddr());\n+        let dma_coherent = DmaCoherent::map(segment.clone().into(), true).unwrap();\n+        assert!(dma_coherent.paddr() == segment.start_paddr());\n     }\n \n     #[ktest]\n     fn map_with_incoherent_device() {\n-        let vm_segment = FrameAllocOptions::new(1)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(1, |_| ())\n             .unwrap();\n-        let dma_coherent = DmaCoherent::map(vm_segment.clone(), false).unwrap();\n-        assert!(dma_coherent.paddr() == vm_segment.paddr());\n+        let dma_coherent = DmaCoherent::map(segment.clone().into(), false).unwrap();\n+        assert!(dma_coherent.paddr() == segment.start_paddr());\n         let page_table = KERNEL_PAGE_TABLE.get().unwrap();\n-        let vaddr = paddr_to_vaddr(vm_segment.paddr());\n+        let vaddr = paddr_to_vaddr(segment.start_paddr());\n         assert!(page_table.query(vaddr).unwrap().1.cache == CachePolicy::Uncacheable);\n     }\n \n     #[ktest]\n     fn duplicate_map() {\n-        let vm_segment_parent = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let vm_segment_child = vm_segment_parent.slice(&(0..PAGE_SIZE));\n-        let _dma_coherent_parent = DmaCoherent::map(vm_segment_parent, false);\n-        let dma_coherent_child = DmaCoherent::map(vm_segment_child, false);\n+        let segment_child = segment.slice(&(0..PAGE_SIZE));\n+        let _dma_coherent_parent = DmaCoherent::map(segment.into(), false);\n+        let dma_coherent_child = DmaCoherent::map(segment_child.into(), false);\n         assert!(dma_coherent_child.is_err());\n     }\n \n     #[ktest]\n     fn read_and_write() {\n-        let vm_segment = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let dma_coherent = DmaCoherent::map(vm_segment, false).unwrap();\n+        let dma_coherent = DmaCoherent::map(segment.into(), false).unwrap();\n \n         let buf_write = vec![1u8; 2 * PAGE_SIZE];\n         dma_coherent.write_bytes(0, &buf_write).unwrap();\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -272,11 +262,10 @@ mod test {\n \n     #[ktest]\n     fn reader_and_writer() {\n-        let vm_segment = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let dma_coherent = DmaCoherent::map(vm_segment, false).unwrap();\n+        let dma_coherent = DmaCoherent::map(segment.into(), false).unwrap();\n \n         let buf_write = vec![1u8; PAGE_SIZE];\n         let mut writer = dma_coherent.writer();\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -373,36 +373,35 @@ mod test {\n \n     #[ktest]\n     fn streaming_map() {\n-        let vm_segment = FrameAllocOptions::new(1)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(1, |_| ())\n             .unwrap();\n         let dma_stream =\n-            DmaStream::map(vm_segment.clone(), DmaDirection::Bidirectional, true).unwrap();\n-        assert!(dma_stream.paddr() == vm_segment.paddr());\n+            DmaStream::map(segment.clone().into(), DmaDirection::Bidirectional, true).unwrap();\n+        assert!(dma_stream.paddr() == segment.start_paddr());\n     }\n \n     #[ktest]\n     fn duplicate_map() {\n-        let vm_segment_parent = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment_parent = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let vm_segment_child = vm_segment_parent.slice(&(0..PAGE_SIZE));\n+        let segment_child = segment_parent.slice(&(0..PAGE_SIZE));\n         let dma_stream_parent =\n-            DmaStream::map(vm_segment_parent, DmaDirection::Bidirectional, false);\n-        let dma_stream_child = DmaStream::map(vm_segment_child, DmaDirection::Bidirectional, false);\n+            DmaStream::map(segment_parent.into(), DmaDirection::Bidirectional, false);\n+        let dma_stream_child =\n+            DmaStream::map(segment_child.into(), DmaDirection::Bidirectional, false);\n         assert!(dma_stream_parent.is_ok());\n         assert!(dma_stream_child.is_err());\n     }\n \n     #[ktest]\n     fn read_and_write() {\n-        let vm_segment = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let dma_stream = DmaStream::map(vm_segment, DmaDirection::Bidirectional, false).unwrap();\n+        let dma_stream =\n+            DmaStream::map(segment.into(), DmaDirection::Bidirectional, false).unwrap();\n \n         let buf_write = vec![1u8; 2 * PAGE_SIZE];\n         dma_stream.write_bytes(0, &buf_write).unwrap();\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -414,11 +413,11 @@ mod test {\n \n     #[ktest]\n     fn reader_and_writer() {\n-        let vm_segment = FrameAllocOptions::new(2)\n-            .is_contiguous(true)\n-            .alloc_contiguous()\n+        let segment = FrameAllocOptions::new()\n+            .alloc_segment_with(2, |_| ())\n             .unwrap();\n-        let dma_stream = DmaStream::map(vm_segment, DmaDirection::Bidirectional, false).unwrap();\n+        let dma_stream =\n+            DmaStream::map(segment.into(), DmaDirection::Bidirectional, false).unwrap();\n \n         let buf_write = vec![1u8; PAGE_SIZE];\n         let mut writer = dma_stream.writer().unwrap();\ndiff --git /dev/null b/ostd/src/mm/frame/allocator.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/frame/allocator.rs\n@@ -0,0 +1,211 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The physical memory allocator.\n+\n+use align_ext::AlignExt;\n+use buddy_system_allocator::FrameAllocator;\n+use log::info;\n+use spin::Once;\n+\n+use super::{meta::AnyFrameMeta, segment::Segment, Frame};\n+use crate::{\n+    boot::memory_region::MemoryRegionType,\n+    error::Error,\n+    mm::{paddr_to_vaddr, Paddr, PAGE_SIZE},\n+    prelude::*,\n+    sync::SpinLock,\n+};\n+\n+/// Options for allocating physical memory frames.\n+pub struct FrameAllocOptions {\n+    zeroed: bool,\n+}\n+\n+impl Default for FrameAllocOptions {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl FrameAllocOptions {\n+    /// Creates new options for allocating the specified number of frames.\n+    pub fn new() -> Self {\n+        Self { zeroed: true }\n+    }\n+\n+    /// Sets whether the allocated frames should be initialized with zeros.\n+    ///\n+    /// If `zeroed` is `true`, the allocated frames are filled with zeros.\n+    /// If not, the allocated frames will contain sensitive data and the caller\n+    /// should clear them before sharing them with other components.\n+    ///\n+    /// By default, the frames are zero-initialized.\n+    pub fn zeroed(&mut self, zeroed: bool) -> &mut Self {\n+        self.zeroed = zeroed;\n+        self\n+    }\n+\n+    /// Allocates a single untyped frame without metadata.\n+    pub fn alloc_frame(&self) -> Result<Frame<()>> {\n+        self.alloc_frame_with(())\n+    }\n+\n+    /// Allocates a single frame with additional metadata.\n+    pub fn alloc_frame_with<M: AnyFrameMeta>(&self, metadata: M) -> Result<Frame<M>> {\n+        let frame = FRAME_ALLOCATOR\n+            .get()\n+            .unwrap()\n+            .disable_irq()\n+            .lock()\n+            .alloc(1)\n+            .map(|idx| {\n+                let paddr = idx * PAGE_SIZE;\n+                Frame::from_unused(paddr, metadata)\n+            })\n+            .ok_or(Error::NoMemory)?;\n+\n+        if self.zeroed {\n+            let addr = paddr_to_vaddr(frame.start_paddr()) as *mut u8;\n+            // SAFETY: The newly allocated frame is guaranteed to be valid.\n+            unsafe { core::ptr::write_bytes(addr, 0, PAGE_SIZE) }\n+        }\n+\n+        Ok(frame)\n+    }\n+\n+    /// Allocates a contiguous range of untyped frames without metadata.\n+    pub fn alloc_segment(&self, nframes: usize) -> Result<Segment<()>> {\n+        self.alloc_segment_with(nframes, |_| ())\n+    }\n+\n+    /// Allocates a contiguous range of frames with additional metadata.\n+    ///\n+    /// The returned [`Segment`] contains at least one frame. The method returns\n+    /// an error if the number of frames is zero.\n+    pub fn alloc_segment_with<M: AnyFrameMeta, F>(\n+        &self,\n+        nframes: usize,\n+        metadata_fn: F,\n+    ) -> Result<Segment<M>>\n+    where\n+        F: FnMut(Paddr) -> M,\n+    {\n+        if nframes == 0 {\n+            return Err(Error::InvalidArgs);\n+        }\n+        let segment = FRAME_ALLOCATOR\n+            .get()\n+            .unwrap()\n+            .disable_irq()\n+            .lock()\n+            .alloc(nframes)\n+            .map(|start| {\n+                Segment::from_unused(\n+                    start * PAGE_SIZE..start * PAGE_SIZE + nframes * PAGE_SIZE,\n+                    metadata_fn,\n+                )\n+            })\n+            .ok_or(Error::NoMemory)?;\n+\n+        if self.zeroed {\n+            let addr = paddr_to_vaddr(segment.start_paddr()) as *mut u8;\n+            // SAFETY: The newly allocated segment is guaranteed to be valid.\n+            unsafe { core::ptr::write_bytes(addr, 0, nframes * PAGE_SIZE) }\n+        }\n+\n+        Ok(segment)\n+    }\n+}\n+\n+#[cfg(ktest)]\n+#[ktest]\n+fn test_alloc_dealloc() {\n+    // Here we allocate and deallocate frames in random orders to test the allocator.\n+    // We expect the test to fail if the underlying implementation panics.\n+    let single_options = FrameAllocOptions::new();\n+    let mut contiguous_options = FrameAllocOptions::new();\n+    contiguous_options.zeroed(false);\n+    let mut remember_vec = Vec::new();\n+    for _ in 0..10 {\n+        for i in 0..10 {\n+            let single_frame = single_options.alloc_frame().unwrap();\n+            if i % 3 == 0 {\n+                remember_vec.push(single_frame);\n+            }\n+        }\n+        let contiguous_segment = contiguous_options.alloc_segment(10).unwrap();\n+        drop(contiguous_segment);\n+        remember_vec.pop();\n+    }\n+}\n+\n+/// FrameAllocator with a counter for allocated memory\n+pub(in crate::mm) struct CountingFrameAllocator {\n+    allocator: FrameAllocator,\n+    total: usize,\n+    allocated: usize,\n+}\n+\n+impl CountingFrameAllocator {\n+    pub fn new(allocator: FrameAllocator, total: usize) -> Self {\n+        CountingFrameAllocator {\n+            allocator,\n+            total,\n+            allocated: 0,\n+        }\n+    }\n+\n+    pub fn alloc(&mut self, count: usize) -> Option<usize> {\n+        match self.allocator.alloc(count) {\n+            Some(value) => {\n+                self.allocated += count * PAGE_SIZE;\n+                Some(value)\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    // TODO: this method should be marked unsafe as invalid arguments will mess\n+    // up the underlying allocator.\n+    pub fn dealloc(&mut self, start_frame: usize, count: usize) {\n+        self.allocator.dealloc(start_frame, count);\n+        self.allocated -= count * PAGE_SIZE;\n+    }\n+\n+    pub fn mem_total(&self) -> usize {\n+        self.total\n+    }\n+\n+    pub fn mem_available(&self) -> usize {\n+        self.total - self.allocated\n+    }\n+}\n+\n+pub(in crate::mm) static FRAME_ALLOCATOR: Once<SpinLock<CountingFrameAllocator>> = Once::new();\n+\n+pub(crate) fn init() {\n+    let regions = crate::boot::memory_regions();\n+    let mut total: usize = 0;\n+    let mut allocator = FrameAllocator::<32>::new();\n+    for region in regions.iter() {\n+        if region.typ() == MemoryRegionType::Usable {\n+            // Make the memory region page-aligned, and skip if it is too small.\n+            let start = region.base().align_up(PAGE_SIZE) / PAGE_SIZE;\n+            let region_end = region.base().checked_add(region.len()).unwrap();\n+            let end = region_end.align_down(PAGE_SIZE) / PAGE_SIZE;\n+            if end <= start {\n+                continue;\n+            }\n+            // Add global free pages to the frame allocator.\n+            allocator.add_frame(start, end);\n+            total += (end - start) * PAGE_SIZE;\n+            info!(\n+                \"Found usable region, start:{:x}, end:{:x}\",\n+                region.base(),\n+                region.base() + region.len()\n+            );\n+        }\n+    }\n+    let counting_allocator = CountingFrameAllocator::new(allocator, total);\n+    FRAME_ALLOCATOR.call_once(|| SpinLock::new(counting_allocator));\n+}\ndiff --git a/ostd/src/mm/frame/options.rs /dev/null\n--- a/ostd/src/mm/frame/options.rs\n+++ /dev/null\n@@ -1,133 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Options for allocating frames\n-\n-use super::{Frame, Segment};\n-use crate::{\n-    mm::{frame::FrameMeta, page, PAGE_SIZE},\n-    prelude::*,\n-    Error,\n-};\n-\n-/// Options for allocating physical memory pages (or frames).\n-///\n-/// All allocated frames are safe to use in the sense that they are\n-/// not _typed memory_. We define typed memory as the memory that\n-/// may store Rust objects or affect Rust memory safety, e.g.,\n-/// the code and data segments of the OS kernel, the stack and heap\n-/// allocated for the OS kernel.\n-pub struct FrameAllocOptions {\n-    nframes: usize,\n-    is_contiguous: bool,\n-    uninit: bool,\n-}\n-\n-impl FrameAllocOptions {\n-    /// Creates new options for allocating the specified number of frames.\n-    pub fn new(nframes: usize) -> Self {\n-        Self {\n-            nframes,\n-            is_contiguous: false,\n-            uninit: false,\n-        }\n-    }\n-\n-    /// Sets whether the allocated frames should be contiguous.\n-    ///\n-    /// The default value is `false`.\n-    pub fn is_contiguous(&mut self, is_contiguous: bool) -> &mut Self {\n-        self.is_contiguous = is_contiguous;\n-        self\n-    }\n-\n-    /// Sets whether the allocated frames should be uninitialized.\n-    ///\n-    /// If `uninit` is set as `false`, the frame will be zeroed once allocated.\n-    /// If `uninit` is set as `true`, the frame will **NOT** be zeroed and should *NOT* be read before writing.\n-    ///\n-    /// The default value is false.\n-    pub fn uninit(&mut self, uninit: bool) -> &mut Self {\n-        self.uninit = uninit;\n-        self\n-    }\n-\n-    /// Allocates a collection of page frames according to the given options.\n-    pub fn alloc(&self) -> Result<Vec<Frame>> {\n-        let pages = if self.is_contiguous {\n-            page::allocator::alloc(self.nframes * PAGE_SIZE, |_| FrameMeta::default())\n-                .ok_or(Error::NoMemory)?\n-        } else {\n-            page::allocator::alloc_contiguous(self.nframes * PAGE_SIZE, |_| FrameMeta::default())\n-                .ok_or(Error::NoMemory)?\n-                .into()\n-        };\n-        let frames: Vec<_> = pages.into_iter().map(|page| Frame { page }).collect();\n-        if !self.uninit {\n-            for frame in frames.iter() {\n-                frame.writer().fill(0);\n-            }\n-        }\n-\n-        Ok(frames)\n-    }\n-\n-    /// Allocates a single page frame according to the given options.\n-    pub fn alloc_single(&self) -> Result<Frame> {\n-        if self.nframes != 1 {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let page = page::allocator::alloc_single(FrameMeta::default()).ok_or(Error::NoMemory)?;\n-        let frame = Frame { page };\n-        if !self.uninit {\n-            frame.writer().fill(0);\n-        }\n-\n-        Ok(frame)\n-    }\n-\n-    /// Allocates a contiguous range of page frames according to the given options.\n-    ///\n-    /// The returned [`Segment`] contains at least one page frame.\n-    pub fn alloc_contiguous(&self) -> Result<Segment> {\n-        // It's no use to checking `self.is_contiguous` here.\n-        if self.nframes == 0 {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let segment: Segment =\n-            page::allocator::alloc_contiguous(self.nframes * PAGE_SIZE, |_| FrameMeta::default())\n-                .ok_or(Error::NoMemory)?\n-                .into();\n-        if !self.uninit {\n-            segment.writer().fill(0);\n-        }\n-\n-        Ok(segment)\n-    }\n-}\n-\n-#[cfg(ktest)]\n-#[ktest]\n-fn test_alloc_dealloc() {\n-    // Here we allocate and deallocate frames in random orders to test the allocator.\n-    // We expect the test to fail if the underlying implementation panics.\n-    let single_options = FrameAllocOptions::new(1);\n-    let multi_options = FrameAllocOptions::new(10);\n-    let mut contiguous_options = FrameAllocOptions::new(10);\n-    contiguous_options.is_contiguous(true);\n-    let mut remember_vec = Vec::new();\n-    for _ in 0..10 {\n-        for i in 0..10 {\n-            let single_frame = single_options.alloc_single().unwrap();\n-            if i % 3 == 0 {\n-                remember_vec.push(single_frame);\n-            }\n-        }\n-        let contiguous_segment = contiguous_options.alloc_contiguous().unwrap();\n-        drop(contiguous_segment);\n-        let multi_frames = multi_options.alloc().unwrap();\n-        remember_vec.extend(multi_frames.into_iter());\n-        remember_vec.pop();\n-    }\n-}\ndiff --git a/ostd/src/mm/page_table/boot_pt.rs b/ostd/src/mm/page_table/boot_pt.rs\n--- a/ostd/src/mm/page_table/boot_pt.rs\n+++ b/ostd/src/mm/page_table/boot_pt.rs\n@@ -250,7 +250,7 @@ fn test_boot_pt_map_protect() {\n         mm::{CachePolicy, FrameAllocOptions, PageFlags},\n     };\n \n-    let root_frame = FrameAllocOptions::new(1).alloc_single().unwrap();\n+    let root_frame = FrameAllocOptions::new().alloc_frame().unwrap();\n     let root_paddr = root_frame.start_paddr();\n \n     let mut boot_pt = BootPageTable::<PageTableEntry, PagingConsts> {\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -5,11 +5,9 @@ use core::mem::ManuallyDrop;\n use super::*;\n use crate::{\n     mm::{\n-        frame::FrameMeta,\n         kspace::LINEAR_MAPPING_BASE_VADDR,\n-        page::allocator,\n         page_prop::{CachePolicy, PageFlags},\n-        MAX_USERSPACE_VADDR,\n+        FrameAllocOptions, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n };\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -32,8 +30,8 @@ fn test_tracked_map_unmap() {\n     let pt = PageTable::<UserMode>::empty();\n \n     let from = PAGE_SIZE..PAGE_SIZE * 2;\n-    let page = allocator::alloc_single(FrameMeta::default()).unwrap();\n-    let start_paddr = page.paddr();\n+    let page = FrameAllocOptions::new().alloc_frame().unwrap();\n+    let start_paddr = page.start_paddr();\n     let prop = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n     unsafe { pt.cursor_mut(&from).unwrap().map(page.into(), prop) };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -88,8 +86,8 @@ fn test_user_copy_on_write() {\n \n     let pt = PageTable::<UserMode>::empty();\n     let from = PAGE_SIZE..PAGE_SIZE * 2;\n-    let page = allocator::alloc_single(FrameMeta::default()).unwrap();\n-    let start_paddr = page.paddr();\n+    let page = FrameAllocOptions::new().alloc_frame().unwrap();\n+    let start_paddr = page.start_paddr();\n     let prop = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n     unsafe { pt.cursor_mut(&from).unwrap().map(page.clone().into(), prop) };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -173,12 +171,12 @@ fn test_base_protect_query() {\n \n     let from_ppn = 1..1000;\n     let from = PAGE_SIZE * from_ppn.start..PAGE_SIZE * from_ppn.end;\n-    let to = allocator::alloc(999 * PAGE_SIZE, |_| FrameMeta::default()).unwrap();\n+    let to = FrameAllocOptions::new().alloc_segment(999).unwrap();\n     let prop = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n     unsafe {\n         let mut cursor = pt.cursor_mut(&from).unwrap();\n         for page in to {\n-            cursor.map(page.clone().into(), prop);\n+            cursor.map(page.into(), prop);\n         }\n     }\n     for (item, i) in pt.cursor(&from).unwrap().zip(from_ppn) {\ndiff --git a/ostd/src/prelude.rs b/ostd/src/prelude.rs\n--- a/ostd/src/prelude.rs\n+++ b/ostd/src/prelude.rs\n@@ -14,6 +14,6 @@ pub use ostd_macros::ktest;\n \n pub use crate::{\n     early_print as print, early_println as println,\n-    mm::{Paddr, Vaddr},\n+    mm::{Paddr, UntypedMem, Vaddr},\n     panic::abort,\n };\n",
        "problem_statement": "Extend the page metadata registry for the page cache\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nThis RFC would like to expose the page metadata registry to OSTD users, mainly for the disk cache.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\nThe page metadata system, introduced by #836 , has offered an efficient page state registry for page table pages. In this registry, pages, according to it's usage, has been categorized into `Frame` (=`Page<FrameMeta>`, untyped pages), `Page<KernelMeta>` (typed kernel pages) and `Page<PageTablePageMeta>` (typed page table pages). The usages are stored as a field in the common part of the metadata storage to allow dynamic inspection and dispatch of dropping or state maintenance functions.\r\n\r\nAs refactoring the page cache (FYI, physical memory pages that are presented as a copy of on-disk file contents) becoming the next goal evolving Asterinas, there would be a question how we should maintain the states of page cache pages. The state of a disk cache page is: whether it is not synchronized with the disk content, i.e. dirty. That's it. If the page is not dirty, we can (in certain cases) recycle the page for other usages without writing back the content to the disk. However, recycling disk cache pages would include 3 very tricky parts. The first part is:\r\n\r\n1. If we want to recycle it, what about other handles that are currently referencing it? If we want to recycle it, shouldn't we firstly un-map it in all user spaces?\r\n\r\nTo avoid this problem, the nonsense way is: recycle pages only when the reference count is 0. It is the acutally the solution: aster-nix should do destroy all the referencer to recycle it. This suits our current implementation and our RAII vision really well, since the reference count is the number of the active handles plus the number of virtual memory spaces that maps to it. In order to recycle a disk cache page, aster-nix should 1. un-map all related mappings 2. drop all handles to it.\r\n\r\nThe second part is:\r\n\r\n2. How to tell the dirtiness if it is mapped to the user space? (even worse, shared memory mapped)\r\n\r\nWith syscall `read` and `write` this is relatively easy. But with memory-mapped files, we must query over the page tables. Luckily, aster-nix could only recycle this page by un-mapping in all the related user spaces. If we collect the dirty bit when doing un-map, we are confident about it's dirtiness after all un-mapping is done.\r\n\r\nThe third part is:\r\n\r\n3. How to enable arbitrary strategy deciding which page to recycle?\r\n\r\nThis is the most interesting topic. Let us just make up an advanced strategy to see what's required for the state book-keeping. With the idea of LRU (least recently used), we can order the pages in a list. There would be a kernel task that periodically scans over all the address spaces that mapped file-backed pages. When found a accessed/dirty flag, the task clears it and move the page to the end of the list, as \"recently used\". Therefore, least recently used pages will appear at the front of the list to be recycled.\r\n\r\nIn order to implement such a strategy, we need to have a global registry of state for pages. The scanning task and the syscall handler would be able to update the dirty state of the pages. Also, the metadata should somehow record the file which the page belongs to. When writing back the content of the page, the task referencing the page should know how to drop other references and which block should we write to.\r\n\r\nSo then, there is another multiple choice question to be resolve, about how do we code such a registry of states:\r\n\r\n Option 1. Utilize the page metadata system in OSTD by:\r\n\r\n    Option 1.1. Allow OSTD users bring their own definition of metadata of frames;\r\n\r\n    Option 1.2. Hard code the metadata of frames in OSTD.\r\n\r\n Option 2. Let aster-nix construct a giant global array by itself.\r\n\r\nThe page metadata system in OSTD was designed to be a centralized, global storage of page states for any page usages. But the way to expose the page metadata system to OSTD users remains unresolved. The major question we want to decide is that: __can we allow OSTD users bring their own definition of frame metadata?__\r\n\r\nThe answer is, sadly, __NO__. It's because that we are not able to do so. Even if we managed to achieve a certain kind of customizability, such as the `Pod` approach in #1076 or the RTTI approach in #1079 , the restriction will be unacceptable. No exisiting way can enable the complex requirement of disk cache pages presented above. Further details of such restriction will be discussed in the \"Alternatives Considered\" part of this RFC.\r\n\r\nSo there would be only 2 choices left. The option 1.2. will decrease OSTD's degree of being general-purpose. The option 2. will be hard to efficiently implement since we don't have unsafe, and wasted about 1/512 of all physical memory since then the metadata system in OSTD will only be useful for a small number of page table pages.\r\n\r\n\r\n\r\n### Proposal\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\nSince I have decided to disallow OSTD users from bringing their own definition of frame metadata, let's inspect the merit and the drawbacks defining a general-purpose frame metadata in OSTD.\r\n\r\nHere are the proposal to add frame metadata to the exisiting metadata registry in OSTD, satisfying both the need of disk cache pages and the anonymous pages.\r\n\r\n\r\n\r\n#### The frame metadata\r\n\r\n\r\n\r\n```rust\r\n// in OSTD\r\n\r\n/// The metadata of a untyped frames.\r\npub struct FrameMeta {\r\n  /// If the frame is dirty.\r\n  pub dirty: AtomicBool,\r\n  /// The index to the owning inode.\r\n  /// This field is useless for anonymous pages, but for file backed pages, since the inode can\r\n  /// own a handle to this page, when we want to recycle the page, we should also let the inode\r\n  /// write back the content and drop the page.\r\n  pub inode_index: usize,\r\n  /// We can provide a very efficient unmap method if having this field.\r\n  /// If such efficient methods don't exist, we cannot trivially recycle shared\r\n  /// file backed memory on memory pressure.\r\n  /// It will be really complex in SMP contexts since you need to flush the TLB after unmapping.\r\n  /// So it is a future possibility. We can neglect recycling shared file backed memory.\r\n  pub(crate) mapped_ptnodes: SpinLock<BtreeSet<(RawPageTableNode, PTEIdx, VmSpaceID, Vaddr)>>\r\n}\r\n```\r\n\r\n\r\n\r\n#### Extra APIs to expose\r\n\r\n\r\n\r\nFor frame handles, we need an extra API to expose:\r\n\r\n```rust\r\nimpl Frame {\r\n  /// Get the reference count of the frame, including mappings and handles.\r\n  ///\r\n  /// This method by itself is safe, but using it correctly requires extra care.\r\n  /// Another thread can change the strong count at any time, including potentially\r\n  /// between calling this method and acting on the result.\r\n  pub reference_count(&self) -> u32 {\r\n    self.page.ref_count()\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\nIn this part, for you who wonders, I give evidences that I tried all I could think to let OSTD users defining their own frame metadata. These attempts have all failed our expectation.\r\n\r\n#1076 defined a trait called `FrameMetaExt`, which requires the implementor to be `Pod`. Then we can define metadata in `Pod` in aster-nix. However, `Pod` is an overly-strong requirement that we cannot even use atomic integers, which forbids interior mutability. Without interior mutability the registry is just useless since no one can update the states.\r\n\r\n#1079 also introduced a trait `FrameMetaExt` requiring only the dropping callback. It uses RTTI to let OSTD can store objects neglecting the specific definitions of metadata. However, RTTI introduces non-negligible performance overhead and requires heap allocation. Theses are the reasons I ruled out all these implementations.\r\n\r\nhttps://github.com/m-ou-se/rfcs/blob/extern-static/text/0000-externally-definable-statics.md May provide a way to define \"existential external types\", which would satisfy our need. But it seemed to be too futuristic.\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n[Rust trait object safety](https://doc.rust-lang.org/reference/items/traits.html#object-safety) and [Rust downcast](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.downcast) for the obstacles using RTTI for metadata.\r\n\r\n\r\n\r\n\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\nIt is still not decided if the frame metadata's dirty field should be called `dirty`, because that anonymous pages, while would have this information but actually don't need it. It is also undecided that if we should include a drop callback function in the metadata, or let OSTD users maintain a frame to disk device mapping.\r\n\r\n\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\r\nSurely we want to implement a \"get rid of all mapped address spaces of this frame\" with good care.\n",
        "hints_text": "",
        "created_at": "2024-12-17T07:08:47Z",
        "version": "0.11"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1717,
        "instance_id": "asterinas__asterinas-1717",
        "issue_numbers": [
            "1715"
        ],
        "base_commit": "6e4a4c58d050a8b42c43e06d42e7b54ec1bd400e",
        "patch": "diff --git a/kernel/src/net/socket/ip/stream/mod.rs b/kernel/src/net/socket/ip/stream/mod.rs\n--- a/kernel/src/net/socket/ip/stream/mod.rs\n+++ b/kernel/src/net/socket/ip/stream/mod.rs\n@@ -10,7 +10,7 @@ use connected::ConnectedStream;\n use connecting::{ConnResult, ConnectingStream};\n use init::InitStream;\n use listen::ListenStream;\n-use options::{Congestion, MaxSegment, NoDelay, WindowClamp, KEEPALIVE_INTERVAL};\n+use options::{Congestion, KeepIdle, MaxSegment, NoDelay, WindowClamp, KEEPALIVE_INTERVAL};\n use ostd::sync::{PreemptDisabled, RwLockReadGuard, RwLockWriteGuard};\n use takeable::Takeable;\n use util::TcpOptionSet;\ndiff --git a/kernel/src/net/socket/ip/stream/mod.rs b/kernel/src/net/socket/ip/stream/mod.rs\n--- a/kernel/src/net/socket/ip/stream/mod.rs\n+++ b/kernel/src/net/socket/ip/stream/mod.rs\n@@ -670,18 +670,22 @@ impl Socket for StreamSocket {\n                 let no_delay = options.tcp.no_delay();\n                 tcp_no_delay.set(no_delay);\n             },\n-            tcp_congestion: Congestion => {\n-                let congestion = options.tcp.congestion();\n-                tcp_congestion.set(congestion);\n-            },\n             tcp_maxseg: MaxSegment => {\n                 let maxseg = options.tcp.maxseg();\n                 tcp_maxseg.set(maxseg);\n             },\n+            tcp_keep_idle: KeepIdle => {\n+                let keep_idle = options.tcp.keep_idle();\n+                tcp_keep_idle.set(keep_idle);\n+            },\n             tcp_window_clamp: WindowClamp => {\n                 let window_clamp = options.tcp.window_clamp();\n                 tcp_window_clamp.set(window_clamp);\n             },\n+            tcp_congestion: Congestion => {\n+                let congestion = options.tcp.congestion();\n+                tcp_congestion.set(congestion);\n+            },\n             _ => return_errno_with_message!(Errno::ENOPROTOOPT, \"the socket option to get is unknown\")\n         });\n \ndiff --git a/kernel/src/net/socket/ip/stream/mod.rs b/kernel/src/net/socket/ip/stream/mod.rs\n--- a/kernel/src/net/socket/ip/stream/mod.rs\n+++ b/kernel/src/net/socket/ip/stream/mod.rs\n@@ -691,61 +695,79 @@ impl Socket for StreamSocket {\n     fn set_option(&self, option: &dyn SocketOption) -> Result<()> {\n         let (mut options, mut state) = self.update_connecting();\n \n-        match options.socket.set_option(option, state.as_mut()) {\n-            Err(err) if err.error() == Errno::ENOPROTOOPT => (),\n+        let need_iface_poll = match options.socket.set_option(option, state.as_mut()) {\n+            Err(err) if err.error() == Errno::ENOPROTOOPT => {\n+                do_tcp_setsockopt(option, &mut options, state.as_mut())?\n+            }\n             Err(err) => return Err(err),\n-            Ok(need_iface_poll) => {\n-                let iface_to_poll = need_iface_poll.then(|| state.iface().cloned()).flatten();\n+            Ok(need_iface_poll) => need_iface_poll,\n+        };\n \n-                drop(state);\n-                drop(options);\n+        let iface_to_poll = need_iface_poll.then(|| state.iface().cloned()).flatten();\n \n-                if let Some(iface) = iface_to_poll {\n-                    iface.poll();\n-                }\n+        drop(state);\n+        drop(options);\n \n-                return Ok(());\n-            }\n+        if let Some(iface) = iface_to_poll {\n+            iface.poll();\n         }\n \n-        // FIXME: Here we have only set the value of the option, without actually\n-        // making any real modifications.\n-        match_sock_option_ref!(option, {\n-            tcp_no_delay: NoDelay => {\n-                let no_delay = tcp_no_delay.get().unwrap();\n-                options.tcp.set_no_delay(*no_delay);\n-                state.set_raw_option(|raw_socket: &dyn RawTcpSetOption| raw_socket.set_nagle_enabled(!no_delay));\n-            },\n-            tcp_congestion: Congestion => {\n-                let congestion = tcp_congestion.get().unwrap();\n-                options.tcp.set_congestion(*congestion);\n-            },\n-            tcp_maxseg: MaxSegment => {\n-                const MIN_MAXSEG: u32 = 536;\n-                const MAX_MAXSEG: u32 = 65535;\n-\n-                let maxseg = tcp_maxseg.get().unwrap();\n-                if *maxseg < MIN_MAXSEG || *maxseg > MAX_MAXSEG {\n-                    return_errno_with_message!(Errno::EINVAL, \"the maximum segment size is out of bounds\");\n-                }\n-                options.tcp.set_maxseg(*maxseg);\n-            },\n-            tcp_window_clamp: WindowClamp => {\n-                let window_clamp = tcp_window_clamp.get().unwrap();\n-                let half_recv_buf = options.socket.recv_buf() / 2;\n-                if *window_clamp <= half_recv_buf {\n-                    options.tcp.set_window_clamp(half_recv_buf);\n-                } else {\n-                    options.tcp.set_window_clamp(*window_clamp);\n-                }\n-            },\n-            _ => return_errno_with_message!(Errno::ENOPROTOOPT, \"the socket option to be set is unknown\")\n-        });\n-\n         Ok(())\n     }\n }\n \n+fn do_tcp_setsockopt(\n+    option: &dyn SocketOption,\n+    options: &mut OptionSet,\n+    state: &mut State,\n+) -> Result<NeedIfacePoll> {\n+    match_sock_option_ref!(option, {\n+        tcp_no_delay: NoDelay => {\n+            let no_delay = tcp_no_delay.get().unwrap();\n+            options.tcp.set_no_delay(*no_delay);\n+            state.set_raw_option(|raw_socket: &dyn RawTcpSetOption| raw_socket.set_nagle_enabled(!no_delay));\n+        },\n+        tcp_maxseg: MaxSegment => {\n+            const MIN_MAXSEG: u32 = 536;\n+            const MAX_MAXSEG: u32 = 65535;\n+\n+            let maxseg = tcp_maxseg.get().unwrap();\n+            if *maxseg < MIN_MAXSEG || *maxseg > MAX_MAXSEG {\n+                return_errno_with_message!(Errno::EINVAL, \"the maximum segment size is out of bounds\");\n+            }\n+            options.tcp.set_maxseg(*maxseg);\n+        },\n+        tcp_keep_idle: KeepIdle => {\n+            const MIN_KEEP_IDLE: u32 = 1;\n+            const MAX_KEEP_IDLE: u32 = 32767;\n+\n+            let keepidle = tcp_keep_idle.get().unwrap();\n+            if *keepidle < MIN_KEEP_IDLE || *keepidle > MAX_KEEP_IDLE {\n+                return_errno_with_message!(Errno::EINVAL, \"the keep idle time is out of bounds\");\n+            }\n+            options.tcp.set_keep_idle(*keepidle);\n+\n+            // TODO: Track when the socket becomes idle to actually support keep idle.\n+        },\n+        tcp_window_clamp: WindowClamp => {\n+            let window_clamp = tcp_window_clamp.get().unwrap();\n+            let half_recv_buf = options.socket.recv_buf() / 2;\n+            if *window_clamp <= half_recv_buf {\n+                options.tcp.set_window_clamp(half_recv_buf);\n+            } else {\n+                options.tcp.set_window_clamp(*window_clamp);\n+            }\n+        },\n+        tcp_congestion: Congestion => {\n+            let congestion = tcp_congestion.get().unwrap();\n+            options.tcp.set_congestion(*congestion);\n+        },\n+        _ => return_errno_with_message!(Errno::ENOPROTOOPT, \"the socket option to be set is unknown\")\n+    });\n+\n+    Ok(NeedIfacePoll::FALSE)\n+}\n+\n impl State {\n     /// Calls `f` to set raw socket option.\n     ///\ndiff --git a/kernel/src/net/socket/ip/stream/options.rs b/kernel/src/net/socket/ip/stream/options.rs\n--- a/kernel/src/net/socket/ip/stream/options.rs\n+++ b/kernel/src/net/socket/ip/stream/options.rs\n@@ -5,9 +5,10 @@ use crate::impl_socket_options;\n \n impl_socket_options!(\n     pub struct NoDelay(bool);\n-    pub struct Congestion(CongestionControl);\n     pub struct MaxSegment(u32);\n+    pub struct KeepIdle(u32);\n     pub struct WindowClamp(u32);\n+    pub struct Congestion(CongestionControl);\n );\n \n /// The keepalive interval.\ndiff --git a/kernel/src/net/socket/ip/stream/util.rs b/kernel/src/net/socket/ip/stream/util.rs\n--- a/kernel/src/net/socket/ip/stream/util.rs\n+++ b/kernel/src/net/socket/ip/stream/util.rs\n@@ -7,21 +7,24 @@ use crate::prelude::*;\n #[set = \"pub\"]\n pub struct TcpOptionSet {\n     no_delay: bool,\n-    congestion: CongestionControl,\n     maxseg: u32,\n+    keep_idle: u32,\n     window_clamp: u32,\n+    congestion: CongestionControl,\n }\n \n pub const DEFAULT_MAXSEG: u32 = 536;\n+pub const DEFAULT_KEEP_IDLE: u32 = 7200;\n pub const DEFAULT_WINDOW_CLAMP: u32 = 0x8000_0000;\n \n impl TcpOptionSet {\n     pub fn new() -> Self {\n         Self {\n             no_delay: false,\n-            congestion: CongestionControl::Reno,\n             maxseg: DEFAULT_MAXSEG,\n+            keep_idle: DEFAULT_KEEP_IDLE,\n             window_clamp: DEFAULT_WINDOW_CLAMP,\n+            congestion: CongestionControl::Reno,\n         }\n     }\n }\ndiff --git a/kernel/src/syscall/getsockopt.rs b/kernel/src/syscall/getsockopt.rs\n--- a/kernel/src/syscall/getsockopt.rs\n+++ b/kernel/src/syscall/getsockopt.rs\n@@ -15,7 +15,7 @@ pub fn sys_getsockopt(\n     optlen_addr: Vaddr,\n     ctx: &Context,\n ) -> Result<SyscallReturn> {\n-    let level = CSocketOptionLevel::try_from(level)?;\n+    let level = CSocketOptionLevel::try_from(level).map_err(|_| Errno::EOPNOTSUPP)?;\n     if optval == 0 || optlen_addr == 0 {\n         return_errno_with_message!(Errno::EINVAL, \"optval or optlen_addr is null pointer\");\n     }\ndiff --git a/kernel/src/syscall/setsockopt.rs b/kernel/src/syscall/setsockopt.rs\n--- a/kernel/src/syscall/setsockopt.rs\n+++ b/kernel/src/syscall/setsockopt.rs\n@@ -15,7 +15,7 @@ pub fn sys_setsockopt(\n     optlen: u32,\n     _ctx: &Context,\n ) -> Result<SyscallReturn> {\n-    let level = CSocketOptionLevel::try_from(level)?;\n+    let level = CSocketOptionLevel::try_from(level).map_err(|_| Errno::EOPNOTSUPP)?;\n     if optval == 0 {\n         return_errno_with_message!(Errno::EINVAL, \"optval is null pointer\");\n     }\ndiff --git a/kernel/src/util/net/options/mod.rs b/kernel/src/util/net/options/mod.rs\n--- a/kernel/src/util/net/options/mod.rs\n+++ b/kernel/src/util/net/options/mod.rs\n@@ -134,7 +134,7 @@ pub fn new_raw_socket_option(\n     match level {\n         CSocketOptionLevel::SOL_SOCKET => new_socket_option(name),\n         CSocketOptionLevel::SOL_TCP => new_tcp_option(name),\n-        _ => todo!(),\n+        _ => return_errno_with_message!(Errno::EOPNOTSUPP, \"unsupported option level\"),\n     }\n }\n \ndiff --git a/kernel/src/util/net/options/socket.rs b/kernel/src/util/net/options/socket.rs\n--- a/kernel/src/util/net/options/socket.rs\n+++ b/kernel/src/util/net/options/socket.rs\n@@ -39,7 +39,7 @@ enum CSocketOptionName {\n }\n \n pub fn new_socket_option(name: i32) -> Result<Box<dyn RawSocketOption>> {\n-    let name = CSocketOptionName::try_from(name)?;\n+    let name = CSocketOptionName::try_from(name).map_err(|_| Errno::ENOPROTOOPT)?;\n     match name {\n         CSocketOptionName::SNDBUF => Ok(Box::new(SendBuf::new())),\n         CSocketOptionName::RCVBUF => Ok(Box::new(RecvBuf::new())),\ndiff --git a/kernel/src/util/net/options/socket.rs b/kernel/src/util/net/options/socket.rs\n--- a/kernel/src/util/net/options/socket.rs\n+++ b/kernel/src/util/net/options/socket.rs\n@@ -48,7 +48,7 @@ pub fn new_socket_option(name: i32) -> Result<Box<dyn RawSocketOption>> {\n         CSocketOptionName::REUSEPORT => Ok(Box::new(ReusePort::new())),\n         CSocketOptionName::LINGER => Ok(Box::new(Linger::new())),\n         CSocketOptionName::KEEPALIVE => Ok(Box::new(KeepAlive::new())),\n-        _ => todo!(),\n+        _ => return_errno_with_message!(Errno::ENOPROTOOPT, \"unsupported socket-level option\"),\n     }\n }\n \ndiff --git a/kernel/src/util/net/options/tcp.rs b/kernel/src/util/net/options/tcp.rs\n--- a/kernel/src/util/net/options/tcp.rs\n+++ b/kernel/src/util/net/options/tcp.rs\n@@ -3,7 +3,7 @@\n use super::RawSocketOption;\n use crate::{\n     impl_raw_socket_option,\n-    net::socket::ip::stream::options::{Congestion, MaxSegment, NoDelay, WindowClamp},\n+    net::socket::ip::stream::options::{Congestion, KeepIdle, MaxSegment, NoDelay, WindowClamp},\n     prelude::*,\n     util::net::options::SocketOption,\n };\ndiff --git a/kernel/src/util/net/options/tcp.rs b/kernel/src/util/net/options/tcp.rs\n--- a/kernel/src/util/net/options/tcp.rs\n+++ b/kernel/src/util/net/options/tcp.rs\n@@ -26,17 +26,19 @@ pub enum CTcpOptionName {\n }\n \n pub fn new_tcp_option(name: i32) -> Result<Box<dyn RawSocketOption>> {\n-    let name = CTcpOptionName::try_from(name)?;\n+    let name = CTcpOptionName::try_from(name).map_err(|_| Errno::ENOPROTOOPT)?;\n     match name {\n         CTcpOptionName::NODELAY => Ok(Box::new(NoDelay::new())),\n-        CTcpOptionName::CONGESTION => Ok(Box::new(Congestion::new())),\n         CTcpOptionName::MAXSEG => Ok(Box::new(MaxSegment::new())),\n+        CTcpOptionName::KEEPIDLE => Ok(Box::new(KeepIdle::new())),\n         CTcpOptionName::WINDOW_CLAMP => Ok(Box::new(WindowClamp::new())),\n-        _ => todo!(),\n+        CTcpOptionName::CONGESTION => Ok(Box::new(Congestion::new())),\n+        _ => return_errno_with_message!(Errno::ENOPROTOOPT, \"unsupported tcp-level option\"),\n     }\n }\n \n impl_raw_socket_option!(NoDelay);\n-impl_raw_socket_option!(Congestion);\n impl_raw_socket_option!(MaxSegment);\n+impl_raw_socket_option!(KeepIdle);\n impl_raw_socket_option!(WindowClamp);\n+impl_raw_socket_option!(Congestion);\n",
        "test_patch": "diff --git a/test/apps/network/sockoption.c b/test/apps/network/sockoption.c\n--- a/test/apps/network/sockoption.c\n+++ b/test/apps/network/sockoption.c\n@@ -38,6 +38,26 @@ FN_SETUP(general)\n }\n END_SETUP()\n \n+FN_TEST(invalid_socket_option)\n+{\n+\tint res;\n+\tsocklen_t res_len = sizeof(res);\n+\n+#define INVALID_LEVEL 99999\n+\tTEST_ERRNO(getsockopt(sk_connected, INVALID_LEVEL, SO_SNDBUF, &res,\n+\t\t\t      &res_len),\n+\t\t   EOPNOTSUPP);\n+#define INVALID_SOCKET_OPTION 99999\n+\tTEST_ERRNO(getsockopt(sk_connected, SOL_SOCKET, INVALID_SOCKET_OPTION,\n+\t\t\t      &res, &res_len),\n+\t\t   ENOPROTOOPT);\n+#define INVALID_TCP_OPTION 99999\n+\tTEST_ERRNO(getsockopt(sk_connected, IPPROTO_TCP, INVALID_TCP_OPTION,\n+\t\t\t      &res, &res_len),\n+\t\t   ENOPROTOOPT);\n+}\n+END_TEST()\n+\n int refresh_connection()\n {\n \tclose(sk_connected);\ndiff --git a/test/apps/network/sockoption.c b/test/apps/network/sockoption.c\n--- a/test/apps/network/sockoption.c\n+++ b/test/apps/network/sockoption.c\n@@ -230,3 +250,27 @@ FN_TEST(keepalive)\n \t\t keepalive == 0);\n }\n END_TEST()\n+\n+FN_TEST(keepidle)\n+{\n+\tint keepidle;\n+\tsocklen_t keepidle_len = sizeof(keepidle);\n+\n+\t// 1. Check default values\n+\trefresh_connection();\n+\tTEST_RES(getsockopt(sk_connected, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle,\n+\t\t\t    &keepidle_len),\n+\t\t keepidle == 7200);\n+\tTEST_RES(getsockopt(sk_accepted, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle,\n+\t\t\t    &keepidle_len),\n+\t\t keepidle == 7200);\n+\n+\t// 2. Set and Get value\n+\tint seconds = 200;\n+\tCHECK(setsockopt(sk_connected, IPPROTO_TCP, TCP_KEEPIDLE, &seconds,\n+\t\t\t sizeof(seconds)));\n+\tTEST_RES(getsockopt(sk_connected, IPPROTO_TCP, TCP_KEEPIDLE, &keepidle,\n+\t\t\t    &keepidle_len),\n+\t\t keepidle == 200);\n+}\n+END_TEST()\n\\ No newline at end of file\n",
        "problem_statement": "Redis benchmark always fails\nThe job `redis/get_100k_conc20_rps` within the [Benchmark workflow](https://github.com/asterinas/asterinas/actions/runs/12341838143/job/34440964283#logs) encountered a failure today. Upon investigation, I discovered that it can be consistently triggered by executing `bash test/benchmark/bench_linux_and_aster.sh redis/get_100k_conc20_rps`.\r\n\r\nThe error messages are as follows:\r\n```log\r\nRunning apache bench connected to 10.0.2.15\r\n[     2.485] ERROR: Uncaught panic:\r\n\tnot yet implemented\r\n\tat /root/asterinas/kernel/src/util/net/options/tcp.rs:35\r\n\ton CPU 0 by thread Some(Thread { task: (Weak), data: Any { .. }, status: AtomicThreadStatus(1), priority: AtomicPriority(120), cpu_affinity: AtomicCpuSet { bits: [1] }, sched)\r\nPrinting stack trace:\r\n```\r\nThe relevant code snippet reveals a `todo!()` marker:\r\n```rust\r\npub fn new_tcp_option(name: i32) -> Result<Box<dyn RawSocketOption>> {\r\n    let name = CTcpOptionName::try_from(name)?;\r\n    match name {\r\n        CTcpOptionName::NODELAY => Ok(Box::new(NoDelay::new())),\r\n        CTcpOptionName::CONGESTION => Ok(Box::new(Congestion::new())),\r\n        CTcpOptionName::MAXSEG => Ok(Box::new(MaxSegment::new())),\r\n        CTcpOptionName::WINDOW_CLAMP => Ok(Box::new(WindowClamp::new())),\r\n        _ => todo!(),\r\n    }\r\n}\r\n```\r\n\r\nThis is perplexing, as previous redis benchmarks have never encountered this particular option. Does anyone have insights into why this might be happening?\n",
        "hints_text": "",
        "created_at": "2024-12-16T09:32:00Z",
        "version": "0.10"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 650,
        "instance_id": "asterinas__asterinas-650",
        "issue_numbers": [
            "646"
        ],
        "base_commit": "07fbbcfd8c22459719c9af7eeeb3dee5ad24ba92",
        "patch": "diff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -105,14 +105,9 @@ static ssize_t receive_all(int sockfd)\n \tsize_t recv_len = 0;\n \tssize_t ret;\n \n-\tif (mark_filde_nonblock(sockfd) < 0) {\n-\t\tperror(\"receive_all: mark_filde_nonblock\");\n-\t\treturn -1;\n-\t}\n-\n \tfor (;;) {\n \t\tret = recv(sockfd, buffer, sizeof(buffer), 0);\n-\t\tif (ret < 0 && errno == EAGAIN)\n+\t\tif (ret == 0)\n \t\t\tbreak;\n \n \t\tif (ret < 0) {\n",
        "test_patch": "diff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -197,6 +192,9 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tif (pid == 0) {\n \t\tssize_t recv_len;\n \n+\t\tclose(sendfd);\n+\t\tsendfd = -1;\n+\n \t\t// Ensure that the parent executes send() first, then the child\n \t\t// executes recv().\n \t\tsleep(1);\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -230,6 +228,9 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tsent_len += 1;\n \tfprintf(stderr, \"Sent bytes: %lu\\n\", sent_len);\n \n+\tclose(sendfd);\n+\tsendfd = -1;\n+\n \tret = 0;\n \n wait:\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -250,7 +251,8 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tclose(recvfd);\n \n out_send:\n-\tclose(sendfd);\n+\tif (sendfd >= 0)\n+\t\tclose(sendfd);\n \n out_listen:\n \tclose(listenfd);\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -18,7 +18,7 @@ echo \"Start network test......\"\n ./socketpair\n ./sockoption\n ./listen_backlog\n-# ./send_buf_full\n+./send_buf_full\n ./http_server &\n ./http_client\n ./tcp_err\n",
        "problem_statement": "The send_buf_full test fails on host linux\nThe test is run within Asterinas dev container. \r\n\r\nTo replay the results, commands are \r\n```bash\r\nmake build\r\ncd regression/build/initramfs/regression/network\r\n./send_buf_full\r\n```\r\nI run `./send_buf_full` for four times, the results are\r\n```\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2586567\r\nTest passed: Equal sent bytes and received bytes\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nnew_bound_socket: bind: Address already in use\r\nTest failed: Error occurs in new_bound_socket\r\n```\r\nI have repeated the test several time and find the same results: the test fails at the first run and succeeds in some following run. And once the test succeeds, the following run will report `Address already in use` error.\r\n\n",
        "hints_text": "",
        "created_at": "2024-02-23T12:37:06Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 637,
        "instance_id": "asterinas__asterinas-637",
        "issue_numbers": [
            "592"
        ],
        "base_commit": "8d456ebe8fc200fc11c75654fdca2f0dd896e656",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -221,37 +221,7 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"aster-rights\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"aster-rights-proc\",\n- \"bitflags 1.3.2\",\n- \"typeflags\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"aster-rights-proc\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n-[[package]]\n-name = \"aster-runner\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anyhow\",\n- \"clap\",\n- \"linux-bzimage-builder\",\n- \"rand\",\n- \"xmas-elf 0.8.0\",\n-]\n-\n-[[package]]\n-name = \"aster-std\"\n+name = \"aster-nix\"\n version = \"0.1.0\"\n dependencies = [\n  \"align_ext\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -296,6 +266,36 @@ dependencies = [\n  \"xmas-elf 0.8.0\",\n ]\n \n+[[package]]\n+name = \"aster-rights\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-rights-proc\",\n+ \"bitflags 1.3.2\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-rights-proc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"aster-runner\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"clap\",\n+ \"linux-bzimage-builder\",\n+ \"rand\",\n+ \"xmas-elf 0.8.0\",\n+]\n+\n [[package]]\n name = \"aster-time\"\n version = \"0.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -350,7 +350,7 @@ version = \"0.3.0\"\n dependencies = [\n  \"aster-frame\",\n  \"aster-framebuffer\",\n- \"aster-std\",\n+ \"aster-nix\",\n  \"aster-time\",\n  \"component\",\n  \"x86_64\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -9,7 +9,7 @@ path = \"kernel/main.rs\"\n \n [dependencies]\n aster-frame = { path = \"framework/aster-frame\" }\n-aster-std = { path = \"services/libs/aster-std\" }\n+aster-nix = { path = \"services/aster-nix\" }\n component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -52,7 +53,6 @@ members = [\n     \"services/libs/int-to-c-enum/derive\",\n     \"services/libs/aster-rights\",\n     \"services/libs/aster-rights-proc\",\n-    \"services/libs/aster-std\",\n     \"services/libs/aster-util\",\n     \"services/libs/keyable-arc\",\n     \"services/libs/typeflags\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -67,4 +67,4 @@ exclude = [\n ]\n \n [features]\n-intel_tdx = [\"aster-frame/intel_tdx\", \"aster-std/intel_tdx\"]\n+intel_tdx = [\"aster-frame/intel_tdx\", \"aster-nix/intel_tdx\"]\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -1,6 +1,6 @@\n # template\n [components]\n-std = { name = \"aster-std\" }\n+nix = { name = \"aster-nix\" }\n virtio = { name = \"aster-virtio\" }\n input = { name = \"aster-input\" }\n block = { name = \"aster-block\" }\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -11,5 +11,5 @@ network = { name = \"aster-network\" }\n main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.std.run_first_process]\n+[whitelist.nix.run_first_process]\n main = true\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -14,6 +14,6 @@ pub fn main() -> ! {\n     aster_frame::init();\n     early_println!(\"[kernel] finish init aster_frame\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    aster_std::init();\n-    aster_std::run_first_process();\n+    aster_nix::init();\n+    aster_nix::run_first_process();\n }\ndiff --git a/services/libs/aster-std/Cargo.toml b/services/aster-nix/Cargo.toml\n--- a/services/libs/aster-std/Cargo.toml\n+++ b/services/aster-nix/Cargo.toml\n@@ -1,28 +1,28 @@\n [package]\n-name = \"aster-std\"\n+name = \"aster-nix\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-aster-frame = { path = \"../../../framework/aster-frame\" }\n-align_ext = { path = \"../../../framework/libs/align_ext\" }\n+aster-frame = { path = \"../../framework/aster-frame\" }\n+align_ext = { path = \"../../framework/libs/align_ext\" }\n pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n-aster-input = { path = \"../../comps/input\" }\n-aster-block = { path = \"../../comps/block\" }\n-aster-network = { path = \"../../comps/network\" }\n-aster-console = { path = \"../../comps/console\" }\n-aster-time = { path = \"../../comps/time\" }\n-aster-virtio = { path = \"../../comps/virtio\" }\n-aster-rights = { path = \"../aster-rights\" }\n-controlled = { path = \"../../libs/comp-sys/controlled\" }\n-typeflags = { path = \"../typeflags\" }\n-typeflags-util = { path = \"../typeflags-util\" }\n-aster-rights-proc = { path = \"../aster-rights-proc\" }\n-aster-util = { path = \"../aster-util\" }\n-int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../cpio-decoder\" }\n+aster-input = { path = \"../comps/input\" }\n+aster-block = { path = \"../comps/block\" }\n+aster-network = { path = \"../comps/network\" }\n+aster-console = { path = \"../comps/console\" }\n+aster-time = { path = \"../comps/time\" }\n+aster-virtio = { path = \"../comps/virtio\" }\n+aster-rights = { path = \"../libs/aster-rights\" }\n+controlled = { path = \"../libs/comp-sys/controlled\" }\n+typeflags = { path = \"../libs/typeflags\" }\n+typeflags-util = { path = \"../libs/typeflags-util\" }\n+aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n+aster-util = { path = \"../libs/aster-util\" }\n+int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"../libs/cpio-decoder\" }\n ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n intrusive-collections = \"0.9.5\"\n time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\ndiff --git a/services/libs/aster-std/Cargo.toml b/services/aster-nix/Cargo.toml\n--- a/services/libs/aster-std/Cargo.toml\n+++ b/services/aster-nix/Cargo.toml\n@@ -49,7 +49,7 @@ xmas-elf = \"0.8.0\"\n # data-structures\n bitflags = \"1.3\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../keyable-arc\" }\n+keyable-arc = { path = \"../libs/keyable-arc\" }\n # unzip initramfs\n libflate = { git = \"https://github.com/asterinas/libflate\", rev = \"b781da6\", features = [\n     \"no_std\",\ndiff --git a/services/libs/aster-std/src/lib.rs b/services/aster-nix/src/lib.rs\n--- a/services/libs/aster-std/src/lib.rs\n+++ b/services/aster-nix/src/lib.rs\n@@ -89,7 +89,7 @@ fn init_thread() {\n     }));\n     thread.join();\n     info!(\n-        \"[aster-std/lib.rs] spawn kernel thread, tid = {}\",\n+        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n         thread.tid()\n     );\n     thread::work_queue::init();\n",
        "test_patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -40,6 +40,7 @@ members = [\n     \"framework/libs/linux-bzimage/setup\",\n     \"framework/libs/ktest\",\n     \"framework/libs/tdx-guest\",\n+    \"services/aster-nix\",\n     \"services/comps/block\",\n     \"services/comps/console\",\n     \"services/comps/framebuffer\",\ndiff --git a/services/libs/aster-std/Cargo.toml b/services/aster-nix/Cargo.toml\n--- a/services/libs/aster-std/Cargo.toml\n+++ b/services/aster-nix/Cargo.toml\n@@ -40,8 +40,8 @@ smoltcp = { version = \"0.9.1\", default-features = false, features = [\n     \"socket-raw\",\n     \"socket-dhcpv4\",\n ] }\n-ktest = { path = \"../../../framework/libs/ktest\" }\n-tdx-guest = { path = \"../../../framework/libs/tdx-guest\", optional = true }\n+ktest = { path = \"../../framework/libs/ktest\" }\n+tdx-guest = { path = \"../../framework/libs/tdx-guest\", optional = true }\n \n # parse elf file\n xmas-elf = \"0.8.0\"\n",
        "problem_statement": "Rename `aster-std` to `aster-nix`\n# Background\r\n\r\nIn the current codebase, the Linux/UNIX layer is implemented in the `aster-std` crate under `services/libs`. The crate does the heavy-lifting job of implementing high-level OS concepts like processes, signals, file systems, sockets, etc. Ideally, we would like to have the system call layer to be more modular, breaking up the large crate into smaller ones. But this is going to take time and is probably done in an incremental fashion. So in the near future, we will still have to make peace with the sheer size of the `aster-std` crate.\r\n\r\n# Goal\r\n\r\nGiven the role and size of the `aster-std` crate, I propose to change the name and location of the crate.\r\n\r\nIts current name is only for historic reason: the crate is originally positioned as the std library for Asterinas, but it ends up with all system calls implemented in it. So calling it std is no longer appropriate. **I propose renaming it `aster-nix`**, as it implements the Linux and UNIX concepts and system calls.\r\n\r\nThe crate is currently buried in the third level of the project hierarchy, under `services/libs`. This crate is probably the second most important crate (after `aster-frame`) and the most frequently-updated one. Given its importance, I think it makes sense to given the crate a more _visible_ location. So **I propose to move the crate to `services/`**.\n",
        "hints_text": "",
        "created_at": "2024-02-05T08:00:55Z",
        "version": "0.3"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 679,
        "instance_id": "asterinas__asterinas-679",
        "issue_numbers": [
            "666"
        ],
        "base_commit": "dede22843a99f6d19c8a2dddcfc7ef0ad45ce815",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -15,8 +15,7 @@ use crate::{\n         memory_region::{non_overlapping_regions_from, MemoryRegion, MemoryRegionType},\n         BootloaderAcpiArg, BootloaderFramebufferArg,\n     },\n-    config::PHYS_OFFSET,\n-    vm::paddr_to_vaddr,\n+    vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR},\n };\n \n static BOOT_PARAMS: Once<BootParams> = Once::new();\ndiff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -71,7 +70,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n     let hdr = &BOOT_PARAMS.get().unwrap().hdr;\n     let ptr = hdr.ramdisk_image as usize;\n     // We must return a slice composed by VA since kernel should read everything in VA.\n-    let base_va = if ptr < PHYS_OFFSET {\n+    let base_va = if ptr < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(ptr)\n     } else {\n         ptr\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -12,8 +12,7 @@ use crate::{\n         memory_region::{non_overlapping_regions_from, MemoryRegion, MemoryRegionType},\n         BootloaderAcpiArg, BootloaderFramebufferArg,\n     },\n-    config::PHYS_OFFSET,\n-    vm::paddr_to_vaddr,\n+    vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR},\n };\n \n global_asm!(include_str!(\"header.S\"));\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -77,7 +76,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n         )\n     };\n     // We must return a slice composed by VA since kernel should read every in VA.\n-    let base_va = if start < PHYS_OFFSET {\n+    let base_va = if start < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(start)\n     } else {\n         start\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -17,7 +17,7 @@ use crate::boot::{\n \n global_asm!(include_str!(\"header.S\"));\n \n-use crate::{config::PHYS_OFFSET, vm::paddr_to_vaddr};\n+use crate::vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR};\n \n pub(super) const MULTIBOOT2_ENTRY_MAGIC: u32 = 0x36d76289;\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -58,7 +58,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n         .expect(\"No Multiboot2 modules found!\");\n     let base_addr = mb2_module_tag.start_address() as usize;\n     // We must return a slice composed by VA since kernel should read every in VA.\n-    let base_va = if base_addr < PHYS_OFFSET {\n+    let base_va = if base_addr < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(base_addr)\n     } else {\n         base_addr\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -3,7 +3,7 @@\n use pod::Pod;\n \n use crate::{\n-    config::ENTRY_COUNT,\n+    arch::x86::mm::NR_ENTRIES_PER_PAGE,\n     vm::page_table::{PageTableEntryTrait, PageTableFlagsTrait},\n };\n \ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -153,6 +153,6 @@ impl PageTableEntryTrait for PageTableEntry {\n \n     fn page_index(va: crate::vm::Vaddr, level: usize) -> usize {\n         debug_assert!((1..=5).contains(&level));\n-        va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+        va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     }\n }\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -6,7 +6,6 @@ use pod::Pod;\n use x86_64::{instructions::tlb, structures::paging::PhysFrame, VirtAddr};\n \n use crate::{\n-    config::ENTRY_COUNT,\n     sync::Mutex,\n     vm::{\n         page_table::{table_of, PageTableEntryTrait, PageTableFlagsTrait},\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -14,6 +13,8 @@ use crate::{\n     },\n };\n \n+pub(crate) const NR_ENTRIES_PER_PAGE: usize = 512;\n+\n bitflags::bitflags! {\n     #[derive(Pod)]\n     #[repr(C)]\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -210,7 +211,7 @@ impl PageTableEntryTrait for PageTableEntry {\n \n     fn page_index(va: crate::vm::Vaddr, level: usize) -> usize {\n         debug_assert!((1..=5).contains(&level));\n-        va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+        va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     }\n }\n \ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -12,11 +12,11 @@ use tdx_guest::{\n \n use crate::{\n     arch::mm::{is_kernel_vaddr, PageTableFlags},\n-    config::PAGE_SIZE,\n     vm::{\n         paddr_to_vaddr,\n         page_table::{PageTableError, KERNEL_PAGE_TABLE},\n     },\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\ndiff --git a/framework/aster-frame/src/config.rs /dev/null\n--- a/framework/aster-frame/src/config.rs\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-#![allow(unused)]\n-\n-use log::Level;\n-\n-pub const USER_STACK_SIZE: usize = PAGE_SIZE * 4;\n-pub const KERNEL_STACK_SIZE: usize = PAGE_SIZE * 64;\n-pub const KERNEL_HEAP_SIZE: usize = PAGE_SIZE * 256;\n-\n-pub const KERNEL_OFFSET: usize = 0xffffffff80000000;\n-\n-pub const PHYS_OFFSET: usize = 0xFFFF800000000000;\n-pub const ENTRY_COUNT: usize = 512;\n-\n-pub const PAGE_SIZE: usize = 0x1000;\n-pub const PAGE_SIZE_BITS: usize = 0xc;\n-\n-pub const KVA_START: usize = (usize::MAX) << PAGE_SIZE_BITS;\n-\n-pub const DEFAULT_LOG_LEVEL: Level = Level::Error;\n-\n-pub const REAL_TIME_TASK_PRI: u16 = 100;\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -28,7 +28,6 @@ extern crate static_assertions;\n pub mod arch;\n pub mod boot;\n pub mod bus;\n-pub mod config;\n pub mod console;\n pub mod cpu;\n mod error;\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -1,16 +1,20 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use log::{Metadata, Record};\n+use log::{Level, Metadata, Record};\n \n-use crate::{config::DEFAULT_LOG_LEVEL, early_println};\n+use crate::early_println;\n \n const LOGGER: Logger = Logger {};\n \n+/// FIXME: The logs should be able to be read from files in the userspace,\n+/// and the log level should be configurable.\n+pub const INIT_LOG_LEVEL: Level = Level::Error;\n+\n struct Logger {}\n \n impl log::Log for Logger {\n     fn enabled(&self, metadata: &Metadata) -> bool {\n-        metadata.level() <= DEFAULT_LOG_LEVEL\n+        metadata.level() <= INIT_LOG_LEVEL\n     }\n \n     fn log(&self, record: &Record) {\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -24,6 +28,6 @@ impl log::Log for Logger {\n \n pub(crate) fn init() {\n     log::set_logger(&LOGGER)\n-        .map(|()| log::set_max_level(DEFAULT_LOG_LEVEL.to_level_filter()))\n+        .map(|()| log::set_max_level(INIT_LOG_LEVEL.to_level_filter()))\n         .unwrap();\n }\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use crate::config::REAL_TIME_TASK_PRI;\n+pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n \n /// The priority of a task.\n /// Similar to Linux, a larger value represents a lower priority,\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -44,6 +44,6 @@ impl Priority {\n     }\n \n     pub const fn is_real_time(&self) -> bool {\n-        self.0 < REAL_TIME_TASK_PRI\n+        self.0 < REAL_TIME_TASK_PRIORITY\n     }\n }\ndiff --git a/framework/aster-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\n--- a/framework/aster-frame/src/task/task.rs\n+++ b/framework/aster-frame/src/task/task.rs\n@@ -9,14 +9,15 @@ use super::{\n };\n use crate::{\n     arch::mm::PageTableFlags,\n-    config::{KERNEL_STACK_SIZE, PAGE_SIZE},\n     cpu::CpuSet,\n     prelude::*,\n     sync::{Mutex, MutexGuard},\n     user::UserSpace,\n-    vm::{page_table::KERNEL_PAGE_TABLE, VmAllocOptions, VmSegment},\n+    vm::{page_table::KERNEL_PAGE_TABLE, VmAllocOptions, VmSegment, PAGE_SIZE},\n };\n \n+pub const KERNEL_STACK_SIZE: usize = PAGE_SIZE * 64;\n+\n core::arch::global_asm!(include_str!(\"switch.S\"));\n \n #[derive(Debug, Default, Clone, Copy)]\ndiff --git a/framework/aster-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\n--- a/framework/aster-frame/src/vm/dma/mod.rs\n+++ b/framework/aster-frame/src/vm/dma/mod.rs\n@@ -10,7 +10,7 @@ pub use dma_stream::{DmaDirection, DmaStream};\n use spin::Once;\n \n use super::Paddr;\n-use crate::{arch::iommu::has_iommu, config::PAGE_SIZE, sync::SpinLock};\n+use crate::{arch::iommu::has_iommu, sync::SpinLock, vm::PAGE_SIZE};\n \n /// If a device performs DMA to read or write system\n /// memory, the addresses used by the device are device addresses.\ndiff --git a/framework/aster-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\n--- a/framework/aster-frame/src/vm/frame.rs\n+++ b/framework/aster-frame/src/vm/frame.rs\n@@ -9,7 +9,7 @@ use core::{\n use pod::Pod;\n \n use super::{frame_allocator, HasPaddr, VmIo};\n-use crate::{config::PAGE_SIZE, prelude::*, Error};\n+use crate::{prelude::*, vm::PAGE_SIZE, Error};\n \n /// A collection of page frames (physical memory pages).\n ///\ndiff --git a/framework/aster-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\n--- a/framework/aster-frame/src/vm/frame_allocator.rs\n+++ b/framework/aster-frame/src/vm/frame_allocator.rs\n@@ -10,8 +10,8 @@ use spin::Once;\n use super::{frame::VmFrameFlags, VmFrame, VmFrameVec, VmSegment};\n use crate::{\n     boot::memory_region::{MemoryRegion, MemoryRegionType},\n-    config::PAGE_SIZE,\n     sync::SpinLock,\n+    vm::PAGE_SIZE,\n };\n \n pub(super) static FRAME_ALLOCATOR: Once<SpinLock<FrameAllocator>> = Once::new();\ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -11,11 +11,10 @@ use log::debug;\n \n use super::paddr_to_vaddr;\n use crate::{\n-    config::{KERNEL_HEAP_SIZE, PAGE_SIZE},\n     prelude::*,\n     sync::SpinLock,\n     trap::disable_local,\n-    vm::frame_allocator::FRAME_ALLOCATOR,\n+    vm::{frame_allocator::FRAME_ALLOCATOR, PAGE_SIZE},\n     Error,\n };\n \ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -27,12 +26,14 @@ pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {\n     panic!(\"Heap allocation error, layout = {:?}\", layout);\n }\n \n-static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];\n+const INIT_KERNEL_HEAP_SIZE: usize = PAGE_SIZE * 256;\n+\n+static mut HEAP_SPACE: [u8; INIT_KERNEL_HEAP_SIZE] = [0; INIT_KERNEL_HEAP_SIZE];\n \n pub fn init() {\n     // Safety: The HEAP_SPACE is a static memory range, so it's always valid.\n     unsafe {\n-        HEAP_ALLOCATOR.init(HEAP_SPACE.as_ptr(), KERNEL_HEAP_SIZE);\n+        HEAP_ALLOCATOR.init(HEAP_SPACE.as_ptr(), INIT_KERNEL_HEAP_SIZE);\n     }\n }\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -6,9 +6,11 @@ use core::fmt;\n use super::page_table::{PageTable, PageTableConfig, UserMode};\n use crate::{\n     arch::mm::{PageTableEntry, PageTableFlags},\n-    config::{PAGE_SIZE, PHYS_OFFSET},\n     prelude::*,\n-    vm::{is_page_aligned, VmAllocOptions, VmFrame, VmFrameVec, VmReader, VmWriter},\n+    vm::{\n+        is_page_aligned, VmAllocOptions, VmFrame, VmFrameVec, VmReader, VmWriter,\n+        PHYS_MEM_BASE_VADDR, PAGE_SIZE,\n+    },\n     Error,\n };\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -148,7 +150,7 @@ impl MemorySet {\n             if let Entry::Vacant(e) = self.areas.entry(area.start_va) {\n                 let area = e.insert(area);\n                 for (va, frame) in area.mapper.iter() {\n-                    debug_assert!(frame.start_paddr() < PHYS_OFFSET);\n+                    debug_assert!(frame.start_paddr() < PHYS_MEM_BASE_VADDR);\n                     self.pt.map(*va, frame, area.flags).unwrap();\n                 }\n             } else {\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -32,10 +32,38 @@ pub use self::{\n     page_table::PageTable,\n     space::{VmMapOptions, VmPerm, VmSpace},\n };\n-use crate::{\n-    boot::memory_region::{MemoryRegion, MemoryRegionType},\n-    config::{KERNEL_OFFSET, PAGE_SIZE, PHYS_OFFSET},\n-};\n+use crate::boot::memory_region::{MemoryRegion, MemoryRegionType};\n+\n+pub const PAGE_SIZE: usize = 0x1000;\n+\n+/// The maximum virtual address of user space (non inclusive).\n+/// \n+/// Typicall 64-bit systems have at least 48-bit virtual address space.\n+/// A typical way to reserve half of the address space for the kernel is\n+/// to use the highest 48-bit virtual address space.\n+///\n+/// Also, the top page is not regarded as usable since it's a workaround\n+/// for some x86_64 CPUs' bugs. See\n+/// <https://github.com/torvalds/linux/blob/480e035fc4c714fb5536e64ab9db04fedc89e910/arch/x86/include/asm/page_64.h#L68-L78>\n+/// for the rationale.\n+pub const MAX_USERSPACE_VADDR: Vaddr = 0x0000_8000_0000_0000 - PAGE_SIZE;\n+\n+/// Start of the kernel address space.\n+/// \n+/// This is the _lowest_ address of the x86-64's _high_ canonical addresses.\n+///\n+/// This is also the base address of the direct mapping of all physical\n+/// memory in the kernel address space.\n+pub(crate) const PHYS_MEM_BASE_VADDR: Vaddr = 0xffff_8000_0000_0000;\n+\n+/// The kernel code is linear mapped to this address.\n+///\n+/// FIXME: This offset should be randomly chosen by the loader or the\n+/// boot compatibility layer. But we disabled it because the framework\n+/// doesn't support relocatable kernel yet.\n+pub fn kernel_loaded_offset() -> usize {\n+    0xffff_ffff_8000_0000\n+}\n \n /// Get physical address trait\n pub trait HasPaddr {\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -43,9 +71,9 @@ pub trait HasPaddr {\n }\n \n pub fn vaddr_to_paddr(va: Vaddr) -> Option<Paddr> {\n-    if (PHYS_OFFSET..=KERNEL_OFFSET).contains(&va) {\n+    if (PHYS_MEM_BASE_VADDR..=kernel_loaded_offset()).contains(&va) {\n         // can use offset to get the physical address\n-        Some(va - PHYS_OFFSET)\n+        Some(va - PHYS_MEM_BASE_VADDR)\n     } else {\n         page_table::vaddr_to_paddr(va)\n     }\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -57,7 +85,7 @@ pub const fn is_page_aligned(p: usize) -> bool {\n \n /// Convert physical address to virtual address using offset, only available inside aster-frame\n pub(crate) fn paddr_to_vaddr(pa: usize) -> usize {\n-    pa + PHYS_OFFSET\n+    pa + PHYS_MEM_BASE_VADDR\n }\n \n /// Only available inside aster-frame\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -9,10 +9,9 @@ use spin::Once;\n \n use super::{paddr_to_vaddr, Paddr, Vaddr, VmAllocOptions};\n use crate::{\n-    arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry},\n-    config::{ENTRY_COUNT, PAGE_SIZE},\n+    arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry, NR_ENTRIES_PER_PAGE},\n     sync::SpinLock,\n-    vm::VmFrame,\n+    vm::{VmFrame, PAGE_SIZE},\n };\n \n pub trait PageTableFlagsTrait: Clone + Copy + Sized + Pod + Debug {\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -77,9 +76,9 @@ pub trait PageTableEntryTrait: Clone + Copy + Sized + Pod + Debug {\n \n     /// The index of the next PTE is determined based on the virtual address and the current level, and the level range is [1,5].\n     ///\n-    /// For example, in x86 we use the following expression to get the index (ENTRY_COUNT is 512):\n+    /// For example, in x86 we use the following expression to get the index (NR_ENTRIES_PER_PAGE is 512):\n     /// ```\n-    /// va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+    /// va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     /// ```\n     ///\n     fn page_index(va: Vaddr, level: usize) -> usize;\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -395,7 +394,7 @@ impl<T: PageTableEntryTrait, M> PageTable<T, M> {\n     }\n }\n \n-/// Read `ENTRY_COUNT` of PageTableEntry from an address\n+/// Read `NR_ENTRIES_PER_PAGE` of PageTableEntry from an address\n ///\n /// # Safety\n ///\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -406,7 +405,7 @@ pub unsafe fn table_of<'a, T: PageTableEntryTrait>(pa: Paddr) -> Option<&'a mut\n         return None;\n     }\n     let ptr = super::paddr_to_vaddr(pa) as *mut _;\n-    Some(core::slice::from_raw_parts_mut(ptr, ENTRY_COUNT))\n+    Some(core::slice::from_raw_parts_mut(ptr, NR_ENTRIES_PER_PAGE))\n }\n \n /// translate a virtual address to physical address which cannot use offset to get physical address\ndiff --git a/framework/aster-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\n--- a/framework/aster-frame/src/vm/space.rs\n+++ b/framework/aster-frame/src/vm/space.rs\n@@ -5,7 +5,7 @@ use core::ops::Range;\n use bitflags::bitflags;\n \n use super::{is_page_aligned, MapArea, MemorySet, VmFrameVec, VmIo};\n-use crate::{arch::mm::PageTableFlags, config::PAGE_SIZE, prelude::*, sync::Mutex, Error};\n+use crate::{arch::mm::PageTableFlags, prelude::*, sync::Mutex, vm::PAGE_SIZE, Error};\n \n /// Virtual memory space.\n ///\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -14,9 +14,8 @@ pub(crate) use alloc::{\n pub(crate) use core::{any::Any, ffi::CStr, fmt::Debug};\n \n pub(crate) use aster_frame::{\n-    config::PAGE_SIZE,\n     sync::{Mutex, MutexGuard, RwLock, RwMutex, SpinLock, SpinLockGuard},\n-    vm::Vaddr,\n+    vm::{Vaddr, PAGE_SIZE},\n };\n pub(crate) use bitflags::bitflags;\n pub(crate) use int_to_c_enum::TryFromInt;\ndiff --git a/kernel/aster-nix/src/process/process_vm/mod.rs b/kernel/aster-nix/src/process/process_vm/mod.rs\n--- a/kernel/aster-nix/src/process/process_vm/mod.rs\n+++ b/kernel/aster-nix/src/process/process_vm/mod.rs\n@@ -14,30 +14,40 @@ use user_heap::UserHeap;\n use crate::vm::vmar::Vmar;\n \n /*\n-* The user vm space layout is look like below.\n-* |-----------------------|-------The highest user vm address\n-* |                       |\n-* |       Mmap Areas      |\n-* |                       |\n-* |                       |\n-* --------------------------------The init stack base\n-* |                       |\n-* | User Stack(Init Stack)|\n-* |                       |\n-* |         ||            |\n-* ----------||----------------------The user stack top, grows down\n-* |         \\/            |\n-* |                       |\n-* |     Unmapped Areas    |\n-* |                       |\n-* |         /\\            |\n-* ----------||---------------------The user heap top, grows up\n-* |         ||            |\n-* |                       |\n-* |        User Heap      |\n-* |                       |\n-* ----------------------------------The user heap base\n-*/\n+ * The user's virtual memory space layout looks like below.\n+ * TODO: The layout of the userheap does not match the current implementation,\n+ * And currently the initial program break is a fixed value.\n+ *\n+ *  (high address)\n+ *  +---------------------+ <------+ The top of Vmar, which is the highest address usable\n+ *  |                     |          Randomly padded pages\n+ *  +---------------------+ <------+ The base of the initial user stack\n+ *  | User stack          |\n+ *  |                     |\n+ *  +---------||----------+ <------+ The user stack limit, can be extended lower\n+ *  |         \\/          |\n+ *  | ...                 |\n+ *  |                     |\n+ *  | MMAP Spaces         |\n+ *  |                     |\n+ *  | ...                 |\n+ *  |         /\\          |\n+ *  +---------||----------+ <------+ The current program break\n+ *  | User heap           |\n+ *  |                     |\n+ *  +---------------------+ <------+ The original program break\n+ *  |                     |          Randomly padded pages\n+ *  +---------------------+ <------+ The end of the program's last segment\n+ *  |                     |\n+ *  | Loaded segments     |\n+ *  | .text, .data, .bss  |\n+ *  | , etc.              |\n+ *  |                     |\n+ *  +---------------------+ <------+ The bottom of Vmar at 0x1_0000\n+ *  |                     |          64 KiB unusable space\n+ *  +---------------------+\n+ *  (low address)\n+ */\n \n /// The virtual space usage.\n /// This struct is used to control brk and mmap now.\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -7,7 +7,7 @@\n use core::mem;\n \n use align_ext::AlignExt;\n-use aster_frame::vm::{VmIo, VmPerm};\n+use aster_frame::vm::{VmIo, VmPerm, MAX_USERSPACE_VADDR};\n use aster_rights::{Full, Rights};\n \n use super::{\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -20,15 +20,16 @@ use crate::{\n     vm::{perms::VmPerms, vmar::Vmar, vmo::VmoOptions},\n };\n \n-pub const INIT_STACK_BASE: Vaddr = 0x0000_0000_2000_0000;\n-pub const INIT_STACK_SIZE: usize = 0x1000 * 16; // 64KB\n+pub const INIT_STACK_SIZE: usize = 64 * 1024; // 64 KiB\n \n /*\n- * The initial stack of a process looks like below(This figure is from occlum):\n+ * Illustration of the virtual memory space containing the processes' init stack:\n  *\n- *\n- *  +---------------------+ <------+ Top of stack\n- *  |                     |          (high address)\n+ *  (high address)\n+ *  +---------------------+ <------+ Highest address\n+ *  |                     |          Random stack paddings\n+ *  +---------------------+ <------+ The base of stack (stack grows down)\n+ *  |                     |\n  *  | Null-terminated     |\n  *  | strings referenced  |\n  *  | by variables below  |\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -62,8 +63,10 @@ pub const INIT_STACK_SIZE: usize = 0x1000 * 16; // 64KB\n  *  +---------------------+\n  *  |                     |\n  *  |                     |\n- *  +                     +\n- *\n+ *  +---------------------+\n+ *  |                     |\n+ *  +---------------------+ <------+ User stack default rlimit\n+ *  (low address)\n  */\n pub struct InitStack {\n     /// The high address of init stack\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -93,9 +96,13 @@ impl InitStack {\n         }\n     }\n \n-    /// This function only work for first process\n     pub fn new_default_config(argv: Vec<CString>, envp: Vec<CString>) -> Self {\n-        let init_stack_top = INIT_STACK_BASE - PAGE_SIZE;\n+        let nr_pages_padding = {\n+            let mut random_nr_pages_padding: u8 = 0;\n+            getrandom::getrandom(random_nr_pages_padding.as_bytes_mut()).unwrap();\n+            random_nr_pages_padding as usize\n+        };\n+        let init_stack_top = MAX_USERSPACE_VADDR - PAGE_SIZE * nr_pages_padding;\n         let init_stack_size = INIT_STACK_SIZE;\n         InitStack::new(init_stack_top, init_stack_size, argv, envp)\n     }\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/aster-nix/src/vdso.rs\n--- a/kernel/aster-nix/src/vdso.rs\n+++ b/kernel/aster-nix/src/vdso.rs\n@@ -13,7 +13,10 @@\n \n use alloc::{boxed::Box, sync::Arc};\n \n-use aster_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n+use aster_frame::{\n+    sync::Mutex,\n+    vm::{VmIo, PAGE_SIZE},\n+};\n use aster_rights::Rights;\n use aster_time::Instant;\n use aster_util::coeff::Coeff;\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -11,7 +11,7 @@ pub mod vm_mapping;\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use aster_frame::vm::VmSpace;\n+use aster_frame::vm::{VmSpace, MAX_USERSPACE_VADDR};\n use aster_rights::Rights;\n \n use self::{\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -124,11 +124,8 @@ impl VmarInner {\n     }\n }\n \n-// FIXME: How to set the correct root vmar range?\n-// We should not include addr 0 here(is this right?), since the 0 addr means the null pointer.\n-// We should include addr 0x0040_0000, since non-pie executables typically are put on 0x0040_0000.\n-const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x0010_0000;\n-const ROOT_VMAR_HIGHEST_ADDR: Vaddr = 0x1000_0000_0000;\n+const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n+const ROOT_VMAR_CAP_ADDR: Vaddr = MAX_USERSPACE_VADDR;\n \n impl Interval<usize> for Arc<Vmar_> {\n     fn range(&self) -> Range<usize> {\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -161,7 +158,7 @@ impl Vmar_ {\n \n     pub fn new_root() -> Arc<Self> {\n         let mut free_regions = BTreeMap::new();\n-        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_HIGHEST_ADDR);\n+        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\n         let vmar_inner = VmarInner {\n             is_destroyed: false,\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -169,7 +166,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        Vmar_::new(vmar_inner, VmSpace::new(), 0, ROOT_VMAR_HIGHEST_ADDR, None)\n+        Vmar_::new(vmar_inner, VmSpace::new(), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\n \n     fn is_root_vmar(&self) -> bool {\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -279,7 +276,7 @@ impl Vmar_ {\n         inner.child_vmar_s.clear();\n         inner.vm_mappings.clear();\n         inner.free_regions.clear();\n-        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_HIGHEST_ADDR);\n+        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         inner.free_regions.insert(root_region.start(), root_region);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/aster-nix/src/vm/vmar/options.rs\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/aster-nix/src/vm/vmar/options.rs\n@@ -2,7 +2,7 @@\n \n //! Options for allocating child VMARs.\n \n-use aster_frame::{config::PAGE_SIZE, Error, Result};\n+use aster_frame::{vm::PAGE_SIZE, Error, Result};\n \n use super::Vmar;\n \ndiff --git a/kernel/comps/block/src/lib.rs b/kernel/comps/block/src/lib.rs\n--- a/kernel/comps/block/src/lib.rs\n+++ b/kernel/comps/block/src/lib.rs\n@@ -49,7 +49,7 @@ use self::{\n     prelude::*,\n };\n \n-pub const BLOCK_SIZE: usize = aster_frame::config::PAGE_SIZE;\n+pub const BLOCK_SIZE: usize = aster_frame::vm::PAGE_SIZE;\n pub const SECTOR_SIZE: usize = 512;\n \n pub trait BlockDevice: Send + Sync + Any + Debug {\ndiff --git a/kernel/comps/framebuffer/src/lib.rs b/kernel/comps/framebuffer/src/lib.rs\n--- a/kernel/comps/framebuffer/src/lib.rs\n+++ b/kernel/comps/framebuffer/src/lib.rs\n@@ -13,7 +13,12 @@ use core::{\n     ops::{Index, IndexMut},\n };\n \n-use aster_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n+use aster_frame::{\n+    boot,\n+    io_mem::IoMem,\n+    sync::SpinLock,\n+    vm::{VmIo, PAGE_SIZE},\n+};\n use component::{init_component, ComponentInitError};\n use font8x8::UnicodeFonts;\n use spin::Once;\ndiff --git a/kernel/comps/virtio/src/device/console/device.rs b/kernel/comps/virtio/src/device/console/device.rs\n--- a/kernel/comps/virtio/src/device/console/device.rs\n+++ b/kernel/comps/virtio/src/device/console/device.rs\n@@ -4,7 +4,7 @@ use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\n use core::hint::spin_loop;\n \n use aster_console::{AnyConsoleDevice, ConsoleCallback};\n-use aster_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame, vm::PAGE_SIZE};\n use aster_util::safe_ptr::SafePtr;\n use log::debug;\n \ndiff --git a/kernel/comps/virtio/src/transport/mmio/device.rs b/kernel/comps/virtio/src/transport/mmio/device.rs\n--- a/kernel/comps/virtio/src/transport/mmio/device.rs\n+++ b/kernel/comps/virtio/src/transport/mmio/device.rs\n@@ -8,12 +8,11 @@ use aster_frame::{\n         bus::MmioDevice,\n         device::{MmioCommonDevice, VirtioMmioVersion},\n     },\n-    config::PAGE_SIZE,\n     io_mem::IoMem,\n     offset_of,\n     sync::RwLock,\n     trap::IrqCallbackFunction,\n-    vm::DmaCoherent,\n+    vm::{DmaCoherent, PAGE_SIZE},\n };\n use aster_rights::{ReadOp, WriteOp};\n use aster_util::{field_ptr, safe_ptr::SafePtr};\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/aster-nix/src/vm/vmar/options.rs\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/aster-nix/src/vm/vmar/options.rs\n@@ -142,14 +142,14 @@ mod test {\n     use crate::vm::{\n         page_fault_handler::PageFaultHandler,\n         perms::VmPerms,\n-        vmar::ROOT_VMAR_HIGHEST_ADDR,\n+        vmar::ROOT_VMAR_CAP_ADDR,\n         vmo::{VmoOptions, VmoRightsOp},\n     };\n \n     #[ktest]\n     fn root_vmar() {\n         let vmar = Vmar::<Full>::new_root();\n-        assert!(vmar.size() == ROOT_VMAR_HIGHEST_ADDR);\n+        assert!(vmar.size() == ROOT_VMAR_CAP_ADDR);\n     }\n \n     #[ktest]\n",
        "problem_statement": "[BUG] Uncaught panic happened in heap_allocator\nI run 416.gamess , one of spec CPU 2006 test items,  but a pacnic happened:\r\n\r\n```\r\n~ # ./gamess_base.amd64-m64-gcc41-nn < exam29.config \r\n[ERROR]: Uncaught panic!\r\npanicked at framework/aster-frame/src/vm/heap_allocator.rs:24:5:\r\nHeap allocation error, layout = Layout { size: 659468632, align: 1 (1 << 0) }\r\n```\r\nThis pacnic alse happened when I run 434.zeusmp.\r\nthe file of 434.zeusmp and 416.gamess: [https://github.com/skpupil/my_spec_test](url) \n",
        "hints_text": "We currently have only the ability to manage <4G of memory. And the default QEMU boot option gives a 2G memory. Maybe an allocation of 629MiB caused an OOM.\r\n\r\nRelated to #318 \n```rust\r\n    if segment_vmo_size > tail_padding_offset {\r\n        let buffer = vec![0u8; segment_vmo_size - tail_padding_offset];\r\n        segment_vmo.write_bytes(tail_padding_offset, &buffer)?;\r\n    }\r\n```\r\n\r\nThe troublemaker is found: the memsize of that segment is 629MiB. And we should do lazy zero out init rather than doing such a scary memset operation of vmo.\r\n\r\n```\r\n(gdb) bt\r\n#0  alloc::alloc::handle_alloc_error (layout=...) at src/alloc.rs:389\r\n#1  0xffffffff8904ba9e in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::allocate_in<u8, alloc::alloc::Global> (\r\n    capacity=659468632, init=alloc::raw_vec::AllocInit::Zeroed, alloc=...) at src/raw_vec.rs:204\r\n#2  0xffffffff88ed31e8 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_zeroed_in<u8, alloc::alloc::Global> (capacity=659468632, alloc=...)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:153\r\n#3  0xffffffff88ece3f4 in alloc::vec::spec_from_elem::{impl#3}::from_elem<alloc::alloc::Global> (elem=0, n=659468632, \r\n    alloc=...)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:52\r\n#4  0xffffffff88ed190f in alloc::vec::from_elem<u8> (elem=0, n=659468632)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2627\r\n#5  0xffffffff88b11985 in aster_nix::process::program_loader::elf::load_elf::init_segment_vmo (\r\n    program_header=0xffff80000c8d2d18, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:309\r\n#6  0xffffffff88b103cd in aster_nix::process::program_loader::elf::load_elf::map_segment_vmos (elf=0xffff800003dbd6d8, \r\n    root_vmar=0xffff80000c8df010, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:201\r\n#7  0xffffffff88b0faa0 in aster_nix::process::program_loader::elf::load_elf::init_and_map_vmos (\r\n    process_vm=0xffff80000c8df010, ldso=..., elf=0xffff800003dbd6d8, elf_file=0xffff80000c184810, argv=..., envp=..., \r\n    vdso_text_base=1064960) at src/process/program_loader/elf/load_elf.rs:123\r\n#8  0xffffffff88b0eece in aster_nix::process::program_loader::elf::load_elf::load_elf_to_vm (\r\n    process_vm=0xffff80000c8df010, file_header=..., elf_file=..., fs_resolver=0xffff80000c8cf910, argv=..., envp=..., \r\n    vdso_text_base=1064960) at src/process/program_loader/elf/load_elf.rs:55\r\n#9  0xffffffff88b0e212 in aster_nix::process::program_loader::load_program_to_vm (process_vm=0xffff80000c8df010, \r\n    elf_file=..., argv=..., envp=..., fs_resolver=0xffff80000c8cf910, recursion_limit=1)\r\n    at src/process/program_loader/mod.rs:89\r\n#10 0xffffffff88d11dc3 in aster_nix::syscall::execve::do_execve (elf_file=..., argv_ptr_ptr=268442568, \r\n    envp_ptr_ptr=268442632, context=0xffff800003dc09c0) at src/syscall/execve.rs:119\r\n#11 0xffffffff88d107b7 in aster_nix::syscall::execve::sys_execve (filename_ptr=268442504, argv_ptr_ptr=268442568, \r\n    envp_ptr_ptr=268442632, context=0xffff800003dc09c0) at src/syscall/execve.rs:36\r\n#12 0xffffffff88d0cd6e in aster_nix::syscall::syscall_dispatch (syscall_number=59, args=..., context=0xffff800003dc09c0)\r\n    at src/syscall/mod.rs:462\r\n#13 0xffffffff88d0c4dc in aster_nix::syscall::handle_syscall (context=0xffff800003dc09c0) at src/syscall/mod.rs:397\r\n#14 0xffffffff88d09fee in aster_nix::thread::task::handle_user_event (user_event=aster_frame::user::UserEvent::Syscall, \r\n    context=0xffff800003dc09c0) at src/thread/task.rs:71\r\n#15 0xffffffff88d09a6d in aster_nix::thread::task::create_new_user_task::user_task_entry () at src/thread/task.rs:37\r\n#16 0xffffffff88d3f8ce in core::ops::function::Fn::call<fn(), ()> ()\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n#17 0xffffffff88fc6ad6 in alloc::boxed::{impl#49}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=0xffff80000c8cfe40, args=()) at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2029\r\n#18 0xffffffff88fac554 in aster_frame::task::task::{impl#3}::build::kernel_task_entry () at src/task/task.rs:259\r\n(gdb) f 6\r\n#6  0xffffffff88b103cd in aster_nix::process::program_loader::elf::load_elf::map_segment_vmos (elf=0xffff800003dbd6d8, \r\n    root_vmar=0xffff80000c8df010, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:201\r\n201                 let vmo = init_segment_vmo(program_header, elf_file)?;\r\n(gdb) p *program_header\r\n$3 = xmas_elf::program::ProgramHeader64 {type_: xmas_elf::program::Type_ (1), flags: xmas_elf::program::Flags (6), offset: 8596504, virtual_addr: 8600600, physical_addr: 8600600, file_size: 66192, mem_size: 659531104, align: 4096}\r\n```",
        "created_at": "2024-03-13T06:03:51Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 665,
        "instance_id": "asterinas__asterinas-665",
        "issue_numbers": [
            "657"
        ],
        "base_commit": "132d36bf2082acafa14edf665e98463f681d6363",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -169,7 +173,7 @@ check: $(CARGO_OSDK)\n \t\t(cd $$dir && cargo clippy -- -D warnings) || exit 1; \\\n \tdone\n \t@for dir in $(OSDK_CRATES); do \\\n-\t\t(cd $$dir && cargo osdk clippy) || exit 1; \\\n+\t\t(cd $$dir && cargo osdk clippy -- -- -D warnings) || exit 1; \\\n \tdone\n \n .PHONY: clean\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -309,7 +309,7 @@ impl UserContextApiInternal for UserContext {\n     }\n }\n \n-/// As Osdev Wiki defines(https://wiki.osdev.org/Exceptions):\n+/// As Osdev Wiki defines(<https://wiki.osdev.org/Exceptions>):\n /// CPU exceptions are classified as:\n ///\n /// Faults: These can be corrected and the program may continue as if nothing happened.\ndiff --git a/framework/aster-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\n--- a/framework/aster-frame/src/arch/x86/device/serial.rs\n+++ b/framework/aster-frame/src/arch/x86/device/serial.rs\n@@ -7,7 +7,7 @@ use crate::arch::x86::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess\n /// A serial port.\n ///\n /// Serial ports are a legacy communications port common on IBM-PC compatible computers.\n-/// Ref: https://wiki.osdev.org/Serial_Ports\n+/// Ref: <https://wiki.osdev.org/Serial_Ports>\n pub struct SerialPort {\n     pub data: IoPort<u8, ReadWriteAccess>,\n     pub int_en: IoPort<u8, WriteOnlyAccess>,\ndiff --git a/framework/aster-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\n--- a/framework/aster-frame/src/arch/x86/timer/pit.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/pit.rs\n@@ -4,7 +4,7 @@\n //! a prescaler and 3 independent frequency dividers. Each frequency divider has an output, which is\n //! used to allow the timer to control external circuitry (for example, IRQ 0).\n //!\n-//! Reference: https://wiki.osdev.org/Programmable_Interval_Timer\n+//! Reference: <https://wiki.osdev.org/Programmable_Interval_Timer>\n //!\n \n use crate::{\ndiff --git a/framework/aster-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/aster-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -5,7 +5,7 @@\n //! The format of the Asterinas command line string conforms\n //! to the Linux kernel command line rules:\n //!\n-//! https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html\n+//! <https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html>\n //!\n \n use alloc::{\ndiff --git a/framework/aster-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\n--- a/framework/aster-frame/src/bus/pci/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/mod.rs\n@@ -9,7 +9,7 @@\n //!\n //! Use case:\n //!\n-//! ```rust norun\n+//! ```rust no_run\n //! #[derive(Debug)]\n //! pub struct PciDeviceA {\n //!     common_device: PciCommonDevice,\ndiff --git a/framework/aster-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/aster-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -103,7 +103,7 @@ impl Drop for IrqLine {\n ///\n /// # Example\n ///\n-/// ``rust\n+/// ```rust\n /// use aster_frame::irq;\n ///\n /// {\ndiff --git a/framework/libs/linux-bzimage/builder/src/pe_header.rs b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/framework/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -3,10 +3,10 @@\n //! Big zImage PE/COFF header generation.\n //!\n //! The definition of the PE/COFF header is in the Microsoft PE/COFF specification:\n-//! https://learn.microsoft.com/en-us/windows/win32/debug/pe-format\n+//! <https://learn.microsoft.com/en-us/windows/win32/debug/pe-format>\n //!\n //! The reference to the Linux PE header definition:\n-//! https://github.com/torvalds/linux/blob/master/include/linux/pe.h\n+//! <https://github.com/torvalds/linux/blob/master/include/linux/pe.h>\n \n use std::{mem::size_of, ops::Range};\n \ndiff --git a/kernel/aster-nix/src/console.rs b/kernel/aster-nix/src/console.rs\n--- a/kernel/aster-nix/src/console.rs\n+++ b/kernel/aster-nix/src/console.rs\n@@ -22,7 +22,7 @@ pub fn _print(args: Arguments) {\n     VirtioConsolesPrinter.write_fmt(args).unwrap();\n }\n \n-/// Copy from Rust std: https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs\n+/// Copied from Rust std: <https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs>\n #[macro_export]\n macro_rules! print {\n     ($($arg:tt)*) => {{\ndiff --git a/kernel/aster-nix/src/console.rs b/kernel/aster-nix/src/console.rs\n--- a/kernel/aster-nix/src/console.rs\n+++ b/kernel/aster-nix/src/console.rs\n@@ -30,7 +30,7 @@ macro_rules! print {\n     }};\n }\n \n-/// Copy from Rust std: https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs\n+/// Copied from Rust std: <https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs>\n #[macro_export]\n macro_rules! println {\n     () => {\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -39,7 +39,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n     /// Bind a socket to the iface. So the packet for this socket will be dealt with by the interface.\n     /// If port is None, the iface will pick up an empheral port for the socket.\n     /// FIXME: The reason for binding socket and interface together is because there are limitations inside smoltcp.\n-    /// See discussion at https://github.com/smoltcp-rs/smoltcp/issues/779.\n+    /// See discussion at <https://github.com/smoltcp-rs/smoltcp/issues/779>.\n     fn bind_socket(\n         &self,\n         socket: Box<AnyUnboundSocket>,\ndiff --git a/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs b/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n--- a/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n+++ b/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n /// Shutdown types\n-/// From https://elixir.bootlin.com/linux/v6.0.9/source/include/linux/net.h\n+/// From <https://elixir.bootlin.com/linux/v6.0.9/source/include/linux/net.h>\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq, TryFromInt)]\n #[allow(non_camel_case_types)]\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -2,7 +2,7 @@\n \n //! This module defines the process initial stack.\n //! The process initial stack, contains arguments, environmental variables and auxiliary vectors\n-//! The data layout of init stack can be seen in Figure 3.9 in https://uclibc.org/docs/psABI-x86_64.pdf\n+//! The data layout of init stack can be seen in Figure 3.9 in <https://uclibc.org/docs/psABI-x86_64.pdf>\n \n use core::mem;\n \ndiff --git a/kernel/aster-nix/src/util/net/options/mod.rs b/kernel/aster-nix/src/util/net/options/mod.rs\n--- a/kernel/aster-nix/src/util/net/options/mod.rs\n+++ b/kernel/aster-nix/src/util/net/options/mod.rs\n@@ -24,7 +24,7 @@\n //!\n //! First, the option should be added in the net module for the TCP socket.\n //!  \n-//! ```rust norun\n+//! ```rust no_run\n //! impl_socket_option!(TcpNodelay(bool));\n //! ```\n //!\ndiff --git a/kernel/aster-nix/src/util/net/options/mod.rs b/kernel/aster-nix/src/util/net/options/mod.rs\n--- a/kernel/aster-nix/src/util/net/options/mod.rs\n+++ b/kernel/aster-nix/src/util/net/options/mod.rs\n@@ -32,15 +32,19 @@\n //! in the utils module. These util functions can be shared if multiple options have the value\n //! of same type.\n //!\n-//! ```rust norun\n-//! impl ReadFromUser for bool { // content omitted here }\n-//! impl WriteFromUser for bool { // content omitted here }\n+//! ```rust compile_fail\n+//! impl ReadFromUser for bool {\n+//!     // content omitted here\n+//! }\n+//! impl WriteFromUser for bool {\n+//!     // content omitted here\n+//! }\n //! ```\n //!\n //! At last, we can implement `RawSocketOption` for `TcpNodelay` so that it can be read/from\n //! user space.\n //!\n-//! ```rust norun\n+//! ```rust no_run\n //! impl_raw_socket_option!(TcpNodeley);\n //! ```\n //!\ndiff --git a/kernel/comps/virtio/src/device/input/mod.rs b/kernel/comps/virtio/src/device/input/mod.rs\n--- a/kernel/comps/virtio/src/device/input/mod.rs\n+++ b/kernel/comps/virtio/src/device/input/mod.rs\n@@ -35,7 +35,7 @@ use crate::transport::VirtioTransport;\n \n pub static DEVICE_NAME: &str = \"Virtio-Input\";\n \n-/// Select value used for [`VirtIOInput::query_config_select()`].\n+/// Select value used for [`device::InputDevice::query_config_select()`].\n #[repr(u8)]\n #[derive(Debug, Clone, Copy)]\n pub enum InputConfigSelect {\ndiff --git a/kernel/libs/aster-rights-proc/src/lib.rs b/kernel/libs/aster-rights-proc/src/lib.rs\n--- a/kernel/libs/aster-rights-proc/src/lib.rs\n+++ b/kernel/libs/aster-rights-proc/src/lib.rs\n@@ -4,11 +4,11 @@\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\n //! The require macro are used to ensure that an object has the enough capability to call the function.\n-//! The **require** macro can accept constraint [SomeRightSet] > [SomeRight],\n-//! which means the SomeRightSet should **contain** the SomeRight.\n-//! The **require** macro can also accept constraint [SomeRightSet] > [AnotherRightSet],\n-//! which means the SomeRightSet should **include** the AnotherRightSet. In this case, AnotherRightSet should be a **generic parameter**.\n-//! i.e., AnotherRightSet should occur the the generic param list of the function.\n+//! The **require** macro can accept constraint `SomeRightSet` > `SomeRight`,\n+//! which means the `SomeRightSet` should **contain** the `SomeRight`.\n+//! The **require** macro can also accept constraint `SomeRightSet` > `AnotherRightSet`,\n+//! which means the `SomeRightSet` should **include** the `AnotherRightSet`. In this case, `AnotherRightSet` should be a **generic parameter**.\n+//! i.e., `AnotherRightSet` should occur the the generic param list of the function.\n //!\n //! If there are multiple constraits, they can be seperated with `|`, which means all constraits should be satisfied.\n //!\ndiff --git a/kernel/libs/aster-rights/src/lib.rs b/kernel/libs/aster-rights/src/lib.rs\n--- a/kernel/libs/aster-rights/src/lib.rs\n+++ b/kernel/libs/aster-rights/src/lib.rs\n@@ -55,7 +55,7 @@ pub type WriteOp = TRights![Write];\n pub type FullOp = TRights![Read, Write, Dup];\n \n /// Wrapper for TRights, used to bypass an error message from the Rust compiler,\n-/// the relevant issue is: https://github.com/rust-lang/rfcs/issues/2758\n+/// the relevant issue is: <https://github.com/rust-lang/rfcs/issues/2758>\n ///\n /// Example:\n ///\ndiff --git a/osdk/src/commands/check.rs /dev/null\n--- a/osdk/src/commands/check.rs\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use std::process;\n-\n-use super::util::{cargo, COMMON_CARGO_ARGS};\n-use crate::{error::Errno, error_msg};\n-\n-pub fn execute_check_command() {\n-    let mut command = cargo();\n-    command\n-        .arg(\"check\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\");\n-    command.args(COMMON_CARGO_ARGS);\n-    let status = command.status().unwrap();\n-    if !status.success() {\n-        error_msg!(\"Check failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-}\ndiff --git a/osdk/src/commands/clippy.rs /dev/null\n--- a/osdk/src/commands/clippy.rs\n+++ /dev/null\n@@ -1,38 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use std::process;\n-\n-use super::util::{cargo, COMMON_CARGO_ARGS};\n-use crate::{error::Errno, error_msg};\n-\n-pub fn execute_clippy_command() {\n-    let mut command = cargo();\n-    command\n-        .arg(\"clippy\")\n-        .arg(\"-h\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\")\n-        .args(COMMON_CARGO_ARGS);\n-    info!(\"Running `cargo clippy -h`\");\n-    let output = command.output().unwrap();\n-    if !output.status.success() {\n-        let stderr = String::from_utf8_lossy(&output.stderr);\n-        eprintln!(\"{}\", &stderr);\n-        error_msg!(\"Cargo clippy failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-\n-    let mut command = cargo();\n-    command\n-        .arg(\"clippy\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\")\n-        .args(COMMON_CARGO_ARGS);\n-    // TODO: Add support for custom clippy args using OSDK commandline rather than hardcode it.\n-    command.args([\"--\", \"-D\", \"warnings\"]);\n-    let status = command.status().unwrap();\n-    if !status.success() {\n-        error_msg!(\"Cargo clippy failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-}\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -144,10 +144,14 @@ ktest: initramfs $(CARGO_OSDK)\n \t\t(cd $$dir && cargo osdk test) || exit 1; \\\n \tdone\n \n-.PHONY: docs\n-docs:\n-\t@cargo doc \t\t\t\t\t\t# Build Rust docs\n-\t@echo \"\" \t\t\t\t\t\t# Add a blank line\n+docs: $(CARGO_OSDK)\n+\t@for dir in $(NON_OSDK_CRATES); do \\\n+\t\t(cd $$dir && cargo doc --no-deps) || exit 1; \\\n+\tdone\n+\t@for dir in $(OSDK_CRATES); do \\\n+\t\t(cd $$dir && cargo osdk doc --no-deps) || exit 1; \\\n+\tdone\n+\t@echo \"\" \t\t\t\t\t\t\t\t# Add a blank line\n \t@cd docs && mdbook build \t\t\t\t# Build mdBook\n \n .PHONY: format\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -6,8 +6,8 @@ use clap::{crate_version, Args, Parser};\n \n use crate::{\n     commands::{\n-        execute_build_command, execute_check_command, execute_clippy_command, execute_new_command,\n-        execute_run_command, execute_test_command,\n+        execute_build_command, execute_forwarded_command, execute_new_command, execute_run_command,\n+        execute_test_command,\n     },\n     config_manager::{\n         boot::{BootLoader, BootProtocol},\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -37,8 +37,9 @@ pub fn main() {\n             let test_config = TestConfig::parse(test_args);\n             execute_test_command(&test_config);\n         }\n-        OsdkSubcommand::Check => execute_check_command(),\n-        OsdkSubcommand::Clippy => execute_clippy_command(),\n+        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args),\n+        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args),\n+        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args),\n     }\n }\n \ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -68,10 +69,22 @@ pub enum OsdkSubcommand {\n     Run(RunArgs),\n     #[command(about = \"Execute kernel mode unit test by starting a VMM\")]\n     Test(TestArgs),\n-    #[command(about = \"Analyze the current package and report errors\")]\n-    Check,\n-    #[command(about = \"Check the current package and catch common mistakes\")]\n-    Clippy,\n+    #[command(about = \"Check a local package and all of its dependencies for errors\")]\n+    Check(ForwardedArguments),\n+    #[command(about = \"Checks a package to catch common mistakes and improve your Rust code\")]\n+    Clippy(ForwardedArguments),\n+    #[command(about = \"Build a package's documentation\")]\n+    Doc(ForwardedArguments),\n+}\n+\n+#[derive(Debug, Parser)]\n+pub struct ForwardedArguments {\n+    #[arg(\n+        help = \"The full set of Cargo arguments\",\n+        trailing_var_arg = true,\n+        allow_hyphen_values = true\n+    )]\n+    pub args: Vec<String>,\n }\n \n #[derive(Debug, Parser)]\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -3,14 +3,25 @@\n //! This module contains subcommands of cargo-osdk.\n \n mod build;\n-mod check;\n-mod clippy;\n mod new;\n mod run;\n mod test;\n mod util;\n \n pub use self::{\n-    build::execute_build_command, check::execute_check_command, clippy::execute_clippy_command,\n-    new::execute_new_command, run::execute_run_command, test::execute_test_command,\n+    build::execute_build_command, new::execute_new_command, run::execute_run_command,\n+    test::execute_test_command,\n };\n+\n+/// Execute the forwarded cargo command with args containing the subcommand and its arguments.\n+pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n+    let mut cargo = util::cargo();\n+    cargo\n+        .arg(subcommand)\n+        .args(util::COMMON_CARGO_ARGS)\n+        .arg(\"--target\")\n+        .arg(\"x86_64-unknown-none\")\n+        .args(args);\n+    let status = cargo.status().expect(\"Failed to execute cargo\");\n+    std::process::exit(status.code().unwrap_or(1));\n+}\n",
        "problem_statement": "[BUG] `cargo doc` reports error and fails\n# Problem\r\n`cargo doc` is used in `make docs` to generate API documentations. However, the command will fail currently. The problem seems to exist for a long time.\r\n\r\nBefore introducing OSDK, the `inventory` crate will report error. Since this crate is forked under Asterinas, we shoube be able to fix the error. \r\n\r\n![iwEcAqNwbmcDAQTRCfIF0QJ2BrCwmeF5_LlFWwXOjUHN7ecAB9MAAAAAuoBoxQgACaJpbQoAC9IABSn4 png_720x720q90](https://github.com/asterinas/asterinas/assets/27764680/f2ccc7b8-a924-402b-b67b-76c3b5a5496f)\r\n\r\nAfter indroducing OSDK, new problem occurs. The `linux-bzimage-setup` panics when running `cargo doc`. \r\n\r\n<img width=\"1458\" alt=\"\u622a\u5c4f2024-02-29 15 30 54\" src=\"https://github.com/asterinas/asterinas/assets/27764680/97c6f89c-419d-46d6-9045-ea515fe80b3c\">\r\n\r\nIf running `cargo doc --target x86_64-unknown-none` to avoid panic in `linux-bzimage-setup` , more error occurs.\r\n\r\n# Possible solution\r\n\r\n1. Fix the error in `inventory`\r\n2. Make `linux-bzimage-setup` can also build under other target, like `x86_64-unknown-linux-gnu`, but should we allow this behavior? \n",
        "hints_text": "This will work.\r\n\r\n```bash\r\ncargo doc --target x86_64-unknown-none -Zbuild-std=core,alloc,compiler_builtins -Zbuild-std-features=compiler-builtins-mem\r\n```",
        "created_at": "2024-03-06T09:10:55Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1256,
        "instance_id": "asterinas__asterinas-1256",
        "issue_numbers": [
            "1237"
        ],
        "base_commit": "539984bbed414969b0c40cf181a10e9341ed2359",
        "patch": "diff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.8.0\"\n+version = \"0.8.1\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\ndiff --git a/osdk/src/config/eval.rs /dev/null\n--- a/osdk/src/config/eval.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The module implementing the evaluation feature.\n-\n-use std::{io, path::Path, process};\n-\n-/// This function is used to evaluate the string using the host's shell recursively\n-/// in order.\n-pub fn eval(cwd: impl AsRef<Path>, s: &String) -> io::Result<String> {\n-    let mut eval = process::Command::new(\"bash\");\n-    eval.arg(\"-c\");\n-    eval.arg(format!(\"echo \\\"{}\\\"\", s));\n-    eval.current_dir(cwd.as_ref());\n-    let output = eval.output()?;\n-    if !output.stderr.is_empty() {\n-        println!(\n-            \"[Info] {}\",\n-            String::from_utf8_lossy(&output.stderr).trim_end_matches('\\n')\n-        );\n-    }\n-    Ok(String::from_utf8_lossy(&output.stdout)\n-        .trim_end_matches('\\n')\n-        .to_string())\n-}\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -12,7 +12,7 @@ use serde::{de, Deserialize, Deserializer, Serialize};\n \n use super::scheme::Scheme;\n \n-use crate::{config::scheme::QemuScheme, error::Errno, error_msg, util::get_cargo_metadata};\n+use crate::{error::Errno, error_msg, util::get_cargo_metadata};\n \n #[derive(Debug, Clone, Serialize, Deserialize)]\n pub struct OsdkMeta {\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -25,6 +27,8 @@ use crate::{\n     arch::{get_default_arch, Arch},\n     cli::CommonArgs,\n     config::unix_args::apply_kv_array,\n+    error::Errno,\n+    error_msg,\n };\n \n /// The global configuration for the OSDK actions.\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -61,7 +69,11 @@ fn apply_args_before_finalize(action_scheme: &mut ActionScheme, args: &CommonArg\n             }\n         }\n         if let Some(initramfs) = &args.initramfs {\n-            boot.initramfs = Some(initramfs.clone());\n+            let Ok(initramfs) = initramfs.canonicalize() else {\n+                error_msg!(\"The initramfs path provided with argument `--initramfs` does not match any files.\");\n+                process::exit(Errno::GetMetadata as _);\n+            };\n+            boot.initramfs = Some(initramfs);\n         }\n         if let Some(boot_method) = args.boot_method {\n             boot.method = Some(boot_method);\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -73,12 +85,90 @@ fn apply_args_before_finalize(action_scheme: &mut ActionScheme, args: &CommonArg\n     }\n     if let Some(ref mut qemu) = action_scheme.qemu {\n         if let Some(path) = &args.qemu_exe {\n-            qemu.path = Some(path.clone());\n+            let Ok(qemu_path) = path.canonicalize() else {\n+                error_msg!(\n+                    \"The QEMU path provided with argument `--qemu-exe` does not match any files.\"\n+                );\n+                process::exit(Errno::GetMetadata as _);\n+            };\n+            qemu.path = Some(qemu_path);\n         }\n         if let Some(bootdev_options) = &args.bootdev_append_options {\n             qemu.bootdev_append_options = Some(bootdev_options.clone());\n         }\n     }\n+\n+    canonicalize_and_eval(action_scheme, workdir);\n+}\n+\n+fn canonicalize_and_eval(action_scheme: &mut ActionScheme, workdir: &PathBuf) {\n+    let canonicalize = |target: &mut PathBuf| {\n+        let last_cwd = std::env::current_dir().unwrap();\n+        std::env::set_current_dir(workdir).unwrap();\n+\n+        *target = target.canonicalize().unwrap_or_else(|err| {\n+            error_msg!(\n+                \"Cannot canonicalize path `{}`: {}\",\n+                target.to_string_lossy(),\n+                err,\n+            );\n+            std::env::set_current_dir(&last_cwd).unwrap();\n+            process::exit(Errno::GetMetadata as _);\n+        });\n+        std::env::set_current_dir(last_cwd).unwrap();\n+    };\n+\n+    if let Some(ref mut boot) = action_scheme.boot {\n+        if let Some(ref mut initramfs) = boot.initramfs {\n+            canonicalize(initramfs);\n+        }\n+\n+        if let Some(ref mut qemu) = action_scheme.qemu {\n+            if let Some(ref mut qemu_path) = qemu.path {\n+                canonicalize(qemu_path);\n+            }\n+        }\n+\n+        if let Some(ref mut grub) = action_scheme.grub {\n+            if let Some(ref mut grub_mkrescue_path) = grub.grub_mkrescue {\n+                canonicalize(grub_mkrescue_path);\n+            }\n+        }\n+    }\n+\n+    // Do evaluations on the need to be evaluated string field, namely,\n+    // QEMU arguments.\n+\n+    if let Some(ref mut qemu) = action_scheme.qemu {\n+        if let Some(ref mut args) = qemu.args {\n+            *args = match eval(workdir, args) {\n+                Ok(v) => v,\n+                Err(e) => {\n+                    error_msg!(\"Failed to evaluate qemu args: {:#?}\", e);\n+                    process::exit(Errno::ParseMetadata as _);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// This function is used to evaluate the string using the host's shell recursively\n+/// in order.\n+pub fn eval(cwd: impl AsRef<Path>, s: &String) -> io::Result<String> {\n+    let mut eval = process::Command::new(\"bash\");\n+    eval.arg(\"-c\");\n+    eval.arg(format!(\"echo \\\"{}\\\"\", s));\n+    eval.current_dir(cwd.as_ref());\n+    let output = eval.output()?;\n+    if !output.stderr.is_empty() {\n+        println!(\n+            \"[Info] {}\",\n+            String::from_utf8_lossy(&output.stderr).trim_end_matches('\\n')\n+        );\n+    }\n+    Ok(String::from_utf8_lossy(&output.stdout)\n+        .trim_end_matches('\\n')\n+        .to_string())\n }\n \n fn apply_args_after_finalize(action: &mut Action, args: &CommonArgs) {\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -111,7 +201,7 @@ impl Config {\n         let run = {\n             let mut run = scheme.run.clone().unwrap_or_default();\n             run.inherit(&default_scheme);\n-            apply_args_before_finalize(&mut run, common_args);\n+            apply_args_before_finalize(&mut run, common_args, scheme.work_dir.as_ref().unwrap());\n             let mut run = run.finalize(target_arch);\n             apply_args_after_finalize(&mut run, common_args);\n             check_compatibility(run.grub.boot_protocol, run.build.encoding.clone());\n",
        "test_patch": "diff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -128,82 +128,7 @@ fn deserialize_toml_manifest(path: impl AsRef<Path>) -> Option<TomlManifest> {\n     for scheme in manifest.map.values_mut() {\n         scheme.work_dir = Some(cwd.to_path_buf());\n     }\n-    // Canonicalize all the path fields\n-    let canonicalize = |target: &mut PathBuf| {\n-        let last_cwd = std::env::current_dir().unwrap();\n-        std::env::set_current_dir(cwd).unwrap();\n-        *target = target.canonicalize().unwrap_or_else(|err| {\n-            error_msg!(\n-                \"Cannot canonicalize path `{}`: {}\",\n-                target.to_string_lossy(),\n-                err,\n-            );\n-            std::env::set_current_dir(&last_cwd).unwrap();\n-            process::exit(Errno::GetMetadata as _);\n-        });\n-        std::env::set_current_dir(last_cwd).unwrap();\n-    };\n-    let canonicalize_scheme = |scheme: &mut Scheme| {\n-        macro_rules! canonicalize_paths_in_scheme {\n-            ($scheme:expr) => {\n-                if let Some(ref mut boot) = $scheme.boot {\n-                    if let Some(ref mut initramfs) = boot.initramfs {\n-                        canonicalize(initramfs);\n-                    }\n-                }\n-                if let Some(ref mut qemu) = $scheme.qemu {\n-                    if let Some(ref mut qemu_path) = qemu.path {\n-                        canonicalize(qemu_path);\n-                    }\n-                }\n-                if let Some(ref mut grub) = $scheme.grub {\n-                    if let Some(ref mut grub_mkrescue_path) = grub.grub_mkrescue {\n-                        canonicalize(grub_mkrescue_path);\n-                    }\n-                }\n-            };\n-        }\n-        canonicalize_paths_in_scheme!(scheme);\n-        if let Some(ref mut run) = scheme.run {\n-            canonicalize_paths_in_scheme!(run);\n-        }\n-        if let Some(ref mut test) = scheme.test {\n-            canonicalize_paths_in_scheme!(test);\n-        }\n-    };\n-    canonicalize_scheme(&mut manifest.default_scheme);\n-    for scheme in manifest.map.values_mut() {\n-        canonicalize_scheme(scheme);\n-    }\n-    // Do evaluations on the need to be evaluated string field, namely,\n-    // QEMU arguments.\n-    use super::eval::eval;\n-    let eval_scheme = |scheme: &mut Scheme| {\n-        let eval_qemu = |qemu: &mut Option<QemuScheme>| {\n-            if let Some(ref mut qemu) = qemu {\n-                if let Some(ref mut args) = qemu.args {\n-                    *args = match eval(cwd, args) {\n-                        Ok(v) => v,\n-                        Err(e) => {\n-                            error_msg!(\"Failed to evaluate qemu args: {:#?}\", e);\n-                            process::exit(Errno::ParseMetadata as _);\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-        eval_qemu(&mut scheme.qemu);\n-        if let Some(ref mut run) = scheme.run {\n-            eval_qemu(&mut run.qemu);\n-        }\n-        if let Some(ref mut test) = scheme.test {\n-            eval_qemu(&mut test.qemu);\n-        }\n-    };\n-    eval_scheme(&mut manifest.default_scheme);\n-    for scheme in manifest.map.values_mut() {\n-        eval_scheme(scheme);\n-    }\n+\n     Some(manifest)\n }\n \ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -5,8 +5,6 @@\n //! arguments if the arguments is missing, e.g., the path of QEMU. The final configuration is stored in `BuildConfig`,\n //! `RunConfig` and `TestConfig`. These `*Config` are used for `build`, `run` and `test` subcommand.\n \n-mod eval;\n-\n pub mod manifest;\n pub mod scheme;\n pub mod unix_args;\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -14,7 +12,11 @@ pub mod unix_args;\n #[cfg(test)]\n mod test;\n \n-use std::{env, path::PathBuf};\n+use std::{\n+    env, io,\n+    path::{Path, PathBuf},\n+    process,\n+};\n \n use linux_bzimage_builder::PayloadEncoding;\n use scheme::{\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -37,7 +41,11 @@ pub struct Config {\n     pub test: Action,\n }\n \n-fn apply_args_before_finalize(action_scheme: &mut ActionScheme, args: &CommonArgs) {\n+fn apply_args_before_finalize(\n+    action_scheme: &mut ActionScheme,\n+    args: &CommonArgs,\n+    workdir: &PathBuf,\n+) {\n     if action_scheme.grub.is_none() {\n         action_scheme.grub = Some(GrubScheme::default());\n     }\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -120,7 +210,7 @@ impl Config {\n         let test = {\n             let mut test = scheme.test.clone().unwrap_or_default();\n             test.inherit(&default_scheme);\n-            apply_args_before_finalize(&mut test, common_args);\n+            apply_args_before_finalize(&mut test, common_args, scheme.work_dir.as_ref().unwrap());\n             let mut test = test.finalize(target_arch);\n             apply_args_after_finalize(&mut test, common_args);\n             check_compatibility(test.grub.boot_protocol, test.build.encoding.clone());\n",
        "problem_statement": "OSDK should not check the options that have been overridden\n### Describe the bug\r\n\r\nOSDK will (but should not) keep checking the existence of the file, despite that option is overridden .\r\n\r\n### To Reproduce\r\n\r\n1. Create a `OSDK.toml` whose `initramfs` points to a non-exist file.\r\n   ``` toml\r\n   [boot]\r\n   initramfs = \"non/exist/directory/initramfs.cpio.gz\"\r\n   ```\r\n2. Run OSDK with command line `initramfs` option, e.g. `cargo osdk build --initramfs=\"test/build/initramfs.cpio.gz\"`, where `initramfs.cpio.gz` does exist.\r\n3. OSDK will report that `non/exist/directory/initramfs.cpio.gz` does not exist, despite it's overridden by command-line `--initramfs`.\r\n   ```\r\n   $ cargo osdk build --initramfs=\"test/build/initramfs.cpio.gz\"\r\n   [Error]: Cannot canonicalize path `non/exist/directory/initramfs.cpio.gz`: No such file or directory (os error 2)\r\n   ```\r\n\r\n### Expected behavior\r\n\r\nIt should work, and don't need to check `non/exist/directory/initramfs.cpio.gz`.\r\n\r\n### Screenshots\r\n\r\n<img width=\"1192\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c80d5a9c-1cf0-4647-aefc-735c469667d4\">\r\n\r\nwhere `result/initrd.gz` exists while `test/build/initramfs.cpio.gz` does not.\n",
        "hints_text": "",
        "created_at": "2024-08-28T11:24:08Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1215,
        "instance_id": "asterinas__asterinas-1215",
        "issue_numbers": [
            "1197"
        ],
        "base_commit": "562e64437584279783f244edba10b512beddc81d",
        "patch": "diff --git a/kernel/aster-nix/src/syscall/waitid.rs b/kernel/aster-nix/src/syscall/waitid.rs\n--- a/kernel/aster-nix/src/syscall/waitid.rs\n+++ b/kernel/aster-nix/src/syscall/waitid.rs\n@@ -15,8 +15,9 @@ pub fn sys_waitid(\n     _ctx: &Context,\n ) -> Result<SyscallReturn> {\n     // FIXME: what does infoq and rusage use for?\n-    let process_filter = ProcessFilter::from_which_and_id(which, upid);\n-    let wait_options = WaitOptions::from_bits(options as u32).expect(\"Unknown wait options\");\n+    let process_filter = ProcessFilter::from_which_and_id(which, upid)?;\n+    let wait_options = WaitOptions::from_bits(options as u32)\n+        .ok_or(Error::with_message(Errno::EINVAL, \"invalid options\"))?;\n     let waited_process = wait_child_exit(process_filter, wait_options)?;\n     let pid = waited_process.map_or(0, |process| process.pid());\n     Ok(SyscallReturn::Return(pid as _))\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/process/process_filter.rs b/kernel/aster-nix/src/process/process_filter.rs\n--- a/kernel/aster-nix/src/process/process_filter.rs\n+++ b/kernel/aster-nix/src/process/process_filter.rs\n@@ -14,14 +14,15 @@ pub enum ProcessFilter {\n \n impl ProcessFilter {\n     // used for waitid\n-    pub fn from_which_and_id(which: u64, id: u64) -> Self {\n+    pub fn from_which_and_id(which: u64, id: u64) -> Result<Self> {\n         // Does not support PID_FD now(which = 3)\n         // https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/wait.h#L20\n         match which {\n-            0 => ProcessFilter::Any,\n-            1 => ProcessFilter::WithPid(id as Pid),\n-            2 => ProcessFilter::WithPgid(id as Pgid),\n-            _ => panic!(\"Unknown id type\"),\n+            0 => Ok(ProcessFilter::Any),\n+            1 => Ok(ProcessFilter::WithPid(id as Pid)),\n+            2 => Ok(ProcessFilter::WithPgid(id as Pgid)),\n+            3 => todo!(),\n+            _ => return_errno_with_message!(Errno::EINVAL, \"invalid which\"),\n         }\n     }\n \n",
        "problem_statement": "Reachable unwrap panic in `ProcessFilter::from_which_and_id()`\n### Describe the bug\r\nThere is a reachable unwrap panic in `ProcessFilter::from_which_and_id()` at kernel/aster-nix/src/process/process_filter.rs:24 when make a `waitid` syscall.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/ce2af1eb057077753a7a757edc1833e677a83918/kernel/aster-nix/src/process/process_filter.rs#L17-L26\r\n\r\n\r\n### To Reproduce\r\n1. Compile a program which calls `waitid`:\r\n```C\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\nint main() {\r\n  waitid(0x31142aad0bc93209, 15, 0x1, -10);\r\n\r\n  return 0;\r\n}\r\n\r\n```\r\n2. Run the compiled program in Asterinas.\r\n\r\n### Expected behavior\r\nAsterinas reports panic and is terminated.\r\n\r\n### Environment\r\n- Official docker asterinas/asterinas:0.6.2\r\n- 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\r\n- Asterinas version: main ce2af1eb\r\n\r\n### Logs\r\n```\r\n~ # /root/waitpid.c\r\npanicked at /root/asterinas/kernel/aster-nix/src/process/process_filter.rs:24:18:\r\nUnknown id type\r\nPrinting stack trace:\r\n   1: fn 0xffffffff8876b840 - pc 0xffffffff8876b858 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a370;\r\n\r\n   2: fn 0xffffffff8876b620 - pc 0xffffffff8876b798 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a380;\r\n\r\n   3: fn 0xffffffff88049000 - pc 0xffffffff8804900a / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a500;\r\n\r\n   4: fn 0xffffffff8897ee20 - pc 0xffffffff8897eea2 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a510;\r\n\r\n   5: fn 0xffffffff88163050 - pc 0xffffffff881630b0 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a5a0;\r\n\r\n   6: fn 0xffffffff8822cc20 - pc 0xffffffff8822cc8d / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a610;\r\n\r\n   7: fn 0xffffffff88292390 - pc 0xffffffff882bebda / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a730;\r\n\r\n   8: fn 0xffffffff88291f70 - pc 0xffffffff88291ffe / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff8000012403d0;\r\n\r\n   9: fn 0xffffffff8836de80 - pc 0xffffffff8836e9ff / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240570;\r\n\r\n  10: fn 0xffffffff885a49f0 - pc 0xffffffff885a49fe / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240f90;\r\n\r\n  11: fn 0xffffffff88781b90 - pc 0xffffffff88781ba6 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240fb0;\r\n\r\n  12: fn 0xffffffff887b9740 - pc 0xffffffff887b97a9 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240fd0;\r\n\r\n  13: fn                0x0 - pc                0x0 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001241000;\r\n\r\n[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\r\n(  1) /root/asterinas/ostd/src/panicking.rs:107\r\n(  2) /root/asterinas/ostd/src/panicking.rs:59\r\n(  3) 2aghao2n2kcoquuybdyjuveav:?\r\n(  4) ??:?\r\n(  5) /root/asterinas/kernel/aster-nix/src/process/process_filter.rs:21\r\n(  6) /root/asterinas/kernel/aster-nix/src/syscall/waitid.rs:18\r\n(  7) /root/asterinas/kernel/aster-nix/src/syscall/mod.rs:195\r\n(  8) /root/asterinas/kernel/aster-nix/src/syscall/mod.rs:325\r\n(  9) /root/asterinas/kernel/aster-nix/src/thread/task.rs:69\r\n( 10) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n( 11) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2077\r\n( 12) /root/asterinas/ostd/src/task/task/mod.rs:310\r\nmake: *** [Makefile:153: run] Error 1\r\n```\n",
        "hints_text": "",
        "created_at": "2024-08-21T12:44:17Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1159,
        "instance_id": "asterinas__asterinas-1159",
        "issue_numbers": [
            "975"
        ],
        "base_commit": "c2a83427520f8263a8eb2c36edacdba261ad5cae",
        "patch": "diff --git a/.github/workflows/benchmark_asterinas.yml b/.github/workflows/benchmark_asterinas.yml\n--- a/.github/workflows/benchmark_asterinas.yml\n+++ b/.github/workflows/benchmark_asterinas.yml\n@@ -57,7 +57,7 @@ jobs:\n       fail-fast: false\n     timeout-minutes: 60\n     container: \n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\ndiff --git a/.github/workflows/push_git_tag.yml b/.github/workflows/push_git_tag.yml\n--- a/.github/workflows/push_git_tag.yml\n+++ b/.github/workflows/push_git_tag.yml\n@@ -17,4 +17,4 @@ jobs:\n         uses: pxpm/github-tag-action@1.0.1\n         with:\n           repo-token: ${{ secrets.GITHUB_TOKEN }}\n-          tag: v0.7.0\n+          tag: v0.8.0\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -153,6 +153,7 @@ dependencies = [\n  \"ascii\",\n  \"aster-block\",\n  \"aster-console\",\n+ \"aster-framebuffer\",\n  \"aster-input\",\n  \"aster-network\",\n  \"aster-rights\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -166,6 +167,7 @@ dependencies = [\n  \"bytemuck\",\n  \"bytemuck_derive\",\n  \"cfg-if\",\n+ \"component\",\n  \"controlled\",\n  \"core2\",\n  \"cpio-decoder\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -262,19 +264,6 @@ dependencies = [\n  \"typeflags-util\",\n ]\n \n-[[package]]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n-dependencies = [\n- \"aster-framebuffer\",\n- \"aster-nix\",\n- \"aster-time\",\n- \"component\",\n- \"id-alloc\",\n- \"ostd\",\n- \"x86_64 0.14.11\",\n-]\n-\n [[package]]\n name = \"atomic\"\n version = \"0.6.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1129,6 +1124,12 @@ version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n+[[package]]\n+name = \"owo-colors\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f\"\n+\n [[package]]\n name = \"paste\"\n version = \"1.0.14\"\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -8,8 +8,7 @@ console = { name = \"aster-console\" }\n time = { name = \"aster-time\" }\n framebuffer = { name = \"aster-framebuffer\" }\n network = { name = \"aster-network\" }\n-main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.nix.run_first_process]\n+[whitelist.nix.main]\n main = true\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -130,7 +130,10 @@ all: build\n # To uninstall, do `cargo uninstall cargo-osdk`\n .PHONY: install_osdk\n install_osdk:\n-\t@cargo install cargo-osdk --path osdk\n+\t@# The `OSDK_LOCAL_DEV` environment variable is used for local development\n+\t@# without the need to publish the changes of OSDK's self-hosted\n+\t@# dependencies to `crates.io`.\n+\t@OSDK_LOCAL_DEV=1 cargo install cargo-osdk --path osdk\n \n # This will install OSDK if it is not already installed\n # To update OSDK, we need to run `install_osdk` manually\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -52,7 +52,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/README_CN.md b/README_CN.md\n--- a/README_CN.md\n+++ b/README_CN.md\n@@ -49,7 +49,7 @@ git clone https://github.com/asterinas/asterinas\n 2. \u8fd0\u884c\u4e00\u4e2a\u4f5c\u4e3a\u5f00\u53d1\u73af\u5883\u7684Docker\u5bb9\u5668\u3002\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. \u5728\u5bb9\u5668\u5185\uff0c\u8fdb\u5165\u9879\u76ee\u6587\u4ef6\u5939\u6784\u5efa\u5e76\u8fd0\u884c\u661f\u7efd\u3002\ndiff --git a/VERSION b/VERSION\n--- a/VERSION\n+++ b/VERSION\n@@ -1,1 +1,1 @@\n-0.7.0\n\\ No newline at end of file\n+0.8.0\n\\ No newline at end of file\ndiff --git a/docs/src/kernel/README.md b/docs/src/kernel/README.md\n--- a/docs/src/kernel/README.md\n+++ b/docs/src/kernel/README.md\n@@ -44,7 +44,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/docs/src/kernel/intel_tdx.md b/docs/src/kernel/intel_tdx.md\n--- a/docs/src/kernel/intel_tdx.md\n+++ b/docs/src/kernel/intel_tdx.md\n@@ -66,7 +66,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0-tdx\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0-tdx\n ```\n \n 3. Inside the container,\ndiff --git a/docs/src/osdk/reference/manifest.md b/docs/src/osdk/reference/manifest.md\n--- a/docs/src/osdk/reference/manifest.md\n+++ b/docs/src/osdk/reference/manifest.md\n@@ -15,10 +15,10 @@ one is of the workspace\n (in the same directory as the workspace's `Cargo.toml`)\n and one of the crate\n (in the same directory as the crate's `Cargo.toml`).\n-OSDK will first refer to the crate-level manifest, then\n-query the workspace-level manifest for undefined fields.\n-In other words, missing fields of the crate manifest\n-will inherit values from the workspace manifest.\n+OSDK will firstly try to find the crate-level manifest.\n+If the crate-level manifest is found, OSDK uses it only.\n+If the manifest is not found, OSDK will look into the\n+workspace-level manifest.\n \n ## Configurations\n \ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -1,18 +1,82 @@\n [package]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n+name = \"aster-nix\"\n+version = \"0.1.0\"\n edition = \"2021\"\n \n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n [dependencies]\n-id-alloc = { path = \"../ostd/libs/id-alloc\" }\n-ostd = { path = \"../ostd\" }\n-aster-nix = { path = \"aster-nix\" }\n+align_ext = { path = \"../ostd/libs/align_ext\" }\n+aster-input = { path = \"comps/input\" }\n+aster-block = { path = \"comps/block\" }\n+aster-network = { path = \"comps/network\" }\n+aster-console = { path = \"comps/console\" }\n+aster-framebuffer = { path = \"comps/framebuffer\" }\n+aster-time = { path = \"comps/time\" }\n+aster-virtio = { path = \"comps/virtio\" }\n+aster-rights = { path = \"libs/aster-rights\" }\n component = { path = \"libs/comp-sys/component\" }\n+controlled = { path = \"libs/comp-sys/controlled\" }\n+ostd = { path = \"../ostd\" }\n+typeflags = { path = \"libs/typeflags\" }\n+typeflags-util = { path = \"libs/typeflags-util\" }\n+aster-rights-proc = { path = \"libs/aster-rights-proc\" }\n+aster-util = { path = \"libs/aster-util\" }\n+id-alloc = { path = \"../ostd/libs/id-alloc\" }\n+int-to-c-enum = { path = \"libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"libs/cpio-decoder\" }\n+ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n+intrusive-collections = \"0.9.5\"\n+paste = \"1.0\"\n+time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n+smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n+    \"alloc\",\n+    \"log\",\n+    \"medium-ethernet\",\n+    \"medium-ip\",\n+    \"proto-dhcpv4\",\n+    \"proto-ipv4\",\n+    \"proto-igmp\",\n+    \"socket-icmp\",\n+    \"socket-udp\",\n+    \"socket-tcp\",\n+    \"socket-raw\",\n+    \"socket-dhcpv4\",\n+] }\n+tdx-guest = { version = \"0.1.7\", optional = true }\n \n-[dev-dependencies]\n-x86_64 = \"0.14.2\"\n-aster-time = { path = \"comps/time\" }\n-aster-framebuffer = { path = \"comps/framebuffer\" }\n+# parse elf file\n+xmas-elf = \"0.8.0\"\n+# data-structures\n+bitflags = \"1.3\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"libs/keyable-arc\" }\n+# unzip initramfs\n+libflate = { version = \"2\", default-features = false }\n+core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n+lending-iterator = \"0.1.7\"\n+spin = \"0.9.4\"\n+vte = \"0.10\"\n+lru = \"0.12.3\"\n+log = \"0.4\"\n+bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n+hashbrown = \"0.14\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\n+    \"small_rng\",\n+    \"std_rng\",\n+] }\n+static_assertions = \"1.1.0\"\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n+getset = \"0.1.2\"\n+atomic = \"0.6\"\n+bytemuck = \"1.14.3\"\n+bytemuck_derive = \"1.5.0\"\n+takeable = \"0.2.2\"\n+cfg-if = \"1.0\"\n+\n+[dependencies.lazy_static]\n+version = \"1.0\"\n+features = [\"spin_no_std\"]\n \n [features]\n-cvm_guest = [\"ostd/cvm_guest\", \"aster-nix/cvm_guest\"]\n+cvm_guest = [\"dep:tdx-guest\", \"ostd/cvm_guest\"]\ndiff --git a/kernel/aster-nix/Cargo.toml /dev/null\n--- a/kernel/aster-nix/Cargo.toml\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-[package]\n-name = \"aster-nix\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-align_ext = { path = \"../../ostd/libs/align_ext\" }\n-aster-input = { path = \"../comps/input\" }\n-aster-block = { path = \"../comps/block\" }\n-aster-network = { path = \"../comps/network\" }\n-aster-console = { path = \"../comps/console\" }\n-aster-time = { path = \"../comps/time\" }\n-aster-virtio = { path = \"../comps/virtio\" }\n-aster-rights = { path = \"../libs/aster-rights\" }\n-controlled = { path = \"../libs/comp-sys/controlled\" }\n-ostd = { path = \"../../ostd\" }\n-typeflags = { path = \"../libs/typeflags\" }\n-typeflags-util = { path = \"../libs/typeflags-util\" }\n-aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n-aster-util = { path = \"../libs/aster-util\" }\n-id-alloc = { path = \"../../ostd/libs/id-alloc\" }\n-int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../libs/cpio-decoder\" }\n-ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n-intrusive-collections = \"0.9.5\"\n-paste = \"1.0\"\n-time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n-smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n-    \"alloc\",\n-    \"log\",\n-    \"medium-ethernet\",\n-    \"medium-ip\",\n-    \"proto-dhcpv4\",\n-    \"proto-ipv4\",\n-    \"proto-igmp\",\n-    \"socket-icmp\",\n-    \"socket-udp\",\n-    \"socket-tcp\",\n-    \"socket-raw\",\n-    \"socket-dhcpv4\",\n-] }\n-tdx-guest = { version = \"0.1.7\", optional = true }\n-\n-# parse elf file\n-xmas-elf = \"0.8.0\"\n-# goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n-# data-structures\n-bitflags = \"1.3\"\n-ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../libs/keyable-arc\" }\n-# unzip initramfs\n-libflate = { version = \"2\", default-features = false }\n-core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n-lending-iterator = \"0.1.7\"\n-spin = \"0.9.4\"\n-vte = \"0.10\"\n-lru = \"0.12.3\"\n-log = \"0.4\"\n-bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-hashbrown = \"0.14\"\n-rand = { version = \"0.8.5\", default-features = false, features = [\n-    \"small_rng\",\n-    \"std_rng\",\n-] }\n-static_assertions = \"1.1.0\"\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-getset = \"0.1.2\"\n-atomic = \"0.6\"\n-bytemuck = \"1.14.3\"\n-bytemuck_derive = \"1.5.0\"\n-takeable = \"0.2.2\"\n-cfg-if = \"1.0\"\n-\n-[dependencies.lazy_static]\n-version = \"1.0\"\n-features = [\"spin_no_std\"]\n-\n-[features]\n-cvm_guest = [\"dep:tdx-guest\"]\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"cargo-osdk\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Accelerate OS development with Asterinas OSDK\"\n license = \"MPL-2.0\"\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -171,7 +171,7 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    if std::env::var(\"AUTO_TEST\").is_ok() || std::env::var(\"OSDK_INTEGRATION_TEST\").is_ok() {\n+    if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n         cmd.arg(\"--path\")\n             .arg(\"../../../ostd/libs/linux-bzimage/setup\");\n     }\ndiff --git a/osdk/src/commands/build/mod.rs b/osdk/src/commands/build/mod.rs\n--- a/osdk/src/commands/build/mod.rs\n+++ b/osdk/src/commands/build/mod.rs\n@@ -72,6 +72,7 @@ pub fn create_base_and_cached_build(\n         &base_crate_path,\n         &get_current_crate_info().name,\n         get_current_crate_info().path,\n+        false,\n     );\n     let original_dir = std::env::current_dir().unwrap();\n     std::env::set_current_dir(&base_crate_path).unwrap();\ndiff --git a/osdk/src/commands/new/kernel.template b/osdk/src/commands/new/kernel.template\n--- a/osdk/src/commands/new/kernel.template\n+++ b/osdk/src/commands/new/kernel.template\n@@ -1,4 +1,6 @@\n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -50,60 +50,33 @@ impl TomlManifest {\n                     .unwrap(),\n             )\n         };\n-        // All the custom schemes should inherit settings from the default scheme, this is a helper.\n-        fn finalize(current_manifest: Option<TomlManifest>) -> TomlManifest {\n-            let Some(mut current_manifest) = current_manifest else {\n-                error_msg!(\n-                    \"Cannot find `OSDK.toml` in the current directory or the workspace root\"\n-                );\n-                process::exit(Errno::GetMetadata as _);\n-            };\n-            for scheme in current_manifest.map.values_mut() {\n-                scheme.inherit(&current_manifest.default_scheme);\n-            }\n-            current_manifest\n-        }\n \n         // Search for OSDK.toml in the current directory first.\n-        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize().ok();\n-        let mut current_manifest = match &current_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n-        };\n-        // Then search in the workspace root.\n-        let workspace_manifest_path = workspace_root.join(\"OSDK.toml\").canonicalize().ok();\n-        // The case that the current directory is also the workspace root.\n-        if let Some(current) = &current_manifest_path {\n-            if let Some(workspace) = &workspace_manifest_path {\n-                if current == workspace {\n-                    return finalize(current_manifest);\n+        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize();\n+        let current_manifest = match &current_manifest_path {\n+            Ok(path) => deserialize_toml_manifest(path),\n+            Err(_) => {\n+                // If not found, search in the workspace root.\n+                if let Ok(workspace_manifest_path) = workspace_root.join(\"OSDK.toml\").canonicalize()\n+                {\n+                    deserialize_toml_manifest(workspace_manifest_path)\n+                } else {\n+                    None\n                 }\n             }\n-        }\n-        let workspace_manifest = match workspace_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n         };\n-        // The current manifest should inherit settings from the workspace manifest.\n-        if let Some(workspace_manifest) = workspace_manifest {\n-            if current_manifest.is_none() {\n-                current_manifest = Some(workspace_manifest);\n-            } else {\n-                // Inherit one scheme at a time.\n-                let current_manifest = current_manifest.as_mut().unwrap();\n-                current_manifest\n-                    .default_scheme\n-                    .inherit(&workspace_manifest.default_scheme);\n-                for (scheme_string, scheme) in workspace_manifest.map {\n-                    let current_scheme = current_manifest\n-                        .map\n-                        .entry(scheme_string)\n-                        .or_insert_with(Scheme::empty);\n-                    current_scheme.inherit(&scheme);\n-                }\n-            }\n+\n+        let Some(mut current_manifest) = current_manifest else {\n+            error_msg!(\"Cannot find `OSDK.toml` in the current directory or the workspace root\");\n+            process::exit(Errno::GetMetadata as _);\n+        };\n+\n+        // All the schemes should inherit from the default scheme.\n+        for scheme in current_manifest.map.values_mut() {\n+            scheme.inherit(&current_manifest.default_scheme);\n         }\n-        finalize(current_manifest)\n+\n+        current_manifest\n     }\n \n     /// Get the scheme given the scheme from the command line arguments.\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -10,6 +10,7 @@ pub enum Errno {\n     ExecuteCommand = 5,\n     BuildCrate = 6,\n     RunBundle = 7,\n+    BadCrateName = 8,\n }\n \n /// Print error message to console\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n license = \"MPL-2.0\"\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -7,12 +7,13 @@ use quote::quote;\n use rand::{distributions::Alphanumeric, Rng};\n use syn::{parse_macro_input, Expr, Ident, ItemFn};\n \n-/// This macro is used to mark the kernel entry point.\n+/// A macro attribute to mark the kernel entry point.\n ///\n /// # Example\n ///\n /// ```ignore\n /// #![no_std]\n+/// #![feature(linkage)]\n ///\n /// use ostd::prelude::*;\n ///\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -56,10 +56,15 @@ pub(crate) use crate::cpu::local::cpu_local_cell;\n /// This function represents the first phase booting up the system. It makes\n /// all functionalities of OSTD available after the call.\n ///\n-/// TODO: We need to refactor this function to make it more modular and\n-/// make inter-initialization-dependencies more clear and reduce usages of\n-/// boot stage only global variables.\n-pub fn init() {\n+/// # Safety\n+///\n+/// This function should be called only once and only on the BSP.\n+//\n+// TODO: We need to refactor this function to make it more modular and\n+// make inter-initialization-dependencies more clear and reduce usages of\n+// boot stage only global variables.\n+#[doc(hidden)]\n+pub unsafe fn init() {\n     arch::enable_cpu_features();\n     arch::serial::init();\n \ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -20,6 +20,13 @@ update_package_version() {\n     sed -i \"0,/${pattern}/s/${pattern}/version = \\\"${new_version}\\\"/1\" $1\n }\n \n+# Update the version of the `ostd` dependency (`ostd = { version = \"\", ...`) in file $1\n+update_ostd_dep_version() {\n+    echo \"Updating file $1\"\n+    pattern=\"^ostd = { version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"\"\n+    sed -i \"0,/${pattern}/s/${pattern}/ostd = { version = \\\"${new_version}\\\"/1\" $1\n+}\n+\n # Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -114,9 +122,11 @@ new_version=$(bump_version ${current_version})\n # Update the package version in Cargo.toml\n update_package_version ${OSTD_CARGO_TOML_PATH}\n update_package_version ${OSDK_CARGO_TOML_PATH}\n+update_package_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n+update_ostd_dep_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p asterinas --precise $new_version\n+cargo update -p aster-nix --precise $new_version\n \n # Update Docker image versions in README files\n update_image_versions ${ASTER_SRC_DIR}/README.md\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -142,4 +152,4 @@ update_image_versions $GET_STARTED_PATH\n # `-n` is used to avoid adding a '\\n' in the VERSION file.\n echo -n \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Asterinas & OSDK version to $new_version\"\n+echo \"Bumped Asterinas OSTD & OSDK version to $new_version\"\n",
        "test_patch": "diff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -16,7 +16,7 @@ jobs:\n   osdk-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v4\n \ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -39,7 +39,7 @@ jobs:\n   ostd-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     strategy:\n       matrix:\n         # All supported targets, this array should keep consistent with\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -48,15 +48,18 @@ jobs:\n     steps:\n       - uses: actions/checkout@v4\n \n-      - name: Check Publish OSTD\n+      - name: Check Publish OSTD and the test runner\n         # On pull request, set `--dry-run` to check whether OSDK can publish\n         if: github.event_name == 'pull_request'\n         run: |\n           cd ostd\n           cargo publish --target ${{ matrix.target }} --dry-run\n           cargo doc --target ${{ matrix.target }}\n+          cd osdk/test-kernel\n+          cargo publish --target ${{ matrix.target }} --dry-run\n+          cargo doc --target ${{ matrix.target }}\n       \n-      - name: Publish OSTD\n+      - name: Publish OSTD and the test runner\n         if: github.event_name == 'push'\n         env:\n           REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -66,4 +69,6 @@ jobs:\n         run: |\n           cd ostd\n           cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n-      \n+          cd osdk/test-kernel\n+          cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n+      \n\\ No newline at end of file\ndiff --git a/.github/workflows/publish_website.yml b/.github/workflows/publish_website.yml\n--- a/.github/workflows/publish_website.yml\n+++ b/.github/workflows/publish_website.yml\n@@ -16,7 +16,7 @@ jobs:\n   build_and_deploy:\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v2\n         with:\ndiff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -14,9 +14,9 @@ jobs:\n     if: github.event_name == 'push' || github.event_name == 'pull_request'\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n       \ndiff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -28,9 +28,9 @@ jobs:\n     if: github.event_name == 'push' || github.event_name == 'pull_request'\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n \ndiff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -49,10 +49,10 @@ jobs:\n     runs-on: ubuntu-latest\n     timeout-minutes: 30\n     container:\n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n \ndiff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -88,7 +88,7 @@ jobs:\n     runs-on: self-hosted\n     timeout-minutes: 30\n     container:\n-      image: asterinas/asterinas:0.7.0-tdx\n+      image: asterinas/asterinas:0.8.0-tdx\n       options: --device=/dev/kvm --privileged\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\ndiff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -96,7 +96,7 @@ jobs:\n       RUSTUP_DIST_SERVER: https://mirrors.ustc.edu.cn/rust-static\n       RUSTUP_UPDATE_ROOT: https://mirrors.ustc.edu.cn/rust-static/rustup\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0-tdx\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0-tdx\"\n       - uses: actions/checkout@v4\n       - name: Set up the environment\n         run: |\ndiff --git a/.github/workflows/test_asterinas_vsock.yml b/.github/workflows/test_asterinas_vsock.yml\n--- a/.github/workflows/test_asterinas_vsock.yml\n+++ b/.github/workflows/test_asterinas_vsock.yml\n@@ -23,7 +23,7 @@ jobs:\n         run: |\n             docker run \\\n               --privileged --network=host --device=/dev/kvm \\\n-              -v ./:/root/asterinas asterinas/asterinas:0.7.0 \\\n+              -v ./:/root/asterinas asterinas/asterinas:0.8.0 \\\n               make run AUTO_TEST=vsock ENABLE_KVM=0 SCHEME=microvm RELEASE_MODE=1 &\n       - name: Run Vsock Client on Host\n         id: host_vsock_client\ndiff --git a/.github/workflows/test_osdk.yml b/.github/workflows/test_osdk.yml\n--- a/.github/workflows/test_osdk.yml\n+++ b/.github/workflows/test_osdk.yml\n@@ -21,9 +21,9 @@ jobs:\n     timeout-minutes: 30\n     strategy:\n       matrix:\n-        # asterinas/asterinas:0.7.0 container is the developing container of asterinas,\n-        # asterinas/osdk:0.7.0 container is built with the intructions from Asterinas Book\n-        container: ['asterinas/asterinas:0.7.0', 'asterinas/osdk:0.7.0']\n+        # asterinas/asterinas:0.8.0 container is the developing container of asterinas,\n+        # asterinas/osdk:0.8.0 container is built with the intructions from Asterinas Book\n+        container: ['asterinas/asterinas:0.8.0', 'asterinas/osdk:0.8.0']\n     container: ${{ matrix.container }}\n     steps:\n       - run: echo \"Running in ${{ matrix.container }}\"\ndiff --git a/.github/workflows/test_osdk.yml b/.github/workflows/test_osdk.yml\n--- a/.github/workflows/test_osdk.yml\n+++ b/.github/workflows/test_osdk.yml\n@@ -32,7 +32,7 @@ jobs:\n \n       - name: Lint\n         id: lint\n-        if: matrix.container == 'asterinas/asterinas:0.7.0'\n+        if: matrix.container == 'asterinas/asterinas:0.8.0'\n         run: make check_osdk\n \n       # Github's actions/checkout@v4 will result in a new user (not root) \ndiff --git a/.github/workflows/test_osdk.yml b/.github/workflows/test_osdk.yml\n--- a/.github/workflows/test_osdk.yml\n+++ b/.github/workflows/test_osdk.yml\n@@ -56,9 +56,9 @@ jobs:\n       RUSTUP_UPDATE_ROOT: https://mirrors.ustc.edu.cn/rust-static/rustup\n     strategy:\n       matrix:\n-        # asterinas/asterinas:0.7.0-tdx container is the developing container of asterinas,\n-        # asterinas/osdk:0.7.0-tdx container is built with the intructions from Asterinas Book\n-        container: ['asterinas/asterinas:0.7.0-tdx', 'asterinas/osdk:0.7.0-tdx']\n+        # asterinas/asterinas:0.8.0-tdx container is the developing container of asterinas,\n+        # asterinas/osdk:0.8.0-tdx container is built with the intructions from Asterinas Book\n+        container: ['asterinas/asterinas:0.8.0-tdx', 'asterinas/osdk:0.8.0-tdx']\n     container: \n       image: ${{ matrix.container }}\n       options: --device=/dev/kvm --privileged\ndiff --git a/.github/workflows/test_osdk.yml b/.github/workflows/test_osdk.yml\n--- a/.github/workflows/test_osdk.yml\n+++ b/.github/workflows/test_osdk.yml\n@@ -67,7 +67,7 @@ jobs:\n       - uses: actions/checkout@v4\n       - name: Lint\n         id: lint\n-        if: matrix.container == 'asterinas/asterinas:0.7.0-tdx'\n+        if: matrix.container == 'asterinas/asterinas:0.8.0-tdx'\n         run: make check_osdk\n       # Github's actions/checkout@v4 will result in a new user (not root) \n       # and thus not using the Rust environment we set up in the container. \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1045,9 +1034,18 @@ version = \"1.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d\"\n \n+[[package]]\n+name = \"osdk-test-kernel\"\n+version = \"0.8.0\"\n+dependencies = [\n+ \"ostd\",\n+ \"owo-colors 4.0.0\",\n+ \"unwinding\",\n+]\n+\n [[package]]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n dependencies = [\n  \"acpi\",\n  \"align_ext\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1075,7 +1073,7 @@ dependencies = [\n  \"ostd-macros\",\n  \"ostd-pod\",\n  \"ostd-test\",\n- \"owo-colors\",\n+ \"owo-colors 3.5.0\",\n  \"rsdp\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1119,9 +1117,6 @@ dependencies = [\n [[package]]\n name = \"ostd-test\"\n version = \"0.1.0\"\n-dependencies = [\n- \"owo-colors\",\n-]\n \n [[package]]\n name = \"owo-colors\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,6 +1,7 @@\n [workspace]\n resolver = \"2\"\n members = [\n+    \"osdk/test-kernel\",\n     \"ostd\",\n     \"ostd/libs/align_ext\",\n     \"ostd/libs/ostd-macros\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -10,7 +11,6 @@ members = [\n     \"ostd/libs/linux-bzimage/setup\",\n     \"ostd/libs/ostd-test\",\n     \"kernel\",\n-    \"kernel/aster-nix\",\n     \"kernel/comps/block\",\n     \"kernel/comps/console\",\n     \"kernel/comps/framebuffer\",\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -110,10 +110,10 @@ NON_OSDK_CRATES := \\\n # In contrast, OSDK crates depend on OSTD (or being `ostd` itself)\n # and need to be built or tested with OSDK.\n OSDK_CRATES := \\\n+\tosdk/test-kernel \\\n \tostd \\\n \tostd/libs/linux-bzimage/setup \\\n \tkernel \\\n-\tkernel/aster-nix \\\n \tkernel/comps/block \\\n \tkernel/comps/console \\\n \tkernel/comps/framebuffer \\\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -206,7 +209,7 @@ format:\n \t@make --no-print-directory -C test format\n \n .PHONY: check\n-check: $(CARGO_OSDK)\n+check: initramfs $(CARGO_OSDK)\n \t@./tools/format_all.sh --check   \t# Check Rust format issues\n \t@# Check if STD_CRATES and NOSTD_CRATES combined is the same as all workspace members\n \t@sed -n '/^\\[workspace\\]/,/^\\[.*\\]/{/members = \\[/,/\\]/p}' Cargo.toml | \\\ndiff --git a/kernel/aster-nix/src/lib.rs /dev/null\n--- a/kernel/aster-nix/src/lib.rs\n+++ /dev/null\n@@ -1,154 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The std library of Asterinas.\n-#![no_std]\n-#![deny(unsafe_code)]\n-#![allow(incomplete_features)]\n-#![feature(btree_cursors)]\n-#![feature(btree_extract_if)]\n-#![feature(const_option)]\n-#![feature(extend_one)]\n-#![feature(fn_traits)]\n-#![feature(format_args_nl)]\n-#![feature(int_roundings)]\n-#![feature(iter_repeat_n)]\n-#![feature(let_chains)]\n-#![feature(linked_list_remove)]\n-#![feature(negative_impls)]\n-#![feature(register_tool)]\n-// FIXME: This feature is used to support vm capbility now as a work around.\n-// Since this is an incomplete feature, use this feature is unsafe.\n-// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n-#![feature(specialization)]\n-#![feature(step_trait)]\n-#![feature(trait_alias)]\n-#![feature(trait_upcasting)]\n-#![feature(linked_list_retain)]\n-#![register_tool(component_access_control)]\n-\n-use ostd::{\n-    arch::qemu::{exit_qemu, QemuExitCode},\n-    boot,\n-};\n-use process::Process;\n-\n-use crate::{\n-    prelude::*,\n-    thread::{\n-        kernel_thread::{KernelThreadExt, ThreadOptions},\n-        Thread,\n-    },\n-};\n-\n-extern crate alloc;\n-extern crate lru;\n-#[macro_use]\n-extern crate controlled;\n-#[macro_use]\n-extern crate getset;\n-\n-pub mod arch;\n-pub mod console;\n-pub mod context;\n-pub mod cpu;\n-pub mod device;\n-pub mod driver;\n-pub mod error;\n-pub mod events;\n-pub mod fs;\n-pub mod ipc;\n-pub mod net;\n-pub mod prelude;\n-mod process;\n-mod sched;\n-pub mod softirq_id;\n-pub mod syscall;\n-mod taskless;\n-pub mod thread;\n-pub mod time;\n-mod util;\n-pub(crate) mod vdso;\n-pub mod vm;\n-\n-pub fn init() {\n-    util::random::init();\n-    driver::init();\n-    time::init();\n-    net::init();\n-    sched::init();\n-    fs::rootfs::init(boot::initramfs()).unwrap();\n-    device::init().unwrap();\n-    vdso::init();\n-    taskless::init();\n-    process::init();\n-}\n-\n-fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n-    // Work queue should be initialized before interrupt is enabled,\n-    // in case any irq handler uses work queue as bottom half\n-    thread::work_queue::init();\n-    net::lazy_init();\n-    fs::lazy_init();\n-    ipc::init();\n-    // driver::pci::virtio::block::block_device_test();\n-    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n-        println!(\"[kernel] Hello world from kernel!\");\n-        let current = current_thread!();\n-        let tid = current.tid();\n-        debug!(\"current tid = {}\", tid);\n-    }));\n-    thread.join();\n-    info!(\n-        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n-        thread.tid()\n-    );\n-\n-    print_banner();\n-\n-    let karg = boot::kernel_cmdline();\n-\n-    let initproc = Process::spawn_user_process(\n-        karg.get_initproc_path().unwrap(),\n-        karg.get_initproc_argv().to_vec(),\n-        karg.get_initproc_envp().to_vec(),\n-    )\n-    .expect(\"Run init process failed.\");\n-    // Wait till initproc become zombie.\n-    while !initproc.is_zombie() {\n-        // We don't have preemptive scheduler now.\n-        // The long running init thread should yield its own execution to allow other tasks to go on.\n-        Thread::yield_now();\n-    }\n-\n-    // TODO: exit via qemu isa debug device should not be the only way.\n-    let exit_code = if initproc.exit_code().unwrap() == 0 {\n-        QemuExitCode::Success\n-    } else {\n-        QemuExitCode::Failed\n-    };\n-    exit_qemu(exit_code);\n-}\n-\n-/// first process never return\n-#[controlled]\n-pub fn run_first_process() -> ! {\n-    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n-    unreachable!()\n-}\n-\n-fn print_banner() {\n-    println!(\"\\x1B[36m\");\n-    println!(\n-        r\"\n-   _   ___ _____ ___ ___ ___ _  _   _   ___\n-  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n- / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n-/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n-\"\n-    );\n-    println!(\"\\x1B[0m\");\n-}\ndiff --git a/kernel/libs/aster-util/src/coeff.rs b/kernel/libs/aster-util/src/coeff.rs\n--- a/kernel/libs/aster-util/src/coeff.rs\n+++ b/kernel/libs/aster-util/src/coeff.rs\n@@ -134,8 +134,8 @@ mod test {\n     #[ktest]\n     fn calculation() {\n         let coeff = Coeff::new(23456, 56789, 1_000_000_000);\n-        assert!(coeff * 0 as u64 == 0);\n-        assert!(coeff * 100 as u64 == 100 * 23456 / 56789);\n-        assert!(coeff * 1_000_000_000 as u64 == 1_000_000_000 * 23456 / 56789);\n+        assert!(coeff * 0_u64 == 0);\n+        assert!(coeff * 100_u64 == 100 * 23456 / 56789);\n+        assert!(coeff * 1_000_000_000_u64 == 1_000_000_000 * 23456 / 56789);\n     }\n }\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -107,7 +107,7 @@ mod test {\n         }\n     }\n     /// Exfat disk image\n-    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../../test/build/exfat.img\");\n+    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../test/build/exfat.img\");\n \n     /// Read exfat disk image\n     fn new_vm_segment_from_image() -> Segment {\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -484,7 +484,7 @@ mod test {\n         let mut read = vec![0u8; BUF_SIZE];\n         let read_after_rename = a_inode_new.read_bytes_at(0, &mut read);\n         assert!(\n-            read_after_rename.is_ok() && read_after_rename.clone().unwrap() == BUF_SIZE,\n+            read_after_rename.is_ok() && read_after_rename.unwrap() == BUF_SIZE,\n             \"Fail to read after rename: {:?}\",\n             read_after_rename.unwrap_err()\n         );\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -495,8 +495,7 @@ mod test {\n         let new_buf = vec![7u8; NEW_BUF_SIZE];\n         let new_write_after_rename = a_inode_new.write_bytes_at(0, &new_buf);\n         assert!(\n-            new_write_after_rename.is_ok()\n-                && new_write_after_rename.clone().unwrap() == NEW_BUF_SIZE,\n+            new_write_after_rename.is_ok() && new_write_after_rename.unwrap() == NEW_BUF_SIZE,\n             \"Fail to write file after rename: {:?}\",\n             new_write_after_rename.unwrap_err()\n         );\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -984,7 +983,7 @@ mod test {\n         let mut file_names: Vec<String> = (0..file_num).map(|x| x.to_string()).collect();\n         file_names.sort();\n         let mut file_inodes: Vec<Arc<dyn Inode>> = Vec::new();\n-        for (_file_id, file_name) in file_names.iter().enumerate() {\n+        for file_name in file_names.iter() {\n             let inode = create_file(root.clone(), file_name);\n             file_inodes.push(inode);\n         }\ndiff --git a/kernel/aster-nix/src/fs/exfat/utils.rs b/kernel/src/fs/exfat/utils.rs\n--- a/kernel/aster-nix/src/fs/exfat/utils.rs\n+++ b/kernel/src/fs/exfat/utils.rs\n@@ -60,7 +60,6 @@ impl DosTimestamp {\n         #[cfg(not(ktest))]\n         {\n             use crate::time::clocks::RealTimeClock;\n-\n             DosTimestamp::from_duration(RealTimeClock::get().read_time())\n         }\n \ndiff --git a/kernel/aster-nix/src/fs/exfat/utils.rs b/kernel/src/fs/exfat/utils.rs\n--- a/kernel/aster-nix/src/fs/exfat/utils.rs\n+++ b/kernel/src/fs/exfat/utils.rs\n@@ -68,9 +67,9 @@ impl DosTimestamp {\n         #[cfg(ktest)]\n         {\n             use crate::time::SystemTime;\n-            return DosTimestamp::from_duration(\n+            DosTimestamp::from_duration(\n                 SystemTime::UNIX_EPOCH.duration_since(&SystemTime::UNIX_EPOCH)?,\n-            );\n+            )\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/aster-nix/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -331,7 +331,7 @@ mod test {\n     #[ktest]\n     fn test_read_closed() {\n         test_blocking(\n-            |writer| drop(writer),\n+            drop,\n             |reader| {\n                 let mut buf = [0; 1];\n                 assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 0);\ndiff --git a/kernel/aster-nix/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/aster-nix/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -350,7 +350,7 @@ mod test {\n                     Errno::EPIPE\n                 );\n             },\n-            |reader| drop(reader),\n+            drop,\n             Ordering::WriteThenRead,\n         );\n     }\ndiff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -1,16 +1,161 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+//! Aster-nix is the Asterinas kernel, a safe, efficient unix-like\n+//! operating system kernel built on top of OSTD and OSDK.\n+\n #![no_std]\n #![no_main]\n #![deny(unsafe_code)]\n-extern crate ostd;\n+#![allow(incomplete_features)]\n+#![feature(btree_cursors)]\n+#![feature(btree_extract_if)]\n+#![feature(const_option)]\n+#![feature(extend_one)]\n+#![feature(fn_traits)]\n+#![feature(format_args_nl)]\n+#![feature(int_roundings)]\n+#![feature(iter_repeat_n)]\n+#![feature(let_chains)]\n+#![feature(linkage)]\n+#![feature(linked_list_remove)]\n+#![feature(negative_impls)]\n+#![feature(register_tool)]\n+// FIXME: This feature is used to support vm capbility now as a work around.\n+// Since this is an incomplete feature, use this feature is unsafe.\n+// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n+#![feature(specialization)]\n+#![feature(step_trait)]\n+#![feature(trait_alias)]\n+#![feature(trait_upcasting)]\n+#![feature(linked_list_retain)]\n+#![register_tool(component_access_control)]\n+\n+use ostd::{\n+    arch::qemu::{exit_qemu, QemuExitCode},\n+    boot,\n+};\n+use process::Process;\n+\n+use crate::{\n+    prelude::*,\n+    thread::{\n+        kernel_thread::{KernelThreadExt, ThreadOptions},\n+        Thread,\n+    },\n+};\n+\n+extern crate alloc;\n+extern crate lru;\n+#[macro_use]\n+extern crate controlled;\n+#[macro_use]\n+extern crate getset;\n \n-use ostd::prelude::*;\n+pub mod arch;\n+pub mod console;\n+pub mod context;\n+pub mod cpu;\n+pub mod device;\n+pub mod driver;\n+pub mod error;\n+pub mod events;\n+pub mod fs;\n+pub mod ipc;\n+pub mod net;\n+pub mod prelude;\n+mod process;\n+mod sched;\n+pub mod softirq_id;\n+pub mod syscall;\n+mod taskless;\n+pub mod thread;\n+pub mod time;\n+mod util;\n+pub(crate) mod vdso;\n+pub mod vm;\n \n #[ostd::main]\n+#[controlled]\n pub fn main() {\n-    println!(\"[kernel] finish init ostd\");\n+    ostd::early_println!(\"[kernel] OSTD initialized. Preparing components.\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    aster_nix::init();\n-    aster_nix::run_first_process();\n+    init();\n+    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n+    unreachable!()\n+}\n+\n+pub fn init() {\n+    util::random::init();\n+    driver::init();\n+    time::init();\n+    net::init();\n+    sched::init();\n+    fs::rootfs::init(boot::initramfs()).unwrap();\n+    device::init().unwrap();\n+    vdso::init();\n+    taskless::init();\n+    process::init();\n+}\n+\n+fn init_thread() {\n+    println!(\n+        \"[kernel] Spawn init thread, tid = {}\",\n+        current_thread!().tid()\n+    );\n+    // Work queue should be initialized before interrupt is enabled,\n+    // in case any irq handler uses work queue as bottom half\n+    thread::work_queue::init();\n+    net::lazy_init();\n+    fs::lazy_init();\n+    ipc::init();\n+    // driver::pci::virtio::block::block_device_test();\n+    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n+        println!(\"[kernel] Hello world from kernel!\");\n+        let current = current_thread!();\n+        let tid = current.tid();\n+        debug!(\"current tid = {}\", tid);\n+    }));\n+    thread.join();\n+    info!(\n+        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n+        thread.tid()\n+    );\n+\n+    print_banner();\n+\n+    let karg = boot::kernel_cmdline();\n+\n+    let initproc = Process::spawn_user_process(\n+        karg.get_initproc_path().unwrap(),\n+        karg.get_initproc_argv().to_vec(),\n+        karg.get_initproc_envp().to_vec(),\n+    )\n+    .expect(\"Run init process failed.\");\n+    // Wait till initproc become zombie.\n+    while !initproc.is_zombie() {\n+        // We don't have preemptive scheduler now.\n+        // The long running init thread should yield its own execution to allow other tasks to go on.\n+        Thread::yield_now();\n+    }\n+\n+    // TODO: exit via qemu isa debug device should not be the only way.\n+    let exit_code = if initproc.exit_code().unwrap() == 0 {\n+        QemuExitCode::Success\n+    } else {\n+        QemuExitCode::Failed\n+    };\n+    exit_qemu(exit_code);\n+}\n+\n+fn print_banner() {\n+    println!(\"\\x1B[36m\");\n+    println!(\n+        r\"\n+   _   ___ _____ ___ ___ ___ _  _   _   ___\n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n+\"\n+    );\n+    println!(\"\\x1B[0m\");\n }\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -291,7 +291,7 @@ mod test {\n             while !*started {\n                 started = cvar.wait(started).unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -316,7 +316,7 @@ mod test {\n                     .wait_timeout(started, Duration::from_secs(1))\n                     .unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -338,7 +338,7 @@ mod test {\n             let started = cvar\n                 .wait_while(lock.lock(), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -360,7 +360,7 @@ mod test {\n             let (started, _) = cvar\n                 .wait_timeout_while(lock.lock(), Duration::from_secs(1), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n }\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/src/taskless.rs\n@@ -216,7 +216,7 @@ mod test {\n         let mut counter = 0;\n \n         // Schedule this taskless for `SCHEDULE_TIMES`.\n-        while taskless.is_scheduled.load(Ordering::Acquire) == false {\n+        while !taskless.is_scheduled.load(Ordering::Acquire) {\n             taskless.schedule();\n             counter += 1;\n             if counter == SCHEDULE_TIMES {\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/src/taskless.rs\n@@ -227,7 +227,9 @@ mod test {\n         // Wait for all taskless having finished.\n         while taskless.is_running.load(Ordering::Acquire)\n             || taskless.is_scheduled.load(Ordering::Acquire)\n-        {}\n+        {\n+            core::hint::spin_loop()\n+        }\n \n         assert_eq!(counter, COUNTER.load(Ordering::Relaxed));\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/src/vm/vmar/options.rs\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/src/vm/vmar/options.rs\n@@ -136,7 +136,7 @@ impl<R> VmarChildOptions<R> {\n #[cfg(ktest)]\n mod test {\n     use aster_rights::Full;\n-    use ostd::{mm::VmIo, prelude::*};\n+    use ostd::prelude::*;\n \n     use super::*;\n     use crate::vm::{\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n //! The base crate is the OSDK generated crate that is ultimately built by cargo.\n-//! It will depend on the kernel crate.\n-//!\n+//! It will depend on the to-be-built kernel crate or the to-be-tested crate.\n \n use std::{\n     fs,\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -12,10 +11,16 @@ use std::{\n \n use crate::util::get_cargo_metadata;\n \n+/// Create a new base crate that will be built by cargo.\n+///\n+/// The dependencies of the base crate will be the target crate. If\n+/// `link_unit_test_runner` is set to true, the base crate will also depend on\n+/// the `ostd-test-runner` crate.\n pub fn new_base_crate(\n     base_crate_path: impl AsRef<Path>,\n     dep_crate_name: &str,\n     dep_crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n ) {\n     let workspace_root = {\n         let meta = get_cargo_metadata(None::<&str>, None::<&[&str]>).unwrap();\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -82,7 +87,7 @@ pub fn new_base_crate(\n     fs::write(\"src/main.rs\", main_rs).unwrap();\n \n     // Add dependencies to the Cargo.toml\n-    add_manifest_dependency(dep_crate_name, dep_crate_path);\n+    add_manifest_dependency(dep_crate_name, dep_crate_path, link_unit_test_runner);\n \n     // Copy the manifest configurations from the target crate to the base crate\n     copy_profile_configurations(workspace_root);\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -94,7 +99,11 @@ pub fn new_base_crate(\n     std::env::set_current_dir(original_dir).unwrap();\n }\n \n-fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n+fn add_manifest_dependency(\n+    crate_name: &str,\n+    crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n+) {\n     let mainfest_path = \"Cargo.toml\";\n \n     let mut manifest: toml::Table = {\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -112,13 +121,26 @@ fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let dep = toml::Table::from_str(&format!(\n+    let target_dep = toml::Table::from_str(&format!(\n         \"{} = {{ path = \\\"{}\\\", default-features = false }}\",\n         crate_name,\n         crate_path.as_ref().display()\n     ))\n     .unwrap();\n-    dependencies.as_table_mut().unwrap().extend(dep);\n+    dependencies.as_table_mut().unwrap().extend(target_dep);\n+\n+    if link_unit_test_runner {\n+        let dep_str = match option_env!(\"OSDK_LOCAL_DEV\") {\n+            Some(\"1\") => \"osdk-test-kernel = { path = \\\"../../../osdk/test-kernel\\\" }\",\n+            _ => concat!(\n+                \"osdk-test-kernel = { version = \\\"\",\n+                env!(\"CARGO_PKG_VERSION\"),\n+                \"\\\" }\"\n+            ),\n+        };\n+        let test_runner_dep = toml::Table::from_str(dep_str).unwrap();\n+        dependencies.as_table_mut().unwrap().extend(test_runner_dep);\n+    }\n \n     let content = toml::to_string(&manifest).unwrap();\n     fs::write(mainfest_path, content).unwrap();\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -49,9 +49,9 @@ pub fn main() {\n         OsdkSubcommand::Test(test_args) => {\n             execute_test_command(&load_config(&test_args.common_args), test_args);\n         }\n-        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args),\n-        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args),\n-        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args),\n+        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args, true),\n+        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args, true),\n+        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args, false),\n     }\n }\n \ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -16,8 +16,10 @@ pub use self::{\n \n use crate::arch::get_default_arch;\n \n-/// Execute the forwarded cargo command with args containing the subcommand and its arguments.\n-pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n+/// Execute the forwarded cargo command with arguments.\n+///\n+/// The `cfg_ktest` parameter controls whether `cfg(ktest)` is enabled.\n+pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>, cfg_ktest: bool) -> ! {\n     let mut cargo = util::cargo();\n     cargo.arg(subcommand).args(util::COMMON_CARGO_ARGS);\n     if !args.contains(&\"--target\".to_owned()) {\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -27,6 +29,11 @@ pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n \n     let env_rustflags = std::env::var(\"RUSTFLAGS\").unwrap_or_default();\n     let rustflags = env_rustflags + \" --check-cfg cfg(ktest)\";\n+    let rustflags = if cfg_ktest {\n+        rustflags + \" --cfg ktest\"\n+    } else {\n+        rustflags\n+    };\n \n     cargo.env(\"RUSTFLAGS\", rustflags);\n \ndiff --git a/osdk/src/commands/test.rs b/osdk/src/commands/test.rs\n--- a/osdk/src/commands/test.rs\n+++ b/osdk/src/commands/test.rs\n@@ -7,6 +7,8 @@ use crate::{\n     base_crate::new_base_crate,\n     cli::TestArgs,\n     config::{scheme::ActionChoice, Config},\n+    error::Errno,\n+    error_msg,\n     util::{\n         get_cargo_metadata, get_current_crate_info, get_target_directory, parse_package_id_string,\n     },\ndiff --git a/osdk/src/commands/test.rs b/osdk/src/commands/test.rs\n--- a/osdk/src/commands/test.rs\n+++ b/osdk/src/commands/test.rs\n@@ -25,7 +27,26 @@ pub fn test_current_crate(config: &Config, args: &TestArgs) {\n     let cargo_target_directory = get_target_directory();\n     let osdk_output_directory = cargo_target_directory.join(DEFAULT_TARGET_RELPATH);\n     let target_crate_dir = osdk_output_directory.join(\"base\");\n-    new_base_crate(&target_crate_dir, &current_crate.name, &current_crate.path);\n+\n+    // A special case is that we use OSDK to test the OSDK test runner crate\n+    // itself. We check it by name.\n+    let runner_self_test = if current_crate.name == \"osdk-test-kernel\" {\n+        if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n+            true\n+        } else {\n+            error_msg!(\"The tested crate name collides with the OSDK test runner crate\");\n+            std::process::exit(Errno::BadCrateName as _);\n+        }\n+    } else {\n+        false\n+    };\n+\n+    new_base_crate(\n+        &target_crate_dir,\n+        &current_crate.name,\n+        &current_crate.path,\n+        !runner_self_test,\n+    );\n \n     let main_rs_path = target_crate_dir.join(\"src\").join(\"main.rs\");\n \ndiff --git a/osdk/src/commands/test.rs b/osdk/src/commands/test.rs\n--- a/osdk/src/commands/test.rs\n+++ b/osdk/src/commands/test.rs\n@@ -39,19 +60,29 @@ pub fn test_current_crate(config: &Config, args: &TestArgs) {\n         ktest_crate_whitelist.push(name.clone());\n     }\n \n-    let ktest_static_var = format!(\n+    // Append the ktest static variable and the runner reference to the\n+    // `main.rs` file.\n+    let ktest_main_rs = format!(\n         r#\"\n+\n+{}\n+\n #[no_mangle]\n pub static KTEST_TEST_WHITELIST: Option<&[&str]> = {};\n #[no_mangle]\n pub static KTEST_CRATE_WHITELIST: Option<&[&str]> = Some(&{:#?});\n+\n \"#,\n-        ktest_test_whitelist, ktest_crate_whitelist,\n+        if runner_self_test {\n+            \"\"\n+        } else {\n+            \"extern crate osdk_test_kernel;\"\n+        },\n+        ktest_test_whitelist,\n+        ktest_crate_whitelist,\n     );\n-\n-    // Append the ktest static variable to the main.rs file\n     let mut main_rs_content = fs::read_to_string(&main_rs_path).unwrap();\n-    main_rs_content.push_str(&ktest_static_var);\n+    main_rs_content.push_str(&ktest_main_rs);\n     fs::write(&main_rs_path, main_rs_content).unwrap();\n \n     // Build the kernel with the given base crate\ndiff --git /dev/null b/osdk/test-kernel/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/test-kernel/Cargo.toml\n@@ -0,0 +1,14 @@\n+[package]\n+name = \"osdk-test-kernel\"\n+version = \"0.8.0\"\n+edition = \"2021\"\n+description = \"The OSTD-based kernel for running unit tests with OSDK.\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+ostd = { version = \"0.8.0\", path = \"../../ostd\" }\n+owo-colors = \"4.0.0\"\n+unwinding = { version = \"0.2.2\", default-features = false, features = [\"fde-gnu-eh-frame-hdr\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -1,24 +1,59 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! Test runner enabling control over the tests.\n-//!\n+//! The OSTD unit test runner is a kernel that runs the tests defined by the\n+//! `#[ostd::ktest]` attribute. The kernel should be automatically selected to\n+//! run when OSDK is used to test a specific crate.\n \n-use alloc::{collections::BTreeSet, string::String, vec::Vec};\n-use core::format_args;\n+#![no_std]\n+#![forbid(unsafe_code)]\n \n-use owo_colors::OwoColorize;\n+extern crate alloc;\n+\n+mod path;\n+mod tree;\n+\n+use alloc::{boxed::Box, collections::BTreeSet, string::String, vec::Vec};\n+use core::{any::Any, format_args};\n \n-use crate::{\n-    path::{KtestPath, SuffixTrie},\n-    tree::{KtestCrate, KtestTree},\n-    CatchUnwindImpl, KtestError, KtestItem, KtestIter,\n+use ostd::{\n+    early_print,\n+    ktest::{\n+        get_ktest_crate_whitelist, get_ktest_test_whitelist, KtestError, KtestItem, KtestIter,\n+    },\n };\n+use owo_colors::OwoColorize;\n+use path::{KtestPath, SuffixTrie};\n+use tree::{KtestCrate, KtestTree};\n \n pub enum KtestResult {\n     Ok,\n     Failed,\n }\n \n+/// The entry point of the test runner.\n+#[ostd::ktest::main]\n+fn main() {\n+    use ostd::task::TaskOptions;\n+\n+    let test_task = move || {\n+        use alloc::string::ToString;\n+\n+        use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n+\n+        match run_ktests(\n+            get_ktest_test_whitelist().map(|s| s.iter().map(|s| s.to_string())),\n+            get_ktest_crate_whitelist(),\n+        ) {\n+            KtestResult::Ok => exit_qemu(QemuExitCode::Success),\n+            KtestResult::Failed => exit_qemu(QemuExitCode::Failed),\n+        };\n+    };\n+\n+    let _ = TaskOptions::new(test_task).data(()).spawn();\n+\n+    unreachable!(\"The spawn method will NOT return in the boot context\")\n+}\n+\n /// Run all the tests registered by `#[ktest]` in the `.ktest_array` section.\n ///\n /// Need to provide a print function `print` to print the test result, and a `catch_unwind`\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -32,27 +67,18 @@ pub enum KtestResult {\n ///\n /// If a test inside a crate fails, the test runner will continue to run the rest of the tests\n /// inside the crate. But the tests in the following crates will not be run.\n-pub fn run_ktests<PrintFn, PathsIter>(\n-    print: &PrintFn,\n-    catch_unwind: &CatchUnwindImpl,\n+fn run_ktests<PathsIter>(\n     test_whitelist: Option<PathsIter>,\n     crate_whitelist: Option<&[&str]>,\n ) -> KtestResult\n where\n-    PrintFn: Fn(core::fmt::Arguments),\n     PathsIter: Iterator<Item = String>,\n {\n-    macro_rules! print {\n-        ($fmt: literal $(, $($arg: tt)+)?) => {\n-            print(format_args!($fmt $(, $($arg)+)?))\n-        }\n-    }\n-\n     let whitelist_trie =\n         test_whitelist.map(|paths| SuffixTrie::from_paths(paths.map(|p| KtestPath::from(&p))));\n \n     let tree = KtestTree::from_iter(KtestIter::new());\n-    print!(\n+    early_print!(\n         \"\\n[ktest runner] running {} tests in {} crates\\n\",\n         tree.nr_tot_tests(),\n         tree.nr_tot_crates()\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -62,36 +88,22 @@ where\n     for crate_ in tree.iter() {\n         if let Some(crate_set) = &crate_set {\n             if !crate_set.contains(crate_.name()) {\n-                print!(\"\\n[ktest runner] skipping crate \\\"{}\\\".\\n\", crate_.name());\n+                early_print!(\"\\n[ktest runner] skipping crate \\\"{}\\\".\\n\", crate_.name());\n                 continue;\n             }\n         }\n-        match run_crate_ktests(crate_, print, catch_unwind, &whitelist_trie) {\n+        match run_crate_ktests(crate_, &whitelist_trie) {\n             KtestResult::Ok => {}\n             KtestResult::Failed => return KtestResult::Failed,\n         }\n     }\n-    print!(\"\\n[ktest runner] All crates tested.\\n\");\n+    early_print!(\"\\n[ktest runner] All crates tested.\\n\");\n     KtestResult::Ok\n }\n \n-fn run_crate_ktests<PrintFn>(\n-    crate_: &KtestCrate,\n-    print: &PrintFn,\n-    catch_unwind: &CatchUnwindImpl,\n-    whitelist: &Option<SuffixTrie>,\n-) -> KtestResult\n-where\n-    PrintFn: Fn(core::fmt::Arguments),\n-{\n-    macro_rules! print {\n-        ($fmt: literal $(, $($arg: tt)+)?) => {\n-            print(format_args!($fmt $(, $($arg)+)?))\n-        }\n-    }\n-\n+fn run_crate_ktests(crate_: &KtestCrate, whitelist: &Option<SuffixTrie>) -> KtestResult {\n     let crate_name = crate_.name();\n-    print!(\n+    early_print!(\n         \"\\nrunning {} tests in crate \\\"{}\\\"\\n\\n\",\n         crate_.nr_tot_tests(),\n         crate_name\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -110,19 +122,22 @@ where\n                     continue;\n                 }\n             }\n-            print!(\n+            early_print!(\n                 \"test {}::{} ...\",\n                 test.info().module_path,\n                 test.info().fn_name\n             );\n             debug_assert_eq!(test.info().package, crate_name);\n-            match test.run(catch_unwind) {\n+            match test.run(\n+                &(unwinding::panic::catch_unwind::<(), fn()>\n+                    as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>),\n+            ) {\n                 Ok(()) => {\n-                    print!(\" {}\\n\", \"ok\".green());\n+                    early_print!(\" {}\\n\", \"ok\".green());\n                     passed += 1;\n                 }\n                 Err(e) => {\n-                    print!(\" {}\\n\", \"FAILED\".red());\n+                    early_print!(\" {}\\n\", \"FAILED\".red());\n                     failed_tests.push((test.clone(), e.clone()));\n                 }\n             }\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -130,19 +145,21 @@ where\n     }\n     let failed = failed_tests.len();\n     if failed == 0 {\n-        print!(\"\\ntest result: {}.\", \"ok\".green());\n+        early_print!(\"\\ntest result: {}.\", \"ok\".green());\n     } else {\n-        print!(\"\\ntest result: {}.\", \"FAILED\".red());\n+        early_print!(\"\\ntest result: {}.\", \"FAILED\".red());\n     }\n-    print!(\n+    early_print!(\n         \" {} passed; {} failed; {} filtered out.\\n\",\n-        passed, failed, filtered\n+        passed,\n+        failed,\n+        filtered\n     );\n     assert!(passed + failed + filtered == crate_.nr_tot_tests());\n     if failed > 0 {\n-        print!(\"\\nfailures:\\n\\n\");\n+        early_print!(\"\\nfailures:\\n\\n\");\n         for (t, e) in failed_tests {\n-            print!(\n+            early_print!(\n                 \"---- {}:{}:{} - {} ----\\n\\n\",\n                 t.info().source,\n                 t.info().line,\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -151,18 +168,18 @@ where\n             );\n             match e {\n                 KtestError::Panic(s) => {\n-                    print!(\"[caught panic] {}\\n\", s);\n+                    early_print!(\"[caught panic] {}\\n\", s);\n                 }\n                 KtestError::ShouldPanicButNoPanic => {\n-                    print!(\"test did not panic as expected\\n\");\n+                    early_print!(\"test did not panic as expected\\n\");\n                 }\n                 KtestError::ExpectedPanicNotMatch(expected, s) => {\n-                    print!(\"[caught panic] expected panic not match\\n\");\n-                    print!(\"expected: {}\\n\", expected);\n-                    print!(\"caught: {}\\n\", s);\n+                    early_print!(\"[caught panic] expected panic not match\\n\");\n+                    early_print!(\"expected: {}\\n\", expected);\n+                    early_print!(\"caught: {}\\n\", s);\n                 }\n                 KtestError::Unknown => {\n-                    print!(\"[caught panic] unknown panic payload! (fatal panic handling error in ktest)\\n\");\n+                    early_print!(\"[caught panic] unknown panic payload! (fatal panic handling error in ktest)\\n\");\n                 }\n             }\n         }\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -112,11 +112,13 @@ impl Display for KtestPath {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod path_test {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -129,7 +131,7 @@ mod path_test {\n         assert_eq!(path.pop_back(), None);\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path_starts_with() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -144,7 +146,7 @@ mod path_test {\n         assert!(!path.starts_with(&KtestPath::from(\"d\")));\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path_ends_with() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -238,8 +240,10 @@ impl Default for SuffixTrie {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod suffix_trie_test {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n     static TEST_PATHS: &[&str] = &[\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -252,7 +256,7 @@ mod suffix_trie_test {\n         \"m::n\",\n     ];\n \n-    #[test]\n+    #[ktest]\n     fn test_contains() {\n         let trie = SuffixTrie::from_paths(TEST_PATHS.iter().map(|&s| KtestPath::from(s)));\n \ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -269,7 +273,7 @@ mod suffix_trie_test {\n         assert!(!trie.contains(KtestPath::from(\"n\").iter()));\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_matches() {\n         let trie = SuffixTrie::from_paths(TEST_PATHS.iter().map(|&s| KtestPath::from(s)));\n \ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -213,21 +213,21 @@ impl<'a> Iterator for KtestModuleIter<'a> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod tests {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n     macro_rules! gen_test_case {\n         () => {{\n-            fn dummy_fn() {\n-                ()\n-            }\n+            fn dummy_fn() {}\n             let mut tree = KtestTree::new();\n             let new = |m: &'static str, f: &'static str, p: &'static str| {\n                 KtestItem::new(\n                     dummy_fn,\n                     (false, None),\n-                    crate::KtestItemInfo {\n+                    ostd::ktest::KtestItemInfo {\n                         module_path: m,\n                         fn_name: f,\n                         package: p,\ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -250,7 +250,7 @@ mod tests {\n         }};\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_tree_iter() {\n         let tree = gen_test_case!();\n         let mut iter = tree.iter();\ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -261,7 +261,7 @@ mod tests {\n         assert!(iter.next().is_none());\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_crate_iter() {\n         let tree = gen_test_case!();\n         for crate_ in tree.iter() {\ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -285,7 +285,7 @@ mod tests {\n         }\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_module_iter() {\n         let tree = gen_test_case!();\n         let mut collection = Vec::<&KtestItem>::new();\ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -293,7 +293,7 @@ mod tests {\n             for mov in crate_.iter() {\n                 let module = mov;\n                 for test in module.iter() {\n-                    collection.push(&test);\n+                    collection.push(test);\n                 }\n             }\n         }\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs b/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\n@@ -1,6 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n #![no_std]\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -1,6 +1,8 @@\n // SPDX-License-Identifier: MPL-2.0\n \n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n \n extern crate alloc;\n \ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -28,8 +29,37 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n \n     quote!(\n         #[no_mangle]\n-        pub fn __ostd_main() -> ! {\n-            ostd::init();\n+        #[linkage = \"weak\"]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n+            #main_fn_name();\n+            ostd::prelude::abort();\n+        }\n+\n+        #main_fn\n+    )\n+    .into()\n+}\n+\n+/// A macro attribute for the unit test kernel entry point.\n+///\n+/// This macro is used for internal OSDK implementation. Do not use it\n+/// directly.\n+///\n+/// It is a strong version of the `main` macro attribute. So if it exists (\n+/// which means the unit test kernel is linked to perform testing), the actual\n+/// kernel entry point will be replaced by this one.\n+#[proc_macro_attribute]\n+pub fn test_main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let main_fn = parse_macro_input!(item as ItemFn);\n+    let main_fn_name = &main_fn.sig.ident;\n+\n+    quote!(\n+        #[no_mangle]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n             #main_fn_name();\n             ostd::prelude::abort();\n         }\ndiff --git a/ostd/libs/ostd-test/Cargo.toml b/ostd/libs/ostd-test/Cargo.toml\n--- a/ostd/libs/ostd-test/Cargo.toml\n+++ b/ostd/libs/ostd-test/Cargo.toml\n@@ -2,11 +2,8 @@\n name = \"ostd-test\"\n version = \"0.1.0\"\n edition = \"2021\"\n-description = \"The kernel mode testing framework of OSTD\"\n+description = \"The kernel mode unit testing framework of OSTD\"\n license = \"MPL-2.0\"\n repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-owo-colors = \"3.5.0\"\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -45,12 +45,6 @@\n //!\n //! Any crates using the ostd-test framework should be linked with ostd.\n //!\n-//! ```toml\n-//! # Cargo.toml\n-//! [dependencies]\n-//! ostd = { path = \"relative/path/to/ostd\" }\n-//! ```\n-//!\n //! By the way, `#[ktest]` attribute along also works, but it hinders test control\n //! using cfgs since plain attribute marked test will be executed in all test runs\n //! no matter what cfgs are passed to the compiler. More importantly, using `#[ktest]`\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -58,27 +52,10 @@\n //! explicitly stripped in normal builds.\n //!\n //! Rust cfg is used to control the compilation of the test module. In cooperation\n-//! with the `ktest` framework, the Makefile will set the `RUSTFLAGS` environment\n-//! variable to pass the cfgs to all rustc invocations. To run the tests, you simply\n-//! need to set a list of cfgs by specifying `KTEST=1` to the Makefile, e.g.:\n-//!\n-//! ```bash\n-//! make run KTEST=1\n-//! ```\n-//!\n-//! Also, you can run a subset of tests by specifying the `KTEST_WHITELIST` variable.\n-//! This is achieved by a whitelist filter on the test name.\n-//!\n-//! ```bash\n-//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,ostd::test::expect_panic\n-//! ```\n-//!\n-//! `KTEST_CRATES` variable is used to specify in which crates the tests to be run.\n-//! This is achieved by conditionally compiling the test module using the `#[cfg]`.\n-//!\n-//! ```bash\n-//! make run KTEST=1 KTEST_CRATES=ostd\n-//! ``\n+//! with the `ktest` framework, OSDK will set the `RUSTFLAGS` environment variable\n+//! to pass the cfgs to all rustc invocations. To run the tests, you simply need\n+//! to use the command `cargo osdk test` in the crate directory. For more information,\n+//! please refer to the OSDK documentation.\n //!\n //! We support the `#[should_panic]` attribute just in the same way as the standard\n //! library do, but the implementation is quite slow currently. Use it with cautious.\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -90,10 +67,6 @@\n #![cfg_attr(not(test), no_std)]\n #![feature(panic_info_message)]\n \n-pub mod path;\n-pub mod runner;\n-pub mod tree;\n-\n extern crate alloc;\n use alloc::{boxed::Box, string::String};\n \ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -113,6 +86,7 @@ impl core::fmt::Display for PanicInfo {\n     }\n }\n \n+/// The error that may occur during the test.\n #[derive(Clone)]\n pub enum KtestError {\n     Panic(Box<PanicInfo>),\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -121,13 +95,22 @@ pub enum KtestError {\n     Unknown,\n }\n \n+/// The information of the unit test.\n #[derive(Clone, PartialEq, Debug)]\n pub struct KtestItemInfo {\n+    /// The path of the module, not including the function name.\n+    ///\n+    /// It would be separated by `::`.\n     pub module_path: &'static str,\n+    /// The name of the unit test function.\n     pub fn_name: &'static str,\n+    /// The name of the crate.\n     pub package: &'static str,\n+    /// The source file where the test function resides.\n     pub source: &'static str,\n+    /// The line number of the test function in the file.\n     pub line: usize,\n+    /// The column number of the test function in the file.\n     pub col: usize,\n }\n \ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -141,6 +124,11 @@ pub struct KtestItem {\n type CatchUnwindImpl = fn(f: fn() -> ()) -> Result<(), Box<dyn core::any::Any + Send>>;\n \n impl KtestItem {\n+    /// Create a new [`KtestItem`].\n+    ///\n+    /// Do not use this function directly. Instead, use the `#[ktest]`\n+    /// attribute to mark the test function.\n+    #[doc(hidden)]\n     pub const fn new(\n         fn_: fn() -> (),\n         should_panic: (bool, Option<&'static str>),\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -153,6 +141,7 @@ impl KtestItem {\n         }\n     }\n \n+    /// Get the information of the test.\n     pub fn info(&self) -> &KtestItemInfo {\n         &self.info\n     }\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -206,12 +195,22 @@ macro_rules! ktest_array {\n     }};\n }\n \n+/// The iterator of the ktest array.\n pub struct KtestIter {\n     index: usize,\n }\n \n+impl Default for KtestIter {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n impl KtestIter {\n-    fn new() -> Self {\n+    /// Create a new [`KtestIter`].\n+    ///\n+    /// It will iterate over all the tests (marked with `#[ktest]`).\n+    pub fn new() -> Self {\n         Self { index: 0 }\n     }\n }\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -225,3 +224,28 @@ impl core::iter::Iterator for KtestIter {\n         Some(ktest_item.clone())\n     }\n }\n+\n+// The whitelists that will be generated by the OSDK as static consts.\n+// They deliver the target tests that the user wants to run.\n+extern \"Rust\" {\n+    static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n+    static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n+}\n+\n+/// Get the whitelist of the tests.\n+///\n+/// The whitelist is generated by the OSDK runner, indicating name of the\n+/// target tests that the user wants to run.\n+pub fn get_ktest_test_whitelist() -> Option<&'static [&'static str]> {\n+    // SAFETY: The two extern statics in the base crate are generated by OSDK.\n+    unsafe { KTEST_TEST_WHITELIST }\n+}\n+\n+/// Get the whitelist of the crates.\n+///\n+/// The whitelist is generated by the OSDK runner, indicating the target crate\n+/// that the user wants to test.\n+pub fn get_ktest_crate_whitelist() -> Option<&'static [&'static str]> {\n+    // SAFETY: The two extern statics in the base crate are generated by OSDK.\n+    unsafe { KTEST_CRATE_WHITELIST }\n+}\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -115,8 +115,9 @@ pub fn init() {\n ///\n /// Any kernel that uses the `ostd` crate should define a function marked with\n /// `ostd::main` as the entrypoint.\n-pub fn call_ostd_main() -> ! {\n-    #[cfg(not(ktest))]\n+///\n+/// This function should be only called from the bootloader-specific module.\n+pub(crate) fn call_ostd_main() -> ! {\n     unsafe {\n         // The entry point of kernel code, which should be defined by the package that\n         // uses OSTD.\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -125,42 +126,4 @@ pub fn call_ostd_main() -> ! {\n         }\n         __ostd_main();\n     }\n-    #[cfg(ktest)]\n-    unsafe {\n-        use crate::task::TaskOptions;\n-\n-        crate::init();\n-        // The whitelists that will be generated by OSDK runner as static consts.\n-        extern \"Rust\" {\n-            static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n-            static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n-        }\n-\n-        let test_task = move || {\n-            run_ktests(KTEST_TEST_WHITELIST, KTEST_CRATE_WHITELIST);\n-        };\n-        let _ = TaskOptions::new(test_task).data(()).spawn();\n-        unreachable!(\"The spawn method will NOT return in the boot context\")\n-    }\n-}\n-\n-fn run_ktests(test_whitelist: Option<&[&str]>, crate_whitelist: Option<&[&str]>) -> ! {\n-    use alloc::{boxed::Box, string::ToString};\n-    use core::any::Any;\n-\n-    use crate::arch::qemu::{exit_qemu, QemuExitCode};\n-\n-    let fn_catch_unwind = &(unwinding::panic::catch_unwind::<(), fn()>\n-        as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>);\n-\n-    use ostd_test::runner::{run_ktests, KtestResult};\n-    match run_ktests(\n-        &crate::console::early_print,\n-        fn_catch_unwind,\n-        test_whitelist.map(|s| s.iter().map(|s| s.to_string())),\n-        crate_whitelist,\n-    ) {\n-        KtestResult::Ok => exit_qemu(QemuExitCode::Success),\n-        KtestResult::Failed => exit_qemu(QemuExitCode::Failed),\n-    };\n }\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -114,6 +119,7 @@ mod test {\n     use crate::prelude::*;\n \n     #[ktest]\n+    #[allow(clippy::eq_op)]\n     fn trivial_assertion() {\n         assert_eq!(0, 0);\n     }\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -131,8 +137,14 @@ mod test {\n     }\n }\n \n-/// The module re-exports everything from the ktest crate\n-#[cfg(ktest)]\n+#[doc(hidden)]\n pub mod ktest {\n+    //! The module re-exports everything from the [`ostd_test`] crate, as well\n+    //! as the test entry point macro.\n+    //!\n+    //! It is rather discouraged to use the definitions here directly. The\n+    //! `ktest` attribute is sufficient for all normal use cases.\n+\n+    pub use ostd_macros::test_main as main;\n     pub use ostd_test::*;\n }\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -334,9 +334,10 @@ mod test {\n             .alloc_contiguous()\n             .unwrap();\n         let vm_segment_child = vm_segment_parent.range(0..1);\n-        let _dma_stream_parent =\n+        let dma_stream_parent =\n             DmaStream::map(vm_segment_parent, DmaDirection::Bidirectional, false);\n         let dma_stream_child = DmaStream::map(vm_segment_child, DmaDirection::Bidirectional, false);\n+        assert!(dma_stream_parent.is_ok());\n         assert!(dma_stream_child.is_err());\n     }\n \ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -313,24 +313,24 @@ mod test {\n     fn set_get() {\n         let bits = AtomicBits::new_zeroes(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n         }\n \n         let bits = AtomicBits::new_ones(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n         }\n     }\n \ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -389,9 +389,9 @@ mod test {\n     #[ktest]\n     fn iter() {\n         let bits = AtomicBits::new_zeroes(7);\n-        assert!(bits.iter().all(|bit| bit == false));\n+        assert!(bits.iter().all(|bit| !bit));\n \n         let bits = AtomicBits::new_ones(128);\n-        assert!(bits.iter().all(|bit| bit == true));\n+        assert!(bits.iter().all(|bit| bit));\n     }\n }\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -293,7 +293,7 @@ mod test {\n             Task::yield_now();\n \n             cond_cloned.store(true, Ordering::Relaxed);\n-            wake(&*queue_cloned);\n+            wake(&queue_cloned);\n         })\n         .data(())\n         .spawn()\ndiff --git a/ostd/src/task/task/mod.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task/mod.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -383,6 +383,7 @@ mod test {\n \n     #[ktest]\n     fn create_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\ndiff --git a/ostd/src/task/task/mod.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task/mod.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -395,6 +396,7 @@ mod test {\n \n     #[ktest]\n     fn spawn_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -98,6 +105,7 @@ ASTER_SRC_DIR=${SCRIPT_DIR}/..\n DOCS_DIR=${ASTER_SRC_DIR}/docs\n OSTD_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/Cargo.toml\n OSDK_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/Cargo.toml\n+OSTD_TEST_RUNNER_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/test-kernel/Cargo.toml\n VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n current_version=$(cat ${VERSION_PATH})\n",
        "problem_statement": "ktest as a kernel\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nWell, I want to make ktest as a kernel built on top of aster-frame (OSTD), and run as a kernel. Currently the ktest crate is a dependency of aster-frame, which leads to many problems such as:\r\n - a lot of runtime needed when running ktest, which need to be passed as parameters #834 ;\r\n - need to pass cfg to aster-frame when rebuilding the test #974 ;\r\n\r\nBy making ktest a kernel depending on aster-frame, which has it's entrypoint as `#[aster_main]` (`#[ostd::main]`), it works for all the above problems.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\n### Proposal\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\nOriginally the dependency chain of testing a target crate `A` is:\r\n\r\n```text\r\nktest <---------------- ostd <--- A <--- base_crate\r\n                       /         / \r\nktest_proc_macro <----'---------'\r\n```\r\n\r\nThe proposed one is:\r\n\r\n```text\r\n\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nInstead of a conditional compilation to choose the ktest entry point at `aster_frame::boot::call_aster_main`, the ktest entry point should be registered as **STRONG** `#[aster_main]`, while other kernel's `#[aster_main]` should be WEAK. So during linking, if the ktest main exist ktests will be excecuted, other wise kernel main would be executed.\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n",
        "hints_text": "This proposal aims to address to problems.\r\n\r\n> * a lot of runtime needed when running ktest, which need to be passed as parameters https://github.com/asterinas/asterinas/pull/834 ;\r\n> * need to pass cfg to aster-frame when rebuilding the test https://github.com/asterinas/asterinas/issues/974 ;\r\n\r\nI can see why this proposal is able to resolve the first problem. But why can it address the second?\n> The proposed one is:\r\n\r\n```plain\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nUsers don't need to be aware of the existence of the `ktest_proc_macro` and `ktest` crates, correct? The `ktest` crate is solely a dependency of the `base_crate`, and the `ktest_proc_macro` is now re-exported from `ostd`. Therefore, the crate A to be tested can only depend on `ostd`.\nDue to the current implementation of both `#[ostd::ktest]` and `ktest` relying on `KtestItem` and `KtestItemInfo`, we cannot directly move `ktest` above `ostd`.\r\n\r\nThe most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n\r\n```text\r\n\t\t            .-- ktest_run <---(if testing)---.\r\n\t\t            v                                 \\\r\n  ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n               \\\t  v            \r\n                .----->  ktest \r\n```\r\n\r\nAn alternative solution might be to place the parameters that originally needed to be wrapped in `KtestItem` into a `.ktest_array`, and then retrieve these parameters to generate `KtestItem` objects during execution. However, this might not be an elegant solution.\r\n\r\nI haven't been able to think of a better approach\u2639\ufe0f. Could you give me some input @junyang-zh ?\n> The most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n> \r\n> ```\r\n> \t\t            .-- ktest_run <---(if testing)---.\r\n> \t\t            v                                 \\\r\n>   ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n>                \\\t  v            \r\n>                 .----->  ktest \r\n> ```\r\n\r\nYour question makes sense. And the best solution I can think of is just like yours, splitting the crate into two.\r\n\r\nSo it seems that we are just making the ktest runner a kernel. The ktest item definitions are still a dependency of OSTD.",
        "created_at": "2024-08-13T11:21:28Z",
        "version": "0.7"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1158,
        "instance_id": "asterinas__asterinas-1158",
        "issue_numbers": [
            "1264"
        ],
        "base_commit": "c68302f7007225fa47f22a1085a8c59dcdae2ad4",
        "patch": "diff --git a/kernel/src/sched/priority_scheduler.rs b/kernel/src/sched/priority_scheduler.rs\n--- a/kernel/src/sched/priority_scheduler.rs\n+++ b/kernel/src/sched/priority_scheduler.rs\n@@ -50,12 +50,12 @@ impl<T: PreemptSchedInfo> PreemptScheduler<T> {\n         let mut minimum_load = usize::MAX;\n \n         for candidate in runnable.cpu_affinity().iter() {\n-            let rq = self.rq[candidate].lock();\n+            let rq = self.rq[candidate as usize].lock();\n             // A wild guess measuring the load of a runqueue. We assume that\n             // real-time tasks are 4-times as important as normal tasks.\n             let load = rq.real_time_entities.len() * 4 + rq.normal_entities.len();\n             if load < minimum_load {\n-                selected = candidate as u32;\n+                selected = candidate;\n                 minimum_load = load;\n             }\n         }\ndiff --git a/kernel/src/thread/work_queue/simple_scheduler.rs b/kernel/src/thread/work_queue/simple_scheduler.rs\n--- a/kernel/src/thread/work_queue/simple_scheduler.rs\n+++ b/kernel/src/thread/work_queue/simple_scheduler.rs\n@@ -24,12 +24,12 @@ impl WorkerScheduler for SimpleScheduler {\n     fn schedule(&self) {\n         let worker_pool = self.worker_pool.upgrade().unwrap();\n         for cpu_id in worker_pool.cpu_set().iter() {\n-            if !worker_pool.heartbeat(cpu_id as u32)\n-                && worker_pool.has_pending_work_items(cpu_id as u32)\n-                && !worker_pool.wake_worker(cpu_id as u32)\n-                && worker_pool.num_workers(cpu_id as u32) < WORKER_LIMIT\n+            if !worker_pool.heartbeat(cpu_id)\n+                && worker_pool.has_pending_work_items(cpu_id)\n+                && !worker_pool.wake_worker(cpu_id)\n+                && worker_pool.num_workers(cpu_id) < WORKER_LIMIT\n             {\n-                worker_pool.add_worker(cpu_id as u32);\n+                worker_pool.add_worker(cpu_id);\n             }\n         }\n     }\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -128,10 +128,7 @@ impl WorkerPool {\n         Arc::new_cyclic(|pool_ref| {\n             let mut local_pools = Vec::new();\n             for cpu_id in cpu_set.iter() {\n-                local_pools.push(Arc::new(LocalWorkerPool::new(\n-                    pool_ref.clone(),\n-                    cpu_id as u32,\n-                )));\n+                local_pools.push(Arc::new(LocalWorkerPool::new(pool_ref.clone(), cpu_id)));\n             }\n             WorkerPool {\n                 local_pools,\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -336,7 +336,7 @@ impl Vmar_ {\n         if !self.is_root_vmar() {\n             return_errno_with_message!(Errno::EACCES, \"The vmar is not root vmar\");\n         }\n-        self.vm_space.clear();\n+        self.clear_vm_space();\n         let mut inner = self.inner.lock();\n         inner.child_vmar_s.clear();\n         inner.vm_mappings.clear();\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -346,6 +346,13 @@ impl Vmar_ {\n         Ok(())\n     }\n \n+    fn clear_vm_space(&self) {\n+        let start = ROOT_VMAR_LOWEST_ADDR;\n+        let end = ROOT_VMAR_CAP_ADDR;\n+        let mut cursor = self.vm_space.cursor_mut(&(start..end)).unwrap();\n+        cursor.unmap(end - start);\n+    }\n+\n     pub fn destroy(&self, range: Range<usize>) -> Result<()> {\n         self.check_destroy_range(&range)?;\n         let mut inner = self.inner.lock();\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -167,16 +167,6 @@ impl VmMapping {\n         self.vmo.as_ref()\n     }\n \n-    /// Adds a new committed page and map it to vmspace. If copy on write is set, it's allowed to unmap the page at the same address.\n-    /// FIXME: This implementation based on the truth that we map one page at a time. If multiple pages are mapped together, this implementation may have problems\n-    fn map_one_page(&self, map_addr: usize, frame: Frame, is_readonly: bool) -> Result<()> {\n-        let parent = self.parent.upgrade().unwrap();\n-        let vm_space = parent.vm_space();\n-        self.inner\n-            .lock()\n-            .map_one_page(vm_space, map_addr, frame, is_readonly)\n-    }\n-\n     /// Returns the mapping's start address.\n     pub fn map_to_addr(&self) -> Vaddr {\n         self.inner.lock().map_to_addr\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -193,11 +183,6 @@ impl VmMapping {\n         self.inner.lock().map_size\n     }\n \n-    /// Returns the mapping's offset in the VMO.\n-    pub fn vmo_offset(&self) -> Option<usize> {\n-        self.inner.lock().vmo_offset\n-    }\n-\n     /// Unmaps pages in the range\n     pub fn unmap(&self, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let parent = self.parent.upgrade().unwrap();\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -234,43 +219,84 @@ impl VmMapping {\n \n         let page_aligned_addr = page_fault_addr.align_down(PAGE_SIZE);\n \n+        let root_vmar = self.parent.upgrade().unwrap();\n+        let mut cursor = root_vmar\n+            .vm_space()\n+            .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n+        let current_mapping = cursor.query().unwrap();\n+\n+        // Perform COW if it is a write access to a shared mapping.\n         if write && !not_present {\n-            // Perform COW at page table.\n-            let root_vmar = self.parent.upgrade().unwrap();\n-            let mut cursor = root_vmar\n-                .vm_space()\n-                .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n             let VmItem::Mapped {\n                 va: _,\n                 frame,\n                 mut prop,\n-            } = cursor.query().unwrap()\n+            } = current_mapping\n             else {\n                 return Err(Error::new(Errno::EFAULT));\n             };\n \n-            if self.is_shared {\n+            // Skip if the page fault is already handled.\n+            if prop.flags.contains(PageFlags::W) {\n+                return Ok(());\n+            }\n+\n+            // If the forked child or parent immediately unmaps the page after\n+            // the fork without accessing it, we are the only reference to the\n+            // frame. We can directly map the frame as writable without\n+            // copying. In this case, the reference count of the frame is 2 (\n+            // one for the mapping and one for the frame handle itself).\n+            let only_reference = frame.reference_count() == 2;\n+\n+            if self.is_shared || only_reference {\n                 cursor.protect(PAGE_SIZE, |p| p.flags |= PageFlags::W);\n             } else {\n                 let new_frame = duplicate_frame(&frame)?;\n-                prop.flags |= PageFlags::W;\n+                prop.flags |= PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n                 cursor.map(new_frame, prop);\n             }\n             return Ok(());\n         }\n \n-        let (frame, is_readonly) = self.prepare_page(page_fault_addr, write)?;\n+        // Map a new frame to the page fault address.\n+        // Skip if the page fault is already handled.\n+        if let VmItem::NotMapped { .. } = current_mapping {\n+            let inner_lock = self.inner.lock();\n+            let (frame, is_readonly) = self.prepare_page(&inner_lock, page_fault_addr, write)?;\n+\n+            let vm_perms = {\n+                let mut perms = inner_lock.perms;\n+                if is_readonly {\n+                    // COW pages are forced to be read-only.\n+                    perms -= VmPerms::WRITE;\n+                }\n+                perms\n+            };\n+            let mut page_flags = vm_perms.into();\n+            page_flags |= PageFlags::ACCESSED;\n+            if write {\n+                page_flags |= PageFlags::DIRTY;\n+            }\n+            let map_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n+\n+            cursor.map(frame, map_prop);\n+        }\n \n-        self.map_one_page(page_aligned_addr, frame, is_readonly)\n+        Ok(())\n     }\n \n-    fn prepare_page(&self, page_fault_addr: Vaddr, write: bool) -> Result<(Frame, bool)> {\n+    fn prepare_page(\n+        &self,\n+        inner_lock: &MutexGuard<VmMappingInner>,\n+        page_fault_addr: Vaddr,\n+        write: bool,\n+    ) -> Result<(Frame, bool)> {\n         let mut is_readonly = false;\n         let Some(vmo) = &self.vmo else {\n             return Ok((FrameAllocOptions::new(1).alloc_single()?, is_readonly));\n         };\n \n-        let vmo_offset = self.vmo_offset().unwrap() + page_fault_addr - self.map_to_addr();\n+        let vmo_offset = inner_lock.vmo_offset.unwrap() + page_fault_addr - inner_lock.map_to_addr;\n         let page_idx = vmo_offset / PAGE_SIZE;\n         let Ok(page) = vmo.get_committed_frame(page_idx) else {\n             if !self.is_shared {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -314,14 +340,18 @@ impl VmMapping {\n         );\n \n         let vm_perms = inner.perms - VmPerms::WRITE;\n-        let vm_map_options = { PageProperty::new(vm_perms.into(), CachePolicy::Writeback) };\n         let parent = self.parent.upgrade().unwrap();\n         let vm_space = parent.vm_space();\n         let mut cursor = vm_space.cursor_mut(&(start_addr..end_addr))?;\n         let operate = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n-            if let VmItem::NotMapped { .. } = cursor.query().unwrap() {\n+            if let VmItem::NotMapped { va, len } = cursor.query().unwrap() {\n+                let mut page_flags = vm_perms.into();\n+                if (va..len).contains(&page_fault_addr) {\n+                    page_flags |= PageFlags::ACCESSED;\n+                }\n+                let page_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n                 let frame = commit_fn()?;\n-                cursor.map(frame, vm_map_options);\n+                cursor.map(frame, page_prop);\n             } else {\n                 let next_addr = cursor.virt_addr() + PAGE_SIZE;\n                 if next_addr < end_addr {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -507,30 +537,6 @@ impl VmMapping {\n }\n \n impl VmMappingInner {\n-    fn map_one_page(\n-        &mut self,\n-        vm_space: &VmSpace,\n-        map_addr: usize,\n-        frame: Frame,\n-        is_readonly: bool,\n-    ) -> Result<()> {\n-        let map_range = map_addr..map_addr + PAGE_SIZE;\n-\n-        let vm_perms = {\n-            let mut perms = self.perms;\n-            if is_readonly {\n-                // COW pages are forced to be read-only.\n-                perms -= VmPerms::WRITE;\n-            }\n-            perms\n-        };\n-        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n-\n-        let mut cursor = vm_space.cursor_mut(&map_range).unwrap();\n-        cursor.map(frame, map_prop);\n-        Ok(())\n-    }\n-\n     /// Unmap pages in the range.\n     fn unmap(&mut self, vm_space: &VmSpace, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let map_addr = range.start.align_down(PAGE_SIZE);\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -150,7 +150,7 @@ fn send_startup_to_all_aps() {\n         (AP_BOOT_START_PA / PAGE_SIZE) as u8,\n     );\n     // SAFETY: we are sending startup IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_to_all_aps() {\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -165,7 +165,7 @@ fn send_init_to_all_aps() {\n         0,\n     );\n     // SAFETY: we are sending init IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_deassert() {\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -180,7 +180,7 @@ fn send_init_deassert() {\n         0,\n     );\n     // SAFETY: we are sending deassert IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n /// Spin wait approximately `c` cycles.\ndiff --git a/ostd/src/arch/x86/irq.rs b/ostd/src/arch/x86/irq.rs\n--- a/ostd/src/arch/x86/irq.rs\n+++ b/ostd/src/arch/x86/irq.rs\n@@ -153,3 +153,27 @@ impl Drop for IrqCallbackHandle {\n         CALLBACK_ID_ALLOCATOR.get().unwrap().lock().free(self.id);\n     }\n }\n+\n+/// Sends a general inter-processor interrupt (IPI) to the specified CPU.\n+///\n+/// # Safety\n+///\n+/// The caller must ensure that the CPU ID and the interrupt number corresponds\n+/// to a safe function to call.\n+pub(crate) unsafe fn send_ipi(cpu_id: u32, irq_num: u8) {\n+    use crate::arch::kernel::apic::{self, Icr};\n+\n+    let icr = Icr::new(\n+        apic::ApicId::from(cpu_id),\n+        apic::DestinationShorthand::NoShorthand,\n+        apic::TriggerMode::Edge,\n+        apic::Level::Assert,\n+        apic::DeliveryStatus::Idle,\n+        apic::DestinationMode::Physical,\n+        apic::DeliveryMode::Fixed,\n+        irq_num,\n+    );\n+    apic::with_borrow(|apic| {\n+        apic.send_ipi(icr);\n+    });\n+}\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -13,7 +13,7 @@ pub mod x2apic;\n pub mod xapic;\n \n cpu_local! {\n-    static APIC_INSTANCE: Once<RefCell<Box<dyn Apic + 'static>>> = Once::new();\n+    static APIC_INSTANCE: RefCell<Option<Box<dyn Apic + 'static>>> = RefCell::new(None);\n }\n \n static APIC_TYPE: Once<ApicType> = Once::new();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -24,23 +24,29 @@ static APIC_TYPE: Once<ApicType> = Once::new();\n /// local APIC instance. During the execution of the closure, the interrupts\n /// are guaranteed to be disabled.\n ///\n+/// This function also lazily initializes the Local APIC instance. It does\n+/// enable the Local APIC if it is not enabled.\n+///\n /// Example:\n /// ```rust\n /// use ostd::arch::x86::kernel::apic;\n ///\n-/// let ticks = apic::borrow(|apic| {\n+/// let ticks = apic::with_borrow(|apic| {\n ///     let ticks = apic.timer_current_count();\n ///     apic.set_timer_init_count(0);\n ///     ticks\n /// });\n /// ```\n-pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n+pub fn with_borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n     let irq_guard = crate::trap::disable_local();\n     let apic_guard = APIC_INSTANCE.get_with(&irq_guard);\n+    let mut apic_init_ref = apic_guard.borrow_mut();\n \n     // If it is not initialized, lazily initialize it.\n-    if !apic_guard.is_completed() {\n-        apic_guard.call_once(|| match APIC_TYPE.get().unwrap() {\n+    let apic_ref = if let Some(apic_ref) = apic_init_ref.as_mut() {\n+        apic_ref\n+    } else {\n+        *apic_init_ref = Some(match APIC_TYPE.get().unwrap() {\n             ApicType::XApic => {\n                 let mut xapic = xapic::XApic::new().unwrap();\n                 xapic.enable();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -51,7 +57,7 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(xapic))\n+                Box::new(xapic)\n             }\n             ApicType::X2Apic => {\n                 let mut x2apic = x2apic::X2Apic::new().unwrap();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -63,13 +69,12 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(x2apic))\n+                Box::new(x2apic)\n             }\n         });\n-    }\n \n-    let apic_cell = apic_guard.get().unwrap();\n-    let mut apic_ref = apic_cell.borrow_mut();\n+        apic_init_ref.as_mut().unwrap()\n+    };\n \n     let ret = f.call_once((apic_ref.as_mut(),));\n \ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -238,7 +243,6 @@ impl From<u32> for ApicId {\n /// in the system excluding the sender.\n #[repr(u64)]\n pub enum DestinationShorthand {\n-    #[allow(dead_code)]\n     NoShorthand = 0b00,\n     #[allow(dead_code)]\n     MySelf = 0b01,\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -278,7 +282,6 @@ pub enum DestinationMode {\n #[repr(u64)]\n pub enum DeliveryMode {\n     /// Delivers the interrupt specified in the vector field to the target processor or processors.\n-    #[allow(dead_code)]\n     Fixed = 0b000,\n     /// Same as fixed mode, except that the interrupt is delivered to the processor executing at\n     /// the lowest priority among the set of processors specified in the destination field. The\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -108,10 +108,21 @@ pub(crate) fn init_on_bsp() {\n     kernel::pic::init();\n }\n \n+/// Architecture-specific initialization on the application processor.\n+///\n+/// # Safety\n+///\n+/// This function must be called only once on each application processor.\n+/// And it should be called after the BSP's call to [`init_on_bsp`].\n+pub(crate) unsafe fn init_on_ap() {\n+    // Trigger the initialization of the local APIC.\n+    crate::arch::x86::kernel::apic::with_borrow(|_| {});\n+}\n+\n pub(crate) fn interrupts_ack(irq_number: usize) {\n     if !cpu::CpuException::is_cpu_exception(irq_number as u16) {\n         kernel::pic::ack();\n-        kernel::apic::borrow(|apic| {\n+        kernel::apic::with_borrow(|apic| {\n             apic.eoi();\n         });\n     }\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -54,7 +54,7 @@ fn is_tsc_deadline_mode_supported() -> bool {\n fn init_tsc_mode() -> IrqLine {\n     let timer_irq = IrqLine::alloc().unwrap();\n     // Enable tsc deadline mode\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 18));\n     });\n     let tsc_step = TSC_FREQ.load(Ordering::Relaxed) / TIMER_FREQ;\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -81,7 +81,7 @@ fn init_periodic_mode() -> IrqLine {\n     super::pit::enable_ioapic_line(irq.clone());\n \n     // Set APIC timer count\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_div_config(DivideConfig::Divide64);\n         apic.set_timer_init_count(0xFFFF_FFFF);\n     });\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -99,7 +99,7 @@ fn init_periodic_mode() -> IrqLine {\n     // Init APIC Timer\n     let timer_irq = IrqLine::alloc().unwrap();\n \n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_init_count(INIT_COUNT.load(Ordering::Relaxed));\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 17));\n         apic.set_timer_div_config(DivideConfig::Divide64);\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -115,7 +115,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || IS_FINISH.load(Ordering::Acquire) {\n             if IN_TIME.load(Ordering::Relaxed) == 0 {\n-                let remain_ticks = apic::borrow(|apic| apic.timer_current_count());\n+                let remain_ticks = apic::with_borrow(|apic| apic.timer_current_count());\n                 APIC_FIRST_COUNT.store(0xFFFF_FFFF - remain_ticks, Ordering::Relaxed);\n             }\n             IN_TIME.fetch_add(1, Ordering::Relaxed);\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -124,7 +124,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         // Stop PIT and APIC Timer\n         super::pit::disable_ioapic_line();\n-        let remain_ticks = apic::borrow(|apic| {\n+        let remain_ticks = apic::with_borrow(|apic| {\n             let remain_ticks = apic.timer_current_count();\n             apic.set_timer_init_count(0);\n             remain_ticks\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -123,6 +123,13 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     unsafe {\n         trapframe::init();\n     }\n+\n+    // SAFETY: this function is only called once on this AP, after the BSP has\n+    // done the architecture-specific initialization.\n+    unsafe {\n+        crate::arch::init_on_ap();\n+    }\n+\n     crate::arch::irq::enable_local();\n \n     // SAFETY: this function is only called once on this AP.\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -10,12 +10,7 @@ cfg_if::cfg_if! {\n     }\n }\n \n-use alloc::vec::Vec;\n-\n-use bitvec::{\n-    prelude::{BitVec, Lsb0},\n-    slice::IterOnes,\n-};\n+use bitvec::prelude::BitVec;\n use local::cpu_local_cell;\n use spin::Once;\n \ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -122,13 +117,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, true);\n     }\n \n-    /// Adds a list of CPUs to the set.\n-    pub fn add_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.add(cpu_id)\n-        }\n-    }\n-\n     /// Adds all CPUs to the set.\n     pub fn add_all(&mut self) {\n         self.bitset.fill(true);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -139,13 +127,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, false);\n     }\n \n-    /// Removes a list of CPUs from the set.\n-    pub fn remove_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.remove(cpu_id);\n-        }\n-    }\n-\n     /// Removes all CPUs from the set.\n     pub fn clear(&mut self) {\n         self.bitset.fill(false);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -162,8 +143,8 @@ impl CpuSet {\n     }\n \n     /// Iterates over the CPUs in the set.\n-    pub fn iter(&self) -> IterOnes<'_, usize, Lsb0> {\n-        self.bitset.iter_ones()\n+    pub fn iter(&self) -> impl Iterator<Item = u32> + '_ {\n+        self.bitset.iter_ones().map(|idx| idx as u32)\n     }\n }\n \ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -39,6 +39,7 @@ pub mod logger;\n pub mod mm;\n pub mod panicking;\n pub mod prelude;\n+pub mod smp;\n pub mod sync;\n pub mod task;\n pub mod trap;\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -90,6 +91,8 @@ pub unsafe fn init() {\n     unsafe { trap::softirq::init() };\n     arch::init_on_bsp();\n \n+    smp::init();\n+\n     bus::init();\n \n     // SAFETY: This function is called only once on the BSP.\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -80,6 +80,21 @@ impl Frame {\n             core::ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.size());\n         }\n     }\n+\n+    /// Get the reference count of the frame.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Frame`]) and all the mappings in the page\n+    /// table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.page.reference_count()\n+    }\n }\n \n impl From<Page<FrameMeta>> for Frame {\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -156,7 +156,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n         for meta_page in meta_pages {\n             // SAFETY: we are doing the metadata mappings for the kernel.\n             unsafe {\n-                cursor.map(meta_page.into(), prop);\n+                let _old = cursor.map(meta_page.into(), prop);\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -199,7 +199,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n             let page = Page::<KernelMeta>::from_unused(frame_paddr, KernelMeta::default());\n             // SAFETY: we are doing mappings for the kernel.\n             unsafe {\n-                cursor.map(page.into(), prop);\n+                let _old = cursor.map(page.into(), prop);\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -164,6 +164,21 @@ impl<M: PageMeta> Page<M> {\n         unsafe { &*(self.ptr as *const M) }\n     }\n \n+    /// Get the reference count of the page.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Page`], [`DynPage`]), and all the mappings in the\n+    /// page table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.ref_count().load(Ordering::Relaxed)\n+    }\n+\n     fn ref_count(&self) -> &AtomicU32 {\n         unsafe { &(*self.ptr).ref_count }\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -73,7 +73,10 @@ use super::{\n     page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n-use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n+use crate::{\n+    mm::{page::DynPage, Paddr, PageProperty, Vaddr},\n+    task::{disable_preempt, DisabledPreemptGuard},\n+};\n \n #[derive(Clone, Debug)]\n pub enum PageTableItem {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -125,7 +128,8 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n-    phantom: PhantomData<&'a PageTable<M, E, C>>,\n+    preempt_guard: DisabledPreemptGuard,\n+    _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\n \n impl<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait> Cursor<'a, M, E, C>\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -162,7 +166,8 @@ where\n             guard_level: C::NR_LEVELS,\n             va: va.start,\n             barrier_va: va.clone(),\n-            phantom: PhantomData,\n+            preempt_guard: disable_preempt(),\n+            _phantom: PhantomData,\n         };\n \n         // Go down and get proper locks. The cursor should hold a lock of a\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -204,37 +209,28 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            let pte = self.read_cur_pte();\n-            if !pte.is_present() {\n-                return Ok(PageTableItem::NotMapped {\n-                    va,\n-                    len: page_size::<C>(level),\n-                });\n-            }\n-            if !pte.is_last(level) {\n-                self.level_down();\n-                continue;\n-            }\n-\n             match self.cur_child() {\n-                Child::Page(page) => {\n-                    return Ok(PageTableItem::Mapped {\n+                Child::PageTable(_) => {\n+                    self.level_down();\n+                    continue;\n+                }\n+                Child::None => {\n+                    return Ok(PageTableItem::NotMapped {\n                         va,\n-                        page,\n-                        prop: pte.prop(),\n+                        len: page_size::<C>(level),\n                     });\n                 }\n-                Child::Untracked(pa) => {\n+                Child::Page(page, prop) => {\n+                    return Ok(PageTableItem::Mapped { va, page, prop });\n+                }\n+                Child::Untracked(pa, prop) => {\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\n-                        prop: pte.prop(),\n+                        prop,\n                     });\n                 }\n-                Child::None | Child::PageTable(_) => {\n-                    unreachable!(); // Already checked with the PTE.\n-                }\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -289,6 +285,10 @@ where\n         self.va\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.preempt_guard\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -423,6 +423,8 @@ where\n \n     /// Maps the range starting from the current address to a [`DynPage`].\n     ///\n+    /// It returns the previously mapped [`DynPage`] if that exists.\n+    ///\n     /// # Panics\n     ///\n     /// This function will panic if\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -434,7 +436,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -458,8 +460,19 @@ where\n \n         // Map the current page.\n         let idx = self.0.cur_idx();\n-        self.cur_node_mut().set_child_page(idx, page, prop);\n+        let old = self\n+            .cur_node_mut()\n+            .replace_child(idx, Child::Page(page, prop), true);\n         self.0.move_forward();\n+\n+        match old {\n+            Child::Page(old_page, _) => Some(old_page),\n+            Child::None => None,\n+            Child::PageTable(_) => {\n+                todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n+            }\n+            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+        }\n     }\n \n     /// Maps the range starting from the current address to a physical address range.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -520,7 +533,9 @@ where\n             // Map the current page.\n             debug_assert!(!self.0.in_tracked_range());\n             let idx = self.0.cur_idx();\n-            self.cur_node_mut().set_child_untracked(idx, pa, prop);\n+            let _ = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::Untracked(pa, prop), false);\n \n             let level = self.0.level;\n             pa += page_size::<C>(level);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -605,23 +620,25 @@ where\n \n             // Unmap the current page and return it.\n             let idx = self.0.cur_idx();\n-            let ret = self.cur_node_mut().take_child(idx, is_tracked);\n+            let ret = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::None, is_tracked);\n             let ret_page_va = self.0.va;\n             let ret_page_size = page_size::<C>(self.0.level);\n \n             self.0.move_forward();\n \n             return match ret {\n-                Child::Page(page) => PageTableItem::Mapped {\n+                Child::Page(page, prop) => PageTableItem::Mapped {\n                     va: ret_page_va,\n                     page,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n-                Child::Untracked(pa) => PageTableItem::MappedUntracked {\n+                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n                     va: ret_page_va,\n                     pa,\n                     len: ret_page_size,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n                 Child::None | Child::PageTable(_) => unreachable!(),\n             };\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -717,6 +734,10 @@ where\n         None\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.0.preempt_guard\n+    }\n+\n     /// Consumes itself and leak the root guard for the caller if it locked the root level.\n     ///\n     /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -743,8 +764,12 @@ where\n         let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n         let idx = self.0.cur_idx();\n         let is_tracked = self.0.in_tracked_range();\n-        self.cur_node_mut()\n-            .set_child_pt(idx, new_node.clone_raw(), is_tracked);\n+        let old = self.cur_node_mut().replace_child(\n+            idx,\n+            Child::PageTable(new_node.clone_raw()),\n+            is_tracked,\n+        );\n+        debug_assert!(old.is_none());\n         self.0.level -= 1;\n         self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n     }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -162,7 +162,11 @@ impl PageTable<KernelMode> {\n         for i in start..end {\n             if !root_node.read_pte(i).is_present() {\n                 let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                root_node.set_child_pt(i, node.into_raw(), i < NR_PTES_PER_NODE * 3 / 4);\n+                let _ = root_node.replace_child(\n+                    i,\n+                    Child::PageTable(node.into_raw()),\n+                    i < NR_PTES_PER_NODE * 3 / 4,\n+                );\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -42,7 +42,6 @@ use crate::{\n         page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n-    task::{disable_preempt, DisabledPreemptGuard},\n };\n \n /// The raw handle to a page table node.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -80,8 +79,6 @@ where\n         // count is needed.\n         let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n \n-        let disable_preempt = disable_preempt();\n-\n         // Acquire the lock.\n         while page\n             .meta()\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -92,10 +89,7 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> {\n-            page,\n-            preempt_guard: disable_preempt,\n-        }\n+        PageTableNode::<E, C> { page, _private: () }\n     }\n \n     /// Creates a copy of the handle.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -190,7 +184,7 @@ pub(super) struct PageTableNode<\n     [(); C::NR_LEVELS as usize]:,\n {\n     pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    preempt_guard: DisabledPreemptGuard,\n+    _private: (),\n }\n \n // FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -215,12 +209,21 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage),\n+    Page(DynPage, PageProperty),\n     /// Pages not tracked by handles.\n-    Untracked(Paddr),\n+    Untracked(Paddr, PageProperty),\n     None,\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    pub(super) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -241,10 +244,7 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self {\n-            page,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { page, _private: () }\n     }\n \n     pub fn level(&self) -> PagingLevel {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -253,16 +253,11 @@ where\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n-        let mut this = ManuallyDrop::new(self);\n+        let this = ManuallyDrop::new(self);\n \n         let raw = this.page.paddr();\n \n         this.page.meta().lock.store(0, Ordering::Release);\n-        // SAFETY: The field will no longer be accessed and we need to drop the field to release\n-        // the preempt count.\n-        unsafe {\n-            core::ptr::drop_in_place(&mut this.preempt_guard);\n-        }\n \n         RawPageTableNode {\n             raw,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -300,40 +295,82 @@ where\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n+                // SAFETY: We have a reference count to the page and can safely\n+                // increase the reference count by one more.\n                 unsafe {\n                     DynPage::inc_ref_count(paddr);\n                 }\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the PTE points to a forgotten\n+                // page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, pte.prop())\n             }\n         }\n     }\n \n-    /// Remove the child at the given index and return it.\n-    pub(super) fn take_child(&mut self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n+    /// Replace the child at the given index with a new child.\n+    ///\n+    /// The old child is returned.\n+    pub(super) fn replace_child(\n+        &mut self,\n+        idx: usize,\n+        new_child: Child<E, C>,\n+        in_tracked_range: bool,\n+    ) -> Child<E, C> {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n \n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            let is_last = pte.is_last(self.level());\n-            *self.nr_children_mut() -= 1;\n-            self.write_pte(idx, E::new_absent());\n-            if !is_last {\n+        let old_pte = self.read_pte(idx);\n+\n+        let new_child_is_none = match new_child {\n+            Child::None => {\n+                if old_pte.is_present() {\n+                    self.write_pte(idx, E::new_absent());\n+                }\n+                true\n+            }\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                let new_pte = E::new_pt(pt.paddr());\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Page(page, prop) => {\n+                debug_assert!(in_tracked_range);\n+                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Untracked(pa, prop) => {\n+                debug_assert!(!in_tracked_range);\n+                let new_pte = E::new_page(pa, self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+        };\n+\n+        if old_pte.is_present() {\n+            if new_child_is_none {\n+                *self.nr_children_mut() -= 1;\n+            }\n+            let paddr = old_pte.paddr();\n+            if !old_pte.is_last(self.level()) {\n                 Child::PageTable(RawPageTableNode {\n                     raw: paddr,\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the old PTE points to a\n+                // forgotten page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, old_pte.prop())\n+            }\n+        } else {\n+            if !new_child_is_none {\n+                *self.nr_children_mut() += 1;\n             }\n+            Child::None\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -364,16 +401,17 @@ where\n                 Child::PageTable(pt) => {\n                     let guard = pt.clone_shallow().lock();\n                     let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    new_pt.set_child_pt(i, new_child.into_raw(), true);\n+                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n-                Child::Page(page) => {\n-                    let prop = self.read_pte_prop(i);\n-                    new_pt.set_child_page(i, page.clone(), prop);\n+                Child::Page(page, prop) => {\n+                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Untracked(_) => {\n+                Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -386,11 +424,16 @@ where\n             debug_assert_eq!(self.level(), C::NR_LEVELS);\n             match self.child(i, /*meaningless*/ true) {\n                 Child::PageTable(pt) => {\n-                    new_pt.set_child_pt(i, pt.clone_shallow(), /*meaningless*/ true);\n+                    let old = new_pt.replace_child(\n+                        i,\n+                        Child::PageTable(pt.clone_shallow()),\n+                        /*meaningless*/ true,\n+                    );\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Page(_) | Child::Untracked(_) => {\n+                Child::Page(_, _) | Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -399,73 +442,23 @@ where\n         new_pt\n     }\n \n-    /// Sets a child page table at a given index.\n-    pub(super) fn set_child_pt(\n-        &mut self,\n-        idx: usize,\n-        pt: RawPageTableNode<E, C>,\n-        in_tracked_range: bool,\n-    ) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // The ownership is transferred to a raw PTE. Don't drop the handle.\n-        let pt = ManuallyDrop::new(pt);\n-\n-        let pte = Some(E::new_pt(pt.paddr()));\n-        self.overwrite_pte(idx, pte, in_tracked_range);\n-    }\n-\n-    /// Map a page at a given index.\n-    pub(super) fn set_child_page(&mut self, idx: usize, page: DynPage, prop: PageProperty) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert_eq!(page.level(), self.level());\n-\n-        // Use the physical address rather than the page handle to track\n-        // the page, and record the physical address in the PTE.\n-        let pte = Some(E::new_page(page.into_raw(), self.level(), prop));\n-        self.overwrite_pte(idx, pte, true);\n-    }\n-\n-    /// Sets an untracked child page at a given index.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller must ensure that the physical address is valid and safe to map.\n-    pub(super) unsafe fn set_child_untracked(&mut self, idx: usize, pa: Paddr, prop: PageProperty) {\n-        // It should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = Some(E::new_page(pa, self.level(), prop));\n-        self.overwrite_pte(idx, pte, false);\n-    }\n-\n-    /// Reads the info from a page table entry at a given index.\n-    pub(super) fn read_pte_prop(&self, idx: usize) -> PageProperty {\n-        self.read_pte(idx).prop()\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n         debug_assert!(self.level() > 1);\n \n-        let Child::Untracked(pa) = self.child(idx, false) else {\n+        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n             panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n         };\n-        let prop = self.read_pte_prop(idx);\n \n         let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n         for i in 0..nr_subpage_per_huge::<C>() {\n             let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            // SAFETY: the index is within the bound and either physical address and\n-            // the property are valid.\n-            unsafe { new_page.set_child_untracked(i, small_pa, prop) };\n+            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n         }\n \n-        self.set_child_pt(idx, new_page.into_raw(), false);\n+        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n     }\n \n     /// Protects an already mapped child at a given index.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -512,47 +505,6 @@ where\n         unsafe { &mut *self.meta().nr_children.get() }\n     }\n \n-    /// Replaces a page table entry at a given index.\n-    ///\n-    /// This method will ensure that the child presented by the overwritten\n-    /// PTE is dropped, and the child count is updated.\n-    ///\n-    /// The caller in this module will ensure that the PTE points to initialized\n-    /// memory if the child is a page table.\n-    fn overwrite_pte(&mut self, idx: usize, pte: Option<E>, in_tracked_range: bool) {\n-        let existing_pte = self.read_pte(idx);\n-\n-        if existing_pte.is_present() {\n-            self.write_pte(idx, pte.unwrap_or(E::new_absent()));\n-\n-            // Drop the child. We must set the PTE before dropping the child.\n-            // Just restore the handle and drop the handle.\n-\n-            let paddr = existing_pte.paddr();\n-            // SAFETY: Both the `from_raw` operations here are safe as the physical\n-            // address is valid and casted from a handle.\n-            unsafe {\n-                if !existing_pte.is_last(self.level()) {\n-                    // This is a page table.\n-                    drop(Page::<PageTablePageMeta<E, C>>::from_raw(paddr));\n-                } else if in_tracked_range {\n-                    // This is a frame.\n-                    drop(DynPage::from_raw(paddr));\n-                }\n-            }\n-\n-            // Update the child count.\n-            if pte.is_none() {\n-                *self.nr_children_mut() -= 1;\n-            }\n-        } else if let Some(e) = pte {\n-            // SAFETY: This is safe as described in the above branch.\n-            unsafe { (self.as_ptr() as *mut E).add(idx).write(e) };\n-\n-            *self.nr_children_mut() += 1;\n-        }\n-    }\n-\n     fn as_ptr(&self) -> *const E {\n         paddr_to_vaddr(self.start_paddr()) as *const E\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,29 +9,31 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use core::ops::Range;\n+use alloc::collections::vec_deque::VecDeque;\n+use core::{\n+    ops::Range,\n+    sync::atomic::{AtomicPtr, Ordering},\n+};\n \n use spin::Once;\n \n use super::{\n     io::Fallible,\n     kspace::KERNEL_PAGE_TABLE,\n+    page::DynPage,\n     page_table::{PageTable, UserMode},\n     PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n };\n use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr, tlb_flush_addr_range,\n-        tlb_flush_all_excluding_global, PageTableEntry, PagingConsts,\n-    },\n-    cpu::{CpuExceptionInfo, CpuSet, PinCurrentCpu},\n-    cpu_local_cell,\n+    arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n+    cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n+    cpu_local,\n     mm::{\n         page_table::{self, PageTableItem},\n         Frame, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::SpinLock,\n+    sync::{RwLock, RwLockReadGuard, SpinLock},\n     task::disable_preempt,\n     Error,\n };\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -55,28 +57,18 @@ use crate::{\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-    /// The CPUs that the `VmSpace` is activated on.\n-    ///\n-    /// TODO: implement an atomic bitset to optimize the performance in cases\n-    /// that the number of CPUs is not large.\n-    activated_cpus: SpinLock<CpuSet>,\n+    /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n+    /// Cursors hold read locks and activation require a write lock.\n+    activation_lock: RwLock<()>,\n }\n \n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n impl VmSpace {\n     /// Creates a new VM address space.\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n             page_fault_handler: Once::new(),\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -102,74 +94,64 @@ impl VmSpace {\n     /// The creation of the cursor may block if another cursor having an\n     /// overlapping range is alive. The modification to the mapping by the\n     /// cursor may also block or be overridden the mapping of another cursor.\n-    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n-        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_, '_>> {\n+        Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n+            let activation_lock = self.activation_lock.read();\n+\n+            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n+\n+            let mut activated_cpus = CpuSet::new_empty();\n+            let mut need_self_flush = false;\n+            let mut need_remote_flush = false;\n+\n+            for cpu in 0..num_cpus() {\n+                // The activation lock is held; other CPUs cannot activate this `VmSpace`.\n+                let ptr =\n+                    ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n+                if ptr == self as *const VmSpace {\n+                    activated_cpus.add(cpu);\n+                    if cpu == cur_cpu {\n+                        need_self_flush = true;\n+                    } else {\n+                        need_remote_flush = true;\n+                    }\n+                }\n+            }\n+\n+            CursorMut {\n+                pt_cursor,\n+                activation_lock,\n+                activated_cpus,\n+                need_remote_flush,\n+                need_self_flush,\n+            }\n+        })?)\n     }\n \n     /// Activates the page table on the current CPU.\n     pub(crate) fn activate(self: &Arc<Self>) {\n-        cpu_local_cell! {\n-            /// The `Arc` pointer to the last activated VM space on this CPU. If the\n-            /// pointer is NULL, it means that the last activated page table is merely\n-            /// the kernel page table.\n-            static LAST_ACTIVATED_VM_SPACE: *const VmSpace = core::ptr::null();\n-        }\n-\n         let preempt_guard = disable_preempt();\n \n-        let mut activated_cpus = self.activated_cpus.lock();\n-        let cpu = preempt_guard.current_cpu();\n+        // Ensure no mutable cursors (which holds read locks) are alive.\n+        let _activation_lock = self.activation_lock.write();\n \n-        if !activated_cpus.contains(cpu) {\n-            activated_cpus.add(cpu);\n-            self.pt.activate();\n+        let cpu = preempt_guard.current_cpu();\n+        let activated_vm_space = ACTIVATED_VM_SPACE.get_on_cpu(cpu);\n \n-            let last_ptr = LAST_ACTIVATED_VM_SPACE.load();\n+        let last_ptr = activated_vm_space.load(Ordering::Relaxed) as *const VmSpace;\n \n+        if last_ptr != Arc::as_ptr(self) {\n+            self.pt.activate();\n+            let ptr = Arc::into_raw(Arc::clone(self)) as *mut VmSpace;\n+            activated_vm_space.store(ptr, Ordering::Relaxed);\n             if !last_ptr.is_null() {\n-                // SAFETY: If the pointer is not NULL, it must be a valid\n-                // pointer casted with `Arc::into_raw` on the last activated\n-                // `Arc<VmSpace>`.\n-                let last = unsafe { Arc::from_raw(last_ptr) };\n-                debug_assert!(!Arc::ptr_eq(self, &last));\n-                let mut last_cpus = last.activated_cpus.lock();\n-                debug_assert!(last_cpus.contains(cpu));\n-                last_cpus.remove(cpu);\n+                // SAFETY: The pointer is cast from an `Arc` when it's activated\n+                // the last time, so it can be restored and only restored once.\n+                drop(unsafe { Arc::from_raw(last_ptr) });\n             }\n-\n-            LAST_ACTIVATED_VM_SPACE.store(Arc::into_raw(Arc::clone(self)));\n-        }\n-\n-        if activated_cpus.count() > 1 {\n-            // We don't support remote TLB flushing yet. It is less desirable\n-            // to activate a `VmSpace` on more than one CPU.\n-            log::warn!(\"A `VmSpace` is activated on more than one CPU\");\n         }\n     }\n \n-    /// Clears all mappings.\n-    pub fn clear(&self) {\n-        let mut cursor = self.pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        loop {\n-            // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { cursor.take_next(MAX_USERSPACE_VADDR - cursor.virt_addr()) };\n-            match result {\n-                PageTableItem::Mapped { page, .. } => {\n-                    drop(page);\n-                }\n-                PageTableItem::NotMapped { .. } => {\n-                    break;\n-                }\n-                PageTableItem::MappedUntracked { .. } => {\n-                    panic!(\"found untracked memory mapped into `VmSpace`\");\n-                }\n-            }\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n-    }\n-\n     pub(crate) fn handle_page_fault(\n         &self,\n         info: &CpuExceptionInfo,\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -199,25 +181,12 @@ impl VmSpace {\n     pub fn fork_copy_on_write(&self) -> Self {\n         // Protect the parent VM space as read-only.\n         let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.pt.cursor_mut(&(0..end)).unwrap();\n+        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n         let mut op = |prop: &mut PageProperty| {\n             prop.flags -= PageFlags::W;\n         };\n \n-        loop {\n-            // SAFETY: It is safe to protect memory in the userspace.\n-            unsafe {\n-                if cursor\n-                    .protect_next(end - cursor.virt_addr(), &mut op)\n-                    .is_none()\n-                {\n-                    break;\n-                }\n-            };\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n+        cursor.protect(end, &mut op);\n \n         let page_fault_handler = {\n             let new_handler = Once::new();\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -227,10 +196,22 @@ impl VmSpace {\n             new_handler\n         };\n \n+        let CursorMut {\n+            pt_cursor,\n+            activation_lock,\n+            ..\n+        } = cursor;\n+\n+        let new_pt = self.pt.clone_with(pt_cursor);\n+\n+        // Release the activation lock after the page table is cloned to\n+        // prevent modification to the parent page table while cloning.\n+        drop(activation_lock);\n+\n         Self {\n-            pt: self.pt.clone_with(cursor),\n+            pt: new_pt,\n             page_fault_handler,\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -326,52 +307,55 @@ impl Cursor<'_> {\n ///\n /// It exclusively owns a sub-tree of the page table, preventing others from\n /// reading or modifying the same sub-tree.\n-pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n-\n-impl CursorMut<'_> {\n-    /// The threshold used to determine whether need to flush TLB all\n-    /// when flushing a range of TLB addresses. If the range of TLB entries\n-    /// to be flushed exceeds this threshold, the overhead incurred by\n-    /// flushing pages individually would surpass the overhead of flushing all entries at once.\n-    const TLB_FLUSH_THRESHOLD: usize = 32 * PAGE_SIZE;\n+pub struct CursorMut<'a, 'b> {\n+    pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n+    #[allow(dead_code)]\n+    activation_lock: RwLockReadGuard<'b, ()>,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead. We have a read lock so the stored set\n+    // is always a superset of actual activated CPUs.\n+    activated_cpus: CpuSet,\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+}\n \n+impl CursorMut<'_, '_> {\n     /// Query about the current slot.\n     ///\n     /// This is the same as [`Cursor::query`].\n     ///\n     /// This function won't bring the cursor to the next slot.\n     pub fn query(&mut self) -> Result<VmItem> {\n-        Ok(self.0.query().map(|item| item.try_into().unwrap())?)\n+        Ok(self\n+            .pt_cursor\n+            .query()\n+            .map(|item| item.try_into().unwrap())?)\n     }\n \n     /// Jump to the virtual address.\n     ///\n     /// This is the same as [`Cursor::jump`].\n     pub fn jump(&mut self, va: Vaddr) -> Result<()> {\n-        self.0.jump(va)?;\n+        self.pt_cursor.jump(va)?;\n         Ok(())\n     }\n \n     /// Get the virtual address of the current slot.\n     pub fn virt_addr(&self) -> Vaddr {\n-        self.0.virt_addr()\n+        self.pt_cursor.virt_addr()\n     }\n \n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n-    pub fn map(&mut self, frame: Frame, mut prop: PageProperty) {\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n         let start_va = self.virt_addr();\n         let end_va = start_va + frame.size();\n-        // TODO: this is a temporary fix to avoid the overhead of setting ACCESSED bit in userspace.\n-        // When this bit is truly enabled, it needs to be set at a more appropriate location.\n-        prop.flags |= PageFlags::ACCESSED;\n         // SAFETY: It is safe to map untyped memory into the userspace.\n-        unsafe {\n-            self.0.map(frame.into(), prop);\n-        }\n+        let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        tlb_flush_addr_range(&(start_va..end_va));\n+        self.issue_tlb_flush(TlbFlushOp::Range(start_va..end_va), old);\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Clear the mapping starting from the current slot.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -388,18 +372,13 @@ impl CursorMut<'_> {\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+\n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { self.0.take_next(end_va - self.virt_addr()) };\n+            let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !need_flush_all {\n-                        // TODO: Ask other processors to flush the TLB before we\n-                        // release the page back to the allocator.\n-                        tlb_flush_addr(va);\n-                    }\n-                    drop(page);\n+                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -409,9 +388,8 @@ impl CursorMut<'_> {\n                 }\n             }\n         }\n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n-        }\n+\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Change the mapping property starting from the current slot.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -426,17 +404,121 @@ impl CursorMut<'_> {\n     /// This method will panic if `len` is not page-aligned.\n     pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n         assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.0.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+        let end = self.virt_addr() + len;\n+        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) = unsafe { self.0.protect_next(end - self.0.virt_addr(), &mut op) } {\n-            if !need_flush_all {\n-                tlb_flush_addr(range.start);\n+        while let Some(range) =\n+            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n+        {\n+            if !tlb_prefer_flush_all {\n+                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n+            }\n+        }\n+\n+        if tlb_prefer_flush_all {\n+            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        }\n+        self.dispatch_tlb_flush();\n+    }\n+\n+    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let request = TlbFlushRequest {\n+            op,\n+            drop_after_flush,\n+        };\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                request.do_flush();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.activated_cpus.iter() {\n+            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n+            queue.push_back(request.clone());\n+        }\n+    }\n+\n+    fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        fn do_remote_flush() {\n+            let preempt_guard = disable_preempt();\n+            let mut requests = TLB_FLUSH_REQUESTS\n+                .get_on_cpu(preempt_guard.current_cpu())\n+                .lock();\n+            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n+                // TODO: in most cases, we need only to flush all the TLB entries\n+                // for an ASID if it is enabled.\n+                crate::arch::mm::tlb_flush_all_excluding_global();\n+                requests.clear();\n+            } else {\n+                while let Some(request) = requests.pop_front() {\n+                    request.do_flush();\n+                    if matches!(request.op, TlbFlushOp::All) {\n+                        requests.clear();\n+                        break;\n+                    }\n+                }\n             }\n         }\n \n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n+        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    }\n+}\n+\n+/// The threshold used to determine whether we need to flush all TLB entries\n+/// when handling a bunch of TLB flush requests. If the number of requests\n+/// exceeds this threshold, the overhead incurred by flushing pages\n+/// individually would surpass the overhead of flushing all entries at once.\n+const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n+\n+cpu_local! {\n+    /// The queue of pending requests.\n+    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n+    /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n+    /// is NULL, it means that the activated page table is merely the kernel\n+    /// page table.\n+    // TODO: If we are enabling ASID, we need to maintain the TLB state of each\n+    // CPU, rather than merely the activated `VmSpace`. When ASID is enabled,\n+    // the non-active `VmSpace`s can still have their TLB entries in the CPU!\n+    static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TlbFlushRequest {\n+    op: TlbFlushOp,\n+    // If we need to remove a mapped page from the page table, we can only\n+    // recycle the page after all the relevant TLB entries in all CPUs are\n+    // flushed. Otherwise if the page is recycled for other purposes, the user\n+    // space program can still access the page through the TLB entries.\n+    #[allow(dead_code)]\n+    drop_after_flush: Option<DynPage>,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TlbFlushOp {\n+    All,\n+    Address(Vaddr),\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushRequest {\n+    /// Perform the TLB flush operation on the current CPU.\n+    fn do_flush(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match &self.op {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n         }\n     }\n }\ndiff --git /dev/null b/ostd/src/smp.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/smp.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Symmetric Multi-Processing (SMP) support.\n+//!\n+//! This module provides a way to execute code on other processors via inter-\n+//! processor interrupts.\n+\n+use alloc::collections::VecDeque;\n+\n+use spin::Once;\n+\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    trap::{self, IrqLine, TrapFrame},\n+};\n+\n+/// Execute a function on other processors.\n+///\n+/// The provided function `f` will be executed on all target processors\n+/// specified by `targets`. It can also be executed on the current processor.\n+/// The function should be short and non-blocking, as it will be executed in\n+/// interrupt context with interrupts disabled.\n+///\n+/// This function does not block until all the target processors acknowledges\n+/// the interrupt. So if any of the target processors disables IRQs for too\n+/// long that the controller cannot queue them, the function will not be\n+/// executed.\n+///\n+/// The function `f` will be executed asynchronously on the target processors.\n+/// However if called on the current processor, it will be synchronous.\n+pub fn inter_processor_call(targets: &CpuSet, f: fn()) {\n+    let irq_guard = trap::disable_local();\n+    let this_cpu_id = irq_guard.current_cpu();\n+    let irq_num = INTER_PROCESSOR_CALL_IRQ.get().unwrap().num();\n+\n+    let mut call_on_self = false;\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            call_on_self = true;\n+            continue;\n+        }\n+        CALL_QUEUES.get_on_cpu(cpu_id).lock().push_back(f);\n+    }\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            continue;\n+        }\n+        // SAFETY: It is safe to send inter processor call IPI to other CPUs.\n+        unsafe {\n+            crate::arch::irq::send_ipi(cpu_id, irq_num);\n+        }\n+    }\n+    if call_on_self {\n+        // Execute the function synchronously.\n+        f();\n+    }\n+}\n+\n+static INTER_PROCESSOR_CALL_IRQ: Once<IrqLine> = Once::new();\n+\n+cpu_local! {\n+    static CALL_QUEUES: SpinLock<VecDeque<fn()>> = SpinLock::new(VecDeque::new());\n+}\n+\n+fn do_inter_processor_call(_trapframe: &TrapFrame) {\n+    // TODO: in interrupt context, disabling interrupts is not necessary.\n+    let preempt_guard = trap::disable_local();\n+    let cur_cpu = preempt_guard.current_cpu();\n+\n+    let mut queue = CALL_QUEUES.get_on_cpu(cur_cpu).lock();\n+    while let Some(f) = queue.pop_front() {\n+        log::trace!(\n+            \"Performing inter-processor call to {:#?} on CPU {}\",\n+            f,\n+            cur_cpu\n+        );\n+        f();\n+    }\n+}\n+\n+pub(super) fn init() {\n+    let mut irq = IrqLine::alloc().unwrap();\n+    irq.on_active(do_inter_processor_call);\n+    INTER_PROCESSOR_CALL_IRQ.call_once(|| irq);\n+}\ndiff --git a/ostd/src/task/preempt/guard.rs b/ostd/src/task/preempt/guard.rs\n--- a/ostd/src/task/preempt/guard.rs\n+++ b/ostd/src/task/preempt/guard.rs\n@@ -3,6 +3,7 @@\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\n+#[derive(Debug)]\n pub struct DisabledPreemptGuard {\n     // This private field prevents user from constructing values of this type directly.\n     _private: (),\n",
        "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -57,6 +57,7 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n         for frame in user_pages {\n             cursor.map(frame, map_prop);\n         }\n+        drop(cursor);\n         Arc::new(vm_space)\n     };\n     let user_cpu_state = {\n",
        "problem_statement": "Sporadic SMP syscall test aborts\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nThe SMP syscall test aborts with no panicking information randomly. The abort does not happen in a specific test case. And there's possibility of such failures both in the CI ([an example](https://github.com/asterinas/asterinas/actions/runs/10615729536/job/29424463727)) and locally.\r\n\r\nOther CI failure logs:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10600745276/job/29378943424\r\n\r\nLink #999 \r\n\n",
        "hints_text": "",
        "created_at": "2024-08-13T09:28:07Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1154,
        "instance_id": "asterinas__asterinas-1154",
        "issue_numbers": [
            "1130"
        ],
        "base_commit": "38b46f7ac3dd206d116f7db1fa33654569a8e443",
        "patch": "diff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -18,12 +18,14 @@ use ostd::{\n \n use super::Process;\n use crate::{\n-    prelude::*,\n     process::{\n         posix_thread::PosixThreadExt,\n         signal::{constants::SIGALRM, signals::kernel::KernelSignal},\n     },\n-    thread::work_queue::{submit_work_item, work_item::WorkItem},\n+    thread::{\n+        work_queue::{submit_work_item, work_item::WorkItem},\n+        Thread,\n+    },\n     time::{\n         clocks::{ProfClock, RealTimeClock},\n         Timer, TimerManager,\ndiff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -36,40 +38,43 @@ use crate::{\n /// invoke the callbacks of expired timers which are based on the updated\n /// CPU clock.\n fn update_cpu_time() {\n-    let current_thread = current_thread!();\n-    if let Some(posix_thread) = current_thread.as_posix_thread() {\n-        let process = posix_thread.process();\n-        let timer_manager = process.timer_manager();\n-        let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n-        // Based on whether the timer interrupt occurs in kernel mode or user mode,\n-        // the function will add the duration of one timer interrupt interval to the\n-        // corresponding CPU clocks.\n-        if is_kernel_interrupted() {\n-            posix_thread\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-            process\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-        } else {\n-            posix_thread\n-                .prof_clock()\n-                .user_clock()\n-                .add_time(jiffies_interval);\n-            process.prof_clock().user_clock().add_time(jiffies_interval);\n-            timer_manager\n-                .virtual_timer()\n-                .timer_manager()\n-                .process_expired_timers();\n-        }\n+    let Some(current_thread) = Thread::current() else {\n+        return;\n+    };\n+    let Some(posix_thread) = current_thread.as_posix_thread() else {\n+        return;\n+    };\n+    let process = posix_thread.process();\n+    let timer_manager = process.timer_manager();\n+    let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n+    // Based on whether the timer interrupt occurs in kernel mode or user mode,\n+    // the function will add the duration of one timer interrupt interval to the\n+    // corresponding CPU clocks.\n+    if is_kernel_interrupted() {\n+        posix_thread\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+        process\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+    } else {\n+        posix_thread\n+            .prof_clock()\n+            .user_clock()\n+            .add_time(jiffies_interval);\n+        process.prof_clock().user_clock().add_time(jiffies_interval);\n         timer_manager\n-            .prof_timer()\n+            .virtual_timer()\n             .timer_manager()\n             .process_expired_timers();\n-        posix_thread.process_expired_timers();\n     }\n+    timer_manager\n+        .prof_timer()\n+        .timer_manager()\n+        .process_expired_timers();\n+    posix_thread.process_expired_timers();\n }\n \n /// Registers a function to update the CPU clock in processes and\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -119,6 +119,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     }\n \n     trap::init();\n+    crate::arch::irq::enable_local();\n \n     // Mark the AP as started.\n     let ap_boot_info = AP_BOOT_INFO.get().unwrap();\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -86,6 +86,8 @@ pub fn init() {\n \n     mm::kspace::activate_kernel_page_table();\n \n+    arch::irq::enable_local();\n+\n     invoke_ffi_init_funcs();\n }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -71,6 +71,11 @@ pub fn preempt(task: &Arc<Task>) {\n ///\n /// If the current task's status not [`TaskStatus::Runnable`], it will not be\n /// added to the scheduler.\n+///\n+/// # Panics\n+///\n+/// This function will panic if called while holding preemption locks or with\n+/// local IRQ disabled.\n fn switch_to_task(next_task: Arc<Task>) {\n     let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n     if preemt_lock_count != 0 {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -80,6 +85,11 @@ fn switch_to_task(next_task: Arc<Task>) {\n         );\n     }\n \n+    assert!(\n+        crate::arch::irq::is_local_enabled(),\n+        \"Switching task with local IRQ disabled\"\n+    );\n+\n     let irq_guard = crate::trap::disable_local();\n \n     let current_task_ptr = CURRENT_TASK_PTR.load();\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -9,7 +9,6 @@ use trapframe::TrapFrame;\n use crate::{\n     arch::irq::{self, IrqCallbackHandle, IRQ_ALLOCATOR},\n     prelude::*,\n-    task::{disable_preempt, DisablePreemptGuard},\n     Error,\n };\n \ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -135,7 +134,6 @@ pub fn disable_local() -> DisabledLocalIrqGuard {\n #[must_use]\n pub struct DisabledLocalIrqGuard {\n     was_enabled: bool,\n-    preempt_guard: DisablePreemptGuard,\n }\n \n impl !Send for DisabledLocalIrqGuard {}\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -146,11 +144,7 @@ impl DisabledLocalIrqGuard {\n         if was_enabled {\n             irq::disable_local();\n         }\n-        let preempt_guard = disable_preempt();\n-        Self {\n-            was_enabled,\n-            preempt_guard,\n-        }\n+        Self { was_enabled }\n     }\n \n     /// Transfers the saved IRQ status of this guard to a new guard.\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -158,10 +152,7 @@ impl DisabledLocalIrqGuard {\n     pub fn transfer_to(&mut self) -> Self {\n         let was_enabled = self.was_enabled;\n         self.was_enabled = false;\n-        Self {\n-            was_enabled,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { was_enabled }\n     }\n }\n \ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -172,18 +163,3 @@ impl Drop for DisabledLocalIrqGuard {\n         }\n     }\n }\n-\n-/// Enables all IRQs on the current CPU.\n-///\n-/// FIXME: The reason we need to add this API is that currently IRQs\n-/// are enabled when the CPU enters the user space for the first time,\n-/// which is too late. During the OS initialization phase,\n-/// we need to get the block device working and mount the filesystems,\n-/// thus requiring the IRQs should be enabled as early as possible.\n-///\n-/// FIXME: this method may be unsound.\n-pub fn enable_local() {\n-    if !crate::arch::irq::is_local_enabled() {\n-        crate::arch::irq::enable_local();\n-    }\n-}\ndiff --git a/ostd/src/trap/mod.rs b/ostd/src/trap/mod.rs\n--- a/ostd/src/trap/mod.rs\n+++ b/ostd/src/trap/mod.rs\n@@ -11,9 +11,7 @@ pub use softirq::SoftIrqLine;\n pub use trapframe::TrapFrame;\n \n pub(crate) use self::handler::call_irq_callback_functions;\n-pub use self::irq::{\n-    disable_local, enable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine,\n-};\n+pub use self::irq::{disable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine};\n \n pub(crate) fn init() {\n     unsafe {\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/lib.rs b/kernel/aster-nix/src/lib.rs\n--- a/kernel/aster-nix/src/lib.rs\n+++ b/kernel/aster-nix/src/lib.rs\n@@ -89,9 +89,6 @@ fn init_thread() {\n     // Work queue should be initialized before interrupt is enabled,\n     // in case any irq handler uses work queue as bottom half\n     thread::work_queue::init();\n-    // FIXME: Remove this if we move the step of mounting\n-    // the filesystems to be done within the init process.\n-    ostd::trap::enable_local();\n     net::lazy_init();\n     fs::lazy_init();\n     // driver::pci::virtio::block::block_device_test();\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -190,7 +190,7 @@ fn taskless_softirq_handler(\n mod test {\n     use core::sync::atomic::AtomicUsize;\n \n-    use ostd::{prelude::*, trap::enable_local};\n+    use ostd::prelude::*;\n \n     use super::*;\n \ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -198,7 +198,6 @@ mod test {\n         static DONE: AtomicBool = AtomicBool::new(false);\n         if !DONE.load(Ordering::SeqCst) {\n             super::init();\n-            enable_local();\n             DONE.store(true, Ordering::SeqCst);\n         }\n     }\n",
        "problem_statement": "We shouldn't disable preemption when disabling IRQ.\nCurrently `ostd::trap::disable_local` disables preemption as well when disabling IRQ. However, such a policy would like to be based on an observation that: \"we shouldn't do `switch_to_task()` when IRQ is disabled\". Indeed we shouldn't do so. But this is not the best way to solve the problem.\r\n\r\nWe shouldn't disable preemption in `ostd::trap::disable_local`, instead, we should check if the IRQ is disabled in `switch_to_task()`. This alternative solution precisely resolves the problem without other overheads.\r\n\r\nIn contrast, if we disable preemption in `ostd::trap::disable_local`, an enormous number of places that preemption won't ever happen will try to disable preemption, introducing non negligible costs since a memory write must happen when disabling preemption. Even worse, in the case of #1125, if the architecture don't implement single instruction writes, the fall back implementation will disable IRQ. But disabling preemption would need a CPU-local write, which in turn needs to disable preemption, causing a dead loop here.\r\n\r\nSo, we need only to check if the IRQ is disabled in `switch_to_task()`. The user should disable both preemption and IRQ if they indeed need both. We should check the entire code base for such needs and add `disable_preempt` delicately.\n",
        "hints_text": "",
        "created_at": "2024-08-12T13:23:15Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1138,
        "instance_id": "asterinas__asterinas-1138",
        "issue_numbers": [
            "1135"
        ],
        "base_commit": "6414111cc57b42db2bae1a0c8b01b85c3830a3b3",
        "patch": "diff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -163,18 +163,14 @@ fn get_manifest_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str\n fn get_src_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str) -> &'a str {\n     let metadata = get_package_metadata(cargo_metadata, crate_name);\n     let targets = metadata.get(\"targets\").unwrap().as_array().unwrap();\n-\n-    for target in targets {\n-        let name = target.get(\"name\").unwrap().as_str().unwrap();\n-        if name != crate_name {\n-            continue;\n-        }\n-\n-        let src_path = target.get(\"src_path\").unwrap();\n-        return src_path.as_str().unwrap();\n-    }\n-\n-    panic!(\"the crate name does not match with any target\");\n+    assert!(\n+        targets.len() == 1,\n+        \"there must be one and only one target generated\"\n+    );\n+\n+    let target = &targets[0];\n+    let src_path = target.get(\"src_path\").unwrap();\n+    return src_path.as_str().unwrap();\n }\n \n fn get_workspace_root(cargo_metadata: &serde_json::Value) -> &str {\n",
        "test_patch": "diff --git a/osdk/tests/cli/mod.rs b/osdk/tests/cli/mod.rs\n--- a/osdk/tests/cli/mod.rs\n+++ b/osdk/tests/cli/mod.rs\n@@ -1,5 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::fs;\n+\n use crate::util::*;\n \n #[test]\ndiff --git a/osdk/tests/cli/mod.rs b/osdk/tests/cli/mod.rs\n--- a/osdk/tests/cli/mod.rs\n+++ b/osdk/tests/cli/mod.rs\n@@ -50,3 +52,13 @@ fn cli_clippy_help_message() {\n     assert_success(&output);\n     assert_stdout_contains_msg(&output, \"cargo osdk clippy\");\n }\n+\n+#[test]\n+fn cli_new_crate_with_hyphen() {\n+    let output = cargo_osdk(&[\"new\", \"--kernel\", \"my-first-os\"])\n+        .output()\n+        .unwrap();\n+    assert_success(&output);\n+    assert!(fs::metadata(\"my-first-os\").is_ok());\n+    fs::remove_dir_all(\"my-first-os\");\n+}\n",
        "problem_statement": "OSDK should support creating crate with `-` in its name\nAs discovered by #1133, `cargo osdk new --kernel my-first-os` will panic due to `my-first-os` contains `-`.\r\n\r\nSince `cargo new my-first-os` is allowed, we should fix the problem to keep osdk consistent with cargo.\r\n\r\n\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2024-08-08T01:38:09Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 193,
        "instance_id": "asterinas__asterinas-193",
        "issue_numbers": [
            "124"
        ],
        "base_commit": "7e1584fca9b0bb818ea8f115ab471bc21613b7bd",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -145,6 +145,15 @@ dependencies = [\n name = \"cpio-decoder\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n [[package]]\n name = \"ctor\"\n version = \"0.1.25\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -359,11 +368,12 @@ dependencies = [\n  \"jinux-rights-proc\",\n  \"jinux-time\",\n  \"jinux-util\",\n+ \"keyable-arc\",\n  \"lazy_static\",\n  \"log\",\n  \"lru\",\n  \"pod\",\n- \"ringbuffer\",\n+ \"ringbuf\",\n  \"spin 0.9.4\",\n  \"time\",\n  \"typeflags\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -411,6 +421,10 @@ version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n \n+[[package]]\n+name = \"keyable-arc\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -536,10 +550,13 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"ringbuffer\"\n-version = \"0.10.0\"\n+name = \"ringbuf\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"310a2514cb46bb500a2f2ad70c79c51c5a475cc23faa245d2c675faabe889370\"\n+checksum = \"93ca10b9c9e53ac855a2d6953bce34cef6edbac32c4b13047a4d59d67299420a\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n \n [[package]]\n name = \"rsdp\"\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/jinux-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/jinux-std/Cargo.toml\n@@ -28,7 +28,8 @@ xmas-elf = \"0.8.0\"\n # goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n # data-structures\n bitflags = \"1.3\"\n-ringbuffer = \"0.10.0\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"../keyable-arc\" }\n \n spin = \"0.9.4\"\n vte = \"0.10\"\ndiff --git a/services/libs/jinux-std/src/events/events.rs b/services/libs/jinux-std/src/events/events.rs\n--- a/services/libs/jinux-std/src/events/events.rs\n+++ b/services/libs/jinux-std/src/events/events.rs\n@@ -1,2 +1,34 @@\n /// A trait to represent any events.\n pub trait Events: Copy + Clone + Send + Sync + 'static {}\n+\n+/// A trait to filter events.\n+///\n+/// # The no-op event filter\n+///\n+/// The unit type `()` can serve as a no-op event filter.\n+/// It implements `EventsFilter<E>` for any events type `E`,\n+/// with a `filter` method that always returns `true`.\n+/// If the `F` type of `Subject<E, F>` is not specified explicitly,\n+/// then the unit type `()` is chosen as the event filter.\n+///\n+/// # Per-object event filter\n+///\n+/// Any `Option<F: EventsFilter>` is also an event filter thanks to\n+/// the blanket implementations the `EventsFilter` trait.\n+/// By using `Option<F: EventsFilter>`, we can decide, on a per-observer basis,\n+/// if an observer needs an event filter.\n+pub trait EventsFilter<E: Events>: Send + Sync + 'static {\n+    fn filter(&self, event: &E) -> bool;\n+}\n+\n+impl<E: Events> EventsFilter<E> for () {\n+    fn filter(&self, _events: &E) -> bool {\n+        true\n+    }\n+}\n+\n+impl<E: Events, F: EventsFilter<E>> EventsFilter<E> for Option<F> {\n+    fn filter(&self, events: &E) -> bool {\n+        self.as_ref().map_or(true, |f| f.filter(events))\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/events/mod.rs b/services/libs/jinux-std/src/events/mod.rs\n--- a/services/libs/jinux-std/src/events/mod.rs\n+++ b/services/libs/jinux-std/src/events/mod.rs\n@@ -2,6 +2,6 @@ mod events;\n mod observer;\n mod subject;\n \n-pub use self::events::Events;\n+pub use self::events::{Events, EventsFilter};\n pub use self::observer::Observer;\n pub use self::subject::Subject;\ndiff --git a/services/libs/jinux-std/src/events/subject.rs b/services/libs/jinux-std/src/events/subject.rs\n--- a/services/libs/jinux-std/src/events/subject.rs\n+++ b/services/libs/jinux-std/src/events/subject.rs\n@@ -1,43 +1,86 @@\n use crate::prelude::*;\n \n-use super::{Events, Observer};\n+use core::sync::atomic::{AtomicUsize, Ordering};\n+use keyable_arc::KeyableWeak;\n \n-/// A Subject notify interesting events to registered observers.\n-pub struct Subject<E: Events> {\n-    observers: Mutex<Vec<Weak<dyn Observer<E>>>>,\n+use super::{Events, EventsFilter, Observer};\n+\n+/// A Subject notifies interesting events to registered observers.\n+pub struct Subject<E: Events, F: EventsFilter<E> = ()> {\n+    // A table that maintains all interesting observers.\n+    observers: Mutex<BTreeMap<KeyableWeak<dyn Observer<E>>, F>>,\n+    // To reduce lock contentions, we maintain a counter for the size of the table\n+    num_observers: AtomicUsize,\n }\n \n-impl<E: Events> Subject<E> {\n+impl<E: Events, F: EventsFilter<E>> Subject<E, F> {\n     pub fn new() -> Self {\n         Self {\n-            observers: Mutex::new(Vec::new()),\n+            observers: Mutex::new(BTreeMap::new()),\n+            num_observers: AtomicUsize::new(0),\n         }\n     }\n \n     /// Register an observer.\n-    pub fn register_observer(&self, observer: Weak<dyn Observer<E>>) {\n+    ///\n+    /// A registered observer will get notified through its `on_events` method.\n+    /// If events `filter` is provided, only filtered events will notify the observer.\n+    ///\n+    /// If the given observer has already been registered, then its registered events\n+    /// filter will be updated.\n+    pub fn register_observer(&self, observer: Weak<dyn Observer<E>>, filter: F) {\n         let mut observers = self.observers.lock();\n-        observers.push(observer);\n+        let is_new = {\n+            let observer: KeyableWeak<dyn Observer<E>> = observer.into();\n+            observers.insert(observer, filter).is_none()\n+        };\n+        if is_new {\n+            self.num_observers.fetch_add(1, Ordering::Release);\n+        }\n     }\n \n     /// Unregister an observer.\n-    pub fn unregister_observer(&self, observer: Weak<dyn Observer<E>>) {\n+    ///\n+    /// If such an observer is found, then the registered observer will be\n+    /// removed from the subject and returned as the return value. Otherwise,\n+    /// a `None` will be returned.\n+    pub fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<E>>,\n+    ) -> Option<Weak<dyn Observer<E>>> {\n+        let observer: KeyableWeak<dyn Observer<E>> = observer.clone().into();\n         let mut observers = self.observers.lock();\n-        observers.retain(|e| !Weak::ptr_eq(&e, &observer));\n+        let observer = observers\n+            .remove_entry(&observer)\n+            .map(|(observer, _)| observer.into());\n+        if observer.is_some() {\n+            self.num_observers.fetch_sub(1, Ordering::Relaxed);\n+        }\n+        observer\n     }\n \n     /// Notify events to all registered observers.\n+    ///\n     /// It will remove the observers which have been freed.\n     pub fn notify_observers(&self, events: &E) {\n+        // Fast path.\n+        if self.num_observers.load(Ordering::Relaxed) == 0 {\n+            return;\n+        }\n+\n+        // Slow path: broadcast the new events to all observers.\n         let mut observers = self.observers.lock();\n-        let mut idx = 0;\n-        while idx < observers.len() {\n-            if let Some(observer) = observers[idx].upgrade() {\n+        observers.retain(|observer, filter| {\n+            if let Some(observer) = observer.upgrade() {\n+                if !filter.filter(events) {\n+                    return true;\n+                }\n                 observer.on_events(events);\n-                idx += 1;\n+                true\n             } else {\n-                observers.remove(idx);\n+                self.num_observers.fetch_sub(1, Ordering::Relaxed);\n+                false\n             }\n-        }\n+        });\n     }\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/epoll/epoll_file.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/epoll/epoll_file.rs\n@@ -0,0 +1,490 @@\n+use crate::events::Observer;\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::file_table::{FdEvents, FileDescripter};\n+use crate::fs::utils::{IoEvents, IoctlCmd, Pollee, Poller};\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+use core::time::Duration;\n+\n+use super::*;\n+\n+/// A file-like object that provides epoll API.\n+///\n+/// Conceptually, we maintain two lists: one consists of all interesting files,\n+/// which can be managed by the epoll ctl commands; the other are for ready files,\n+/// which are files that have some events. A epoll wait only needs to iterate the\n+/// ready list and poll each file to see if the file is ready for the interesting\n+/// I/O.\n+///\n+/// To maintain the ready list, we need to monitor interesting events that happen\n+/// on the files. To do so, the `EpollFile` registers itself as an `Observer` to\n+/// the monotored files. Thus, we can add a file to the ready list when an interesting\n+/// event happens on the file.\n+pub struct EpollFile {\n+    // All interesting entries.\n+    interest: Mutex<BTreeMap<FileDescripter, Arc<EpollEntry>>>,\n+    // Entries that are probably ready (having events happened).\n+    ready: Mutex<VecDeque<Arc<EpollEntry>>>,\n+    // EpollFile itself is also pollable\n+    pollee: Pollee,\n+    // Any EpollFile is wrapped with Arc when created.\n+    weak_self: Weak<Self>,\n+}\n+\n+impl EpollFile {\n+    /// Creates a new epoll file.\n+    pub fn new() -> Arc<Self> {\n+        Arc::new_cyclic(|me| Self {\n+            interest: Mutex::new(BTreeMap::new()),\n+            ready: Mutex::new(VecDeque::new()),\n+            pollee: Pollee::new(IoEvents::empty()),\n+            weak_self: me.clone(),\n+        })\n+    }\n+\n+    /// Control the interest list of the epoll file.\n+    pub fn control(&self, cmd: &EpollCtl) -> Result<()> {\n+        match *cmd {\n+            EpollCtl::Add(fd, ep_event, ep_flags) => self.add_interest(fd, ep_event, ep_flags),\n+            EpollCtl::Del(fd) => {\n+                self.del_interest(fd)?;\n+                self.unregister_from_file_table_entry(fd);\n+                Ok(())\n+            }\n+            EpollCtl::Mod(fd, ep_event, ep_flags) => self.mod_interest(fd, ep_event, ep_flags),\n+        }\n+    }\n+\n+    fn add_interest(\n+        &self,\n+        fd: FileDescripter,\n+        ep_event: EpollEvent,\n+        ep_flags: EpollFlags,\n+    ) -> Result<()> {\n+        self.warn_unsupported_flags(&ep_flags);\n+\n+        let current = current!();\n+        let file_table = current.file_table().lock();\n+        let file_table_entry = file_table.get_entry(fd)?;\n+        let file = file_table_entry.file();\n+        let weak_file = Arc::downgrade(file);\n+        let mask = ep_event.events;\n+        let entry = EpollEntry::new(fd, weak_file, ep_event, ep_flags, self.weak_self.clone());\n+\n+        // Add the new entry to the interest list and start monitering its events\n+        let mut interest = self.interest.lock();\n+        if interest.contains_key(&fd) {\n+            return_errno_with_message!(Errno::EEXIST, \"the fd has been added\");\n+        }\n+        file.register_observer(entry.self_weak() as _, IoEvents::all())?;\n+        interest.insert(fd, entry.clone());\n+        // Register self to the file table entry\n+        file_table_entry.register_observer(self.weak_self.clone() as _);\n+        let file = file.clone();\n+        drop(file_table);\n+        drop(interest);\n+\n+        // Add the new entry to the ready list if the file is ready\n+        let events = file.poll(mask, None);\n+        if !events.is_empty() {\n+            self.push_ready(entry);\n+        }\n+        Ok(())\n+    }\n+\n+    fn del_interest(&self, fd: FileDescripter) -> Result<()> {\n+        let mut interest = self.interest.lock();\n+        let entry = interest\n+            .remove(&fd)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"fd is not in the interest list\"))?;\n+\n+        // If this epoll entry is in the ready list, then we should delete it.\n+        // But unfortunately, deleting an entry from the ready list has a\n+        // complexity of O(N).\n+        //\n+        // To optimize the performance, we only mark the epoll entry as\n+        // deleted at this moment. The real deletion happens when the ready list\n+        // is scanned in EpolFile::wait.\n+        entry.set_deleted();\n+\n+        let file = match entry.file() {\n+            Some(file) => file,\n+            // TODO: should we warn about it?\n+            None => return Ok(()),\n+        };\n+\n+        file.unregister_observer(&(entry.self_weak() as _)).unwrap();\n+        Ok(())\n+    }\n+\n+    fn mod_interest(\n+        &self,\n+        fd: FileDescripter,\n+        new_ep_event: EpollEvent,\n+        new_ep_flags: EpollFlags,\n+    ) -> Result<()> {\n+        self.warn_unsupported_flags(&new_ep_flags);\n+\n+        // Update the epoll entry\n+        let interest = self.interest.lock();\n+        let entry = interest\n+            .get(&fd)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"fd is not in the interest list\"))?;\n+        if entry.is_deleted() {\n+            return_errno_with_message!(Errno::ENOENT, \"fd is not in the interest list\");\n+        }\n+        let new_mask = new_ep_event.events;\n+        entry.update(new_ep_event, new_ep_flags);\n+        let entry = entry.clone();\n+        drop(interest);\n+\n+        // Add the updated entry to the ready list if the file is ready\n+        let file = match entry.file() {\n+            Some(file) => file,\n+            None => return Ok(()),\n+        };\n+        let events = file.poll(new_mask, None);\n+        if !events.is_empty() {\n+            self.push_ready(entry);\n+        }\n+        Ok(())\n+    }\n+\n+    fn unregister_from_file_table_entry(&self, fd: FileDescripter) {\n+        let current = current!();\n+        let file_table = current.file_table().lock();\n+        if let Ok(entry) = file_table.get_entry(fd) {\n+            entry.unregister_observer(&(self.weak_self.clone() as _));\n+        }\n+    }\n+\n+    /// Wait for interesting events happen on the files in the interest list\n+    /// of the epoll file.\n+    ///\n+    /// This method blocks until either some interesting events happen or\n+    /// the timeout expires or a signal arrives. The first case returns\n+    /// `Ok(events)`, where `events` is a `Vec` containing at most `max_events`\n+    /// number of `EpollEvent`s. The second and third case returns errors.\n+    ///\n+    /// When `max_events` equals to zero, the method returns when the timeout\n+    /// expires or a signal arrives.\n+    pub fn wait(&self, max_events: usize, timeout: Option<&Duration>) -> Result<Vec<EpollEvent>> {\n+        let mut ep_events = Vec::new();\n+        let mut poller = None;\n+        loop {\n+            // Try to pop some ready entries\n+            if self.pop_ready(max_events, &mut ep_events) > 0 {\n+                return Ok(ep_events);\n+            }\n+\n+            // Return immediately if specifying a timeout of zero\n+            if timeout.is_some() && timeout.as_ref().unwrap().is_zero() {\n+                return Ok(ep_events);\n+            }\n+\n+            // If no ready entries for now, wait for them\n+            if poller.is_none() {\n+                poller = Some(Poller::new());\n+                let events = self.pollee.poll(IoEvents::IN, poller.as_ref());\n+                if !events.is_empty() {\n+                    continue;\n+                }\n+            }\n+\n+            // FIXME: respect timeout parameter\n+            poller.as_ref().unwrap().wait();\n+        }\n+    }\n+\n+    fn push_ready(&self, entry: Arc<EpollEntry>) {\n+        let mut ready = self.ready.lock();\n+        if entry.is_deleted() {\n+            return;\n+        }\n+\n+        if !entry.is_ready() {\n+            entry.set_ready();\n+            ready.push_back(entry);\n+        }\n+\n+        // Even if the entry is already set to ready, there might be new events that we are interested in.\n+        // Wake the poller anyway.\n+        self.pollee.add_events(IoEvents::IN);\n+    }\n+\n+    fn pop_ready(&self, max_events: usize, ep_events: &mut Vec<EpollEvent>) -> usize {\n+        let mut count_events = 0;\n+        let mut ready = self.ready.lock();\n+        let mut pop_quota = ready.len();\n+        loop {\n+            // Pop some ready entries per round.\n+            //\n+            // Since the popped ready entries may contain \"false positive\" and\n+            // we want to return as many results as possible, this has to\n+            // be done in a loop.\n+            let pop_count = (max_events - count_events).min(pop_quota);\n+            if pop_count == 0 {\n+                break;\n+            }\n+            let ready_entries: Vec<Arc<EpollEntry>> = ready\n+                .drain(..pop_count)\n+                .filter(|entry| !entry.is_deleted())\n+                .collect();\n+            pop_quota -= pop_count;\n+\n+            // Examine these ready entries, which are candidates for the results\n+            // to be returned.\n+            for entry in ready_entries {\n+                let (ep_event, ep_flags) = entry.event_and_flags();\n+                // If this entry's file is ready, save it in the output array.\n+                // EPOLLHUP and EPOLLERR should always be reported.\n+                let ready_events = entry.poll() & (ep_event.events | IoEvents::HUP | IoEvents::ERR);\n+                if !ready_events.is_empty() {\n+                    ep_events.push(EpollEvent::new(ready_events, ep_event.user_data));\n+                    count_events += 1;\n+                }\n+\n+                // If the epoll entry is neither edge-triggered or one-shot, then we should\n+                // keep the entry in the ready list.\n+                if !ep_flags.intersects(EpollFlags::ONE_SHOT | EpollFlags::EDGE_TRIGGER) {\n+                    ready.push_back(entry);\n+                }\n+                // Otherwise, the entry is indeed removed the ready list and we should reset\n+                // its ready flag.\n+                else {\n+                    entry.reset_ready();\n+                    // For EPOLLONESHOT flag, this entry should also be removed from the interest list\n+                    if ep_flags.intersects(EpollFlags::ONE_SHOT) {\n+                        self.del_interest(entry.fd())\n+                            .expect(\"this entry should be in the interest list\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Clear the epoll file's events if no ready entries\n+        if ready.len() == 0 {\n+            self.pollee.del_events(IoEvents::IN);\n+        }\n+        count_events\n+    }\n+\n+    fn warn_unsupported_flags(&self, flags: &EpollFlags) {\n+        if flags.intersects(EpollFlags::EXCLUSIVE | EpollFlags::WAKE_UP) {\n+            warn!(\"{:?} contains unsupported flags\", flags);\n+        }\n+    }\n+}\n+\n+impl Observer<FdEvents> for EpollFile {\n+    fn on_events(&self, events: &FdEvents) {\n+        // Delete the file from the interest list if it is closed.\n+        if let FdEvents::Close(fd) = events {\n+            let _ = self.del_interest(*fd);\n+        }\n+    }\n+}\n+\n+impl Drop for EpollFile {\n+    fn drop(&mut self) {\n+        trace!(\"EpollFile Drop\");\n+        let mut interest = self.interest.lock();\n+        let fds: Vec<_> = interest\n+            .drain_filter(|_, _| true)\n+            .map(|(fd, entry)| {\n+                entry.set_deleted();\n+                if let Some(file) = entry.file() {\n+                    let _ = file.unregister_observer(&(entry.self_weak() as _));\n+                }\n+                fd\n+            })\n+            .collect();\n+        drop(interest);\n+\n+        fds.iter()\n+            .for_each(|&fd| self.unregister_from_file_table_entry(fd));\n+    }\n+}\n+\n+// Implement the common methods required by FileHandle\n+impl FileLike for EpollFile {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support read\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support write\");\n+    }\n+\n+    fn ioctl(&self, _cmd: IoctlCmd, _arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support ioctl\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.pollee.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.pollee.register_observer(observer, mask);\n+        Ok(())\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.pollee\n+            .unregister_observer(observer)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"observer is not registered\"))\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+/// An epoll entry contained in an epoll file. Each epoll entry is added, modified,\n+/// or deleted by the `EpollCtl` command.\n+pub struct EpollEntry {\n+    fd: FileDescripter,\n+    file: Weak<dyn FileLike>,\n+    inner: Mutex<Inner>,\n+    // Whether the entry is in the ready list\n+    is_ready: AtomicBool,\n+    // Whether the entry has been deleted from the interest list\n+    is_deleted: AtomicBool,\n+    // Refers to the epoll file containing this epoll entry\n+    weak_epoll: Weak<EpollFile>,\n+    // An EpollEntry is always contained inside Arc\n+    weak_self: Weak<Self>,\n+}\n+\n+struct Inner {\n+    event: EpollEvent,\n+    flags: EpollFlags,\n+}\n+\n+impl EpollEntry {\n+    /// Creates a new epoll entry associated with the given epoll file.\n+    pub fn new(\n+        fd: FileDescripter,\n+        file: Weak<dyn FileLike>,\n+        event: EpollEvent,\n+        flags: EpollFlags,\n+        weak_epoll: Weak<EpollFile>,\n+    ) -> Arc<Self> {\n+        Arc::new_cyclic(|me| Self {\n+            fd,\n+            file,\n+            inner: Mutex::new(Inner { event, flags }),\n+            is_ready: AtomicBool::new(false),\n+            is_deleted: AtomicBool::new(false),\n+            weak_epoll,\n+            weak_self: me.clone(),\n+        })\n+    }\n+\n+    /// Get the epoll file associated with this epoll entry.\n+    pub fn epoll_file(&self) -> Option<Arc<EpollFile>> {\n+        self.weak_epoll.upgrade()\n+    }\n+\n+    /// Get an instance of `Arc` that refers to this epoll entry.\n+    pub fn self_arc(&self) -> Arc<Self> {\n+        self.weak_self.upgrade().unwrap()\n+    }\n+\n+    /// Get an instance of `Weak` that refers to this epoll entry.\n+    pub fn self_weak(&self) -> Weak<Self> {\n+        self.weak_self.clone()\n+    }\n+\n+    /// Get the file associated with this epoll entry.\n+    ///\n+    /// Since an epoll entry only holds a weak reference to the file,\n+    /// it is possible (albeit unlikely) that the file has been dropped.\n+    pub fn file(&self) -> Option<Arc<dyn FileLike>> {\n+        self.file.upgrade()\n+    }\n+\n+    /// Get the epoll event associated with the epoll entry.\n+    pub fn event(&self) -> EpollEvent {\n+        let inner = self.inner.lock();\n+        inner.event\n+    }\n+\n+    /// Get the epoll flags associated with the epoll entry.\n+    pub fn flags(&self) -> EpollFlags {\n+        let inner = self.inner.lock();\n+        inner.flags\n+    }\n+\n+    /// Get the epoll event and flags that are associated with this epoll entry.\n+    pub fn event_and_flags(&self) -> (EpollEvent, EpollFlags) {\n+        let inner = self.inner.lock();\n+        (inner.event, inner.flags)\n+    }\n+\n+    /// Poll the events of the file associated with this epoll entry.\n+    ///\n+    /// If the returned events is not empty, then the file is considered ready.\n+    pub fn poll(&self) -> IoEvents {\n+        match self.file.upgrade() {\n+            Some(file) => file.poll(IoEvents::all(), None),\n+            None => IoEvents::empty(),\n+        }\n+    }\n+\n+    /// Update the epoll entry, most likely to be triggered via `EpollCtl::Mod`.\n+    pub fn update(&self, event: EpollEvent, flags: EpollFlags) {\n+        let mut inner = self.inner.lock();\n+        *inner = Inner { event, flags }\n+    }\n+\n+    /// Returns whether the epoll entry is in the ready list.\n+    pub fn is_ready(&self) -> bool {\n+        self.is_ready.load(Ordering::Relaxed)\n+    }\n+\n+    /// Mark the epoll entry as being in the ready list.\n+    pub fn set_ready(&self) {\n+        self.is_ready.store(true, Ordering::Relaxed);\n+    }\n+\n+    /// Mark the epoll entry as not being in the ready list.\n+    pub fn reset_ready(&self) {\n+        self.is_ready.store(false, Ordering::Relaxed)\n+    }\n+\n+    /// Returns whether the epoll entry has been deleted from the interest list.\n+    pub fn is_deleted(&self) -> bool {\n+        self.is_deleted.load(Ordering::Relaxed)\n+    }\n+\n+    /// Mark the epoll entry as having been deleted from the interest list.\n+    pub fn set_deleted(&self) {\n+        self.is_deleted.store(true, Ordering::Relaxed);\n+    }\n+\n+    /// Get the file descriptor associated with the epoll entry.\n+    pub fn fd(&self) -> FileDescripter {\n+        self.fd\n+    }\n+}\n+\n+impl Observer<IoEvents> for EpollEntry {\n+    fn on_events(&self, _events: &IoEvents) {\n+        // Fast path\n+        if self.is_deleted() {\n+            return;\n+        }\n+\n+        if let Some(epoll_file) = self.epoll_file() {\n+            epoll_file.push_ready(self.self_arc());\n+        }\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/epoll/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/epoll/mod.rs\n@@ -0,0 +1,72 @@\n+use super::file_table::FileDescripter;\n+use super::utils::IoEvents;\n+use crate::prelude::*;\n+\n+mod epoll_file;\n+\n+pub use self::epoll_file::EpollFile;\n+\n+/// An epoll control command.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum EpollCtl {\n+    Add(FileDescripter, EpollEvent, EpollFlags),\n+    Del(FileDescripter),\n+    Mod(FileDescripter, EpollEvent, EpollFlags),\n+}\n+\n+bitflags! {\n+    /// Linux's epoll flags.\n+    pub struct EpollFlags: u32 {\n+        const EXCLUSIVE      = (1 << 28);\n+        const WAKE_UP        = (1 << 29);\n+        const ONE_SHOT       = (1 << 30);\n+        const EDGE_TRIGGER   = (1 << 31);\n+    }\n+}\n+\n+/// An epoll event.\n+///\n+/// This could be used as either an input of epoll ctl or an output of epoll wait.\n+/// The memory layout is compatible with that of C's struct epoll_event.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct EpollEvent {\n+    /// I/O events.\n+    ///\n+    /// When `EpollEvent` is used as inputs, this is treated as a mask of events.\n+    /// When `EpollEvent` is used as outputs, this is the active events.\n+    pub events: IoEvents,\n+    /// A 64-bit, user-given data.\n+    pub user_data: u64,\n+}\n+\n+impl EpollEvent {\n+    /// Create a new epoll event.\n+    pub fn new(events: IoEvents, user_data: u64) -> Self {\n+        Self { events, user_data }\n+    }\n+}\n+\n+impl From<&c_epoll_event> for EpollEvent {\n+    fn from(c_event: &c_epoll_event) -> Self {\n+        Self {\n+            events: IoEvents::from_bits_truncate(c_event.events as u32),\n+            user_data: c_event.data,\n+        }\n+    }\n+}\n+\n+impl From<&EpollEvent> for c_epoll_event {\n+    fn from(ep_event: &EpollEvent) -> Self {\n+        Self {\n+            events: ep_event.events.bits() as u32,\n+            data: ep_event.user_data,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+pub struct c_epoll_event {\n+    pub events: u32,\n+    pub data: u64,\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/file_handle.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -0,0 +1,74 @@\n+//! Opend File Handle\n+\n+use crate::events::Observer;\n+use crate::fs::utils::{IoEvents, IoctlCmd, Metadata, Poller, SeekFrom};\n+use crate::prelude::*;\n+use crate::tty::get_n_tty;\n+\n+use core::any::Any;\n+\n+/// The basic operations defined on a file\n+pub trait FileLike: Send + Sync + Any {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"read is not supported\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"write is not supported\");\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                // FIXME: only a work around\n+                let tty = get_n_tty();\n+                tty.ioctl(cmd, arg)\n+            }\n+            _ => panic!(\"Ioctl unsupported\"),\n+        }\n+    }\n+\n+    fn poll(&self, _mask: IoEvents, _poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+\n+    fn flush(&self) -> Result<()> {\n+        Ok(())\n+    }\n+\n+    fn metadata(&self) -> Metadata {\n+        panic!(\"metadata unsupported\");\n+    }\n+\n+    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"seek is not supported\");\n+    }\n+\n+    fn clean_for_close(&self) -> Result<()> {\n+        self.flush()?;\n+        Ok(())\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        return_errno_with_message!(Errno::EINVAL, \"register_observer is not supported\")\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        return_errno_with_message!(Errno::EINVAL, \"unregister_observer is not supported\")\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any;\n+}\n+\n+impl dyn FileLike {\n+    pub fn downcast_ref<T: FileLike>(&self) -> Option<&T> {\n+        self.as_any_ref().downcast_ref::<T>()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/file.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/file_handle/file.rs\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-use crate::fs::utils::{IoEvents, IoctlCmd, Metadata, SeekFrom};\n-use crate::prelude::*;\n-use crate::tty::get_n_tty;\n-\n-use core::any::Any;\n-\n-/// The basic operations defined on a file\n-pub trait File: Send + Sync + Any {\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        panic!(\"read unsupported\");\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        panic!(\"write unsupported\");\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        match cmd {\n-            IoctlCmd::TCGETS => {\n-                // FIXME: only a work around\n-                let tty = get_n_tty();\n-                tty.ioctl(cmd, arg)\n-            }\n-            _ => panic!(\"Ioctl unsupported\"),\n-        }\n-    }\n-\n-    fn poll(&self) -> IoEvents {\n-        IoEvents::empty()\n-    }\n-\n-    fn flush(&self) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn metadata(&self) -> Metadata {\n-        panic!(\"metadata unsupported\");\n-    }\n-\n-    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n-        panic!(\"seek unsupported\");\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/mod.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/file_handle/mod.rs\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-//! Opend File Handle\n-\n-mod file;\n-mod inode_handle;\n-\n-use crate::fs::utils::{Metadata, SeekFrom};\n-use crate::prelude::*;\n-use crate::rights::{ReadOp, WriteOp};\n-use alloc::sync::Arc;\n-\n-pub use self::file::File;\n-pub use self::inode_handle::InodeHandle;\n-\n-#[derive(Clone)]\n-pub struct FileHandle {\n-    inner: Inner,\n-}\n-\n-#[derive(Clone)]\n-enum Inner {\n-    File(Arc<dyn File>),\n-    Inode(InodeHandle),\n-}\n-\n-impl FileHandle {\n-    pub fn new_file(file: Arc<dyn File>) -> Self {\n-        let inner = Inner::File(file);\n-        Self { inner }\n-    }\n-\n-    pub fn new_inode_handle(inode_handle: InodeHandle) -> Self {\n-        let inner = Inner::Inode(inode_handle);\n-        Self { inner }\n-    }\n-\n-    pub fn as_file(&self) -> Option<&Arc<dyn File>> {\n-        match &self.inner {\n-            Inner::File(file) => Some(file),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_inode_handle(&self) -> Option<&InodeHandle> {\n-        match &self.inner {\n-            Inner::Inode(inode_handle) => Some(inode_handle),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.read(buf),\n-            Inner::Inode(inode_handle) => {\n-                let static_handle = inode_handle.clone().to_static::<ReadOp>()?;\n-                static_handle.read(buf)\n-            }\n-        }\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.write(buf),\n-            Inner::Inode(inode_handle) => {\n-                let static_handle = inode_handle.clone().to_static::<WriteOp>()?;\n-                static_handle.write(buf)\n-            }\n-        }\n-    }\n-\n-    pub fn metadata(&self) -> Metadata {\n-        match &self.inner {\n-            Inner::File(file) => file.metadata(),\n-            Inner::Inode(inode_handle) => inode_handle.dentry().vnode().metadata(),\n-        }\n-    }\n-\n-    pub fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.seek(seek_from),\n-            Inner::Inode(inode_handle) => inode_handle.seek(seek_from),\n-        }\n-    }\n-\n-    pub fn clean_for_close(&self) -> Result<()> {\n-        match &self.inner {\n-            Inner::Inode(_) => {\n-                // Close does not guarantee that the data has been successfully saved to disk.\n-            }\n-            Inner::File(file) => file.flush()?,\n-        }\n-        Ok(())\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -1,105 +1,128 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n+use core::cell::Cell;\n+use jinux_util::slot_vec::SlotVec;\n+\n use super::{\n-    file_handle::FileHandle,\n-    stdio::{Stderr, Stdin, Stdout, FD_STDERR, FD_STDIN, FD_STDOUT},\n+    file_handle::FileLike,\n+    stdio::{Stderr, Stdin, Stdout},\n };\n \n pub type FileDescripter = i32;\n \n pub struct FileTable {\n-    table: BTreeMap<FileDescripter, FileHandle>,\n+    table: SlotVec<FileTableEntry>,\n     subject: Subject<FdEvents>,\n }\n \n impl FileTable {\n     pub fn new() -> Self {\n         Self {\n-            table: BTreeMap::new(),\n+            table: SlotVec::new(),\n             subject: Subject::new(),\n         }\n     }\n \n     pub fn new_with_stdio() -> Self {\n-        let mut table = BTreeMap::new();\n+        let mut table = SlotVec::new();\n         let stdin = Stdin::new_with_default_console();\n         let stdout = Stdout::new_with_default_console();\n         let stderr = Stderr::new_with_default_console();\n-        table.insert(FD_STDIN, FileHandle::new_file(Arc::new(stdin)));\n-        table.insert(FD_STDOUT, FileHandle::new_file(Arc::new(stdout)));\n-        table.insert(FD_STDERR, FileHandle::new_file(Arc::new(stderr)));\n+        table.put(FileTableEntry::new(Arc::new(stdin), false));\n+        table.put(FileTableEntry::new(Arc::new(stdout), false));\n+        table.put(FileTableEntry::new(Arc::new(stderr), false));\n         Self {\n             table,\n             subject: Subject::new(),\n         }\n     }\n \n-    pub fn dup(&mut self, fd: FileDescripter, new_fd: Option<FileDescripter>) -> Result<()> {\n-        let file = self.table.get(&fd).map_or_else(\n+    pub fn dup(&mut self, fd: FileDescripter, new_fd: FileDescripter) -> Result<FileDescripter> {\n+        let entry = self.table.get(fd as usize).map_or_else(\n             || return_errno_with_message!(Errno::ENOENT, \"No such file\"),\n-            |f| Ok(f.clone()),\n+            |e| Ok(e.clone()),\n         )?;\n-        let new_fd = if let Some(new_fd) = new_fd {\n-            new_fd\n-        } else {\n-            self.max_fd() + 1\n+\n+        // Get the lowest-numbered available fd equal to or greater than `new_fd`.\n+        let get_min_free_fd = || -> usize {\n+            let new_fd = new_fd as usize;\n+            if self.table.get(new_fd).is_none() {\n+                return new_fd;\n+            }\n+\n+            for idx in new_fd + 1..self.table.slots_len() {\n+                if self.table.get(idx).is_none() {\n+                    return idx;\n+                }\n+            }\n+            self.table.slots_len()\n         };\n-        if self.table.contains_key(&new_fd) {\n-            return_errno_with_message!(Errno::EBADF, \"Fd exists\");\n-        }\n-        self.table.insert(new_fd, file);\n \n-        Ok(())\n+        let min_free_fd = get_min_free_fd();\n+        self.table.put_at(min_free_fd, entry);\n+        Ok(min_free_fd as FileDescripter)\n     }\n \n-    fn max_fd(&self) -> FileDescripter {\n-        self.table.iter().map(|(fd, _)| fd.clone()).max().unwrap()\n+    pub fn insert(&mut self, item: Arc<dyn FileLike>) -> FileDescripter {\n+        let entry = FileTableEntry::new(item, false);\n+        self.table.put(entry) as FileDescripter\n     }\n \n-    pub fn insert(&mut self, item: FileHandle) -> FileDescripter {\n-        let fd = self.max_fd() + 1;\n-        self.table.insert(fd, item);\n-        fd\n+    pub fn insert_at(\n+        &mut self,\n+        fd: FileDescripter,\n+        item: Arc<dyn FileLike>,\n+    ) -> Option<Arc<dyn FileLike>> {\n+        let entry = FileTableEntry::new(item, false);\n+        let entry = self.table.put_at(fd as usize, entry);\n+        if entry.is_some() {\n+            let events = FdEvents::Close(fd);\n+            self.notify_fd_events(&events);\n+            entry.as_ref().unwrap().notify_fd_events(&events);\n+        }\n+        entry.map(|e| e.file)\n     }\n \n-    pub fn insert_at(&mut self, fd: FileDescripter, item: FileHandle) -> Option<FileHandle> {\n-        let file = self.table.insert(fd, item);\n-        if file.is_some() {\n-            self.notify_close_fd_event(fd);\n+    pub fn close_file(&mut self, fd: FileDescripter) -> Option<Arc<dyn FileLike>> {\n+        let entry = self.table.remove(fd as usize);\n+        if entry.is_some() {\n+            let events = FdEvents::Close(fd);\n+            self.notify_fd_events(&events);\n+            entry.as_ref().unwrap().notify_fd_events(&events);\n         }\n-        file\n+        entry.map(|e| e.file)\n     }\n \n-    pub fn close_file(&mut self, fd: FileDescripter) -> Option<FileHandle> {\n-        let file = self.table.remove(&fd);\n-        if file.is_some() {\n-            self.notify_close_fd_event(fd);\n-        }\n-        file\n+    pub fn get_file(&self, fd: FileDescripter) -> Result<&Arc<dyn FileLike>> {\n+        self.table\n+            .get(fd as usize)\n+            .map(|entry| &entry.file)\n+            .ok_or(Error::with_message(Errno::EBADF, \"fd not exits\"))\n     }\n \n-    pub fn get_file(&self, fd: FileDescripter) -> Result<&FileHandle> {\n+    pub fn get_entry(&self, fd: FileDescripter) -> Result<&FileTableEntry> {\n         self.table\n-            .get(&fd)\n+            .get(fd as usize)\n             .ok_or(Error::with_message(Errno::EBADF, \"fd not exits\"))\n     }\n \n-    pub fn fds_and_files(&self) -> impl Iterator<Item = (&'_ FileDescripter, &'_ FileHandle)> {\n-        self.table.iter()\n+    pub fn fds_and_files(&self) -> impl Iterator<Item = (FileDescripter, &'_ Arc<dyn FileLike>)> {\n+        self.table\n+            .idxes_and_items()\n+            .map(|(idx, entry)| (idx as FileDescripter, &entry.file))\n     }\n \n     pub fn register_observer(&self, observer: Weak<dyn Observer<FdEvents>>) {\n-        self.subject.register_observer(observer);\n+        self.subject.register_observer(observer, ());\n     }\n \n-    pub fn unregister_observer(&self, observer: Weak<dyn Observer<FdEvents>>) {\n+    pub fn unregister_observer(&self, observer: &Weak<dyn Observer<FdEvents>>) {\n         self.subject.unregister_observer(observer);\n     }\n \n-    fn notify_close_fd_event(&self, fd: FileDescripter) {\n-        let events = FdEvents::Close(fd);\n-        self.subject.notify_observers(&events);\n+    fn notify_fd_events(&self, events: &FdEvents) {\n+        self.subject.notify_observers(events);\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -126,3 +149,45 @@ pub enum FdEvents {\n }\n \n impl Events for FdEvents {}\n+\n+pub struct FileTableEntry {\n+    file: Arc<dyn FileLike>,\n+    close_on_exec: Cell<bool>,\n+    subject: Subject<FdEvents>,\n+}\n+\n+impl FileTableEntry {\n+    pub fn new(file: Arc<dyn FileLike>, close_on_exec: bool) -> Self {\n+        Self {\n+            file,\n+            close_on_exec: Cell::new(close_on_exec),\n+            subject: Subject::new(),\n+        }\n+    }\n+\n+    pub fn file(&self) -> &Arc<dyn FileLike> {\n+        &self.file\n+    }\n+\n+    pub fn register_observer(&self, epoll: Weak<dyn Observer<FdEvents>>) {\n+        self.subject.register_observer(epoll, ());\n+    }\n+\n+    pub fn unregister_observer(&self, epoll: &Weak<dyn Observer<FdEvents>>) {\n+        self.subject.unregister_observer(epoll);\n+    }\n+\n+    pub fn notify_fd_events(&self, events: &FdEvents) {\n+        self.subject.notify_observers(events);\n+    }\n+}\n+\n+impl Clone for FileTableEntry {\n+    fn clone(&self) -> Self {\n+        Self {\n+            file: self.file.clone(),\n+            close_on_exec: self.close_on_exec.clone(),\n+            subject: Subject::new(),\n+        }\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/jinux-std/src/fs/fs_resolver.rs\n--- a/services/libs/jinux-std/src/fs/fs_resolver.rs\n+++ b/services/libs/jinux-std/src/fs/fs_resolver.rs\n@@ -2,8 +2,8 @@ use crate::prelude::*;\n use alloc::str;\n use alloc::string::String;\n \n-use super::file_handle::InodeHandle;\n use super::file_table::FileDescripter;\n+use super::inode_handle::InodeHandle;\n use super::procfs::ProcFS;\n use super::ramfs::RamFS;\n use super::utils::{\ndiff --git a/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/jinux-std/src/fs/fs_resolver.rs\n--- a/services/libs/jinux-std/src/fs/fs_resolver.rs\n+++ b/services/libs/jinux-std/src/fs/fs_resolver.rs\n@@ -253,7 +253,7 @@ impl FsResolver {\n         let file_table = current.file_table().lock();\n         let inode_handle = file_table\n             .get_file(fd)?\n-            .as_inode_handle()\n+            .downcast_ref::<InodeHandle>()\n             .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n         Ok(inode_handle.dentry().clone())\n     }\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -36,13 +36,6 @@ impl InodeHandle<Rights> {\n         Ok(InodeHandle(self.0, R1::new()))\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        if !self.1.contains(Rights::READ) {\n-            return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n-        }\n-        self.0.read(buf)\n-    }\n-\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -50,13 +43,6 @@ impl InodeHandle<Rights> {\n         self.0.read_to_end(buf)\n     }\n \n-    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n-        if !self.1.contains(Rights::WRITE) {\n-            return_errno_with_message!(Errno::EBADF, \"File is not writable\");\n-        }\n-        self.0.write(buf)\n-    }\n-\n     pub fn readdir(&self, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -70,3 +56,40 @@ impl Clone for InodeHandle<Rights> {\n         Self(self.0.clone(), self.1.clone())\n     }\n }\n+\n+impl FileLike for InodeHandle<Rights> {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        if !self.1.contains(Rights::READ) {\n+            return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n+        }\n+        self.0.read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        if !self.1.contains(Rights::WRITE) {\n+            return_errno_with_message!(Errno::EBADF, \"File is not writable\");\n+        }\n+        self.0.write(buf)\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.dentry().vnode().poll(mask, poller)\n+    }\n+\n+    fn metadata(&self) -> Metadata {\n+        self.dentry().vnode().metadata()\n+    }\n+\n+    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n+        self.0.seek(seek_from)\n+    }\n+\n+    fn clean_for_close(&self) -> Result<()> {\n+        // Close does not guarantee that the data has been successfully saved to disk.\n+        Ok(())\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -3,7 +3,10 @@\n mod dyn_cap;\n mod static_cap;\n \n-use crate::fs::utils::{AccessMode, Dentry, DirentVisitor, InodeType, SeekFrom, StatusFlags};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::utils::{\n+    AccessMode, Dentry, DirentVisitor, InodeType, IoEvents, Metadata, Poller, SeekFrom, StatusFlags,\n+};\n use crate::prelude::*;\n use crate::rights::Rights;\n \ndiff --git a/services/libs/jinux-std/src/fs/mod.rs b/services/libs/jinux-std/src/fs/mod.rs\n--- a/services/libs/jinux-std/src/fs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/mod.rs\n@@ -1,7 +1,10 @@\n+pub mod epoll;\n pub mod file_handle;\n pub mod file_table;\n pub mod fs_resolver;\n pub mod initramfs;\n+pub mod inode_handle;\n+pub mod pipe;\n pub mod procfs;\n pub mod ramfs;\n pub mod stdio;\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/pipe.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/pipe.rs\n@@ -0,0 +1,134 @@\n+use crate::events::Observer;\n+use crate::prelude::*;\n+\n+use super::file_handle::FileLike;\n+use super::utils::{Consumer, IoEvents, Poller, Producer};\n+\n+pub struct PipeReader {\n+    consumer: Consumer<u8>,\n+}\n+\n+impl PipeReader {\n+    pub fn new(consumer: Consumer<u8>) -> Self {\n+        Self { consumer }\n+    }\n+}\n+\n+impl FileLike for PipeReader {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        let is_nonblocking = self.consumer.is_nonblocking();\n+\n+        // Fast path\n+        let res = self.consumer.read(buf);\n+        if should_io_return(&res, is_nonblocking) {\n+            return res;\n+        }\n+\n+        // Slow path\n+        let mask = IoEvents::IN;\n+        let poller = Poller::new();\n+        loop {\n+            let res = self.consumer.read(buf);\n+            if should_io_return(&res, is_nonblocking) {\n+                return res;\n+            }\n+            let events = self.poll(mask, Some(&poller));\n+            if events.is_empty() {\n+                poller.wait();\n+            }\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.consumer.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.consumer.register_observer(observer, mask)\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.consumer.unregister_observer(observer)\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+pub struct PipeWriter {\n+    producer: Producer<u8>,\n+}\n+\n+impl PipeWriter {\n+    pub fn new(producer: Producer<u8>) -> Self {\n+        Self { producer }\n+    }\n+}\n+\n+impl FileLike for PipeWriter {\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let is_nonblocking = self.producer.is_nonblocking();\n+\n+        // Fast path\n+        let res = self.producer.write(buf);\n+        if should_io_return(&res, is_nonblocking) {\n+            return res;\n+        }\n+\n+        // Slow path\n+        let mask = IoEvents::OUT;\n+        let poller = Poller::new();\n+        loop {\n+            let res = self.producer.write(buf);\n+            if should_io_return(&res, is_nonblocking) {\n+                return res;\n+            }\n+            let events = self.poll(mask, Some(&poller));\n+            if events.is_empty() {\n+                poller.wait();\n+            }\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.producer.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.producer.register_observer(observer, mask)\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.producer.unregister_observer(observer)\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+fn should_io_return(res: &Result<usize>, is_nonblocking: bool) -> bool {\n+    if is_nonblocking {\n+        return true;\n+    }\n+    match res {\n+        Ok(_) => true,\n+        Err(e) if e.error() == Errno::EAGAIN => false,\n+        Err(_) => true,\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -1,6 +1,7 @@\n use super::*;\n-use crate::fs::file_handle::FileHandle;\n+use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::FileDescripter;\n+use crate::fs::inode_handle::InodeHandle;\n \n /// Represents the inode at `/proc/[pid]/fd`.\n pub struct FdDirOps(Arc<Process>);\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -62,10 +63,10 @@ impl DirOps for FdDirOps {\n }\n \n /// Represents the inode at `/proc/[pid]/fd/N`.\n-struct FileSymOps(FileHandle);\n+struct FileSymOps(Arc<dyn FileLike>);\n \n impl FileSymOps {\n-    pub fn new_inode(file: FileHandle, parent: Weak<dyn Inode>) -> Arc<dyn Inode> {\n+    pub fn new_inode(file: Arc<dyn FileLike>, parent: Weak<dyn Inode>) -> Arc<dyn Inode> {\n         ProcSymBuilder::new(Self(file))\n             .parent(parent)\n             .build()\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -75,13 +76,11 @@ impl FileSymOps {\n \n impl SymOps for FileSymOps {\n     fn read_link(&self) -> Result<String> {\n-        let path = if let Some(inode_handle) = self.0.as_inode_handle() {\n+        let path = if let Some(inode_handle) = self.0.downcast_ref::<InodeHandle>() {\n             inode_handle.dentry().abs_path()\n-        } else if let Some(file) = self.0.as_file() {\n-            // TODO: get the real path for stdio\n-            String::from(\"/dev/tty\")\n         } else {\n-            unreachable!()\n+            // TODO: get the real path for other FileLike object\n+            String::from(\"/dev/tty\")\n         };\n         Ok(path)\n     }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -2,9 +2,10 @@ use alloc::string::String;\n use core::any::Any;\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n+use jinux_util::slot_vec::SlotVec;\n \n use crate::fs::utils::{\n-    DirEntryVec, DirentVisitor, FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n+    DirentVisitor, FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n };\n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -14,7 +15,7 @@ pub struct ProcDir<D: DirOps> {\n     inner: D,\n     this: Weak<ProcDir<D>>,\n     parent: Option<Weak<dyn Inode>>,\n-    cached_children: RwLock<DirEntryVec<(String, Arc<dyn Inode>)>>,\n+    cached_children: RwLock<SlotVec<(String, Arc<dyn Inode>)>>,\n     info: ProcInodeInfo,\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -38,7 +39,7 @@ impl<D: DirOps> ProcDir<D> {\n             inner: dir,\n             this: weak_self.clone(),\n             parent,\n-            cached_children: RwLock::new(DirEntryVec::new()),\n+            cached_children: RwLock::new(SlotVec::new()),\n             info,\n         })\n     }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -51,7 +52,7 @@ impl<D: DirOps> ProcDir<D> {\n         self.parent.as_ref().and_then(|p| p.upgrade())\n     }\n \n-    pub fn cached_children(&self) -> &RwLock<DirEntryVec<(String, Arc<dyn Inode>)>> {\n+    pub fn cached_children(&self) -> &RwLock<SlotVec<(String, Arc<dyn Inode>)>> {\n         &self.cached_children\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -127,7 +128,7 @@ impl<D: DirOps + 'static> Inode for ProcDir<D> {\n             self.inner.populate_children(self.this.clone());\n             let cached_children = self.cached_children.read();\n             for (idx, (name, child)) in cached_children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .map(|(idx, (name, child))| (idx + 2, (name, child)))\n             {\n                 if idx < *offset {\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -5,12 +5,12 @@ use core::any::Any;\n use core::sync::atomic::{AtomicUsize, Ordering};\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n+use jinux_util::slot_vec::SlotVec;\n use spin::{RwLock, RwLockWriteGuard};\n \n use super::*;\n use crate::fs::utils::{\n-    DirEntryVec, DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd,\n-    Metadata, SuperBlock,\n+    DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata, SuperBlock,\n };\n \n pub struct RamFS {\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -164,7 +164,7 @@ impl Inner {\n }\n \n struct DirEntry {\n-    children: DirEntryVec<(Str256, Arc<RamInode>)>,\n+    children: SlotVec<(Str256, Arc<RamInode>)>,\n     this: Weak<RamInode>,\n     parent: Weak<RamInode>,\n }\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -172,7 +172,7 @@ struct DirEntry {\n impl DirEntry {\n     fn new() -> Self {\n         Self {\n-            children: DirEntryVec::new(),\n+            children: SlotVec::new(),\n             this: Weak::default(),\n             parent: Weak::default(),\n         }\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -205,13 +205,13 @@ impl DirEntry {\n             Some((1, self.parent.upgrade().unwrap()))\n         } else {\n             self.children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .find(|(_, (child, _))| child == &Str256::from(name))\n                 .map(|(idx, (_, inode))| (idx + 2, inode.clone()))\n         }\n     }\n \n-    fn append_entry(&mut self, name: &str, inode: Arc<RamInode>) {\n+    fn append_entry(&mut self, name: &str, inode: Arc<RamInode>) -> usize {\n         self.children.put((Str256::from(name), inode))\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -255,7 +255,7 @@ impl DirEntry {\n             // Read the normal child entries.\n             for (offset, (name, child)) in self\n                 .children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .map(|(offset, (name, child))| (offset + 2, (name, child)))\n             {\n                 if offset < *idx {\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -1,9 +1,9 @@\n use crate::prelude::*;\n use crate::tty::{get_n_tty, Tty};\n \n-use super::file_handle::File;\n+use super::file_handle::FileLike;\n use super::file_table::FileDescripter;\n-use super::utils::{InodeMode, InodeType, IoEvents, Metadata, SeekFrom};\n+use super::utils::{InodeMode, InodeType, IoEvents, Metadata, Poller, SeekFrom};\n \n pub const FD_STDIN: FileDescripter = 0;\n pub const FD_STDOUT: FileDescripter = 1;\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -21,10 +21,10 @@ pub struct Stderr {\n     console: Option<Arc<Tty>>,\n }\n \n-impl File for Stdin {\n-    fn poll(&self) -> IoEvents {\n+impl FileLike for Stdin {\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         if let Some(console) = self.console.as_ref() {\n-            console.poll()\n+            console.poll(mask, poller)\n         } else {\n             todo!()\n         }\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -69,8 +69,12 @@ impl File for Stdin {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n-impl File for Stdout {\n+impl FileLike for Stdout {\n     fn ioctl(&self, cmd: super::utils::IoctlCmd, arg: usize) -> Result<i32> {\n         if let Some(console) = self.console.as_ref() {\n             console.ioctl(cmd, arg)\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -110,9 +114,13 @@ impl File for Stdout {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n-impl File for Stderr {\n+impl FileLike for Stderr {\n     fn ioctl(&self, cmd: super::utils::IoctlCmd, arg: usize) -> Result<i32> {\n         if let Some(console) = self.console.as_ref() {\n             console.ioctl(cmd, arg)\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -152,6 +160,10 @@ impl File for Stderr {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n impl Stdin {\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/utils/channel.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/utils/channel.rs\n@@ -0,0 +1,347 @@\n+use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n+use jinux_rights_proc::require;\n+use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\n+\n+use crate::events::Observer;\n+use crate::prelude::*;\n+use crate::rights::*;\n+\n+use super::{IoEvents, Pollee, Poller, StatusFlags};\n+\n+/// A unidirectional communication channel, intended to implement IPC, e.g., pipe,\n+/// unix domain sockets, etc.\n+pub struct Channel<T> {\n+    producer: Producer<T>,\n+    consumer: Consumer<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    pub fn with_capacity(capacity: usize) -> Result<Self> {\n+        Self::with_capacity_and_flags(capacity, StatusFlags::empty())\n+    }\n+\n+    pub fn with_capacity_and_flags(capacity: usize, flags: StatusFlags) -> Result<Self> {\n+        let common = Arc::new(Common::with_capacity_and_flags(capacity, flags)?);\n+        let producer = Producer(EndPoint::new(common.clone(), WriteOp::new()));\n+        let consumer = Consumer(EndPoint::new(common, ReadOp::new()));\n+        Ok(Self { producer, consumer })\n+    }\n+\n+    pub fn split(self) -> (Producer<T>, Consumer<T>) {\n+        let Self { producer, consumer } = self;\n+        (producer, consumer)\n+    }\n+\n+    pub fn producer(&self) -> &Producer<T> {\n+        &self.producer\n+    }\n+\n+    pub fn consumer(&self) -> &Consumer<T> {\n+        &self.consumer\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.producer.0.common.capacity()\n+    }\n+}\n+\n+pub struct Producer<T>(EndPoint<T, WriteOp>);\n+\n+pub struct Consumer<T>(EndPoint<T, ReadOp>);\n+\n+macro_rules! impl_common_methods_for_channel {\n+    () => {\n+        pub fn shutdown(&self) {\n+            self.this_end().shutdown()\n+        }\n+\n+        pub fn is_shutdown(&self) -> bool {\n+            self.this_end().is_shutdown()\n+        }\n+\n+        pub fn is_peer_shutdown(&self) -> bool {\n+            self.peer_end().is_shutdown()\n+        }\n+\n+        pub fn status_flags(&self) -> StatusFlags {\n+            self.this_end().status_flags()\n+        }\n+\n+        pub fn set_status_flags(&self, new_flags: StatusFlags) {\n+            self.this_end().set_status_flags(new_flags)\n+        }\n+\n+        pub fn is_nonblocking(&self) -> bool {\n+            self.this_end()\n+                .status_flags()\n+                .contains(StatusFlags::O_NONBLOCK)\n+        }\n+\n+        pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+            self.this_end().pollee.poll(mask, poller)\n+        }\n+\n+        pub fn register_observer(\n+            &self,\n+            observer: Weak<dyn Observer<IoEvents>>,\n+            mask: IoEvents,\n+        ) -> Result<()> {\n+            self.this_end().pollee.register_observer(observer, mask);\n+            Ok(())\n+        }\n+\n+        pub fn unregister_observer(\n+            &self,\n+            observer: &Weak<dyn Observer<IoEvents>>,\n+        ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+            self.this_end()\n+                .pollee\n+                .unregister_observer(observer)\n+                .ok_or_else(|| Error::with_message(Errno::ENOENT, \"the observer is not registered\"))\n+        }\n+    };\n+}\n+\n+impl<T> Producer<T> {\n+    fn this_end(&self) -> &EndPointInner<HeapRbProducer<T>> {\n+        &self.0.common.producer\n+    }\n+\n+    fn peer_end(&self) -> &EndPointInner<HeapRbConsumer<T>> {\n+        &self.0.common.consumer\n+    }\n+\n+    fn update_pollee(&self) {\n+        let this_end = self.this_end();\n+        let peer_end = self.peer_end();\n+\n+        // Update the event of pollee in a critical region so that pollee\n+        // always reflects the _true_ state of the underlying ring buffer\n+        // regardless of any race conditions.\n+        self.0.common.lock_event();\n+\n+        let rb = this_end.rb();\n+        if rb.is_full() {\n+            this_end.pollee.del_events(IoEvents::OUT);\n+        }\n+        if !rb.is_empty() {\n+            peer_end.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+\n+    impl_common_methods_for_channel!();\n+}\n+\n+impl<T: Copy> Producer<T> {\n+    pub fn write(&self, buf: &[T]) -> Result<usize> {\n+        if self.is_shutdown() || self.is_peer_shutdown() {\n+            return_errno!(Errno::EPIPE);\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let written_len = self.0.write(buf);\n+\n+        self.update_pollee();\n+\n+        if written_len > 0 {\n+            Ok(written_len)\n+        } else {\n+            return_errno_with_message!(Errno::EAGAIN, \"try write later\");\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Producer<T> {\n+    fn drop(&mut self) {\n+        self.shutdown();\n+\n+        self.0.common.lock_event();\n+\n+        // When reading from a channel such as a pipe or a stream socket,\n+        // POLLHUP merely indicates that the peer closed its end of the channel.\n+        self.peer_end().pollee.add_events(IoEvents::HUP);\n+    }\n+}\n+\n+impl<T> Consumer<T> {\n+    fn this_end(&self) -> &EndPointInner<HeapRbConsumer<T>> {\n+        &self.0.common.consumer\n+    }\n+\n+    fn peer_end(&self) -> &EndPointInner<HeapRbProducer<T>> {\n+        &self.0.common.producer\n+    }\n+\n+    fn update_pollee(&self) {\n+        let this_end = self.this_end();\n+        let peer_end = self.peer_end();\n+\n+        // Update the event of pollee in a critical region so that pollee\n+        // always reflects the _true_ state of the underlying ring buffer\n+        // regardless of any race conditions.\n+        self.0.common.lock_event();\n+\n+        let rb = this_end.rb();\n+        if rb.is_empty() {\n+            this_end.pollee.del_events(IoEvents::IN);\n+        }\n+        if !rb.is_full() {\n+            peer_end.pollee.add_events(IoEvents::OUT);\n+        }\n+    }\n+\n+    impl_common_methods_for_channel!();\n+}\n+\n+impl<T: Copy> Consumer<T> {\n+    pub fn read(&self, buf: &mut [T]) -> Result<usize> {\n+        if self.is_shutdown() {\n+            return_errno!(Errno::EPIPE);\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let read_len = self.0.read(buf);\n+\n+        self.update_pollee();\n+\n+        if self.is_peer_shutdown() {\n+            return Ok(read_len);\n+        }\n+\n+        if read_len > 0 {\n+            Ok(read_len)\n+        } else {\n+            return_errno_with_message!(Errno::EAGAIN, \"try read later\");\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Consumer<T> {\n+    fn drop(&mut self) {\n+        self.shutdown();\n+\n+        self.0.common.lock_event();\n+\n+        // POLLERR is also set for a file descriptor referring to the write end of a pipe\n+        // when the read end has been closed.\n+        self.peer_end().pollee.add_events(IoEvents::ERR);\n+    }\n+}\n+\n+struct EndPoint<T, R: TRights> {\n+    common: Arc<Common<T>>,\n+    rights: R,\n+}\n+\n+impl<T, R: TRights> EndPoint<T, R> {\n+    pub fn new(common: Arc<Common<T>>, rights: R) -> Self {\n+        Self { common, rights }\n+    }\n+}\n+\n+impl<T: Copy, R: TRights> EndPoint<T, R> {\n+    #[require(R > Read)]\n+    pub fn read(&self, buf: &mut [T]) -> usize {\n+        let mut rb = self.common.consumer.rb();\n+        rb.pop_slice(buf)\n+    }\n+\n+    #[require(R > Write)]\n+    pub fn write(&self, buf: &[T]) -> usize {\n+        let mut rb = self.common.producer.rb();\n+        rb.push_slice(buf)\n+    }\n+}\n+\n+struct Common<T> {\n+    producer: EndPointInner<HeapRbProducer<T>>,\n+    consumer: EndPointInner<HeapRbConsumer<T>>,\n+    event_lock: Mutex<()>,\n+}\n+\n+impl<T> Common<T> {\n+    fn with_capacity_and_flags(capacity: usize, flags: StatusFlags) -> Result<Self> {\n+        check_status_flags(flags)?;\n+\n+        if capacity == 0 {\n+            return_errno_with_message!(Errno::EINVAL, \"capacity cannot be zero\");\n+        }\n+\n+        let rb: HeapRb<T> = HeapRb::new(capacity);\n+        let (rb_producer, rb_consumer) = rb.split();\n+\n+        let producer = EndPointInner::new(rb_producer, IoEvents::OUT, flags);\n+        let consumer = EndPointInner::new(rb_consumer, IoEvents::empty(), flags);\n+        let event_lock = Mutex::new(());\n+\n+        Ok(Self {\n+            producer,\n+            consumer,\n+            event_lock,\n+        })\n+    }\n+\n+    pub fn lock_event(&self) -> MutexGuard<()> {\n+        self.event_lock.lock()\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.producer.rb().capacity()\n+    }\n+}\n+\n+struct EndPointInner<T> {\n+    rb: Mutex<T>,\n+    pollee: Pollee,\n+    is_shutdown: AtomicBool,\n+    status_flags: AtomicU32,\n+}\n+\n+impl<T> EndPointInner<T> {\n+    pub fn new(rb: T, init_events: IoEvents, status_flags: StatusFlags) -> Self {\n+        Self {\n+            rb: Mutex::new(rb),\n+            pollee: Pollee::new(init_events),\n+            is_shutdown: AtomicBool::new(false),\n+            status_flags: AtomicU32::new(status_flags.bits()),\n+        }\n+    }\n+\n+    pub fn rb(&self) -> MutexGuard<T> {\n+        self.rb.lock()\n+    }\n+\n+    pub fn is_shutdown(&self) -> bool {\n+        self.is_shutdown.load(Ordering::Acquire)\n+    }\n+\n+    pub fn shutdown(&self) {\n+        self.is_shutdown.store(true, Ordering::Release)\n+    }\n+\n+    pub fn status_flags(&self) -> StatusFlags {\n+        let bits = self.status_flags.load(Ordering::Relaxed);\n+        StatusFlags::from_bits(bits).unwrap()\n+    }\n+\n+    pub fn set_status_flags(&self, new_flags: StatusFlags) {\n+        self.status_flags.store(new_flags.bits(), Ordering::Relaxed);\n+    }\n+}\n+\n+fn check_status_flags(flags: StatusFlags) -> Result<()> {\n+    let valid_flags: StatusFlags = StatusFlags::O_NONBLOCK | StatusFlags::O_DIRECT;\n+    if !valid_flags.contains(flags) {\n+        return_errno_with_message!(Errno::EINVAL, \"invalid flags\");\n+    }\n+    if flags.contains(StatusFlags::O_DIRECT) {\n+        return_errno_with_message!(Errno::EINVAL, \"O_DIRECT is not supported\");\n+    }\n+    Ok(())\n+}\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -1,87 +1,7 @@\n use super::Inode;\n use crate::prelude::*;\n \n-/// DirEntryVec is used to store the entries of a directory.\n-/// It can guarantee that the index of one dir entry remains unchanged during\n-/// adding or deleting other dir entries of it.\n-pub struct DirEntryVec<T> {\n-    // The slots to store dir entries.\n-    slots: Vec<Option<T>>,\n-    // The number of occupied slots.\n-    // The i-th slot is occupied if `self.slots[i].is_some()`.\n-    num_occupied: usize,\n-}\n-\n-impl<T> DirEntryVec<T> {\n-    /// New an empty vec.\n-    pub fn new() -> Self {\n-        Self {\n-            slots: Vec::new(),\n-            num_occupied: 0,\n-        }\n-    }\n-\n-    /// Returns `true` if the vec contains no entries.\n-    pub fn is_empty(&self) -> bool {\n-        self.num_occupied == 0\n-    }\n-\n-    /// Put a dir entry into the vec.\n-    /// it may be put into an existing empty slot or the back of the vec.\n-    pub fn put(&mut self, entry: T) {\n-        if self.num_occupied == self.slots.len() {\n-            self.slots.push(Some(entry));\n-        } else {\n-            let idx = self.slots.iter().position(|x| x.is_none()).unwrap();\n-            self.slots[idx] = Some(entry);\n-        }\n-        self.num_occupied += 1;\n-    }\n-\n-    /// Removes and returns the entry at position `idx`.\n-    /// Returns `None` if `idx` is out of bounds or the entry has been removed.\n-    pub fn remove(&mut self, idx: usize) -> Option<T> {\n-        if idx >= self.slots.len() {\n-            return None;\n-        }\n-        let mut del_entry = None;\n-        core::mem::swap(&mut del_entry, &mut self.slots[idx]);\n-        if del_entry.is_some() {\n-            debug_assert!(self.num_occupied > 0);\n-            self.num_occupied -= 1;\n-        }\n-        del_entry\n-    }\n-\n-    /// Put and returns the entry at position `idx`.\n-    /// Returns `None` if `idx` is out of bounds or the entry has been removed.\n-    pub fn put_at(&mut self, idx: usize, entry: T) -> Option<T> {\n-        if idx >= self.slots.len() {\n-            return None;\n-        }\n-        let mut sub_entry = Some(entry);\n-        core::mem::swap(&mut sub_entry, &mut self.slots[idx]);\n-        if sub_entry.is_none() {\n-            self.num_occupied += 1;\n-        }\n-        sub_entry\n-    }\n-\n-    /// Creates an iterator which gives both of the index and the dir entry.\n-    /// The index may not be continuous.\n-    pub fn idxes_and_entries(&self) -> impl Iterator<Item = (usize, &'_ T)> {\n-        self.slots\n-            .iter()\n-            .enumerate()\n-            .filter(|(_, x)| x.is_some())\n-            .map(|(idx, x)| (idx, x.as_ref().unwrap()))\n-    }\n-\n-    /// Creates an iterator which gives the dir entry.\n-    pub fn iter(&self) -> impl Iterator<Item = &'_ T> {\n-        self.slots.iter().filter_map(|x| x.as_ref())\n-    }\n-}\n+use jinux_util::slot_vec::SlotVec;\n \n pub trait DirEntryVecExt {\n     /// If the entry is not found by `name`, use `f` to get the inode, then put the entry into vec.\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -92,7 +12,7 @@ pub trait DirEntryVecExt {\n     fn remove_entry_by_name(&mut self, name: &str) -> Option<(String, Arc<dyn Inode>)>;\n }\n \n-impl DirEntryVecExt for DirEntryVec<(String, Arc<dyn Inode>)> {\n+impl DirEntryVecExt for SlotVec<(String, Arc<dyn Inode>)> {\n     fn put_entry_if_not_found(&mut self, name: &str, f: impl Fn() -> Arc<dyn Inode>) {\n         if self\n             .iter()\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -106,7 +26,7 @@ impl DirEntryVecExt for DirEntryVec<(String, Arc<dyn Inode>)> {\n \n     fn remove_entry_by_name(&mut self, name: &str) -> Option<(String, Arc<dyn Inode>)> {\n         let idx = self\n-            .idxes_and_entries()\n+            .idxes_and_items()\n             .find(|(_, (child_name, _))| child_name == name)\n             .map(|(idx, _)| idx);\n         if let Some(idx) = idx {\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -5,7 +5,7 @@ use core::any::Any;\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n \n-use super::{DirentVisitor, FileSystem, IoctlCmd, SuperBlock};\n+use super::{DirentVisitor, FileSystem, IoEvents, IoctlCmd, Poller, SuperBlock};\n use crate::prelude::*;\n \n #[repr(u32)]\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -197,6 +197,11 @@ pub trait Inode: Any + Sync + Send {\n \n     fn sync(&self) -> Result<()>;\n \n+    fn poll(&self, mask: IoEvents, _poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n+\n     fn fs(&self) -> Arc<dyn FileSystem>;\n \n     fn as_any_ref(&self) -> &dyn Any;\ndiff --git a/services/libs/jinux-std/src/fs/utils/io_events.rs b/services/libs/jinux-std/src/fs/utils/io_events.rs\n--- a/services/libs/jinux-std/src/fs/utils/io_events.rs\n+++ b/services/libs/jinux-std/src/fs/utils/io_events.rs\n@@ -1,11 +1,23 @@\n+use crate::events::{Events, EventsFilter};\n+\n crate::bitflags! {\n     pub struct IoEvents: u32 {\n-        const POLLIN    = 0x0001;\n-        const POLLPRI   = 0x0002;\n-        const POLLOUT   = 0x0004;\n-        const POLLERR   = 0x0008;\n-        const POLLHUP   = 0x0010;\n-        const POLLNVAL  = 0x0020;\n-        const POLLRDHUP = 0x2000;\n+        const IN    = 0x0001;\n+        const PRI   = 0x0002;\n+        const OUT   = 0x0004;\n+        const ERR   = 0x0008;\n+        const HUP   = 0x0010;\n+        const NVAL  = 0x0020;\n+        const RDHUP = 0x2000;\n+        /// Events that are always polled even without specifying them.\n+        const ALWAYS_POLL = Self::ERR.bits | Self::HUP.bits;\n+    }\n+}\n+\n+impl Events for IoEvents {}\n+\n+impl EventsFilter<IoEvents> for IoEvents {\n+    fn filter(&self, events: &IoEvents) -> bool {\n+        self.intersects(*events)\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/jinux-std/src/fs/utils/mod.rs\n--- a/services/libs/jinux-std/src/fs/utils/mod.rs\n+++ b/services/libs/jinux-std/src/fs/utils/mod.rs\n@@ -1,10 +1,11 @@\n //! VFS components\n \n pub use access_mode::AccessMode;\n+pub use channel::{Channel, Consumer, Producer};\n pub use creation_flags::CreationFlags;\n pub use dentry_cache::Dentry;\n pub use dirent_visitor::DirentVisitor;\n-pub use direntry_vec::{DirEntryVec, DirEntryVecExt};\n+pub use direntry_vec::DirEntryVecExt;\n pub use fcntl::FcntlCmd;\n pub use file_creation_mask::FileCreationMask;\n pub use fs::{FileSystem, FsFlags, SuperBlock};\ndiff --git a/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/jinux-std/src/fs/utils/mod.rs\n--- a/services/libs/jinux-std/src/fs/utils/mod.rs\n+++ b/services/libs/jinux-std/src/fs/utils/mod.rs\n@@ -12,11 +13,12 @@ pub use inode::{Inode, InodeMode, InodeType, Metadata};\n pub use io_events::IoEvents;\n pub use ioctl::IoctlCmd;\n pub use page_cache::PageCache;\n-pub use poll::{c_nfds, c_pollfd, PollFd};\n+pub use poll::{Pollee, Poller};\n pub use status_flags::StatusFlags;\n pub use vnode::Vnode;\n \n mod access_mode;\n+mod channel;\n mod creation_flags;\n mod dentry_cache;\n mod dirent_visitor;\ndiff --git a/services/libs/jinux-std/src/fs/utils/poll.rs b/services/libs/jinux-std/src/fs/utils/poll.rs\n--- a/services/libs/jinux-std/src/fs/utils/poll.rs\n+++ b/services/libs/jinux-std/src/fs/utils/poll.rs\n@@ -1,46 +1,214 @@\n-#![allow(non_camel_case_types)]\n-\n use super::IoEvents;\n-use crate::fs::file_table::FileDescripter;\n+use crate::events::{Observer, Subject};\n use crate::prelude::*;\n-pub type c_nfds = u64;\n \n-// https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/poll.h\n-#[derive(Debug, Clone, Copy, Pod)]\n-#[repr(C)]\n-pub struct c_pollfd {\n-    fd: FileDescripter,\n-    events: i16,\n-    revents: i16,\n+use core::sync::atomic::{AtomicU32, AtomicUsize, Ordering};\n+use jinux_frame::sync::WaitQueue;\n+use keyable_arc::KeyableWeak;\n+\n+/// A pollee maintains a set of active events, which can be polled with\n+/// pollers or be monitored with observers.\n+pub struct Pollee {\n+    inner: Arc<PolleeInner>,\n+}\n+\n+struct PolleeInner {\n+    // A subject which is monitored with pollers.\n+    subject: Subject<IoEvents, IoEvents>,\n+    // For efficient manipulation, we use AtomicU32 instead of RwLock<IoEvents>.\n+    events: AtomicU32,\n+}\n+\n+impl Pollee {\n+    /// Creates a new instance of pollee.\n+    pub fn new(init_events: IoEvents) -> Self {\n+        let inner = PolleeInner {\n+            subject: Subject::new(),\n+            events: AtomicU32::new(init_events.bits()),\n+        };\n+        Self {\n+            inner: Arc::new(inner),\n+        }\n+    }\n+\n+    /// Returns the current events of the pollee given an event mask.\n+    ///\n+    /// If no interesting events are polled and a poller is provided, then\n+    /// the poller will start monitoring the pollee and receive event\n+    /// notification once the pollee gets any interesting events.\n+    ///\n+    /// This operation is _atomic_ in the sense that either some interesting\n+    /// events are returned or the poller is registered (if a poller is provided).\n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mask = mask | IoEvents::ALWAYS_POLL;\n+\n+        // Fast path: return events immediately\n+        let revents = self.events() & mask;\n+        if !revents.is_empty() || poller.is_none() {\n+            return revents;\n+        }\n+\n+        // Register the provided poller.\n+        self.register_poller(poller.unwrap(), mask);\n+\n+        // It is important to check events again to handle race conditions\n+        let revents = self.events() & mask;\n+        revents\n+    }\n+\n+    fn register_poller(&self, poller: &Poller, mask: IoEvents) {\n+        self.inner\n+            .subject\n+            .register_observer(poller.observer(), mask);\n+        let mut pollees = poller.inner.pollees.lock();\n+        pollees.insert(Arc::downgrade(&self.inner).into(), ());\n+    }\n+\n+    /// Register an IoEvents observer.\n+    ///\n+    /// A registered observer will get notified (through its `on_events` method)\n+    /// every time new events specified by the `mask` argument happen on the\n+    /// pollee (through the `add_events` method).\n+    ///\n+    /// If the given observer has already been registered, then its registered\n+    /// event mask will be updated.\n+    ///\n+    /// Note that the observer will always get notified of the events in\n+    /// `IoEvents::ALWAYS_POLL` regardless of the value of `mask`.\n+    pub fn register_observer(&self, observer: Weak<dyn Observer<IoEvents>>, mask: IoEvents) {\n+        let mask = mask | IoEvents::ALWAYS_POLL;\n+        self.inner.subject.register_observer(observer, mask);\n+    }\n+\n+    /// Unregister an IoEvents observer.\n+    ///\n+    /// If such an observer is found, then the registered observer will be\n+    /// removed from the pollee and returned as the return value. Otherwise,\n+    /// a `None` will be returned.\n+    pub fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Option<Weak<dyn Observer<IoEvents>>> {\n+        self.inner.subject.unregister_observer(observer)\n+    }\n+\n+    /// Add some events to the pollee's state.\n+    ///\n+    /// This method wakes up all registered pollers that are interested in\n+    /// the added events.\n+    pub fn add_events(&self, events: IoEvents) {\n+        self.inner.events.fetch_or(events.bits(), Ordering::Release);\n+        self.inner.subject.notify_observers(&events);\n+    }\n+\n+    /// Remove some events from the pollee's state.\n+    ///\n+    /// This method will not wake up registered pollers even when\n+    /// the pollee still has some interesting events to the pollers.\n+    pub fn del_events(&self, events: IoEvents) {\n+        self.inner\n+            .events\n+            .fetch_and(!events.bits(), Ordering::Release);\n+    }\n+\n+    /// Reset the pollee's state.\n+    ///\n+    /// Reset means removing all events on the pollee.\n+    pub fn reset_events(&self) {\n+        self.inner\n+            .events\n+            .fetch_and(!IoEvents::all().bits(), Ordering::Release);\n+    }\n+\n+    fn events(&self) -> IoEvents {\n+        let event_bits = self.inner.events.load(Ordering::Acquire);\n+        IoEvents::from_bits(event_bits).unwrap()\n+    }\n }\n \n-#[derive(Debug, Clone, Copy)]\n-pub struct PollFd {\n-    pub fd: FileDescripter,\n-    pub events: IoEvents,\n-    pub revents: IoEvents,\n+/// A poller gets notified when its associated pollees have interesting events.\n+pub struct Poller {\n+    inner: Arc<PollerInner>,\n }\n \n-impl From<c_pollfd> for PollFd {\n-    fn from(raw: c_pollfd) -> Self {\n-        let events = IoEvents::from_bits_truncate(raw.events as _);\n-        let revents = IoEvents::from_bits_truncate(raw.revents as _);\n+struct PollerInner {\n+    // Use event counter to wait or wake up a poller\n+    event_counter: EventCounter,\n+    // All pollees that are interesting to this poller\n+    pollees: Mutex<BTreeMap<KeyableWeak<PolleeInner>, ()>>,\n+}\n+\n+impl Poller {\n+    /// Constructs a new `Poller`.\n+    pub fn new() -> Self {\n+        let inner = PollerInner {\n+            event_counter: EventCounter::new(),\n+            pollees: Mutex::new(BTreeMap::new()),\n+        };\n         Self {\n-            fd: raw.fd,\n-            events,\n-            revents,\n+            inner: Arc::new(inner),\n         }\n     }\n+\n+    /// Wait until there are any interesting events happen since last `wait`.\n+    pub fn wait(&self) {\n+        self.inner.event_counter.read();\n+    }\n+\n+    fn observer(&self) -> Weak<dyn Observer<IoEvents>> {\n+        Arc::downgrade(&self.inner) as _\n+    }\n+}\n+\n+impl Observer<IoEvents> for PollerInner {\n+    fn on_events(&self, _events: &IoEvents) {\n+        self.event_counter.write();\n+    }\n }\n \n-impl From<PollFd> for c_pollfd {\n-    fn from(raw: PollFd) -> Self {\n-        let events = raw.events.bits() as i16;\n-        let revents = raw.revents.bits() as i16;\n+impl Drop for Poller {\n+    fn drop(&mut self) {\n+        let mut pollees = self.inner.pollees.lock();\n+        if pollees.len() == 0 {\n+            return;\n+        }\n+\n+        let self_observer = self.observer();\n+        for (weak_pollee, _) in pollees.drain_filter(|_, _| true) {\n+            if let Some(pollee) = weak_pollee.upgrade() {\n+                pollee.subject.unregister_observer(&self_observer);\n+            }\n+        }\n+    }\n+}\n+\n+/// A counter for wait and wakeup.\n+struct EventCounter {\n+    counter: AtomicUsize,\n+    wait_queue: WaitQueue,\n+}\n+\n+impl EventCounter {\n+    pub fn new() -> Self {\n         Self {\n-            fd: raw.fd,\n-            events,\n-            revents,\n+            counter: AtomicUsize::new(0),\n+            wait_queue: WaitQueue::new(),\n         }\n     }\n+\n+    pub fn read(&self) -> usize {\n+        self.wait_queue.wait_until(|| {\n+            let val = self.counter.swap(0, Ordering::Relaxed);\n+            if val > 0 {\n+                Some(val)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    pub fn write(&self) {\n+        self.counter.fetch_add(1, Ordering::Relaxed);\n+        self.wait_queue.wake_one();\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -1,4 +1,6 @@\n-use super::{DirentVisitor, FsFlags, Inode, InodeMode, InodeType, Metadata, PageCache};\n+use super::{\n+    DirentVisitor, FsFlags, Inode, InodeMode, InodeType, IoEvents, Metadata, PageCache, Poller,\n+};\n use crate::prelude::*;\n use crate::rights::Full;\n use crate::vm::vmo::Vmo;\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -184,6 +186,10 @@ impl Vnode {\n         self.inner.read().inode.readdir_at(offset, visitor)\n     }\n \n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.inner.read().inode.poll(mask, poller)\n+    }\n+\n     pub fn metadata(&self) -> Metadata {\n         self.inner.read().inode.metadata()\n     }\ndiff --git a/services/libs/jinux-std/src/prelude.rs b/services/libs/jinux-std/src/prelude.rs\n--- a/services/libs/jinux-std/src/prelude.rs\n+++ b/services/libs/jinux-std/src/prelude.rs\n@@ -13,6 +13,7 @@ pub(crate) use alloc::sync::Weak;\n pub(crate) use alloc::vec;\n pub(crate) use alloc::vec::Vec;\n pub(crate) use bitflags::bitflags;\n+pub(crate) use core::any::Any;\n pub(crate) use core::ffi::CStr;\n pub(crate) use jinux_frame::config::PAGE_SIZE;\n pub(crate) use jinux_frame::sync::{Mutex, MutexGuard};\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -49,8 +49,6 @@ pub struct Process {\n     root_vmar: Arc<Vmar<Full>>,\n     /// wait for child status changed\n     waiting_children: WaitQueue,\n-    /// wait for io events\n-    poll_queue: WaitQueue,\n \n     // Mutable Part\n     /// The executable path.\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -110,7 +108,6 @@ impl Process {\n     ) -> Self {\n         let children = BTreeMap::new();\n         let waiting_children = WaitQueue::new();\n-        let poll_queue = WaitQueue::new();\n         let resource_limits = ResourceLimits::default();\n         Self {\n             pid,\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -119,7 +116,6 @@ impl Process {\n             user_vm,\n             root_vmar,\n             waiting_children,\n-            poll_queue,\n             exit_code: AtomicI32::new(0),\n             status: Mutex::new(ProcessStatus::Runnable),\n             parent: Mutex::new(parent),\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -138,10 +134,6 @@ impl Process {\n         &self.waiting_children\n     }\n \n-    pub fn poll_queue(&self) -> &WaitQueue {\n-        &self.poll_queue\n-    }\n-\n     /// init a user process and run the process\n     pub fn spawn_user_process(\n         executable_path: &str,\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs b/services/libs/jinux-std/src/process/process_group.rs\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ b/services/libs/jinux-std/src/process/process_group.rs\n@@ -69,14 +69,6 @@ impl ProcessGroup {\n         self.inner.lock().pgid\n     }\n \n-    /// Wake up all processes waiting on polling queue\n-    pub fn wake_all_polling_procs(&self) {\n-        let inner = self.inner.lock();\n-        for (_, process) in &inner.processes {\n-            process.poll_queue().wake_all();\n-        }\n-    }\n-\n     /// send kernel signal to all processes in the group\n     pub fn kernel_signal(&self, signal: KernelSignal) {\n         for (_, process) in &self.inner.lock().processes {\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -65,10 +65,10 @@ pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n }\n \n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n-    PROCESS_TABLE_SUBJECT.register_observer(observer);\n+    PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n-pub fn unregister_observer(observer: Weak<dyn Observer<PidEvent>>) {\n+pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\n \ndiff --git a/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/jinux-std/src/syscall/chdir.rs\n--- a/services/libs/jinux-std/src/syscall/chdir.rs\n+++ b/services/libs/jinux-std/src/syscall/chdir.rs\n@@ -1,4 +1,6 @@\n-use crate::fs::{file_table::FileDescripter, fs_resolver::FsPath, utils::InodeType};\n+use crate::fs::{\n+    file_table::FileDescripter, fs_resolver::FsPath, inode_handle::InodeHandle, utils::InodeType,\n+};\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::syscall::constants::MAX_FILENAME_LEN;\ndiff --git a/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/jinux-std/src/syscall/chdir.rs\n--- a/services/libs/jinux-std/src/syscall/chdir.rs\n+++ b/services/libs/jinux-std/src/syscall/chdir.rs\n@@ -38,7 +40,7 @@ pub fn sys_fchdir(fd: FileDescripter) -> Result<SyscallReturn> {\n         let file_table = current.file_table().lock();\n         let file = file_table.get_file(fd)?;\n         let inode_handle = file\n-            .as_inode_handle()\n+            .downcast_ref::<InodeHandle>()\n             .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n         inode_handle.dentry().clone()\n     };\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/epoll.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/epoll.rs\n@@ -0,0 +1,133 @@\n+use core::time::Duration;\n+\n+use crate::fs::epoll::{c_epoll_event, EpollCtl, EpollEvent, EpollFile, EpollFlags};\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::utils::CreationFlags;\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+use super::SyscallReturn;\n+use super::{SYS_EPOLL_CREATE1, SYS_EPOLL_CTL, SYS_EPOLL_WAIT};\n+\n+pub fn sys_epoll_create(size: i32) -> Result<SyscallReturn> {\n+    if size <= 0 {\n+        return_errno_with_message!(Errno::EINVAL, \"size is not positive\");\n+    }\n+    sys_epoll_create1(0)\n+}\n+\n+pub fn sys_epoll_create1(flags: u32) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_CREATE1);\n+    debug!(\"flags = 0x{:x}\", flags);\n+\n+    let close_on_exec = {\n+        let flags = CreationFlags::from_bits(flags)\n+            .ok_or_else(|| Error::with_message(Errno::EINVAL, \"invalid flags\"))?;\n+        if flags == CreationFlags::empty() {\n+            false\n+        } else if flags == CreationFlags::O_CLOEXEC {\n+            true\n+        } else {\n+            // Only O_CLOEXEC is valid\n+            return_errno_with_message!(Errno::EINVAL, \"invalid flags\");\n+        }\n+    };\n+\n+    let current = current!();\n+    let epoll_file: Arc<EpollFile> = EpollFile::new();\n+    let mut file_table = current.file_table().lock();\n+    let fd = file_table.insert(epoll_file);\n+    Ok(SyscallReturn::Return(fd as _))\n+}\n+\n+pub fn sys_epoll_ctl(\n+    epfd: FileDescripter,\n+    op: i32,\n+    fd: FileDescripter,\n+    event_addr: Vaddr,\n+) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_CTL);\n+    debug!(\n+        \"epfd = {}, op = {}, fd = {}, event_addr = 0x{:x}\",\n+        epfd, op, fd, event_addr\n+    );\n+\n+    const EPOLL_CTL_ADD: i32 = 1;\n+    const EPOLL_CTL_DEL: i32 = 2;\n+    const EPOLL_CTL_MOD: i32 = 3;\n+\n+    let cmd = match op {\n+        EPOLL_CTL_ADD => {\n+            let c_epoll_event = read_val_from_user::<c_epoll_event>(event_addr)?;\n+            let event = EpollEvent::from(&c_epoll_event);\n+            let flags = EpollFlags::from_bits_truncate(c_epoll_event.events);\n+            EpollCtl::Add(fd, event, flags)\n+        }\n+        EPOLL_CTL_DEL => EpollCtl::Del(fd),\n+        EPOLL_CTL_MOD => {\n+            let c_epoll_event = read_val_from_user::<c_epoll_event>(event_addr)?;\n+            let event = EpollEvent::from(&c_epoll_event);\n+            let flags = EpollFlags::from_bits_truncate(c_epoll_event.events);\n+            EpollCtl::Mod(fd, event, flags)\n+        }\n+        _ => return_errno_with_message!(Errno::EINVAL, \"invalid op\"),\n+    };\n+\n+    let current = current!();\n+    let file = {\n+        let file_table = current.file_table().lock();\n+        file_table.get_file(epfd)?.clone()\n+    };\n+    let epoll_file = file\n+        .downcast_ref::<EpollFile>()\n+        .ok_or(Error::with_message(Errno::EINVAL, \"not epoll file\"))?;\n+    epoll_file.control(&cmd)?;\n+\n+    Ok(SyscallReturn::Return(0 as _))\n+}\n+\n+pub fn sys_epoll_wait(\n+    epfd: FileDescripter,\n+    events_addr: Vaddr,\n+    max_events: i32,\n+    timeout: i32,\n+) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_WAIT);\n+\n+    let max_events = {\n+        if max_events <= 0 {\n+            return_errno_with_message!(Errno::EINVAL, \"max_events is not positive\");\n+        }\n+        max_events as usize\n+    };\n+    let timeout = if timeout >= 0 {\n+        Some(Duration::from_millis(timeout as _))\n+    } else {\n+        None\n+    };\n+    debug!(\n+        \"epfd = {}, events_addr = 0x{:x}, max_events = {}, timeout = {:?}\",\n+        epfd, events_addr, max_events, timeout\n+    );\n+\n+    let current = current!();\n+    let file = {\n+        let file_table = current.file_table().lock();\n+        file_table.get_file(epfd)?.clone()\n+    };\n+    let epoll_file = file\n+        .downcast_ref::<EpollFile>()\n+        .ok_or(Error::with_message(Errno::EINVAL, \"not epoll file\"))?;\n+    let epoll_events = epoll_file.wait(max_events, timeout.as_ref())?;\n+\n+    // Write back\n+    let mut write_addr = events_addr;\n+    for epoll_event in epoll_events.iter() {\n+        let c_epoll_event = c_epoll_event::from(epoll_event);\n+        write_val_to_user(write_addr, &c_epoll_event)?;\n+        write_addr += core::mem::size_of::<c_epoll_event>();\n+    }\n+\n+    Ok(SyscallReturn::Return(epoll_events.len() as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/fcntl.rs b/services/libs/jinux-std/src/syscall/fcntl.rs\n--- a/services/libs/jinux-std/src/syscall/fcntl.rs\n+++ b/services/libs/jinux-std/src/syscall/fcntl.rs\n@@ -12,8 +12,7 @@ pub fn sys_fcntl(fd: FileDescripter, cmd: i32, arg: u64) -> Result<SyscallReturn\n             // FIXME: deal with the cloexec flag\n             let current = current!();\n             let mut file_table = current.file_table().lock();\n-            let new_fd = arg as FileDescripter;\n-            file_table.dup(fd, Some(new_fd))?;\n+            let new_fd = file_table.dup(fd, arg as FileDescripter)?;\n             return Ok(SyscallReturn::Return(new_fd as _));\n         }\n         FcntlCmd::F_SETFD => {\ndiff --git a/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/jinux-std/src/syscall/getdents64.rs\n--- a/services/libs/jinux-std/src/syscall/getdents64.rs\n+++ b/services/libs/jinux-std/src/syscall/getdents64.rs\n@@ -1,5 +1,6 @@\n use crate::fs::{\n     file_table::FileDescripter,\n+    inode_handle::InodeHandle,\n     utils::{DirentVisitor, InodeType},\n };\n use crate::log_syscall_entry;\ndiff --git a/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/jinux-std/src/syscall/getdents64.rs\n--- a/services/libs/jinux-std/src/syscall/getdents64.rs\n+++ b/services/libs/jinux-std/src/syscall/getdents64.rs\n@@ -27,7 +28,7 @@ pub fn sys_getdents64(\n         file_table.get_file(fd)?.clone()\n     };\n     let inode_handle = file\n-        .as_inode_handle()\n+        .downcast_ref::<InodeHandle>()\n         .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n     if inode_handle.dentry().inode_type() != InodeType::Dir {\n         return_errno!(Errno::ENOTDIR);\ndiff --git a/services/libs/jinux-std/src/syscall/ioctl.rs b/services/libs/jinux-std/src/syscall/ioctl.rs\n--- a/services/libs/jinux-std/src/syscall/ioctl.rs\n+++ b/services/libs/jinux-std/src/syscall/ioctl.rs\n@@ -16,6 +16,6 @@ pub fn sys_ioctl(fd: FileDescripter, cmd: u32, arg: Vaddr) -> Result<SyscallRetu\n     let current = current!();\n     let file_table = current.file_table().lock();\n     let file = file_table.get_file(fd)?;\n-    let res = file.as_file().unwrap().ioctl(ioctl_cmd, arg)?;\n+    let res = file.ioctl(ioctl_cmd, arg)?;\n     return Ok(SyscallReturn::Return(res as _));\n }\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -9,6 +9,7 @@ use crate::syscall::clock_nanosleep::sys_clock_nanosleep;\n use crate::syscall::clone::sys_clone;\n use crate::syscall::close::sys_close;\n use crate::syscall::dup::{sys_dup, sys_dup2};\n+use crate::syscall::epoll::{sys_epoll_create, sys_epoll_create1, sys_epoll_ctl, sys_epoll_wait};\n use crate::syscall::execve::sys_execve;\n use crate::syscall::exit::sys_exit;\n use crate::syscall::exit_group::sys_exit_group;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -36,6 +37,7 @@ use crate::syscall::mprotect::sys_mprotect;\n use crate::syscall::munmap::sys_munmap;\n use crate::syscall::open::{sys_open, sys_openat};\n use crate::syscall::pause::sys_pause;\n+use crate::syscall::pipe::{sys_pipe, sys_pipe2};\n use crate::syscall::poll::sys_poll;\n use crate::syscall::prctl::sys_prctl;\n use crate::syscall::prlimit64::sys_prlimit64;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -75,6 +77,7 @@ mod clone;\n mod close;\n mod constants;\n mod dup;\n+mod epoll;\n mod execve;\n mod exit;\n mod exit_group;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -102,6 +105,7 @@ mod mprotect;\n mod munmap;\n mod open;\n mod pause;\n+mod pipe;\n mod poll;\n mod prctl;\n mod pread64;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -181,6 +185,7 @@ define_syscall_nums!(\n     SYS_PREAD64 = 17,\n     SYS_WRITEV = 20,\n     SYS_ACCESS = 21,\n+    SYS_PIPE = 22,\n     SYS_SCHED_YIELD = 24,\n     SYS_MADVISE = 28,\n     SYS_DUP = 32,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -218,10 +223,13 @@ define_syscall_nums!(\n     SYS_GETTID = 186,\n     SYS_TIME = 201,\n     SYS_FUTEX = 202,\n+    SYS_EPOLL_CREATE = 213,\n     SYS_GETDENTS64 = 217,\n     SYS_SET_TID_ADDRESS = 218,\n     SYS_CLOCK_NANOSLEEP = 230,\n     SYS_EXIT_GROUP = 231,\n+    SYS_EPOLL_WAIT = 232,\n+    SYS_EPOLL_CTL = 233,\n     SYS_TGKILL = 234,\n     SYS_WAITID = 247,\n     SYS_OPENAT = 257,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -234,6 +242,8 @@ define_syscall_nums!(\n     SYS_READLINKAT = 267,\n     SYS_SET_ROBUST_LIST = 273,\n     SYS_UTIMENSAT = 280,\n+    SYS_EPOLL_CREATE1 = 291,\n+    SYS_PIPE2 = 293,\n     SYS_PRLIMIT64 = 302\n );\n \ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -313,6 +323,7 @@ pub fn syscall_dispatch(\n         SYS_PREAD64 => syscall_handler!(4, sys_pread64, args),\n         SYS_WRITEV => syscall_handler!(3, sys_writev, args),\n         SYS_ACCESS => syscall_handler!(2, sys_access, args),\n+        SYS_PIPE => syscall_handler!(1, sys_pipe, args),\n         SYS_SCHED_YIELD => syscall_handler!(0, sys_sched_yield),\n         SYS_MADVISE => syscall_handler!(3, sys_madvise, args),\n         SYS_DUP => syscall_handler!(1, sys_dup, args),\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -350,10 +361,13 @@ pub fn syscall_dispatch(\n         SYS_GETTID => syscall_handler!(0, sys_gettid),\n         SYS_TIME => syscall_handler!(1, sys_time, args),\n         SYS_FUTEX => syscall_handler!(6, sys_futex, args),\n+        SYS_EPOLL_CREATE => syscall_handler!(1, sys_epoll_create, args),\n         SYS_GETDENTS64 => syscall_handler!(3, sys_getdents64, args),\n         SYS_SET_TID_ADDRESS => syscall_handler!(1, sys_set_tid_address, args),\n         SYS_CLOCK_NANOSLEEP => syscall_handler!(4, sys_clock_nanosleep, args),\n         SYS_EXIT_GROUP => syscall_handler!(1, sys_exit_group, args),\n+        SYS_EPOLL_WAIT => syscall_handler!(4, sys_epoll_wait, args),\n+        SYS_EPOLL_CTL => syscall_handler!(4, sys_epoll_ctl, args),\n         SYS_TGKILL => syscall_handler!(3, sys_tgkill, args),\n         SYS_WAITID => syscall_handler!(5, sys_waitid, args),\n         SYS_OPENAT => syscall_handler!(4, sys_openat, args),\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -366,6 +380,8 @@ pub fn syscall_dispatch(\n         SYS_READLINKAT => syscall_handler!(4, sys_readlinkat, args),\n         SYS_SET_ROBUST_LIST => syscall_handler!(2, sys_set_robust_list, args),\n         SYS_UTIMENSAT => syscall_handler!(4, sys_utimensat, args),\n+        SYS_EPOLL_CREATE1 => syscall_handler!(1, sys_epoll_create1, args),\n+        SYS_PIPE2 => syscall_handler!(2, sys_pipe2, args),\n         SYS_PRLIMIT64 => syscall_handler!(4, sys_prlimit64, args),\n         _ => {\n             error!(\"Unimplemented syscall number: {}\", syscall_number);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -1,5 +1,5 @@\n use crate::fs::{\n-    file_handle::{File, FileHandle},\n+    file_handle::FileLike,\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\n };\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -39,7 +39,7 @@ pub fn sys_openat(\n \n     if dirfd == AT_FDCWD && pathname == CString::new(\"./trace\")? {\n         // Debug use: This file is used for output busybox log\n-        let trace_file = FileHandle::new_file(Arc::new(BusyBoxTraceFile) as Arc<dyn File>);\n+        let trace_file = Arc::new(BusyBoxTraceFile);\n         let current = current!();\n         let mut file_table = current.file_table().lock();\n         let fd = file_table.insert(trace_file);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -47,7 +47,7 @@ pub fn sys_openat(\n     }\n \n     if dirfd == AT_FDCWD && pathname == CString::new(\"/dev/tty\")? {\n-        let tty_file = FileHandle::new_file(get_n_tty().clone() as Arc<dyn File>);\n+        let tty_file = get_n_tty().clone();\n         let current = current!();\n         let mut file_table = current.file_table().lock();\n         let fd = file_table.insert(tty_file);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -60,7 +60,7 @@ pub fn sys_openat(\n         let pathname = pathname.to_string_lossy();\n         let fs_path = FsPath::new(dirfd, pathname.as_ref())?;\n         let inode_handle = current.fs().read().open(&fs_path, flags, mode)?;\n-        FileHandle::new_inode_handle(inode_handle)\n+        Arc::new(inode_handle)\n     };\n     let mut file_table = current.file_table().lock();\n     let fd = file_table.insert(file_handle);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -74,9 +74,13 @@ pub fn sys_open(pathname_addr: Vaddr, flags: u32, mode: u16) -> Result<SyscallRe\n /// File for output busybox ash log.\n struct BusyBoxTraceFile;\n \n-impl File for BusyBoxTraceFile {\n+impl FileLike for BusyBoxTraceFile {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         debug!(\"ASH TRACE: {}\", core::str::from_utf8(buf)?);\n         Ok(buf.len())\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/pipe.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/pipe.rs\n@@ -0,0 +1,47 @@\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::pipe::{PipeReader, PipeWriter};\n+use crate::fs::utils::{Channel, StatusFlags};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+use super::SyscallReturn;\n+use super::SYS_PIPE2;\n+\n+pub fn sys_pipe2(fds: Vaddr, flags: u32) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_PIPE2);\n+    debug!(\"flags: {:?}\", flags);\n+\n+    let mut pipe_fds = read_val_from_user::<PipeFds>(fds)?;\n+    let (reader, writer) = {\n+        let (producer, consumer) = Channel::with_capacity_and_flags(\n+            PIPE_BUF_SIZE,\n+            StatusFlags::from_bits_truncate(flags),\n+        )?\n+        .split();\n+        (PipeReader::new(consumer), PipeWriter::new(producer))\n+    };\n+    let pipe_reader = Arc::new(reader);\n+    let pipe_writer = Arc::new(writer);\n+\n+    let current = current!();\n+    let mut file_table = current.file_table().lock();\n+    pipe_fds.reader_fd = file_table.insert(pipe_reader);\n+    pipe_fds.writer_fd = file_table.insert(pipe_writer);\n+    write_val_to_user(fds, &pipe_fds)?;\n+\n+    Ok(SyscallReturn::Return(0))\n+}\n+\n+pub fn sys_pipe(fds: Vaddr) -> Result<SyscallReturn> {\n+    self::sys_pipe2(fds, 0)\n+}\n+\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+struct PipeFds {\n+    reader_fd: FileDescripter,\n+    writer_fd: FileDescripter,\n+}\n+\n+const PIPE_BUF_SIZE: usize = 1024 * 1024;\ndiff --git a/services/libs/jinux-std/src/syscall/poll.rs b/services/libs/jinux-std/src/syscall/poll.rs\n--- a/services/libs/jinux-std/src/syscall/poll.rs\n+++ b/services/libs/jinux-std/src/syscall/poll.rs\n@@ -1,65 +1,161 @@\n+use core::cell::Cell;\n use core::time::Duration;\n \n-use crate::fs::utils::{c_pollfd, PollFd};\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::utils::{IoEvents, Poller};\n use crate::log_syscall_entry;\n+use crate::prelude::*;\n use crate::util::{read_val_from_user, write_val_to_user};\n-use crate::{fs::utils::c_nfds, prelude::*};\n \n use super::SyscallReturn;\n use super::SYS_POLL;\n \n-pub fn sys_poll(fds: Vaddr, nfds: c_nfds, timeout: i32) -> Result<SyscallReturn> {\n+pub fn sys_poll(fds: Vaddr, nfds: u64, timeout: i32) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_POLL);\n \n-    let mut read_addr = fds;\n-    let mut pollfds = Vec::with_capacity(nfds as _);\n-    for _ in 0..nfds {\n-        let c_poll_fd = read_val_from_user::<c_pollfd>(read_addr)?;\n-        let poll_fd = PollFd::from(c_poll_fd);\n-        pollfds.push(poll_fd);\n-        // FIXME: do we need to respect align of c_pollfd here?\n-        read_addr += core::mem::size_of::<c_pollfd>();\n-    }\n-    let timeout = if timeout == 0 {\n-        None\n-    } else {\n+    let poll_fds = {\n+        let mut read_addr = fds;\n+        let mut poll_fds = Vec::with_capacity(nfds as _);\n+        for _ in 0..nfds {\n+            let c_poll_fd = read_val_from_user::<c_pollfd>(read_addr)?;\n+            let poll_fd = PollFd::from(c_poll_fd);\n+            // Always clear the revents fields first\n+            poll_fd.revents().set(IoEvents::empty());\n+            poll_fds.push(poll_fd);\n+            // FIXME: do we need to respect align of c_pollfd here?\n+            read_addr += core::mem::size_of::<c_pollfd>();\n+        }\n+        poll_fds\n+    };\n+    let timeout = if timeout >= 0 {\n         Some(Duration::from_millis(timeout as _))\n+    } else {\n+        None\n     };\n     debug!(\n         \"poll_fds = {:?}, nfds = {}, timeout = {:?}\",\n-        pollfds, nfds, timeout\n+        poll_fds, nfds, timeout\n     );\n-    let current = current!();\n-    // FIXME: respect timeout parameter\n-    let ready_files = current.poll_queue().wait_until(|| {\n-        let mut ready_files = 0;\n-        for pollfd in &mut pollfds {\n-            let file_table = current.file_table().lock();\n-            let file = file_table.get_file(pollfd.fd);\n-            match file {\n-                Err(_) => return Some(Err(Error::new(Errno::EBADF))),\n-                Ok(file) => {\n-                    let file_events = file.as_file().unwrap().poll();\n-                    let polled_events = pollfd.events.intersection(file_events);\n-                    if !polled_events.is_empty() {\n-                        ready_files += 1;\n-                        pollfd.revents |= polled_events;\n-                    }\n-                }\n-            }\n-        }\n-        if ready_files > 0 {\n-            return Some(Ok(ready_files));\n-        } else {\n-            return None;\n-        }\n-    })?;\n+\n+    let num_revents = do_poll(&poll_fds, timeout)?;\n+\n+    // Write back\n     let mut write_addr = fds;\n-    for pollfd in pollfds {\n+    for pollfd in poll_fds {\n         let c_poll_fd = c_pollfd::from(pollfd);\n         write_val_to_user(write_addr, &c_poll_fd)?;\n         // FIXME: do we need to respect align of c_pollfd here?\n         write_addr += core::mem::size_of::<c_pollfd>();\n     }\n-    Ok(SyscallReturn::Return(ready_files))\n+\n+    Ok(SyscallReturn::Return(num_revents as _))\n+}\n+\n+fn do_poll(poll_fds: &[PollFd], timeout: Option<Duration>) -> Result<usize> {\n+    // The main loop of polling\n+    let poller = Poller::new();\n+    loop {\n+        let mut num_revents = 0;\n+\n+        for poll_fd in poll_fds {\n+            // Skip poll_fd if it is not given a fd\n+            let fd = match poll_fd.fd() {\n+                Some(fd) => fd,\n+                None => continue,\n+            };\n+\n+            // Poll the file\n+            let current = current!();\n+            let file = {\n+                let file_table = current.file_table().lock();\n+                file_table.get_file(fd)?.clone()\n+            };\n+            let need_poller = if num_revents == 0 {\n+                Some(&poller)\n+            } else {\n+                None\n+            };\n+            let revents = file.poll(poll_fd.events(), need_poller);\n+            if !revents.is_empty() {\n+                poll_fd.revents().set(revents);\n+                num_revents += 1;\n+            }\n+        }\n+\n+        if num_revents > 0 {\n+            return Ok(num_revents);\n+        }\n+\n+        // Return immediately if specifying a timeout of zero\n+        if timeout.is_some() && timeout.as_ref().unwrap().is_zero() {\n+            return Ok(0);\n+        }\n+\n+        // FIXME: respect timeout parameter\n+        poller.wait();\n+    }\n+}\n+\n+// https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/poll.h\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+pub struct c_pollfd {\n+    fd: i32,\n+    events: i16,\n+    revents: i16,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct PollFd {\n+    fd: Option<FileDescripter>,\n+    events: IoEvents,\n+    revents: Cell<IoEvents>,\n+}\n+\n+impl PollFd {\n+    pub fn fd(&self) -> Option<FileDescripter> {\n+        self.fd\n+    }\n+\n+    pub fn events(&self) -> IoEvents {\n+        self.events\n+    }\n+\n+    pub fn revents(&self) -> &Cell<IoEvents> {\n+        &self.revents\n+    }\n+}\n+\n+impl From<c_pollfd> for PollFd {\n+    fn from(raw: c_pollfd) -> Self {\n+        let fd = if raw.fd >= 0 {\n+            Some(raw.fd as FileDescripter)\n+        } else {\n+            None\n+        };\n+        let events = IoEvents::from_bits_truncate(raw.events as _);\n+        let revents = Cell::new(IoEvents::from_bits_truncate(raw.revents as _));\n+        Self {\n+            fd,\n+            events,\n+            revents,\n+        }\n+    }\n+}\n+\n+impl From<PollFd> for c_pollfd {\n+    fn from(raw: PollFd) -> Self {\n+        let fd = if let Some(fd) = raw.fd() {\n+            fd as i32\n+        } else {\n+            -1\n+        };\n+        let events = raw.events().bits() as i16;\n+        let revents = raw.revents().get().bits() as i16;\n+        Self {\n+            fd,\n+            events,\n+            revents,\n+        }\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -1,11 +1,10 @@\n-use crate::fs::utils::IoEvents;\n+use crate::fs::utils::{IoEvents, Pollee, Poller};\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n use crate::{\n     prelude::*,\n     process::{process_table, signal::signals::kernel::KernelSignal, Pgid},\n };\n-use jinux_frame::sync::WaitQueue;\n-use ringbuffer::{ConstGenericRingBuffer, RingBuffer, RingBufferRead, RingBufferWrite};\n+use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n use super::termio::{KernelTermios, CC_C_CHAR};\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -18,40 +17,39 @@ pub struct LineDiscipline {\n     /// current line\n     current_line: RwLock<CurrentLine>,\n     /// The read buffer\n-    read_buffer: Mutex<ConstGenericRingBuffer<u8, BUFFER_CAPACITY>>,\n+    read_buffer: Mutex<StaticRb<u8, BUFFER_CAPACITY>>,\n     /// The foreground process group\n     foreground: RwLock<Option<Pgid>>,\n     /// termios\n     termios: RwLock<KernelTermios>,\n-    /// wait until self is readable\n-    read_wait_queue: WaitQueue,\n+    /// Pollee\n+    pollee: Pollee,\n }\n \n-#[derive(Debug)]\n pub struct CurrentLine {\n-    buffer: ConstGenericRingBuffer<u8, BUFFER_CAPACITY>,\n+    buffer: StaticRb<u8, BUFFER_CAPACITY>,\n }\n \n impl CurrentLine {\n     pub fn new() -> Self {\n         Self {\n-            buffer: ConstGenericRingBuffer::new(),\n+            buffer: StaticRb::default(),\n         }\n     }\n \n     /// read all bytes inside current line and clear current line\n     pub fn drain(&mut self) -> Vec<u8> {\n-        self.buffer.drain().collect()\n+        self.buffer.pop_iter().collect()\n     }\n \n     pub fn push_char(&mut self, char: u8) {\n         // What should we do if line is full?\n         debug_assert!(!self.is_full());\n-        self.buffer.push(char);\n+        self.buffer.push_overwrite(char);\n     }\n \n     pub fn backspace(&mut self) {\n-        self.buffer.dequeue();\n+        self.buffer.pop();\n     }\n \n     pub fn is_full(&self) -> bool {\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -68,10 +66,10 @@ impl LineDiscipline {\n     pub fn new() -> Self {\n         Self {\n             current_line: RwLock::new(CurrentLine::new()),\n-            read_buffer: Mutex::new(ConstGenericRingBuffer::new()),\n+            read_buffer: Mutex::new(StaticRb::default()),\n             foreground: RwLock::new(None),\n             termios: RwLock::new(KernelTermios::default()),\n-            read_wait_queue: WaitQueue::new(),\n+            pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -118,7 +116,7 @@ impl LineDiscipline {\n                 current_line.push_char(item);\n                 let current_line_chars = current_line.drain();\n                 for char in current_line_chars {\n-                    self.read_buffer.lock().push(char);\n+                    self.read_buffer.lock().push_overwrite(char);\n                 }\n             } else if item >= 0x20 && item < 0x7f {\n                 // printable character\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -126,7 +124,7 @@ impl LineDiscipline {\n             }\n         } else {\n             // raw mode\n-            self.read_buffer.lock().push(item);\n+            self.read_buffer.lock().push_overwrite(item);\n             // debug!(\"push char: {}\", char::from(item))\n         }\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -135,13 +133,13 @@ impl LineDiscipline {\n         }\n \n         if self.is_readable() {\n-            self.read_wait_queue.wake_all();\n+            self.pollee.add_events(IoEvents::IN);\n         }\n     }\n \n     /// whether self is readable\n     fn is_readable(&self) -> bool {\n-        self.read_buffer.lock().len() > 0\n+        !self.read_buffer.lock().is_empty()\n     }\n \n     // TODO: respect output flags\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -170,58 +168,84 @@ impl LineDiscipline {\n \n     /// read all bytes buffered to dst, return the actual read length.\n     pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let termios = self.termios.read();\n-        let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n-        let vtime = *termios.get_special_char(CC_C_CHAR::VTIME);\n-        drop(termios);\n-        let read_len: usize = self.read_wait_queue.wait_until(|| {\n-            // if current process does not belong to foreground process group,\n-            // block until current process become foreground.\n-            if !self.current_belongs_to_foreground() {\n-                warn!(\"current process does not belong to foreground process group\");\n-                return None;\n+        let mut poller = None;\n+        loop {\n+            let res = self.try_read(dst);\n+            match res {\n+                Ok(read_len) => {\n+                    return Ok(read_len);\n+                }\n+                Err(e) => {\n+                    if e.error() != Errno::EAGAIN {\n+                        return Err(e);\n+                    }\n+                }\n+            }\n+\n+            // Wait for read event\n+            let need_poller = if poller.is_none() {\n+                poller = Some(Poller::new());\n+                poller.as_ref()\n+            } else {\n+                None\n+            };\n+            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n+            if revents.is_empty() {\n+                poller.as_ref().unwrap().wait();\n             }\n+        }\n+    }\n+\n+    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n+        if !self.current_belongs_to_foreground() {\n+            return_errno!(Errno::EAGAIN);\n+        }\n+\n+        let (vmin, vtime) = {\n+            let termios = self.termios.read();\n+            let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n+            let vtime = *termios.get_special_char(CC_C_CHAR::VTIME);\n+            (vmin, vtime)\n+        };\n+        let read_len = {\n             let len = self.read_buffer.lock().len();\n             let max_read_len = len.min(dst.len());\n             if vmin == 0 && vtime == 0 {\n                 // poll read\n-                return self.poll_read(dst);\n-            }\n-            if vmin > 0 && vtime == 0 {\n+                self.poll_read(dst)\n+            } else if vmin > 0 && vtime == 0 {\n                 // block read\n-                return self.block_read(dst, vmin);\n-            }\n-            if vmin == 0 && vtime > 0 {\n+                self.block_read(dst, vmin)?\n+            } else if vmin == 0 && vtime > 0 {\n                 todo!()\n-            }\n-            if vmin > 0 && vtime > 0 {\n+            } else if vmin > 0 && vtime > 0 {\n                 todo!()\n+            } else {\n+                unreachable!()\n             }\n-            unreachable!()\n-        });\n+        };\n+        if !self.is_readable() {\n+            self.pollee.del_events(IoEvents::IN);\n+        }\n         Ok(read_len)\n     }\n \n-    pub fn poll(&self) -> IoEvents {\n-        if self.is_empty() {\n-            IoEvents::empty()\n-        } else {\n-            IoEvents::POLLIN\n-        }\n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.pollee.poll(mask, poller)\n     }\n \n     /// returns immediately with the lesser of the number of bytes available or the number of bytes requested.\n     /// If no bytes are available, completes immediately, returning 0.\n-    fn poll_read(&self, dst: &mut [u8]) -> Option<usize> {\n+    fn poll_read(&self, dst: &mut [u8]) -> usize {\n         let mut buffer = self.read_buffer.lock();\n         let len = buffer.len();\n         let max_read_len = len.min(dst.len());\n         if max_read_len == 0 {\n-            return Some(0);\n+            return 0;\n         }\n         let mut read_len = 0;\n         for i in 0..max_read_len {\n-            if let Some(next_char) = buffer.dequeue() {\n+            if let Some(next_char) = buffer.pop() {\n                 if self.termios.read().is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if meet_new_line(next_char, &self.termios.read()) {\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -245,18 +269,18 @@ impl LineDiscipline {\n             }\n         }\n \n-        Some(read_len)\n+        read_len\n     }\n \n     // The read() blocks until the lesser of the number of bytes requested or\n     // MIN bytes are available, and returns the lesser of the two values.\n-    pub fn block_read(&self, dst: &mut [u8], vmin: u8) -> Option<usize> {\n+    pub fn block_read(&self, dst: &mut [u8], vmin: u8) -> Result<usize> {\n         let min_read_len = (vmin as usize).min(dst.len());\n         let buffer_len = self.read_buffer.lock().len();\n         if buffer_len < min_read_len {\n-            return None;\n+            return_errno!(Errno::EAGAIN);\n         }\n-        return self.poll_read(&mut dst[..min_read_len]);\n+        Ok(self.poll_read(&mut dst[..min_read_len]))\n     }\n \n     /// write bytes to buffer, if flush to console, then write the content to console\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -283,7 +307,7 @@ impl LineDiscipline {\n         *self.foreground.write() = Some(fg_pgid);\n         // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n         if self.is_readable() {\n-            self.read_wait_queue.wake_all();\n+            self.pollee.add_events(IoEvents::IN);\n         }\n     }\n \ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -1,9 +1,12 @@\n use self::line_discipline::LineDiscipline;\n use crate::driver::tty::TtyDriver;\n use crate::fs::utils::{InodeMode, InodeType, IoEvents, Metadata};\n-use crate::fs::{file_handle::File, utils::IoctlCmd};\n+use crate::fs::{\n+    file_handle::FileLike,\n+    utils::{IoctlCmd, Poller},\n+};\n use crate::prelude::*;\n-use crate::process::{process_table, Pgid};\n+use crate::process::Pgid;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod line_discipline;\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -43,23 +46,12 @@ impl Tty {\n         *self.driver.lock() = driver;\n     }\n \n-    /// Wake up foreground process group that wait on IO events.\n-    /// This function should be called when the interrupt handler of IO events is called.\n-    fn wake_fg_proc_grp(&self) {\n-        if let Some(fg_pgid) = self.ldisc.get_fg() {\n-            if let Some(fg_proc_grp) = process_table::pgid_to_process_group(fg_pgid) {\n-                fg_proc_grp.wake_all_polling_procs();\n-            }\n-        }\n-    }\n-\n     pub fn receive_char(&self, item: u8) {\n         self.ldisc.push_char(item);\n-        self.wake_fg_proc_grp();\n     }\n }\n \n-impl File for Tty {\n+impl FileLike for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         self.ldisc.read(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -73,8 +65,8 @@ impl File for Tty {\n         Ok(buf.len())\n     }\n \n-    fn poll(&self) -> IoEvents {\n-        self.ldisc.poll()\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.ldisc.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -137,6 +129,10 @@ impl File for Tty {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n /// FIXME: should we maintain a static console?\ndiff --git a/services/libs/jinux-util/src/lib.rs b/services/libs/jinux-util/src/lib.rs\n--- a/services/libs/jinux-util/src/lib.rs\n+++ b/services/libs/jinux-util/src/lib.rs\n@@ -2,5 +2,8 @@\n #![no_std]\n #![forbid(unsafe_code)]\n \n+extern crate alloc;\n+\n pub mod frame_ptr;\n+pub mod slot_vec;\n pub mod union_read_ptr;\ndiff --git /dev/null b/services/libs/jinux-util/src/slot_vec.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-util/src/slot_vec.rs\n@@ -0,0 +1,119 @@\n+use alloc::vec::Vec;\n+\n+/// SlotVec is the variant of Vector.\n+/// It guarantees that the index of one item remains unchanged during adding\n+/// or deleting other items of the vector.\n+pub struct SlotVec<T> {\n+    // The slots to store items.\n+    slots: Vec<Option<T>>,\n+    // The number of occupied slots.\n+    // The i-th slot is occupied if `self.slots[i].is_some()`.\n+    num_occupied: usize,\n+}\n+\n+impl<T> SlotVec<T> {\n+    /// New an empty vector.\n+    pub fn new() -> Self {\n+        Self {\n+            slots: Vec::new(),\n+            num_occupied: 0,\n+        }\n+    }\n+\n+    /// Return `true` if the vector contains no items.\n+    pub fn is_empty(&self) -> bool {\n+        self.num_occupied == 0\n+    }\n+\n+    /// Return the number of items.\n+    pub fn len(&self) -> usize {\n+        self.num_occupied\n+    }\n+\n+    /// Return the number of slots.\n+    pub fn slots_len(&self) -> usize {\n+        self.slots.len()\n+    }\n+\n+    /// Get the item at position `idx`.\n+    ///\n+    /// Return `None` if `idx` is out of bounds or the item is not exist.\n+    pub fn get(&self, idx: usize) -> Option<&T> {\n+        if idx >= self.slots.len() {\n+            return None;\n+        }\n+        self.slots[idx].as_ref()\n+    }\n+\n+    /// Put an item into the vector.\n+    /// It may be put into any existing empty slots or the back of the vector.\n+    ///\n+    /// Return the index of the inserted item.\n+    pub fn put(&mut self, entry: T) -> usize {\n+        let idx = if self.num_occupied == self.slots.len() {\n+            self.slots.push(Some(entry));\n+            self.slots.len() - 1\n+        } else {\n+            let idx = self.slots.iter().position(|x| x.is_none()).unwrap();\n+            self.slots[idx] = Some(entry);\n+            idx\n+        };\n+        self.num_occupied += 1;\n+        idx\n+    }\n+\n+    /// Put and return the item at position `idx`.\n+    ///\n+    /// Return `None` if the item is not exist.\n+    pub fn put_at(&mut self, idx: usize, item: T) -> Option<T> {\n+        if idx >= self.slots.len() {\n+            self.slots.resize_with(idx + 1, Default::default);\n+        }\n+        let mut sub_item = Some(item);\n+        core::mem::swap(&mut sub_item, &mut self.slots[idx]);\n+        if sub_item.is_none() {\n+            self.num_occupied += 1;\n+        }\n+        sub_item\n+    }\n+\n+    /// Remove and return the item at position `idx`.\n+    ///\n+    /// Return `None` if `idx` is out of bounds or the item has been removed.\n+    pub fn remove(&mut self, idx: usize) -> Option<T> {\n+        if idx >= self.slots.len() {\n+            return None;\n+        }\n+        let mut del_item = None;\n+        core::mem::swap(&mut del_item, &mut self.slots[idx]);\n+        if del_item.is_some() {\n+            debug_assert!(self.num_occupied > 0);\n+            self.num_occupied -= 1;\n+        }\n+        del_item\n+    }\n+\n+    /// Create an iterator which gives both of the index and the item.\n+    /// The index may not be continuous.\n+    pub fn idxes_and_items(&self) -> impl Iterator<Item = (usize, &'_ T)> {\n+        self.slots\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, x)| x.is_some())\n+            .map(|(idx, x)| (idx, x.as_ref().unwrap()))\n+    }\n+\n+    /// Create an iterator which just gives the item.\n+    pub fn iter(&self) -> impl Iterator<Item = &'_ T> {\n+        self.slots.iter().filter_map(|x| x.as_ref())\n+    }\n+}\n+\n+impl<T: Clone> Clone for SlotVec<T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            slots: self.slots.clone(),\n+            num_occupied: self.num_occupied.clone(),\n+        }\n+    }\n+}\ndiff --git /dev/null b/services/libs/keyable-arc/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/keyable-arc/Cargo.toml\n@@ -0,0 +1,9 @@\n+[package]\n+name = \"keyable-arc\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n",
        "test_patch": "diff --git /dev/null b/services/libs/keyable-arc/src/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/keyable-arc/src/lib.rs\n@@ -0,0 +1,362 @@\n+//! Same as the standard `Arc`, except that it can be used as the key type of a hash table.\n+//!\n+//! # Motivation\n+//!\n+//! A type `K` is _keyable_ if it can be used as the key type for a hash map. Specifically,\n+//! according to the document of `std::collections::HashMap`, the type `K` must satisfy\n+//! the following properties.\n+//!\n+//! 1. It implements the `Eq` and `Hash` traits.\n+//! 2. The two values of `k1` and `k2` of type `K` equal to each other,\n+//! if and only if their hash values equal to each other.\n+//! 3. The hashes of a value of `k` of type `K` cannot change while it\n+//! is in a map.\n+//!\n+//! Sometimes we want to use `Arc<T>` as the key type for a hash map but cannot do so\n+//! since `T` does not satisfy the properties above. For example, a lot of types\n+//! do not or cannot implemennt the `Eq` trait. This is when `KeyableArc<T>` can come\n+//! to your aid.\n+//!\n+//! # Overview\n+//!\n+//! For any type `T`, `KeyableArc<T>` satisfies all the properties to be keyable.\n+//! This can be achieved easily and efficiently as we can simply use the address\n+//! of the data (of `T` type) of a `KeyableArc<T>` object in the heap to determine the\n+//! equality and hash of the `KeyableArc<T>` object. As the address won't change for\n+//! an immutable `KeyableArc<T>` object, the hash and equality also stay the same.\n+//!\n+//! This crate is `#[no_std]` compatible, but requires the `alloc` crate.\n+//!\n+//! # Usage\n+//!\n+//! Here is a basic example to how that `KeyableArc<T>` is keyable even when `T`\n+//! is not.\n+//!\n+//! ```rust\n+//! use std::collections::HashMap;\n+//! use std::sync::Arc;\n+//! use keyable_arc::KeyableArc;\n+//!\n+//! struct Dummy; // Does not implement Eq and Hash\n+//!\n+//! let map: HashMap<KeyableArc<Dummy>, String> = HashMap::new();\n+//! ```\n+//!\n+//! `KeyableArc` is a reference counter-based smart pointer, just like `Arc`.\n+//! So you can use `KeyableArc` the same way you would use `Arc`.\n+//!\n+//! ```rust\n+//! use std::sync::atomic::{AtomicU64, Ordering::Relaxed};\n+//! use keyable_arc::KeyableArc;\n+//!\n+//! let key_arc0 = KeyableArc::new(AtomicU64::new(0));\n+//! let key_arc1 = key_arc0.clone();\n+//! assert!(key_arc0.load(Relaxed) == 0 && key_arc1.load(Relaxed) == 0);\n+//!\n+//! key_arc0.fetch_add(1, Relaxed);\n+//! assert!(key_arc0.load(Relaxed) == 1 && key_arc1.load(Relaxed) == 1);\n+//! ```\n+//!\n+//! # Differences from `Arc<T>`\n+//!\n+//! Notice how `KeyableArc` differs from standard smart pointers in determining equality?\n+//! Two `KeyableArc` objects are considered different even when their data have the same\n+//! value.\n+//!\n+//! ```rust\n+//! use keyable_arc::KeyableArc;\n+//!\n+//! let key_arc0 = KeyableArc::new(0);\n+//! let key_arc1 = key_arc0.clone();\n+//! assert!(key_arc0 == key_arc1);\n+//! assert!(*key_arc0 == *key_arc1);\n+//!\n+//! let key_arc1 = KeyableArc::new(0);\n+//! assert!(key_arc0 != key_arc1);\n+//! assert!(*key_arc0 == *key_arc1);\n+//! ```\n+//!\n+//! `KeyableArc<T>` is simply a wrapper of `Arc<T>. So converting between them\n+//! through the `From` and `Into` traits is zero cost.\n+//!\n+//! ```rust\n+//! use std::sync::Arc;\n+//! use keyable_arc::KeyableArc;\n+//!\n+//! let key_arc: KeyableArc<u32> = Arc::new(0).into();\n+//! let arc: Arc<u32> = KeyableArc::new(0).into();\n+//! ```\n+//!\n+//! # The weak version\n+//!\n+//! `KeyableWeak<T>` is the weak version of `KeyableArc<T>`, just like `Weak<T>` is\n+//! that of `Arc<T>`. And of course, `KeyableWeak<T>` is also _keyable_ for any\n+//! type `T`.\n+\n+// TODO: Add `KeyableBox<T>` or other keyable versions of smart pointers.\n+// If this is needed in the future, this crate should be renamed to `keyable`.\n+\n+// TODO: Add the missing methods offered by `Arc` or `Weak` but not their\n+// keyable counterparts.\n+\n+#![cfg_attr(not(test), no_std)]\n+#![feature(coerce_unsized)]\n+#![feature(unsize)]\n+#![forbid(unsafe_code)]\n+\n+extern crate alloc;\n+\n+use alloc::sync::{Arc, Weak};\n+use core::borrow::Borrow;\n+use core::cmp::Ordering;\n+use core::convert::AsRef;\n+use core::fmt;\n+use core::hash::{Hash, Hasher};\n+use core::marker::Unsize;\n+use core::ops::{CoerceUnsized, Deref};\n+\n+/// Same as the standard `Arc`, except that it can be used as the key type of a hash table.\n+#[repr(transparent)]\n+pub struct KeyableArc<T: ?Sized>(Arc<T>);\n+\n+impl<T> KeyableArc<T> {\n+    /// Constructs a new instance of `KeyableArc<T>`.\n+    #[inline]\n+    pub fn new(data: T) -> Self {\n+        Self(Arc::new(data))\n+    }\n+}\n+\n+impl<T: ?Sized> KeyableArc<T> {\n+    /// Returns a raw pointer to the object `T` pointed to by this `KeyableArc<T>`.\n+    #[inline]\n+    pub fn as_ptr(this: &Self) -> *const T {\n+        Arc::as_ptr(&this.0)\n+    }\n+\n+    /// Creates a new `KeyableWeak` pointer to this allocation.\n+    pub fn downgrade(this: &Self) -> KeyableWeak<T> {\n+        Arc::downgrade(&this.0).into()\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for KeyableArc<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<T: ?Sized> AsRef<T> for KeyableArc<T> {\n+    #[inline]\n+    fn as_ref(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+impl<T: ?Sized> Borrow<T> for KeyableArc<T> {\n+    #[inline]\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+impl<T: ?Sized> From<Arc<T>> for KeyableArc<T> {\n+    #[inline]\n+    fn from(arc: Arc<T>) -> Self {\n+        Self(arc)\n+    }\n+}\n+\n+impl<T: ?Sized> Into<Arc<T>> for KeyableArc<T> {\n+    #[inline]\n+    fn into(self) -> Arc<T> {\n+        self.0\n+    }\n+}\n+\n+impl<T: ?Sized> PartialEq for KeyableArc<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::as_ptr(&self.0) == Arc::as_ptr(&other.0)\n+    }\n+}\n+\n+impl<T: ?Sized> Eq for KeyableArc<T> {}\n+\n+impl<T: ?Sized> PartialOrd for KeyableArc<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(Arc::as_ptr(&self.0).cmp(&Arc::as_ptr(&other.0)))\n+    }\n+}\n+\n+impl<T: ?Sized> Ord for KeyableArc<T> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Arc::as_ptr(&self.0).cmp(&Arc::as_ptr(&other.0))\n+    }\n+}\n+\n+impl<T: ?Sized> Hash for KeyableArc<T> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        Arc::as_ptr(&self.0).hash(s)\n+    }\n+}\n+\n+impl<T: ?Sized> Clone for KeyableArc<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for KeyableArc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+//=========================================================\n+// The weak version\n+//=========================================================\n+\n+/// The weak counterpart of `KeyableArc<T>`, similar to `Weak<T>`.\n+///\n+/// `KeyableWeak<T>` is also _keyable_ for any type `T` just like\n+/// `KeyableArc<T>`.\n+#[repr(transparent)]\n+pub struct KeyableWeak<T: ?Sized>(Weak<T>);\n+\n+impl<T> KeyableWeak<T> {\n+    /// Constructs a new `KeyableWeak<T>`, without allocating any memory.\n+    /// Calling `upgrade` on the return value always gives `None`.\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self(Weak::new())\n+    }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `KeyableWeak<T>`.\n+    ///\n+    /// The pointer is valid only if there are some strong references.\n+    /// The pointer may be dangling, unaligned or even null otherwise.\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        self.0.as_ptr()\n+    }\n+}\n+\n+impl<T: ?Sized> KeyableWeak<T> {\n+    /// Attempts to upgrade the Weak pointer to an Arc,\n+    /// delaying dropping of the inner value if successful.\n+    ///\n+    /// Returns None if the inner value has since been dropped.\n+    #[inline]\n+    pub fn upgrade(&self) -> Option<KeyableArc<T>> {\n+        self.0.upgrade().map(|arc| arc.into())\n+    }\n+\n+    /// Gets the number of strong pointers pointing to this allocation.\n+    #[inline]\n+    pub fn strong_count(&self) -> usize {\n+        self.0.strong_count()\n+    }\n+\n+    /// Gets the number of weak pointers pointing to this allocation.\n+    #[inline]\n+    pub fn weak_count(&self) -> usize {\n+        self.0.weak_count()\n+    }\n+}\n+\n+impl<T: ?Sized> PartialEq for KeyableWeak<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.as_ptr() == other.0.as_ptr()\n+    }\n+}\n+\n+impl<T: ?Sized> Eq for KeyableWeak<T> {}\n+\n+impl<T: ?Sized> PartialOrd for KeyableWeak<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.0.as_ptr().cmp(&other.0.as_ptr()))\n+    }\n+}\n+\n+impl<T: ?Sized> Ord for KeyableWeak<T> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.0.as_ptr().cmp(&other.0.as_ptr())\n+    }\n+}\n+\n+impl<T: ?Sized> Hash for KeyableWeak<T> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0.as_ptr().hash(s)\n+    }\n+}\n+\n+impl<T: ?Sized> From<Weak<T>> for KeyableWeak<T> {\n+    #[inline]\n+    fn from(weak: Weak<T>) -> Self {\n+        Self(weak)\n+    }\n+}\n+\n+impl<T: ?Sized> Into<Weak<T>> for KeyableWeak<T> {\n+    #[inline]\n+    fn into(self) -> Weak<T> {\n+        self.0\n+    }\n+}\n+\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for KeyableWeak<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"(KeyableWeak)\")\n+    }\n+}\n+\n+// Enabling type coercing, e.g., converting from `KeyableArc<T>` to `KeyableArc<dyn S>`,\n+// where `T` implements `S`.\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<KeyableArc<U>> for KeyableArc<T> {}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn downgrade_and_upgrade() {\n+        let arc = KeyableArc::new(1);\n+        let weak = KeyableArc::downgrade(&arc);\n+        assert!(arc.clone() == weak.upgrade().unwrap());\n+        assert!(weak == KeyableArc::downgrade(&arc));\n+    }\n+\n+    #[test]\n+    fn debug_format() {\n+        println!(\"{:?}\", KeyableArc::new(1u32));\n+        println!(\"{:?}\", KeyableWeak::<u32>::new());\n+    }\n+\n+    #[test]\n+    fn use_as_key() {\n+        use std::collections::HashMap;\n+\n+        let mut map: HashMap<KeyableArc<u32>, u32> = HashMap::new();\n+        let key = KeyableArc::new(1);\n+        let val = 1;\n+        map.insert(key.clone(), val);\n+        assert!(map.get(&key) == Some(&val));\n+        assert!(map.remove(&key) == Some(val));\n+        assert!(map.keys().count() == 0);\n+    }\n+\n+    #[test]\n+    fn as_trait_object() {\n+        trait DummyTrait {}\n+        struct DummyStruct;\n+        impl DummyTrait for DummyStruct {}\n+\n+        let arc_struct = KeyableArc::new(DummyStruct);\n+        let arc_dyn0: KeyableArc<dyn DummyTrait> = arc_struct.clone();\n+        let arc_dyn1: KeyableArc<dyn DummyTrait> = arc_struct.clone();\n+        assert!(arc_dyn0 == arc_dyn1);\n+    }\n+}\n",
        "problem_statement": "Implement the epoll system call\n\n",
        "hints_text": "",
        "created_at": "2023-04-20T03:46:19Z",
        "version": "0.1"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 183,
        "instance_id": "asterinas__asterinas-183",
        "issue_numbers": [
            "115"
        ],
        "base_commit": "888853a6de752e97c6f94fff83c00594be42929f",
        "patch": "diff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -13,8 +13,8 @@ target/\n **/.DS_Store\n \n # Ramdisk file\n-src/ramdisk/initramfs/\n-src/ramdisk/build/\n+regression/ramdisk/initramfs/\n+regression/ramdisk/build/\n \n # qemu log file\n qemu.log\ndiff --git a/src/Cargo.toml b/Cargo.toml\n--- a/src/Cargo.toml\n+++ b/Cargo.toml\n@@ -3,11 +3,15 @@ name = \"jinux\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n+[[bin]]\n+name = \"jinux\"\n+path = \"kernel/main.rs\"\n+\n [dependencies]\n limine = \"0.1.10\"\n jinux-frame = { path = \"framework/jinux-frame\" }\n jinux-std = { path = \"services/libs/jinux-std\" }\n-component = { path = \"services/comp-sys/component\" }\n+component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\ndiff --git a/src/Cargo.toml b/Cargo.toml\n--- a/src/Cargo.toml\n+++ b/Cargo.toml\n@@ -33,4 +37,4 @@ members = [\n     \"services/libs/cpio-decoder\",\n ]\n \n-exclude = [\"services/comp-sys/controlled\", \"services/comp-sys/cargo-component\"]\n+exclude = [\"services/libs/comp-sys/controlled\", \"services/libs/comp-sys/cargo-component\"]\ndiff --git a/src/boot/limine/scripts/limine-build.sh b/boot/limine/scripts/limine-build.sh\n--- a/src/boot/limine/scripts/limine-build.sh\n+++ b/boot/limine/scripts/limine-build.sh\n@@ -25,7 +25,7 @@ cp target/limine/limine-cd.bin target/iso_root\n cp target/limine/limine-cd-efi.bin target/iso_root\n \n # Copy ramdisk\n-cp ramdisk/build/ramdisk.cpio target/iso_root\n+cp regression/ramdisk/build/ramdisk.cpio target/iso_root\n \n xorriso -as mkisofs                                             \\\n     -b limine-cd.bin                                            \\\ndiff --git a/src/framework/jinux-frame/Cargo.toml b/framework/jinux-frame/Cargo.toml\n--- a/src/framework/jinux-frame/Cargo.toml\n+++ b/framework/jinux-frame/Cargo.toml\n@@ -12,7 +12,7 @@ spin = \"0.9.4\"\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n buddy_system_allocator = \"0.9.0\"\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-align_ext = { path = \"../align_ext\" }\n+align_ext = { path = \"../libs/align_ext\" }\n intrusive-collections = \"0.9.5\"\n log = \"0.4\"\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\ndiff --git /dev/null b/regression/apps/hello_c/hello\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/hello_c/hello\n@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:dda5a7d6081cc2252056375d0550731ef2fd24789aa5f17da189a36bf78c588d\n+size 871896\ndiff --git a/src/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/src/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\n--- a/src/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n font8x8 = { version = \"0.2.5\", default-features = false, features = [\ndiff --git a/src/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/src/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\n \ndiff --git a/src/services/comps/pci/Cargo.toml b/services/comps/pci/Cargo.toml\n--- a/src/services/comps/pci/Cargo.toml\n+++ b/services/comps/pci/Cargo.toml\n@@ -11,7 +11,7 @@ spin = \"0.9.4\"\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [dependencies.lazy_static]\ndiff --git a/src/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\n--- a/src/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n \ndiff --git a/src/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/src/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/libs/jinux-std/Cargo.toml b/services/libs/jinux-std/Cargo.toml\n--- a/src/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/jinux-std/Cargo.toml\n@@ -7,12 +7,12 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-align_ext = { path = \"../../../framework/align_ext\" }\n+align_ext = { path = \"../../../framework/libs/align_ext\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n jinux-input = { path = \"../../comps/input\" }\n jinux-block = { path = \"../../comps/block\" }\n jinux-time = { path = \"../../comps/time\" }\n-controlled = { path = \"../../comp-sys/controlled\" }\n+controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n jinux-rights-proc = { path = \"../jinux-rights-proc\" }\ndiff --git a/src/services/libs/jinux-std/src/lib.rs b/services/libs/jinux-std/src/lib.rs\n--- a/src/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/jinux-std/src/lib.rs\n@@ -79,7 +79,7 @@ fn init_thread() {\n }\n \n fn read_ramdisk_content() -> &'static [u8] {\n-    include_bytes!(\"../../../../ramdisk/build/ramdisk.cpio\")\n+    include_bytes!(\"../../../../regression/ramdisk/build/ramdisk.cpio\")\n }\n \n /// first process never return\n",
        "test_patch": "diff --git a/.gitattributes b/.gitattributes\n--- a/.gitattributes\n+++ b/.gitattributes\n@@ -1,10 +1,10 @@\n-src/apps/hello_world/hello_world filter=lfs diff=lfs merge=lfs -text\n-src/apps/fork/fork filter=lfs diff=lfs merge=lfs -text\n-src/apps/hello_c/hello filter=lfs diff=lfs merge=lfs -text\n-src/apps/execve/execve filter=lfs diff=lfs merge=lfs -text\n-src/apps/execve/hello filter=lfs diff=lfs merge=lfs -text\n-src/apps/fork_c/fork filter=lfs diff=lfs merge=lfs -text\n-src/apps/signal_c/signal_test filter=lfs diff=lfs merge=lfs -text\n-src/apps/busybox/busybox filter=lfs diff=lfs merge=lfs -text\n-src/apps/pthread/pthread_test filter=lfs diff=lfs merge=lfs -text\n-src/apps/hello_pie/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_world/hello_world filter=lfs diff=lfs merge=lfs -text\n+regression/apps/fork/fork filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_c/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/execve/execve filter=lfs diff=lfs merge=lfs -text\n+regression/apps/execve/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/fork_c/fork filter=lfs diff=lfs merge=lfs -text\n+regression/apps/signal_c/signal_test filter=lfs diff=lfs merge=lfs -text\n+regression/apps/busybox/busybox filter=lfs diff=lfs merge=lfs -text\n+regression/apps/pthread/pthread_test filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_pie/hello filter=lfs diff=lfs merge=lfs -text\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,6 +1,6 @@\n .PHONY: all build clean docs fmt run setup test tools\n \n-all: build test\n+all: build\n \n setup:\n \t@rustup component add rust-src\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -9,28 +9,28 @@ setup:\n \t@cargo install mdbook\n \n build:\n-\t@make --no-print-directory -C src/ramdisk\n-\t@cd src && cargo kbuild\n+\t@make --no-print-directory -C regression/ramdisk\n+\t@cargo kbuild\n \n tools:\n-\t@cd src/services/comp-sys && cargo install --path cargo-component\n+\t@cd services/libs/comp-sys && cargo install --path cargo-component\n \n run: build\n-\t@cd src && cargo krun\n+\t@cargo krun\n \n test: build\n-\t@cd src && cargo ktest\n+\t@cargo ktest\n \n docs:\n-\t@cd src && cargo doc \t\t\t\t\t# Build Rust docs\n+\t@cargo doc \t\t\t\t\t\t\t\t# Build Rust docs\n \t@echo \"\" \t\t\t\t\t\t\t\t# Add a blank line\n \t@cd docs && mdbook build \t\t\t\t# Build mdBook\n \n check:\n-\t@cd src && cargo fmt --check \t\t\t# Check Rust format issues\n-\t@cd src && cargo clippy\t\t\t\t\t# Check common programming mistakes\n+\t@cargo fmt --check \t\t\t\t# Check Rust format issues\n+\t@cargo clippy\t\t\t\t\t# Check common programming mistakes\n \n clean:\n-\t@cd src && cargo clean\n+\t@cargo clean\n \t@cd docs && mdbook clean\n-\t@make --no-print-directory -C src/ramdisk clean\n+\t@make --no-print-directory -C regression/ramdisk clean\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -23,16 +23,16 @@ As a zero-cost, least-privilege OS, Jinux provides the best of both worlds: the\n ## How to build and test\n \n While most code is written in Rust, the project-scope build process is governed \n-by Makefile.\n+by Makefile. The following commands are intended for use on an Ubuntu server that has installed qemu-system-x86_64.\n \n-Before downloading source code, install and init Git LFS since the project manage binaries with Git LFS.\n+### Preparation\n+Before downloading source code, install and init Git LFS since the project manages binaries with Git LFS. \n ```bash\n # 1. install git-lfs\n-brew install git-lfs            # for mac\n-apt install git-lfs             # for ubuntu\n+apt install git-lfs             \n \n # 2. init git-lfs for current user\n-git lfs install --skip-repo     # for mac & ubuntu\n+git lfs install --skip-repo     \n ```\n \n Then, download source codes as normal.\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -46,22 +46,29 @@ all developmennt tools are installed.\n make setup\n ```\n \n-Then, install some standalone tools (e.g., `cargo-component`) under the project directory.\n-``` bash\n-make tools\n+### build\n+Then, we can build the project.\n+```bash\n+make build\n ```\n \n-Set environmental variables to enable `cargo` find installed tools.\n+If everything goes well, then we can run the OS.\n ```bash\n-export PATH=`pwd`/src/target/bin:${PATH}\n+make run\n ```\n \n-Then, we can build and test the project.\n+### Test  \n+We can run unit tests and integration tests if building succeeds.\n ```bash\n-make\n+make test\n ```\n \n-If everything goes well, then we can run the OS.\n+If we want to check access control policy among components, install some standalone tools (e.g., `cargo-component`), and set environmental variables to enable `cargo` find installed tools under the project directory. \n+``` bash\n+make tools\n+export PATH=`pwd`/target/bin:${PATH}\n+```\n+Then we can use the tool to check access control policy.\n ```bash\n-make run\n+cargo component-check\n ```\n",
        "problem_statement": "Reorganize the codebase for cleanness\nTo make the codebase more clean and understandable, I propose to do the following changes:\r\n\r\n* Rename `tests` to `test`, which indicates that the directory contains various types of testing code, including unit tests, user programs, and possibly LTP tests\r\n  * Rename `apps` to `test/apps`\r\n  * In the future, add LTP tests to `test`\r\n  * Put `ramdisk` under `test` because its content is only intended for testing\r\n* Create a `framework/libs` and move every dir (except `jinux-frame`) to the new dir\r\n* Rename `jinux-boot` to `boot` to make the name consistent with other dirs like `services` and `framework`\r\n* Move `services/comp-sys` to `services/libs/comp-sys`\r\n* Move `src/*` to the project root dir\r\n* [Optional] Rename `src/src` to `src/kernel`\n",
        "hints_text": "",
        "created_at": "2023-04-10T03:22:03Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 630,
        "instance_id": "asterinas__asterinas-630",
        "issue_numbers": [
            "625"
        ],
        "base_commit": "b450eef1660c0362ba65de07a3bd03c8199c3265",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,6 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n+use aster_frame::sync::WaitQueue;\n use keyable_arc::KeyableWeak;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -22,9 +23,11 @@ pub struct IfaceCommon {\n     interface: SpinLock<smoltcp::iface::Interface>,\n     sockets: SpinLock<SocketSet<'static>>,\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n-    /// The time should do next poll. We stores the total microseconds since system boots up.\n+    /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n     bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    /// The wait queue that background polling thread will sleep on\n+    polling_wait_queue: WaitQueue,\n }\n \n impl IfaceCommon {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -37,6 +40,7 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -60,6 +64,10 @@ impl IfaceCommon {\n         })\n     }\n \n+    pub(super) fn polling_wait_queue(&self) -> &WaitQueue {\n+        &self.polling_wait_queue\n+    }\n+\n     /// Alloc an unused port range from 49152 ~ 65535 (According to smoltcp docs)\n     fn alloc_ephemeral_port(&self) -> Result<u16> {\n         let mut used_ports = self.used_ports.write();\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -155,10 +163,16 @@ impl IfaceCommon {\n \n         let sockets = self.sockets.lock_irq_disabled();\n         if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+            let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms\n-                .store(instant.total_millis() as u64, Ordering::SeqCst);\n+                .store(instant.total_millis() as u64, Ordering::Relaxed);\n+\n+            if new_instant < old_instant {\n+                self.polling_wait_queue.wake_all();\n+            }\n         } else {\n-            self.next_poll_at_ms.store(0, Ordering::SeqCst);\n+            self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -1,5 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use aster_frame::sync::WaitQueue;\n use smoltcp::iface::SocketSet;\n \n use self::common::IfaceCommon;\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -60,6 +61,11 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n     fn netmask(&self) -> Option<Ipv4Address> {\n         self.common().netmask()\n     }\n+\n+    /// The waitqueue used to background polling thread\n+    fn polling_wait_queue(&self) -> &WaitQueue {\n+        self.common().polling_wait_queue()\n+    }\n }\n \n mod internal {\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -1,6 +1,8 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use aster_frame::timer::read_monotonic_milli_seconds;\n+use core::time::Duration;\n+\n+use aster_frame::{task::Priority, timer::read_monotonic_milli_seconds};\n \n use super::Iface;\n use crate::{\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -46,30 +48,40 @@ impl BindPortConfig {\n }\n \n pub fn spawn_background_poll_thread(iface: Arc<dyn Iface>) {\n-    // FIXME: use timer or wait_timeout when timer is enable.\n     let task_fn = move || {\n-        debug!(\"spawn background poll thread\");\n+        trace!(\"spawn background poll thread for {}\", iface.name());\n+        let wait_queue = iface.polling_wait_queue();\n         loop {\n-            let next_poll_time = if let Some(next_poll_time) = iface.next_poll_at_ms() {\n-                next_poll_time\n+            let next_poll_at_ms = if let Some(next_poll_at_ms) = iface.next_poll_at_ms() {\n+                next_poll_at_ms\n             } else {\n-                Thread::yield_now();\n-                continue;\n+                wait_queue.wait_until(|| iface.next_poll_at_ms())\n             };\n-            let now = read_monotonic_milli_seconds();\n-            if now > next_poll_time {\n-                // FIXME: now is later than next poll time. This may cause problem.\n+\n+            let now_as_ms = read_monotonic_milli_seconds();\n+\n+            // FIXME: Ideally, we should perform the `poll` just before `next_poll_at_ms`.\n+            // However, this approach may result in a spinning busy loop\n+            // if the `poll` operation yields no results.\n+            // To mitigate this issue,\n+            // we have opted to assign a high priority to the polling thread,\n+            // ensuring that the `poll` runs as soon as possible.\n+            // For a more in-depth discussion, please refer to the following link:\n+            // <https://github.com/asterinas/asterinas/pull/630#discussion_r1496817030>.\n+            if now_as_ms >= next_poll_at_ms {\n                 iface.poll();\n                 continue;\n             }\n-            let duration = next_poll_time - now;\n-            // FIXME: choose a suitable time interval\n-            if duration < 10 {\n-                iface.poll();\n-            } else {\n-                Thread::yield_now();\n-            }\n+\n+            let duration = Duration::from_millis(next_poll_at_ms - now_as_ms);\n+            wait_queue.wait_until_or_timeout(\n+                // If `iface.next_poll_at_ms()` changes to an earlier time, we will end the waiting.\n+                || (iface.next_poll_at_ms()? < next_poll_at_ms).then_some(()),\n+                &duration,\n+            );\n         }\n     };\n-    Thread::spawn_kernel_thread(ThreadOptions::new(task_fn));\n+\n+    let options = ThreadOptions::new(task_fn).priority(Priority::high());\n+    Thread::spawn_kernel_thread(options);\n }\n",
        "test_patch": "diff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -18,7 +18,7 @@ echo \"Start network test......\"\n ./socketpair\n ./sockoption\n ./listen_backlog\n-./send_buf_full\n+# ./send_buf_full\n \n \n echo \"All network test passed\"\n",
        "problem_statement": "Support for in-kernel sleep\nCurrently sleep function we provide seems to be the only `pauser.pause_until_or_timeout()` for the POSIX threads from users, as in the `clock_nanosleep` syscall. However, some functionalities within kernel also need sleep like\r\nhttps://github.com/asterinas/asterinas/blob/bd6f65667df494f6fb88fc60eb4ed18a106bed71/services/libs/aster-std/src/net/iface/util.rs#L49-L76\r\nWithout the support for kernel-level sleep, the polling would consume all the CPU cycles just to busy polling, while there is already hint for how long it should wait.\n",
        "hints_text": "In-kernel sleep is supported. A kernel thread can sleep using the `WaitQueue` API provided by the Framework. `Pauser` is in fact based on `WaitQueue`.\r\n\r\nIn theory, the specific code snippet you show can and should be refactored using `WaitQueue` to avoid busy looping. But it is written that way. Why? My guess is that at the time when this busy loop is written, the timer API of the Framework is not ready.\r\n\r\n```rust\r\n// FIXME: use timer or wait_timeout when timer is enable. \r\n```\r\n\r\n@StevenJiang1110 is the original author so his answer is the most wanted. \r\n\nYes, the origin code is added when `WaitQueue` cannot accept a `timeout` parameter.  Since timeout is supported now, we can avoid using busy loop here. #630 provides a fix for this problem.",
        "created_at": "2024-01-29T03:53:41Z",
        "version": "0.4"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 567,
        "instance_id": "asterinas__asterinas-567",
        "issue_numbers": [
            "555"
        ],
        "base_commit": "5fb8a9f7e558977a8027eec32565a2de6b87636b",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n # Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{error::Error, path::PathBuf};\n \n fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\ndiff --git a/framework/aster-frame/src/arch/mod.rs b/framework/aster-frame/src/arch/mod.rs\n--- a/framework/aster-frame/src/arch/mod.rs\n+++ b/framework/aster-frame/src/arch/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[cfg(target_arch = \"x86_64\")]\n pub mod x86;\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/boot.S b/framework/aster-frame/src/arch/x86/boot/boot.S\n--- a/framework/aster-frame/src/arch/x86/boot/boot.S\n+++ b/framework/aster-frame/src/arch/x86/boot/boot.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The boot header, initial boot setup code, temporary GDT and page tables are\n // in the boot section. The boot section is mapped writable since kernel may\n // modify the initial page table.\ndiff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Linux 64-bit Boot Protocol supporting module.\n //!\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html\n .section \".multiboot_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{string::String, vec::Vec};\n use multiboot2::MemoryAreaType;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot 2 header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot2/html_node/Index.html//Index\n .section \".multiboot2_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{\n     string::{String, ToString},\n     vec::Vec,\ndiff --git a/framework/aster-frame/src/arch/x86/console.rs b/framework/aster-frame/src/arch/x86/console.rs\n--- a/framework/aster-frame/src/arch/x86/console.rs\n+++ b/framework/aster-frame/src/arch/x86/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Write;\n \n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use core::arch::x86_64::{_fxrstor, _fxsave};\ndiff --git a/framework/aster-frame/src/arch/x86/device/cmos.rs b/framework/aster-frame/src/arch/x86/device/cmos.rs\n--- a/framework/aster-frame/src/arch/x86/device/cmos.rs\n+++ b/framework/aster-frame/src/arch/x86/device/cmos.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::{fadt::Fadt, sdt::Signature};\n use x86_64::instructions::port::{ReadOnlyAccess, WriteOnlyAccess};\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/io_port.rs b/framework/aster-frame/src/arch/x86/device/io_port.rs\n--- a/framework/aster-frame/src/arch/x86/device/io_port.rs\n+++ b/framework/aster-frame/src/arch/x86/device/io_port.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n pub use x86_64::instructions::port::{\ndiff --git a/framework/aster-frame/src/arch/x86/device/mod.rs b/framework/aster-frame/src/arch/x86/device/mod.rs\n--- a/framework/aster-frame/src/arch/x86/device/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Device-related APIs.\n //! This module mainly contains the APIs that should exposed to the device driver like PCI, RTC\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\n--- a/framework/aster-frame/src/arch/x86/device/serial.rs\n+++ b/framework/aster-frame/src/arch/x86/device/serial.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A port-mapped UART. Copied from uart_16550.\n \n use crate::arch::x86::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/context_table.rs b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use alloc::collections::BTreeMap;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/fault.rs b/framework/aster-frame/src/arch/x86/iommu/fault.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/fault.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/mod.rs b/framework/aster-frame/src/arch/x86/iommu/mod.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod context_table;\n mod fault;\n mod remapping;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/remapping.rs b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use log::debug;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use pod::Pod;\n \n use crate::{\ndiff --git a/framework/aster-frame/src/arch/x86/irq.rs b/framework/aster-frame/src/arch/x86/irq.rs\n--- a/framework/aster-frame/src/arch/x86/irq.rs\n+++ b/framework/aster-frame/src/arch/x86/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{boxed::Box, fmt::Debug, sync::Arc, vec::Vec};\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, mem::size_of, slice::Iter};\n \n use acpi::{sdt::Signature, AcpiTable};\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod dmar;\n pub mod remapping;\n \ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Remapping structures of DMAR table.\n //! This file defines these structures and provides a \"Debug\" implementation to see the value inside these structures.\n //! Most of the introduction are copied from Intel vt-directed-io-specification.\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::PlatformInfo;\n use alloc::vec;\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::boxed::Box;\n use alloc::sync::Arc;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use x86::msr::{\n     rdmsr, wrmsr, IA32_APIC_BASE, IA32_X2APIC_APICID, IA32_X2APIC_CUR_COUNT, IA32_X2APIC_DIV_CONF,\n     IA32_X2APIC_EOI, IA32_X2APIC_INIT_COUNT, IA32_X2APIC_LVT_TIMER, IA32_X2APIC_SIVR,\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use crate::vm;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/mod.rs b/framework/aster-frame/src/arch/x86/kernel/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) mod acpi;\n pub(super) mod apic;\n pub(super) mod pic;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/pic.rs b/framework/aster-frame/src/arch/x86/kernel/pic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/pic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/pic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::x86::device::io_port::{IoPort, WriteOnlyAccess};\n use crate::trap::IrqLine;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/tsc.rs b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicU64;\n use x86::cpuid::cpuid;\n \ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{collections::BTreeMap, fmt};\n use pod::Pod;\ndiff --git a/framework/aster-frame/src/arch/x86/mod.rs b/framework/aster-frame/src/arch/x86/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod boot;\n pub mod console;\n pub(crate) mod cpu;\ndiff --git a/framework/aster-frame/src/arch/x86/pci.rs b/framework/aster-frame/src/arch/x86/pci.rs\n--- a/framework/aster-frame/src/arch/x86/pci.rs\n+++ b/framework/aster-frame/src/arch/x86/pci.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus io port\n \n use super::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/qemu.rs b/framework/aster-frame/src/arch/x86/qemu.rs\n--- a/framework/aster-frame/src/arch/x86/qemu.rs\n+++ b/framework/aster-frame/src/arch/x86/qemu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the ability to exit QEMU and return a value as debug result.\n \n /// The exit code of x86 QEMU isa debug device. In `qemu-system-x86_64` the\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use tdx_guest::{\n     tdcall::TdgVeInfo,\n     tdvmcall::{cpuid, hlt, rdmsr, wrmsr, IoSize},\ndiff --git a/framework/aster-frame/src/arch/x86/timer/apic.rs b/framework/aster-frame/src/arch/x86/timer/apic.rs\n--- a/framework/aster-frame/src/arch/x86/timer/apic.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_rdtsc;\n use core::sync::atomic::{AtomicBool, AtomicU64, Ordering};\ndiff --git a/framework/aster-frame/src/arch/x86/timer/hpet.rs b/framework/aster-frame/src/arch/x86/timer/hpet.rs\n--- a/framework/aster-frame/src/arch/x86/timer/hpet.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/hpet.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{trap::IrqLine, vm::paddr_to_vaddr};\n use acpi::{AcpiError, HpetInfo};\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/mod.rs b/framework/aster-frame/src/arch/x86/timer/mod.rs\n--- a/framework/aster-frame/src/arch/x86/timer/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod apic;\n pub mod hpet;\n pub mod pit;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\n--- a/framework/aster-frame/src/arch/x86/timer/pit.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/pit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! used for PIT Timer\n \n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/aster-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The module to parse kernel command-line arguments.\n //!\n //! The format of the Asterinas command line string conforms\ndiff --git a/framework/aster-frame/src/boot/memory_region.rs b/framework/aster-frame/src/boot/memory_region.rs\n--- a/framework/aster-frame/src/boot/memory_region.rs\n+++ b/framework/aster-frame/src/boot/memory_region.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Information of memory regions in the boot phase.\n //!\n \ndiff --git a/framework/aster-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\n--- a/framework/aster-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The architecture-independent boot module, which provides a universal interface\n //! from the bootloader to the rest of the framework.\n //!\ndiff --git a/framework/aster-frame/src/bus/mmio/bus.rs b/framework/aster-frame/src/bus/mmio/bus.rs\n--- a/framework/aster-frame/src/bus/mmio/bus.rs\n+++ b/framework/aster-frame/src/bus/mmio/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{collections::VecDeque, fmt::Debug, sync::Arc, vec::Vec};\n use log::{debug, error};\n \ndiff --git a/framework/aster-frame/src/bus/mmio/device.rs b/framework/aster-frame/src/bus/mmio/device.rs\n--- a/framework/aster-frame/src/bus/mmio/device.rs\n+++ b/framework/aster-frame/src/bus/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use int_to_c_enum::TryFromInt;\n use log::info;\n \ndiff --git a/framework/aster-frame/src/bus/mmio/mod.rs b/framework/aster-frame/src/bus/mmio/mod.rs\n--- a/framework/aster-frame/src/bus/mmio/mod.rs\n+++ b/framework/aster-frame/src/bus/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtio over MMIO\n \n pub mod bus;\ndiff --git a/framework/aster-frame/src/bus/mod.rs b/framework/aster-frame/src/bus/mod.rs\n--- a/framework/aster-frame/src/bus/mod.rs\n+++ b/framework/aster-frame/src/bus/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod mmio;\n pub mod pci;\n \ndiff --git a/framework/aster-frame/src/bus/pci/bus.rs b/framework/aster-frame/src/bus/pci/bus.rs\n--- a/framework/aster-frame/src/bus/pci/bus.rs\n+++ b/framework/aster-frame/src/bus/pci/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{collections::VecDeque, sync::Arc, vec::Vec};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/mod.rs b/framework/aster-frame/src/bus/pci/capability/mod.rs\n--- a/framework/aster-frame/src/bus/pci/capability/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use self::{msix::CapabilityMsixData, vendor::CapabilityVndrData};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/msix.rs b/framework/aster-frame/src/bus/pci/capability/msix.rs\n--- a/framework/aster-frame/src/bus/pci/capability/msix.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n \n use crate::{\ndiff --git a/framework/aster-frame/src/bus/pci/capability/vendor.rs b/framework/aster-frame/src/bus/pci/capability/vendor.rs\n--- a/framework/aster-frame/src/bus/pci/capability/vendor.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/vendor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::bus::pci::{common_device::PciCommonDevice, device_info::PciDeviceLocation};\n use crate::{Error, Result};\n \ndiff --git a/framework/aster-frame/src/bus/pci/cfg_space.rs b/framework/aster-frame/src/bus/pci/cfg_space.rs\n--- a/framework/aster-frame/src/bus/pci/cfg_space.rs\n+++ b/framework/aster-frame/src/bus/pci/cfg_space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use bitflags::bitflags;\n \ndiff --git a/framework/aster-frame/src/bus/pci/common_device.rs b/framework/aster-frame/src/bus/pci/common_device.rs\n--- a/framework/aster-frame/src/bus/pci/common_device.rs\n+++ b/framework/aster-frame/src/bus/pci/common_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use super::{\ndiff --git a/framework/aster-frame/src/bus/pci/device_info.rs b/framework/aster-frame/src/bus/pci/device_info.rs\n--- a/framework/aster-frame/src/bus/pci/device_info.rs\n+++ b/framework/aster-frame/src/bus/pci/device_info.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::iter;\n \n use crate::arch::pci::{PCI_ADDRESS_PORT, PCI_DATA_PORT};\ndiff --git a/framework/aster-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\n--- a/framework/aster-frame/src/bus/pci/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus\n //!\n //! Users can implement the bus under the `PciDriver` to the PCI bus to register devices,\ndiff --git a/framework/aster-frame/src/config.rs b/framework/aster-frame/src/config.rs\n--- a/framework/aster-frame/src/config.rs\n+++ b/framework/aster-frame/src/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n use log::Level;\ndiff --git a/framework/aster-frame/src/console.rs b/framework/aster-frame/src/console.rs\n--- a/framework/aster-frame/src/console.rs\n+++ b/framework/aster-frame/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Arguments;\n \n pub fn print(args: Arguments) {\ndiff --git a/framework/aster-frame/src/cpu.rs b/framework/aster-frame/src/cpu.rs\n--- a/framework/aster-frame/src/cpu.rs\n+++ b/framework/aster-frame/src/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use crate::trap::disable_local;\ndiff --git a/framework/aster-frame/src/error.rs b/framework/aster-frame/src/error.rs\n--- a/framework/aster-frame/src/error.rs\n+++ b/framework/aster-frame/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// The error type which is returned from the APIs of this crate.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum Error {\ndiff --git a/framework/aster-frame/src/io_mem.rs b/framework/aster-frame/src/io_mem.rs\n--- a/framework/aster-frame/src/io_mem.rs\n+++ b/framework/aster-frame/src/io_mem.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{mem::size_of, ops::Range};\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{config::DEFAULT_LOG_LEVEL, early_println};\n \n use log::{Metadata, Record};\ndiff --git a/framework/aster-frame/src/panicking.rs b/framework/aster-frame/src/panicking.rs\n--- a/framework/aster-frame/src/panicking.rs\n+++ b/framework/aster-frame/src/panicking.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Panic support.\n \n use alloc::{boxed::Box, string::ToString};\ndiff --git a/framework/aster-frame/src/prelude.rs b/framework/aster-frame/src/prelude.rs\n--- a/framework/aster-frame/src/prelude.rs\n+++ b/framework/aster-frame/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The prelude.\n \n pub type Result<T> = core::result::Result<T, crate::error::Error>;\ndiff --git a/framework/aster-frame/src/sync/atomic_bits.rs b/framework/aster-frame/src/sync/atomic_bits.rs\n--- a/framework/aster-frame/src/sync/atomic_bits.rs\n+++ b/framework/aster-frame/src/sync/atomic_bits.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self};\n use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n \ndiff --git a/framework/aster-frame/src/sync/mod.rs b/framework/aster-frame/src/sync/mod.rs\n--- a/framework/aster-frame/src/sync/mod.rs\n+++ b/framework/aster-frame/src/sync/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod atomic_bits;\n mod mutex;\n // TODO: refactor this rcu implementation\ndiff --git a/framework/aster-frame/src/sync/mutex.rs b/framework/aster-frame/src/sync/mutex.rs\n--- a/framework/aster-frame/src/sync/mutex.rs\n+++ b/framework/aster-frame/src/sync/mutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::WaitQueue;\n use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rcu/mod.rs b/framework/aster-frame/src/sync/rcu/mod.rs\n--- a/framework/aster-frame/src/sync/rcu/mod.rs\n+++ b/framework/aster-frame/src/sync/rcu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read-copy update (RCU).\n \n use core::marker::PhantomData;\ndiff --git a/framework/aster-frame/src/sync/rcu/monitor.rs b/framework/aster-frame/src/sync/rcu/monitor.rs\n--- a/framework/aster-frame/src/sync/rcu/monitor.rs\n+++ b/framework/aster-frame/src/sync/rcu/monitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::collections::VecDeque;\n use core::sync::atomic::{\n     AtomicBool,\ndiff --git a/framework/aster-frame/src/sync/rcu/owner_ptr.rs b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n--- a/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n+++ b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ptr::NonNull;\n \n use crate::prelude::*;\ndiff --git a/framework/aster-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\n--- a/framework/aster-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\n--- a/framework/aster-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/spin.rs b/framework/aster-frame/src/sync/spin.rs\n--- a/framework/aster-frame/src/sync/spin.rs\n+++ b/framework/aster-frame/src/sync/spin.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/wait.rs b/framework/aster-frame/src/sync/wait.rs\n--- a/framework/aster-frame/src/sync/wait.rs\n+++ b/framework/aster-frame/src/sync/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SpinLock;\n use crate::arch::timer::add_timeout_list;\n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/task/mod.rs b/framework/aster-frame/src/task/mod.rs\n--- a/framework/aster-frame/src/task/mod.rs\n+++ b/framework/aster-frame/src/task/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Tasks are the unit of code execution.\n \n mod priority;\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::REAL_TIME_TASK_PRI;\n \n /// The priority of a task.\ndiff --git a/framework/aster-frame/src/task/processor.rs b/framework/aster-frame/src/task/processor.rs\n--- a/framework/aster-frame/src/task/processor.rs\n+++ b/framework/aster-frame/src/task/processor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicUsize;\n \n use crate::cpu_local;\ndiff --git a/framework/aster-frame/src/task/scheduler.rs b/framework/aster-frame/src/task/scheduler.rs\n--- a/framework/aster-frame/src/task/scheduler.rs\n+++ b/framework/aster-frame/src/task/scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::sync::SpinLock;\n use crate::task::Task;\ndiff --git a/framework/aster-frame/src/task/switch.S b/framework/aster-frame/src/task/switch.S\n--- a/framework/aster-frame/src/task/switch.S\n+++ b/framework/aster-frame/src/task/switch.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .text\n .global context_switch\n .code64\ndiff --git a/framework/aster-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\n--- a/framework/aster-frame/src/task/task.rs\n+++ b/framework/aster-frame/src/task/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::{KERNEL_STACK_SIZE, PAGE_SIZE};\n use crate::cpu::CpuSet;\ndiff --git a/framework/aster-frame/src/timer.rs b/framework/aster-frame/src/timer.rs\n--- a/framework/aster-frame/src/timer.rs\n+++ b/framework/aster-frame/src/timer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Timer.\n \n #[cfg(target_arch = \"x86_64\")]\ndiff --git a/framework/aster-frame/src/trap/handler.rs b/framework/aster-frame/src/trap/handler.rs\n--- a/framework/aster-frame/src/trap/handler.rs\n+++ b/framework/aster-frame/src/trap/handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{arch::irq::IRQ_LIST, cpu::CpuException};\n \n #[cfg(feature = \"intel_tdx\")]\ndiff --git a/framework/aster-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/aster-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::irq::{self, IrqCallbackHandle, NOT_USING_IRQ};\n use crate::task::{disable_preempt, DisablePreemptGuard};\n use crate::{prelude::*, Error};\ndiff --git a/framework/aster-frame/src/trap/mod.rs b/framework/aster-frame/src/trap/mod.rs\n--- a/framework/aster-frame/src/trap/mod.rs\n+++ b/framework/aster-frame/src/trap/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod handler;\n mod irq;\n \ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! User space.\n \n use crate::cpu::UserContext;\ndiff --git a/framework/aster-frame/src/util/mod.rs b/framework/aster-frame/src/util/mod.rs\n--- a/framework/aster-frame/src/util/mod.rs\n+++ b/framework/aster-frame/src/util/mod.rs\n@@ -1,1 +1,3 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod recycle_allocator;\ndiff --git a/framework/aster-frame/src/util/recycle_allocator.rs b/framework/aster-frame/src/util/recycle_allocator.rs\n--- a/framework/aster-frame/src/util/recycle_allocator.rs\n+++ b/framework/aster-frame/src/util/recycle_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n #[derive(Debug)]\ndiff --git a/framework/aster-frame/src/vm/dma/dma_coherent.rs b/framework/aster-frame/src/vm/dma/dma_coherent.rs\n--- a/framework/aster-frame/src/vm/dma/dma_coherent.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_coherent.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::ops::Deref;\n \ndiff --git a/framework/aster-frame/src/vm/dma/dma_stream.rs b/framework/aster-frame/src/vm/dma/dma_stream.rs\n--- a/framework/aster-frame/src/vm/dma/dma_stream.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_stream.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_mm_clflush;\n use core::ops::Range;\ndiff --git a/framework/aster-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\n--- a/framework/aster-frame/src/vm/dma/mod.rs\n+++ b/framework/aster-frame/src/vm/dma/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod dma_coherent;\n mod dma_stream;\n \ndiff --git a/framework/aster-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\n--- a/framework/aster-frame/src/vm/frame.rs\n+++ b/framework/aster-frame/src/vm/frame.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use core::{\n     iter::Iterator,\ndiff --git a/framework/aster-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\n--- a/framework/aster-frame/src/vm/frame_allocator.rs\n+++ b/framework/aster-frame/src/vm/frame_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n use alloc::vec::Vec;\n use buddy_system_allocator::FrameAllocator;\ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::{KERNEL_HEAP_SIZE, PAGE_SIZE};\n use crate::prelude::*;\n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/vm/io.rs b/framework/aster-frame/src/vm/io.rs\n--- a/framework/aster-frame/src/vm/io.rs\n+++ b/framework/aster-frame/src/vm/io.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::page_table::{PageTable, PageTableConfig, UserMode};\n use crate::{\n     arch::mm::{PageTableEntry, PageTableFlags},\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n \n /// Virtual addresses.\ndiff --git a/framework/aster-frame/src/vm/offset.rs b/framework/aster-frame/src/vm/offset.rs\n--- a/framework/aster-frame/src/vm/offset.rs\n+++ b/framework/aster-frame/src/vm/offset.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Get the offset of a field within a type as a pointer.\n ///\n /// ```rust\ndiff --git a/framework/aster-frame/src/vm/options.rs b/framework/aster-frame/src/vm/options.rs\n--- a/framework/aster-frame/src/vm/options.rs\n+++ b/framework/aster-frame/src/vm/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, Error};\n \n use super::{frame::VmFrameFlags, frame_allocator, VmFrame, VmFrameVec, VmSegment};\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{paddr_to_vaddr, Paddr, Vaddr, VmAllocOptions};\n use crate::{\n     arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry},\ndiff --git a/framework/aster-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\n--- a/framework/aster-frame/src/vm/space.rs\n+++ b/framework/aster-frame/src/vm/space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::PAGE_SIZE;\n use crate::sync::Mutex;\ndiff --git a/framework/libs/linux-bzimage/boot-params/src/lib.rs b/framework/libs/linux-bzimage/boot-params/src/lib.rs\n--- a/framework/libs/linux-bzimage/boot-params/src/lib.rs\n+++ b/framework/libs/linux-bzimage/boot-params/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The definition of Linux Boot Protocol boot_params struct.\n //!\n //! The bootloader will deliver the address of the `BootParams` struct\ndiff --git a/framework/libs/linux-bzimage/builder/src/lib.rs b/framework/libs/linux-bzimage/builder/src/lib.rs\n--- a/framework/libs/linux-bzimage/builder/src/lib.rs\n+++ b/framework/libs/linux-bzimage/builder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage builder.\n //!\n //! This crate is responsible for building the bzImage. It contains methods to build\ndiff --git a/framework/libs/linux-bzimage/builder/src/mapping.rs b/framework/libs/linux-bzimage/builder/src/mapping.rs\n--- a/framework/libs/linux-bzimage/builder/src/mapping.rs\n+++ b/framework/libs/linux-bzimage/builder/src/mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! In the setup, VA - SETUP32_LMA == FileOffset - LEGACY_SETUP_SEC_SIZE.\n //! And the addresses are specified in the ELF file.\n //!\ndiff --git a/framework/libs/linux-bzimage/builder/src/pe_header.rs b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/framework/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Big zImage PE/COFF header generation.\n //!\n //! The definition of the PE/COFF header is in the Microsoft PE/COFF specification:\ndiff --git a/framework/libs/linux-bzimage/setup/build.rs b/framework/libs/linux-bzimage/setup/build.rs\n--- a/framework/libs/linux-bzimage/setup/build.rs\n+++ b/framework/libs/linux-bzimage/setup/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::path::PathBuf;\n \n fn main() {\ndiff --git a/framework/libs/linux-bzimage/setup/src/console.rs b/framework/libs/linux-bzimage/setup/src/console.rs\n--- a/framework/libs/linux-bzimage/setup/src/console.rs\n+++ b/framework/libs/linux-bzimage/setup/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self, Write};\n \n use uart_16550::SerialPort;\ndiff --git a/framework/libs/linux-bzimage/setup/src/loader.rs b/framework/libs/linux-bzimage/setup/src/loader.rs\n--- a/framework/libs/linux-bzimage/setup/src/loader.rs\n+++ b/framework/libs/linux-bzimage/setup/src/loader.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use xmas_elf::program::{ProgramHeader, SegmentData};\n \n /// Load the kernel ELF payload to memory.\ndiff --git a/framework/libs/linux-bzimage/setup/src/main.rs b/framework/libs/linux-bzimage/setup/src/main.rs\n--- a/framework/libs/linux-bzimage/setup/src/main.rs\n+++ b/framework/libs/linux-bzimage/setup/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage setup binary.\n //!\n //! With respect to the format of the bzImage, we design our bzImage setup in the similar\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use uefi::{\n     data_types::Handle,\n     proto::loaded_image::LoadedImage,\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod efi;\n mod paging;\n mod relocation;\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstraction over the Intel IA32E paging mechanism. And\n //! offers method to create linear page tables.\n //!\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::x86::get_image_loaded_offset;\n \n struct Elf64Rela {\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .section \".setup\", \"ax\"\n .code64\n // start_of_setup32 should be loaded at CODE32_START, which is our base.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_boot_params::BootParams;\n \n use core::arch::{asm, global_asm};\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // 32-bit setup code starts here, and will be loaded at CODE32_START.\n .section \".setup\", \"ax\"\n .code32\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")] {\n         mod amd64_efi;\ndiff --git a/framework/libs/tdx-guest/src/asm/mod.rs b/framework/libs/tdx-guest/src/asm/mod.rs\n--- a/framework/libs/tdx-guest/src/asm/mod.rs\n+++ b/framework/libs/tdx-guest/src/asm/mod.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n use crate::{tdcall::TdcallArgs, tdvmcall::TdVmcallArgs};\n use core::arch::global_asm;\n \ndiff --git a/framework/libs/tdx-guest/src/asm/tdcall.asm b/framework/libs/tdx-guest/src/asm/tdcall.asm\n--- a/framework/libs/tdx-guest/src/asm/tdcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Arguments offsets in TdVmcallArgs struct\ndiff --git a/framework/libs/tdx-guest/src/asm/tdvmcall.asm b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n--- a/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Mask used to control which part of the guest TD GPR and XMM\ndiff --git a/framework/libs/tdx-guest/src/lib.rs b/framework/libs/tdx-guest/src/lib.rs\n--- a/framework/libs/tdx-guest/src/lib.rs\n+++ b/framework/libs/tdx-guest/src/lib.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n #![no_std]\n #![allow(dead_code)]\n #![allow(unused_variables)]\ndiff --git a/framework/libs/tdx-guest/src/tdcall.rs b/framework/libs/tdx-guest/src/tdcall.rs\n--- a/framework/libs/tdx-guest/src/tdcall.rs\n+++ b/framework/libs/tdx-guest/src/tdcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDCALL instruction causes a VM exit to the Intel TDX module.\n //! It is used to call guest-side Intel TDX functions. For more information about\n //! TDCALL, please refer to the [Intel\u00ae TDX Module v1.5 ABI Specification](https://cdrdv2.intel.com/v1/dl/getContent/733579)\ndiff --git a/framework/libs/tdx-guest/src/tdvmcall.rs b/framework/libs/tdx-guest/src/tdvmcall.rs\n--- a/framework/libs/tdx-guest/src/tdvmcall.rs\n+++ b/framework/libs/tdx-guest/src/tdvmcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDVMCALL helps invoke services from the host VMM. From the perspective of the host VMM, the TDVMCALL is a trap-like, VM exit into\n //! the host VMM, reported via the SEAMRET instruction flow.\n //! By design, after the SEAMRET, the host VMM services the request specified in the parameters\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![no_main]\n // The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\ndiff --git a/regression/Makefile b/regression/Makefile\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n BUILD_DIR := $(CUR_DIR)/build\ndiff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MAKEFLAGS += --no-builtin-rules # Prevent the implicit rules from compiling \".c\" or \".s\" files automatically.\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\ndiff --git a/regression/apps/execve/execve.c b/regression/apps/execve/execve.c\n--- a/regression/apps/execve/execve.c\n+++ b/regression/apps/execve/execve.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/execve/hello.c b/regression/apps/execve/hello.c\n--- a/regression/apps/execve/hello.c\n+++ b/regression/apps/execve/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main(int argc, char *argv[], char *envp[]) {\ndiff --git a/regression/apps/fork/fork.s b/regression/apps/fork/fork.s\n--- a/regression/apps/fork/fork.s\n+++ b/regression/apps/fork/fork.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/fork_c/fork.c b/regression/apps/fork_c/fork.c\n--- a/regression/apps/fork_c/fork.c\n+++ b/regression/apps/fork_c/fork.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/hello_c/hello.c b/regression/apps/hello_c/hello.c\n--- a/regression/apps/hello_c/hello.c\n+++ b/regression/apps/hello_c/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_pie/hello.c b/regression/apps/hello_pie/hello.c\n--- a/regression/apps/hello_pie/hello.c\n+++ b/regression/apps/hello_pie/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_world/hello_world.s b/regression/apps/hello_world/hello_world.s\n--- a/regression/apps/hello_world/hello_world.s\n+++ b/regression/apps/hello_world/hello_world.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/network/listen_backlog.c b/regression/apps/network/listen_backlog.c\n--- a/regression/apps/network/listen_backlog.c\n+++ b/regression/apps/network/listen_backlog.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/socketpair.c b/regression/apps/network/socketpair.c\n--- a/regression/apps/network/socketpair.c\n+++ b/regression/apps/network/socketpair.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <sys/socket.h>\n #include <stdlib.h>\ndiff --git a/regression/apps/network/sockoption.c b/regression/apps/network/sockoption.c\n--- a/regression/apps/network/sockoption.c\n+++ b/regression/apps/network/sockoption.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <sys/socket.h>\ndiff --git a/regression/apps/network/tcp_client.c b/regression/apps/network/tcp_client.c\n--- a/regression/apps/network/tcp_client.c\n+++ b/regression/apps/network/tcp_client.c\n@@ -1,51 +1,44 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Client side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n #include <stdio.h>\n+#include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-  \n-int main(int argc, char const* argv[])\n-{\n-    int status, valread, client_fd;\n+\n+int main() {\n+    int sock = 0, valread;\n     struct sockaddr_in serv_addr;\n-    char* hello = \"Hello from client\";\n-    char buffer[1024] = { 0 };\n-    if ((client_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char *hello = \"Hello from client\";\n+    char buffer[1024] = {0};\n+\n+    // Create socket\n+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n         printf(\"\\n Socket creation error \\n\");\n         return -1;\n     }\n-  \n+\n     serv_addr.sin_family = AF_INET;\n     serv_addr.sin_port = htons(PORT);\n-  \n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(serv_addr.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    if ((status\n-         = connect(client_fd, (struct sockaddr*)&serv_addr,\n-                   sizeof(serv_addr)))\n-        < 0) {\n-        printf(\"\\nConnection Failed \\n\");\n+\n+    // Connect to the server\n+    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n+        printf(\"\\n Connection Failed \\n\");\n         return -1;\n     }\n-    send(client_fd, hello, strlen(hello), 0);\n+\n+    // Send message to the server and receive the reply\n+    send(sock, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-    valread = read(client_fd, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n-  \n-    // closing the connected socket\n-    close(client_fd);\n+    valread = read(sock, buffer, 1024);\n+    printf(\"Server: %s\\n\", buffer);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/tcp_server.c b/regression/apps/network/tcp_server.c\n--- a/regression/apps/network/tcp_server.c\n+++ b/regression/apps/network/tcp_server.c\n@@ -1,75 +1,65 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Server side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n-#include <netinet/in.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-int main(int argc, char const* argv[])\n-{\n+\n+int main() {\n     int server_fd, new_socket, valread;\n     struct sockaddr_in address;\n     int opt = 1;\n     int addrlen = sizeof(address);\n-    char buffer[1024] = { 0 };\n-    char* hello = \"Hello from server\";\n-  \n-    // Creating socket file descriptor\n-    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char buffer[1024] = {0};\n+    char *hello = \"Hello from server\";\n+\n+    // Create socket\n+    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n         perror(\"socket failed\");\n         exit(EXIT_FAILURE);\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (setsockopt(server_fd, SOL_SOCKET,\n-                   SO_REUSEADDR | SO_REUSEPORT, &opt,\n-                   sizeof(opt))) {\n-        perror(\"setsockopt\");\n+\n+    // Set socket options\n+    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n+        perror(\"setsockopt failed\");\n         exit(EXIT_FAILURE);\n     }\n+    \n     address.sin_family = AF_INET;\n+    address.sin_addr.s_addr = INADDR_ANY;\n     address.sin_port = htons(PORT);\n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &address.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(address.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (bind(server_fd, (struct sockaddr*)&address,\n-             sizeof(address))\n-        < 0) {\n+\n+    // Bind the socket to specified IP and port\n+    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n         perror(\"bind failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Listen for connections\n     if (listen(server_fd, 3) < 0) {\n-        perror(\"listen\");\n+        perror(\"listen failed\");\n         exit(EXIT_FAILURE);\n     }\n-    if ((new_socket\n-         = accept(server_fd, (struct sockaddr*)&address,\n-                  (socklen_t*)&addrlen))\n-        < 0) {\n-        perror(\"accept\");\n+\n+    // Accept the connection\n+    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {\n+        perror(\"accept failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Read the message from the client and reply\n     valread = read(new_socket, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n+    printf(\"Client: %s\\n\", buffer);\n     send(new_socket, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-  \n-    // closing the connected socket\n-    close(new_socket);\n-    // closing the listening socket\n-    shutdown(server_fd, SHUT_RDWR);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/udp_client.c b/regression/apps/network/udp_client.c\n--- a/regression/apps/network/udp_client.c\n+++ b/regression/apps/network/udp_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/udp_server.c b/regression/apps/network/udp_server.c\n--- a/regression/apps/network/udp_server.c\n+++ b/regression/apps/network/udp_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_client.c b/regression/apps/network/unix_client.c\n--- a/regression/apps/network/unix_client.c\n+++ b/regression/apps/network/unix_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_server.c b/regression/apps/network/unix_server.c\n--- a/regression/apps/network/unix_server.c\n+++ b/regression/apps/network/unix_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/pty/open_pty.c b/regression/apps/pty/open_pty.c\n--- a/regression/apps/pty/open_pty.c\n+++ b/regression/apps/pty/open_pty.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <unistd.h>\ndiff --git a/regression/apps/scripts/Makefile b/regression/apps/scripts/Makefile\n--- a/regression/apps/scripts/Makefile\n+++ b/regression/apps/scripts/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .PHONY: all\n \n all: ./*.sh\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n NETTEST_DIR=/regression/network\ndiff --git a/regression/apps/scripts/process.sh b/regression/apps/scripts/process.sh\n--- a/regression/apps/scripts/process.sh\n+++ b/regression/apps/scripts/process.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=/regression\ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n set -x\n \ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the utility to run the GDB scripts for the runner.\n \n use crate::qemu_grub_efi;\ndiff --git a/runner/src/machine/microvm.rs b/runner/src/machine/microvm.rs\n--- a/runner/src/machine/microvm.rs\n+++ b/runner/src/machine/microvm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{\n     fs::OpenOptions,\n     io::{Seek, SeekFrom, Write},\ndiff --git a/runner/src/machine/mod.rs b/runner/src/machine/mod.rs\n--- a/runner/src/machine/mod.rs\n+++ b/runner/src/machine/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod microvm;\n pub mod qemu_grub_efi;\ndiff --git a/runner/src/machine/qemu_grub_efi.rs b/runner/src/machine/qemu_grub_efi.rs\n--- a/runner/src/machine/qemu_grub_efi.rs\n+++ b/runner/src/machine/qemu_grub_efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_bzimage_builder::{make_bzimage, BzImageType};\n \n use std::{\ndiff --git a/services/comps/block/src/bio.rs b/services/comps/block/src/bio.rs\n--- a/services/comps/block/src/bio.rs\n+++ b/services/comps/block/src/bio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{id::Sid, BlockDevice};\ndiff --git a/services/comps/block/src/id.rs b/services/comps/block/src/id.rs\n--- a/services/comps/block/src/id.rs\n+++ b/services/comps/block/src/id.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     iter::Step,\n     ops::{Add, Sub},\ndiff --git a/services/comps/block/src/impl_block_device.rs b/services/comps/block/src/impl_block_device.rs\n--- a/services/comps/block/src/impl_block_device.rs\n+++ b/services/comps/block/src/impl_block_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The block devices of Asterinas.\n //\uff01\n //\uff01This crate provides a number of base components for block devices, including\ndiff --git a/services/comps/block/src/prelude.rs b/services/comps/block/src/prelude.rs\n--- a/services/comps/block/src/prelude.rs\n+++ b/services/comps/block/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(crate) use alloc::collections::{BTreeMap, VecDeque};\n pub(crate) use alloc::string::String;\n pub(crate) use alloc::sync::Arc;\ndiff --git a/services/comps/block/src/request_queue.rs b/services/comps/block/src/request_queue.rs\n--- a/services/comps/block/src/request_queue.rs\n+++ b/services/comps/block/src/request_queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/network/src/buffer.rs b/services/comps/network/src/buffer.rs\n--- a/services/comps/network/src/buffer.rs\n+++ b/services/comps/network/src/buffer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use align_ext::AlignExt;\ndiff --git a/services/comps/network/src/driver.rs b/services/comps/network/src/driver.rs\n--- a/services/comps/network/src/driver.rs\n+++ b/services/comps/network/src/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use smoltcp::{phy, time::Instant};\n \ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(trait_alias)]\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstractions for hardware-assisted timing mechanisms, encapsulated by the `ClockSource` struct.\n //! A `ClockSource` can be constructed from any counter with a stable frequency, enabling precise time measurements to be taken\n //! by retrieving instances of `Instant`.\ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provide a instance of `ClockSource` based on TSC.\n //!\n //! Use `init` to initialize this module.\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     fmt::Debug,\n     hint::spin_loop,\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n \n use aster_frame::io_mem::IoMem;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/console/mod.rs b/services/comps/virtio/src/device/console/mod.rs\n--- a/services/comps/virtio/src/device/console/mod.rs\n+++ b/services/comps/virtio/src/device/console/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n \ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use crate::{device::VirtioDeviceError, queue::VirtQueue, transport::VirtioTransport};\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n // Modified from input.rs in virtio-drivers project\n //\n // MIT License\ndiff --git a/services/comps/virtio/src/device/mod.rs b/services/comps/virtio/src/device/mod.rs\n--- a/services/comps/virtio/src/device/mod.rs\n+++ b/services/comps/virtio/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::queue::QueueError;\n use int_to_c_enum::TryFromInt;\n \ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/network/header.rs b/services/comps/virtio/src/device/network/header.rs\n--- a/services/comps/virtio/src/device/network/header.rs\n+++ b/services/comps/virtio/src/device/network/header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/network/mod.rs b/services/comps/virtio/src/device/network/mod.rs\n--- a/services/comps/virtio/src/device/network/mod.rs\n+++ b/services/comps/virtio/src/device/network/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n pub mod header;\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtqueue\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{boxed::Box, sync::Arc};\n use aster_frame::{\n     bus::mmio::{\ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/mmio/layout.rs b/services/comps/virtio/src/transport/mmio/layout.rs\n--- a/services/comps/virtio/src/transport/mmio/layout.rs\n+++ b/services/comps/virtio/src/transport/mmio/layout.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     bus::{\n         pci::{\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod capability;\n pub mod common_cfg;\n pub mod device;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \ndiff --git a/services/libs/aster-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\n--- a/services/libs/aster-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\ndiff --git a/services/libs/aster-rights-proc/src/require_attr.rs b/services/libs/aster-rights-proc/src/require_attr.rs\n--- a/services/libs/aster-rights-proc/src/require_attr.rs\n+++ b/services/libs/aster-rights-proc/src/require_attr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! expand the require macro\n \n use proc_macro2::{Ident, TokenStream};\ndiff --git a/services/libs/aster-rights-proc/src/require_item.rs b/services/libs/aster-rights-proc/src/require_item.rs\n--- a/services/libs/aster-rights-proc/src/require_item.rs\n+++ b/services/libs/aster-rights-proc/src/require_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use syn::{parse::Parse, ItemFn, ItemImpl, Token};\n \n pub enum RequireItem {\ndiff --git a/services/libs/aster-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\n--- a/services/libs/aster-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n \n use core::ops::{Deref, DerefMut};\ndiff --git a/services/libs/aster-std/src/console.rs b/services/libs/aster-std/src/console.rs\n--- a/services/libs/aster-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! `print` and `println` macros\n //!\n //! FIXME: It will print to all `virtio-console` devices, which is not a good choice.\ndiff --git a/services/libs/aster-std/src/device/mod.rs b/services/libs/aster-std/src/device/mod.rs\n--- a/services/libs/aster-std/src/device/mod.rs\n+++ b/services/libs/aster-std/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod null;\n mod pty;\n mod random;\ndiff --git a/services/libs/aster-std/src/device/null.rs b/services/libs/aster-std/src/device/null.rs\n--- a/services/libs/aster-std/src/device/null.rs\n+++ b/services/libs/aster-std/src/device/null.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/pty/mod.rs b/services/libs/aster-std/src/device/pty/mod.rs\n--- a/services/libs/aster-std/src/device/pty/mod.rs\n+++ b/services/libs/aster-std/src/device/pty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/device/pty/pty.rs b/services/libs/aster-std/src/device/pty/pty.rs\n--- a/services/libs/aster-std/src/device/pty/pty.rs\n+++ b/services/libs/aster-std/src/device/pty/pty.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \ndiff --git a/services/libs/aster-std/src/device/random.rs b/services/libs/aster-std/src/device/random.rs\n--- a/services/libs/aster-std/src/device/random.rs\n+++ b/services/libs/aster-std/src/device/random.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tdxguest/mod.rs b/services/libs/aster-std/src/device/tdxguest/mod.rs\n--- a/services/libs/aster-std/src/device/tdxguest/mod.rs\n+++ b/services/libs/aster-std/src/device/tdxguest/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::error::Error;\n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/device/tty/device.rs b/services/libs/aster-std/src/device/tty/device.rs\n--- a/services/libs/aster-std/src/device/tty/device.rs\n+++ b/services/libs/aster-std/src/device/tty/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/aster-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \ndiff --git a/services/libs/aster-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\n--- a/services/libs/aster-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\ndiff --git a/services/libs/aster-std/src/device/tty/mod.rs b/services/libs/aster-std/src/device/tty/mod.rs\n--- a/services/libs/aster-std/src/device/tty/mod.rs\n+++ b/services/libs/aster-std/src/device/tty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use spin::Once;\n \n use self::driver::TtyDriver;\ndiff --git a/services/libs/aster-std/src/device/tty/termio.rs b/services/libs/aster-std/src/device/tty/termio.rs\n--- a/services/libs/aster-std/src/device/tty/termio.rs\n+++ b/services/libs/aster-std/src/device/tty/termio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/device/urandom.rs b/services/libs/aster-std/src/device/urandom.rs\n--- a/services/libs/aster-std/src/device/urandom.rs\n+++ b/services/libs/aster-std/src/device/urandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/zero.rs b/services/libs/aster-std/src/device/zero.rs\n--- a/services/libs/aster-std/src/device/zero.rs\n+++ b/services/libs/aster-std/src/device/zero.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/driver/mod.rs b/services/libs/aster-std/src/driver/mod.rs\n--- a/services/libs/aster-std/src/driver/mod.rs\n+++ b/services/libs/aster-std/src/driver/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use log::info;\n \n pub fn init() {\ndiff --git a/services/libs/aster-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/aster-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -1,4 +1,6 @@\n-/// Errno. Copied from Occlum\n+// SPDX-License-Identifier: MPL-2.0\n+\n+/// Error number.\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Errno {\ndiff --git a/services/libs/aster-std/src/events/events.rs b/services/libs/aster-std/src/events/events.rs\n--- a/services/libs/aster-std/src/events/events.rs\n+++ b/services/libs/aster-std/src/events/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A trait to represent any events.\n ///\n /// # The unit event\ndiff --git a/services/libs/aster-std/src/events/io_events.rs b/services/libs/aster-std/src/events/io_events.rs\n--- a/services/libs/aster-std/src/events/io_events.rs\n+++ b/services/libs/aster-std/src/events/io_events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Events, EventsFilter};\n \n crate::bitflags! {\ndiff --git a/services/libs/aster-std/src/events/mod.rs b/services/libs/aster-std/src/events/mod.rs\n--- a/services/libs/aster-std/src/events/mod.rs\n+++ b/services/libs/aster-std/src/events/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[allow(clippy::module_inception)]\n mod events;\n mod io_events;\ndiff --git a/services/libs/aster-std/src/events/observer.rs b/services/libs/aster-std/src/events/observer.rs\n--- a/services/libs/aster-std/src/events/observer.rs\n+++ b/services/libs/aster-std/src/events/observer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Events;\n \n /// An observer for events.\ndiff --git a/services/libs/aster-std/src/events/subject.rs b/services/libs/aster-std/src/events/subject.rs\n--- a/services/libs/aster-std/src/events/subject.rs\n+++ b/services/libs/aster-std/src/events/subject.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use core::sync::atomic::{AtomicUsize, Ordering};\ndiff --git a/services/libs/aster-std/src/fs/device.rs b/services/libs/aster-std/src/fs/device.rs\n--- a/services/libs/aster-std/src/fs/device.rs\n+++ b/services/libs/aster-std/src/fs/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n use crate::fs::utils::{InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\n--- a/services/libs/aster-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/devpts/ptmx.rs b/services/libs/aster-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/aster-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/aster-std/src/fs/devpts/ptmx.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/fs/devpts/slave.rs b/services/libs/aster-std/src/fs/devpts/slave.rs\n--- a/services/libs/aster-std/src/fs/devpts/slave.rs\n+++ b/services/libs/aster-std/src/fs/devpts/slave.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/epoll/epoll_file.rs b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n--- a/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n+++ b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::{FdEvents, FileDescripter};\ndiff --git a/services/libs/aster-std/src/fs/epoll/mod.rs b/services/libs/aster-std/src/fs/epoll/mod.rs\n--- a/services/libs/aster-std/src/fs/epoll/mod.rs\n+++ b/services/libs/aster-std/src/fs/epoll/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::file_table::FileDescripter;\n use crate::events::IoEvents;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/block_group.rs b/services/libs/aster-std/src/fs/ext2/block_group.rs\n--- a/services/libs/aster-std/src/fs/ext2/block_group.rs\n+++ b/services/libs/aster-std/src/fs/ext2/block_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::fs::Ext2;\n use super::inode::{Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n--- a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n+++ b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n \n /// A blocks hole descriptor implemented by the `BitVec`.\ndiff --git a/services/libs/aster-std/src/fs/ext2/dir.rs b/services/libs/aster-std/src/fs/ext2/dir.rs\n--- a/services/libs/aster-std/src/fs/ext2/dir.rs\n+++ b/services/libs/aster-std/src/fs/ext2/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::{FileType, MAX_FNAME_LEN};\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/fs.rs b/services/libs/aster-std/src/fs/ext2/fs.rs\n--- a/services/libs/aster-std/src/fs/ext2/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::block_group::{BlockGroup, RawGroupDescriptor};\n use super::inode::{FilePerm, FileType, Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::ext2::{utils::Dirty, Ext2, SuperBlock as Ext2SuperBlock, MAGIC_NUM as EXT2_MAGIC};\n use crate::fs::utils::{FileSystem, FsFlags, Inode, SuperBlock, NAME_MAX};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::fs::ext2::{FilePerm, FileType, Inode as Ext2Inode};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod fs;\n mod inode;\ndiff --git a/services/libs/aster-std/src/fs/ext2/inode.rs b/services/libs/aster-std/src/fs/ext2/inode.rs\n--- a/services/libs/aster-std/src/fs/ext2/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::blocks_hole::BlocksHoleDesc;\n use super::dir::{DirEntry, DirEntryReader, DirEntryWriter};\n use super::fs::Ext2;\ndiff --git a/services/libs/aster-std/src/fs/ext2/mod.rs b/services/libs/aster-std/src/fs/ext2/mod.rs\n--- a/services/libs/aster-std/src/fs/ext2/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust Ext2 filesystem.\n //!\n //! The Second Extended File System(Ext2) is a major rewrite of the Ext filesystem.\ndiff --git a/services/libs/aster-std/src/fs/ext2/prelude.rs b/services/libs/aster-std/src/fs/ext2/prelude.rs\n--- a/services/libs/aster-std/src/fs/ext2/prelude.rs\n+++ b/services/libs/aster-std/src/fs/ext2/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) use super::utils::{Dirty, IsPowerOf};\n \n pub(super) use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/super_block.rs b/services/libs/aster-std/src/fs/ext2/super_block.rs\n--- a/services/libs/aster-std/src/fs/ext2/super_block.rs\n+++ b/services/libs/aster-std/src/fs/ext2/super_block.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::RawInode;\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/utils.rs b/services/libs/aster-std/src/fs/ext2/utils.rs\n--- a/services/libs/aster-std/src/fs/ext2/utils.rs\n+++ b/services/libs/aster-std/src/fs/ext2/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::prelude::*;\n \n use core::ops::MulAssign;\ndiff --git a/services/libs/aster-std/src/fs/file_handle.rs b/services/libs/aster-std/src/fs/file_handle.rs\n--- a/services/libs/aster-std/src/fs/file_handle.rs\n+++ b/services/libs/aster-std/src/fs/file_handle.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\n--- a/services/libs/aster-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/fs_resolver.rs b/services/libs/aster-std/src/fs/fs_resolver.rs\n--- a/services/libs/aster-std/src/fs/fs_resolver.rs\n+++ b/services/libs/aster-std/src/fs/fs_resolver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use alloc::str;\n \ndiff --git a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend Inode-backed File Handle\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::{Read, TRightSet, TRights, Write};\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-std/src/fs/mod.rs b/services/libs/aster-std/src/fs/mod.rs\n--- a/services/libs/aster-std/src/fs/mod.rs\n+++ b/services/libs/aster-std/src/fs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n pub mod devpts;\n pub mod epoll;\ndiff --git a/services/libs/aster-std/src/fs/pipe.rs b/services/libs/aster-std/src/fs/pipe.rs\n--- a/services/libs/aster-std/src/fs/pipe.rs\n+++ b/services/libs/aster-std/src/fs/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/procfs/mod.rs b/services/libs/aster-std/src/fs/procfs/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::events::Observer;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/comm.rs b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/comm`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/exe.rs b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/exe`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/fd.rs b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/mod.rs b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::fs::file_table::FdEvents;\n use crate::fs::utils::{DirEntryVecExt, Inode};\ndiff --git a/services/libs/aster-std/src/fs/procfs/self_.rs b/services/libs/aster-std/src/fs/procfs/self_.rs\n--- a/services/libs/aster-std/src/fs/procfs/self_.rs\n+++ b/services/libs/aster-std/src/fs/procfs/self_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/self`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/builder.rs b/services/libs/aster-std/src/fs/procfs/template/builder.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/builder.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::{FileSystem, Inode};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/mod.rs b/services/libs/aster-std/src/fs/procfs/template/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, InodeMode, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\n--- a/services/libs/aster-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::sync::RwLockWriteGuard;\n use aster_frame::vm::VmFrame;\n use aster_frame::vm::VmIo;\ndiff --git a/services/libs/aster-std/src/fs/ramfs/mod.rs b/services/libs/aster-std/src/fs/ramfs/mod.rs\n--- a/services/libs/aster-std/src/fs/ramfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Ramfs based on PageCache\n \n pub use fs::RamFS;\ndiff --git a/services/libs/aster-std/src/fs/rootfs.rs b/services/libs/aster-std/src/fs/rootfs.rs\n--- a/services/libs/aster-std/src/fs/rootfs.rs\n+++ b/services/libs/aster-std/src/fs/rootfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::fs_resolver::{FsPath, FsResolver};\ndiff --git a/services/libs/aster-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\n--- a/services/libs/aster-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::Rights;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\n--- a/services/libs/aster-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\ndiff --git a/services/libs/aster-std/src/fs/utils/creation_flags.rs b/services/libs/aster-std/src/fs/utils/creation_flags.rs\n--- a/services/libs/aster-std/src/fs/utils/creation_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/creation_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/fs/utils/dentry.rs b/services/libs/aster-std/src/fs/utils/dentry.rs\n--- a/services/libs/aster-std/src/fs/utils/dentry.rs\n+++ b/services/libs/aster-std/src/fs/utils/dentry.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n--- a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n+++ b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::InodeType;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n--- a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n+++ b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A mask for the file mode of a newly-created file or directory.\n ///\n /// This mask is always a subset of `0o777`.\ndiff --git a/services/libs/aster-std/src/fs/utils/fs.rs b/services/libs/aster-std/src/fs/utils/fs.rs\n--- a/services/libs/aster-std/src/fs/utils/fs.rs\n+++ b/services/libs/aster-std/src/fs/utils/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\n--- a/services/libs/aster-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\ndiff --git a/services/libs/aster-std/src/fs/utils/ioctl.rs b/services/libs/aster-std/src/fs/utils/ioctl.rs\n--- a/services/libs/aster-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/aster-std/src/fs/utils/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[repr(u32)]\ndiff --git a/services/libs/aster-std/src/fs/utils/mod.rs b/services/libs/aster-std/src/fs/utils/mod.rs\n--- a/services/libs/aster-std/src/fs/utils/mod.rs\n+++ b/services/libs/aster-std/src/fs/utils/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! VFS components\n \n pub use access_mode::AccessMode;\ndiff --git a/services/libs/aster-std/src/fs/utils/mount.rs b/services/libs/aster-std/src/fs/utils/mount.rs\n--- a/services/libs/aster-std/src/fs/utils/mount.rs\n+++ b/services/libs/aster-std/src/fs/utils/mount.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Dentry, DentryKey, FileSystem, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\n--- a/services/libs/aster-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n use aster_rights::Full;\ndiff --git a/services/libs/aster-std/src/fs/utils/status_flags.rs b/services/libs/aster-std/src/fs/utils/status_flags.rs\n--- a/services/libs/aster-std/src/fs/utils/status_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/status_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/aster-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-std/src/net/iface/any_socket.rs b/services/libs/aster-std/src/net/iface/any_socket.rs\n--- a/services/libs/aster-std/src/net/iface/any_socket.rs\n+++ b/services/libs/aster-std/src/net/iface/any_socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/net/iface/common.rs b/services/libs/aster-std/src/net/iface/common.rs\n--- a/services/libs/aster-std/src/net/iface/common.rs\n+++ b/services/libs/aster-std/src/net/iface/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU64, Ordering};\n \n use super::Ipv4Address;\ndiff --git a/services/libs/aster-std/src/net/iface/loopback.rs b/services/libs/aster-std/src/net/iface/loopback.rs\n--- a/services/libs/aster-std/src/net/iface/loopback.rs\n+++ b/services/libs/aster-std/src/net/iface/loopback.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{IpAddress, Ipv4Address};\n use crate::prelude::*;\n use smoltcp::{\ndiff --git a/services/libs/aster-std/src/net/iface/mod.rs b/services/libs/aster-std/src/net/iface/mod.rs\n--- a/services/libs/aster-std/src/net/iface/mod.rs\n+++ b/services/libs/aster-std/src/net/iface/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use self::common::IfaceCommon;\n use crate::prelude::*;\n use smoltcp::iface::SocketSet;\ndiff --git a/services/libs/aster-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\n--- a/services/libs/aster-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\ndiff --git a/services/libs/aster-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\n--- a/services/libs/aster-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/aster-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::SpinLock;\n use aster_network::AnyNetworkDevice;\ndiff --git a/services/libs/aster-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\n--- a/services/libs/aster-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     net::iface::{Iface, IfaceLoopback, IfaceVirtio},\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/net/socket/ip/always_some.rs b/services/libs/aster-std/src/net/socket/ip/always_some.rs\n--- a/services/libs/aster-std/src/net/socket/ip/always_some.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/always_some.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use core::ops::{Deref, DerefMut};\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/common.rs b/services/libs/aster-std/src/net/socket/ip/common.rs\n--- a/services/libs/aster-std/src/net/socket/ip/common.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::BindPortConfig;\n use crate::net::iface::Iface;\n use crate::net::iface::{AnyBoundSocket, AnyUnboundSocket};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/mod.rs b/services/libs/aster-std/src/net/socket/ip/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod always_some;\n mod common;\n mod datagram;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use alloc::sync::Arc;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/init.rs b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::StatusFlags;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/options.rs b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n \n use super::CongestionControl;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/util.rs b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[derive(Debug, Clone, Copy, CopyGetters, Setters)]\ndiff --git a/services/libs/aster-std/src/net/socket/mod.rs b/services/libs/aster-std/src/net/socket/mod.rs\n--- a/services/libs/aster-std/src/net/socket/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{fs::file_handle::FileLike, prelude::*};\n \n use self::options::SocketOption;\ndiff --git a/services/libs/aster-std/src/net/socket/options/macros.rs b/services/libs/aster-std/src/net/socket/options/macros.rs\n--- a/services/libs/aster-std/src/net/socket/options/macros.rs\n+++ b/services/libs/aster-std/src/net/socket/options/macros.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[macro_export]\n macro_rules! impl_socket_options {\n     ($(\ndiff --git a/services/libs/aster-std/src/net/socket/options/mod.rs b/services/libs/aster-std/src/net/socket/options/mod.rs\n--- a/services/libs/aster-std/src/net/socket/options/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n use crate::prelude::*;\n mod macros;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/addr.rs b/services/libs/aster-std/src/net/socket/unix/addr.rs\n--- a/services/libs/aster-std/src/net/socket/unix/addr.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::Dentry;\n use crate::net::socket::util::socket_addr::SocketAddr;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/mod.rs b/services/libs/aster-std/src/net/socket/unix/mod.rs\n--- a/services/libs/aster-std/src/net/socket/unix/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod stream;\n \ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::endpoint::Endpoint;\n use crate::events::IoEvents;\n use crate::net::socket::{unix::addr::UnixSocketAddrBound, SockShutdownCmd};\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::process::signal::Poller;\n use crate::{\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/init.rs b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{connected::Connected, endpoint::Endpoint, UnixStreamSocket};\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod connected;\n mod endpoint;\n mod init;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::fs_resolver::FsPath;\ndiff --git a/services/libs/aster-std/src/net/socket/util/mod.rs b/services/libs/aster-std/src/net/socket/util/mod.rs\n--- a/services/libs/aster-std/src/net/socket/util/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod options;\n pub mod send_recv_flags;\n pub mod shutdown_cmd;\ndiff --git a/services/libs/aster-std/src/net/socket/util/options.rs b/services/libs/aster-std/src/net/socket/util/options.rs\n--- a/services/libs/aster-std/src/net/socket/util/options.rs\n+++ b/services/libs/aster-std/src/net/socket/util/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::net::iface::{RECV_BUF_LEN, SEND_BUF_LEN};\ndiff --git a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n--- a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n+++ b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n--- a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n+++ b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Shutdown types\ndiff --git a/services/libs/aster-std/src/net/socket/util/socket_addr.rs b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n--- a/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n+++ b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::{IpAddress, Ipv4Address};\n use crate::net::iface::{IpEndpoint, IpListenEndpoint};\n use crate::net::socket::unix::UnixSocketAddr;\ndiff --git a/services/libs/aster-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\n--- a/services/libs/aster-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n pub(crate) use alloc::boxed::Box;\ndiff --git a/services/libs/aster-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\n--- a/services/libs/aster-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n use super::process_vm::ProcessVm;\n use super::signal::sig_disposition::SigDispositions;\ndiff --git a/services/libs/aster-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\n--- a/services/libs/aster-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\ndiff --git a/services/libs/aster-std/src/process/credentials/group.rs b/services/libs/aster-std/src/process/credentials/group.rs\n--- a/services/libs/aster-std/src/process/credentials/group.rs\n+++ b/services/libs/aster-std/src/process/credentials/group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\n--- a/services/libs/aster-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod credentials_;\n mod group;\n mod static_cap;\ndiff --git a/services/libs/aster-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\n--- a/services/libs/aster-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/user.rs b/services/libs/aster-std/src/process/credentials/user.rs\n--- a/services/libs/aster-std/src/process/credentials/user.rs\n+++ b/services/libs/aster-std/src/process/credentials/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/exit.rs b/services/libs/aster-std/src/process/exit.rs\n--- a/services/libs/aster-std/src/process/exit.rs\n+++ b/services/libs/aster-std/src/process/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::signals::kernel::KernelSignal;\n use crate::{prelude::*, process::signal::constants::SIGCHLD};\ndiff --git a/services/libs/aster-std/src/process/kill.rs b/services/libs/aster-std/src/process/kill.rs\n--- a/services/libs/aster-std/src/process/kill.rs\n+++ b/services/libs/aster-std/src/process/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::signal::signals::user::UserSignal;\n use super::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/mod.rs b/services/libs/aster-std/src/process/mod.rs\n--- a/services/libs/aster-std/src/process/mod.rs\n+++ b/services/libs/aster-std/src/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod clone;\n mod credentials;\n mod exit;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\n--- a/services/libs/aster-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::user::UserSpace;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\n--- a/services/libs/aster-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use aster_frame::cpu::num_cpus;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\n--- a/services/libs/aster-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::kill::SignalSenderIds;\n use super::signal::sig_mask::SigMask;\n use super::signal::sig_num::SigNum;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/name.rs b/services/libs/aster-std/src/process/posix_thread/name.rs\n--- a/services/libs/aster-std/src/process/posix_thread/name.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/name.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n pub const MAX_THREAD_NAME_LEN: usize = 16;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n--- a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/robust_list.rs b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n--- a/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The implementation of robust list is from occlum.\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/process/builder.rs b/services/libs/aster-std/src/process/process/builder.rs\n--- a/services/libs/aster-std/src/process/process/builder.rs\n+++ b/services/libs/aster-std/src/process/process/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\ndiff --git a/services/libs/aster-std/src/process/process/job_control.rs b/services/libs/aster-std/src/process/process/job_control.rs\n--- a/services/libs/aster-std/src/process/process/job_control.rs\n+++ b/services/libs/aster-std/src/process/process/job_control.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGCONT, SIGHUP};\n use crate::process::signal::signals::kernel::KernelSignal;\ndiff --git a/services/libs/aster-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\n--- a/services/libs/aster-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\ndiff --git a/services/libs/aster-std/src/process/process/process_group.rs b/services/libs/aster-std/src/process/process/process_group.rs\n--- a/services/libs/aster-std/src/process/process/process_group.rs\n+++ b/services/libs/aster-std/src/process/process/process_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid, Process, Session};\n use crate::prelude::*;\n use crate::process::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/process/session.rs b/services/libs/aster-std/src/process/process/session.rs\n--- a/services/libs/aster-std/src/process/process/session.rs\n+++ b/services/libs/aster-std/src/process/process/session.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\ndiff --git a/services/libs/aster-std/src/process/process/terminal.rs b/services/libs/aster-std/src/process/process/terminal.rs\n--- a/services/libs/aster-std/src/process/process/terminal.rs\n+++ b/services/libs/aster-std/src/process/process/terminal.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, ProcessGroup};\ndiff --git a/services/libs/aster-std/src/process/process_filter.rs b/services/libs/aster-std/src/process/process_filter.rs\n--- a/services/libs/aster-std/src/process/process_filter.rs\n+++ b/services/libs/aster-std/src/process/process_filter.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/process_table.rs b/services/libs/aster-std/src/process/process_table.rs\n--- a/services/libs/aster-std/src/process/process_table.rs\n+++ b/services/libs/aster-std/src/process/process_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A global table stores the pid to process mapping.\n //! This table can be used to get process with pid.\n //! TODO: progress group, thread all need similar mapping\ndiff --git a/services/libs/aster-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\n--- a/services/libs/aster-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the UserVm of a process.\n //! The UserSpace of a process only contains the virtual-physical memory mapping.\n //! But we cannot know which vaddr is user heap, which vaddr is mmap areas.\ndiff --git a/services/libs/aster-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n--- a/services/libs/aster-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::vm::perms::VmPerms;\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This implementation is from occlum.\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A wrapper of xmas_elf's elf parsing\n use xmas_elf::{\n     header::{self, Header, HeaderPt1, HeaderPt2, HeaderPt2_, Machine_, Type_},\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the process initial stack.\n //! The process initial stack, contains arguments, environmental variables and auxiliary vectors\n //! The data layout of init stack can be seen in Figure 3.9 in https://uclibc.org/docs/psABI-x86_64.pdf\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module is used to parse elf file content to get elf_load_info.\n //! When create a process from elf file, we will use the elf_load_info to construct the VmSpace\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/mod.rs b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod aux_vec;\n mod elf_file;\n mod init_stack;\ndiff --git a/services/libs/aster-std/src/process/program_loader/mod.rs b/services/libs/aster-std/src/process/program_loader/mod.rs\n--- a/services/libs/aster-std/src/process/program_loader/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod elf;\n mod shebang;\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/shebang.rs b/services/libs/aster-std/src/process/program_loader/shebang.rs\n--- a/services/libs/aster-std/src/process/program_loader/shebang.rs\n+++ b/services/libs/aster-std/src/process/program_loader/shebang.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Try to parse a buffer as a shebang line.\ndiff --git a/services/libs/aster-std/src/process/rlimit.rs b/services/libs/aster-std/src/process/rlimit.rs\n--- a/services/libs/aster-std/src/process/rlimit.rs\n+++ b/services/libs/aster-std/src/process/rlimit.rs\n@@ -1,4 +1,4 @@\n-//! This implementation is from occlum\n+// SPDX-License-Identifier: MPL-2.0\n \n #![allow(non_camel_case_types)]\n \ndiff --git a/services/libs/aster-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\n--- a/services/libs/aster-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::mem;\n \ndiff --git a/services/libs/aster-std/src/process/signal/constants.rs b/services/libs/aster-std/src/process/signal/constants.rs\n--- a/services/libs/aster-std/src/process/signal/constants.rs\n+++ b/services/libs/aster-std/src/process/signal/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Standard signals\n pub(super) const MIN_STD_SIG_NUM: u8 = 1;\n pub(super) const MAX_STD_SIG_NUM: u8 = 31; // inclusive\ndiff --git a/services/libs/aster-std/src/process/signal/events.rs b/services/libs/aster-std/src/process/signal/events.rs\n--- a/services/libs/aster-std/src/process/signal/events.rs\n+++ b/services/libs/aster-std/src/process/signal/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, EventsFilter};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\n--- a/services/libs/aster-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod c_types;\n pub mod constants;\n mod events;\ndiff --git a/services/libs/aster-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\n--- a/services/libs/aster-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/process/signal/poll.rs b/services/libs/aster-std/src/process/signal/poll.rs\n--- a/services/libs/aster-std/src/process/signal/poll.rs\n+++ b/services/libs/aster-std/src/process/signal/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_action.rs b/services/libs/aster-std/src/process/signal/sig_action.rs\n--- a/services/libs/aster-std/src/process/signal/sig_action.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_action.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{c_types::sigaction_t, constants::*, sig_mask::SigMask, sig_num::SigNum};\n use crate::prelude::*;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_disposition.rs b/services/libs/aster-std/src/process/signal/sig_disposition.rs\n--- a/services/libs/aster-std/src/process/signal/sig_disposition.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_disposition.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, sig_action::SigAction, sig_num::SigNum};\n \n #[derive(Copy, Clone)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_mask.rs b/services/libs/aster-std/src/process/signal/sig_mask.rs\n--- a/services/libs/aster-std/src/process/signal/sig_mask.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::MIN_STD_SIG_NUM, sig_num::SigNum};\n \n #[derive(Debug, Copy, Clone, Default, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_num.rs b/services/libs/aster-std/src/process/signal/sig_num.rs\n--- a/services/libs/aster-std/src/process/signal/sig_num.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_num.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::constants::*;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/sig_queues.rs b/services/libs/aster-std/src/process/signal/sig_queues.rs\n--- a/services/libs/aster-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_queues.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SigEvents, SigEventsFilter};\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_stack.rs b/services/libs/aster-std/src/process/signal/sig_stack.rs\n--- a/services/libs/aster-std/src/process/signal/sig_stack.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// User-provided signal stack. `SigStack` is per-thread, and each thread can have\ndiff --git a/services/libs/aster-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\n--- a/services/libs/aster-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\ndiff --git a/services/libs/aster-std/src/process/signal/signals/kernel.rs b/services/libs/aster-std/src/process/signal/signals/kernel.rs\n--- a/services/libs/aster-std/src/process/signal/signals/kernel.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/kernel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::SI_KERNEL;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/mod.rs b/services/libs/aster-std/src/process/signal/signals/mod.rs\n--- a/services/libs/aster-std/src/process/signal/signals/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod fault;\n pub mod kernel;\n pub mod user;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/user.rs b/services/libs/aster-std/src/process/signal/signals/user.rs\n--- a/services/libs/aster-std/src/process/signal/signals/user.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::{SI_QUEUE, SI_TKILL, SI_USER};\ndiff --git a/services/libs/aster-std/src/process/status.rs b/services/libs/aster-std/src/process/status.rs\n--- a/services/libs/aster-std/src/process/status.rs\n+++ b/services/libs/aster-std/src/process/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The process status\n \n use super::TermStatus;\ndiff --git a/services/libs/aster-std/src/process/term_status.rs b/services/libs/aster-std/src/process/term_status.rs\n--- a/services/libs/aster-std/src/process/term_status.rs\n+++ b/services/libs/aster-std/src/process/term_status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::signal::sig_num::SigNum;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/wait.rs b/services/libs/aster-std/src/process/wait.rs\n--- a/services/libs/aster-std/src/process/wait.rs\n+++ b/services/libs/aster-std/src/process/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, process::process_table, thread::thread_table};\n \n use super::{process_filter::ProcessFilter, ExitCode, Pid, Process};\ndiff --git a/services/libs/aster-std/src/sched/mod.rs b/services/libs/aster-std/src/sched/mod.rs\n--- a/services/libs/aster-std/src/sched/mod.rs\n+++ b/services/libs/aster-std/src/sched/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod priority_scheduler;\n \n // There may be multiple scheduling policies in the system,\ndiff --git a/services/libs/aster-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\n--- a/services/libs/aster-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\ndiff --git a/services/libs/aster-std/src/syscall/accept.rs b/services/libs/aster-std/src/syscall/accept.rs\n--- a/services/libs/aster-std/src/syscall/accept.rs\n+++ b/services/libs/aster-std/src/syscall/accept.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/access.rs b/services/libs/aster-std/src/syscall/access.rs\n--- a/services/libs/aster-std/src/syscall/access.rs\n+++ b/services/libs/aster-std/src/syscall/access.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SyscallReturn};\n use crate::{log_syscall_entry, prelude::*, syscall::SYS_ACCESS, util::read_cstring_from_user};\n \ndiff --git a/services/libs/aster-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\n--- a/services/libs/aster-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\ndiff --git a/services/libs/aster-std/src/syscall/bind.rs b/services/libs/aster-std/src/syscall/bind.rs\n--- a/services/libs/aster-std/src/syscall/bind.rs\n+++ b/services/libs/aster-std/src/syscall/bind.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/brk.rs b/services/libs/aster-std/src/syscall/brk.rs\n--- a/services/libs/aster-std/src/syscall/brk.rs\n+++ b/services/libs/aster-std/src/syscall/brk.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/chdir.rs b/services/libs/aster-std/src/syscall/chdir.rs\n--- a/services/libs/aster-std/src/syscall/chdir.rs\n+++ b/services/libs/aster-std/src/syscall/chdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter, fs_resolver::FsPath, inode_handle::InodeHandle, utils::InodeType,\n };\ndiff --git a/services/libs/aster-std/src/syscall/chmod.rs b/services/libs/aster-std/src/syscall/chmod.rs\n--- a/services/libs/aster-std/src/syscall/chmod.rs\n+++ b/services/libs/aster-std/src/syscall/chmod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/clock_gettime.rs b/services/libs/aster-std/src/syscall/clock_gettime.rs\n--- a/services/libs/aster-std/src/syscall/clock_gettime.rs\n+++ b/services/libs/aster-std/src/syscall/clock_gettime.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOCK_GETTIME;\n use crate::time::now_as_duration;\ndiff --git a/services/libs/aster-std/src/syscall/clock_nanosleep.rs b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n--- a/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n+++ b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use super::SyscallReturn;\ndiff --git a/services/libs/aster-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\n--- a/services/libs/aster-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/close.rs b/services/libs/aster-std/src/syscall/close.rs\n--- a/services/libs/aster-std/src/syscall/close.rs\n+++ b/services/libs/aster-std/src/syscall/close.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOSE;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/connect.rs b/services/libs/aster-std/src/syscall/connect.rs\n--- a/services/libs/aster-std/src/syscall/connect.rs\n+++ b/services/libs/aster-std/src/syscall/connect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/constants.rs b/services/libs/aster-std/src/syscall/constants.rs\n--- a/services/libs/aster-std/src/syscall/constants.rs\n+++ b/services/libs/aster-std/src/syscall/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! constants used in syscall\n \n /// LONGEST ALLOWED FILENAME\ndiff --git a/services/libs/aster-std/src/syscall/dup.rs b/services/libs/aster-std/src/syscall/dup.rs\n--- a/services/libs/aster-std/src/syscall/dup.rs\n+++ b/services/libs/aster-std/src/syscall/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/epoll.rs b/services/libs/aster-std/src/syscall/epoll.rs\n--- a/services/libs/aster-std/src/syscall/epoll.rs\n+++ b/services/libs/aster-std/src/syscall/epoll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\n--- a/services/libs/aster-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n use aster_rights::WriteOp;\n \ndiff --git a/services/libs/aster-std/src/syscall/exit.rs b/services/libs/aster-std/src/syscall/exit.rs\n--- a/services/libs/aster-std/src/syscall/exit.rs\n+++ b/services/libs/aster-std/src/syscall/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::TermStatus;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/exit_group.rs b/services/libs/aster-std/src/syscall/exit_group.rs\n--- a/services/libs/aster-std/src/syscall/exit_group.rs\n+++ b/services/libs/aster-std/src/syscall/exit_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{do_exit_group, TermStatus};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/fcntl.rs b/services/libs/aster-std/src/syscall/fcntl.rs\n--- a/services/libs/aster-std/src/syscall/fcntl.rs\n+++ b/services/libs/aster-std/src/syscall/fcntl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_FCNTL};\n use crate::log_syscall_entry;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\n--- a/services/libs/aster-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/fsync.rs b/services/libs/aster-std/src/syscall/fsync.rs\n--- a/services/libs/aster-std/src/syscall/fsync.rs\n+++ b/services/libs/aster-std/src/syscall/fsync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::{\n     fs::{file_table::FileDescripter, inode_handle::InodeHandle},\ndiff --git a/services/libs/aster-std/src/syscall/futex.rs b/services/libs/aster-std/src/syscall/futex.rs\n--- a/services/libs/aster-std/src/syscall/futex.rs\n+++ b/services/libs/aster-std/src/syscall/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::futex::{\n     futex_op_and_flags_from_u32, futex_requeue, futex_wait, futex_wait_bitset, futex_wake,\n     futex_wake_bitset, FutexOp, FutexTimeout,\ndiff --git a/services/libs/aster-std/src/syscall/getcwd.rs b/services/libs/aster-std/src/syscall/getcwd.rs\n--- a/services/libs/aster-std/src/syscall/getcwd.rs\n+++ b/services/libs/aster-std/src/syscall/getcwd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/getdents64.rs b/services/libs/aster-std/src/syscall/getdents64.rs\n--- a/services/libs/aster-std/src/syscall/getdents64.rs\n+++ b/services/libs/aster-std/src/syscall/getdents64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     inode_handle::InodeHandle,\ndiff --git a/services/libs/aster-std/src/syscall/getegid.rs b/services/libs/aster-std/src/syscall/getegid.rs\n--- a/services/libs/aster-std/src/syscall/getegid.rs\n+++ b/services/libs/aster-std/src/syscall/getegid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::credentials;\ndiff --git a/services/libs/aster-std/src/syscall/geteuid.rs b/services/libs/aster-std/src/syscall/geteuid.rs\n--- a/services/libs/aster-std/src/syscall/geteuid.rs\n+++ b/services/libs/aster-std/src/syscall/geteuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETEUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgid.rs b/services/libs/aster-std/src/syscall/getgid.rs\n--- a/services/libs/aster-std/src/syscall/getgid.rs\n+++ b/services/libs/aster-std/src/syscall/getgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgroups.rs b/services/libs/aster-std/src/syscall/getgroups.rs\n--- a/services/libs/aster-std/src/syscall/getgroups.rs\n+++ b/services/libs/aster-std/src/syscall/getgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpeername.rs b/services/libs/aster-std/src/syscall/getpeername.rs\n--- a/services/libs/aster-std/src/syscall/getpeername.rs\n+++ b/services/libs/aster-std/src/syscall/getpeername.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpgrp.rs b/services/libs/aster-std/src/syscall/getpgrp.rs\n--- a/services/libs/aster-std/src/syscall/getpgrp.rs\n+++ b/services/libs/aster-std/src/syscall/getpgrp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETPGRP};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/getpid.rs b/services/libs/aster-std/src/syscall/getpid.rs\n--- a/services/libs/aster-std/src/syscall/getpid.rs\n+++ b/services/libs/aster-std/src/syscall/getpid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETPID;\ndiff --git a/services/libs/aster-std/src/syscall/getppid.rs b/services/libs/aster-std/src/syscall/getppid.rs\n--- a/services/libs/aster-std/src/syscall/getppid.rs\n+++ b/services/libs/aster-std/src/syscall/getppid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/getrandom.rs b/services/libs/aster-std/src/syscall/getrandom.rs\n--- a/services/libs/aster-std/src/syscall/getrandom.rs\n+++ b/services/libs/aster-std/src/syscall/getrandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresgid.rs b/services/libs/aster-std/src/syscall/getresgid.rs\n--- a/services/libs/aster-std/src/syscall/getresgid.rs\n+++ b/services/libs/aster-std/src/syscall/getresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresuid.rs b/services/libs/aster-std/src/syscall/getresuid.rs\n--- a/services/libs/aster-std/src/syscall/getresuid.rs\n+++ b/services/libs/aster-std/src/syscall/getresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsid.rs b/services/libs/aster-std/src/syscall/getsid.rs\n--- a/services/libs/aster-std/src/syscall/getsid.rs\n+++ b/services/libs/aster-std/src/syscall/getsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/getsockname.rs b/services/libs/aster-std/src/syscall/getsockname.rs\n--- a/services/libs/aster-std/src/syscall/getsockname.rs\n+++ b/services/libs/aster-std/src/syscall/getsockname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsockopt.rs b/services/libs/aster-std/src/syscall/getsockopt.rs\n--- a/services/libs/aster-std/src/syscall/getsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/getsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/gettid.rs b/services/libs/aster-std/src/syscall/gettid.rs\n--- a/services/libs/aster-std/src/syscall/gettid.rs\n+++ b/services/libs/aster-std/src/syscall/gettid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETTID;\ndiff --git a/services/libs/aster-std/src/syscall/gettimeofday.rs b/services/libs/aster-std/src/syscall/gettimeofday.rs\n--- a/services/libs/aster-std/src/syscall/gettimeofday.rs\n+++ b/services/libs/aster-std/src/syscall/gettimeofday.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_GETTIMEOFDAY;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/getuid.rs b/services/libs/aster-std/src/syscall/getuid.rs\n--- a/services/libs/aster-std/src/syscall/getuid.rs\n+++ b/services/libs/aster-std/src/syscall/getuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/ioctl.rs b/services/libs/aster-std/src/syscall/ioctl.rs\n--- a/services/libs/aster-std/src/syscall/ioctl.rs\n+++ b/services/libs/aster-std/src/syscall/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::IoctlCmd;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/kill.rs b/services/libs/aster-std/src/syscall/kill.rs\n--- a/services/libs/aster-std/src/syscall/kill.rs\n+++ b/services/libs/aster-std/src/syscall/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_KILL};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/link.rs b/services/libs/aster-std/src/syscall/link.rs\n--- a/services/libs/aster-std/src/syscall/link.rs\n+++ b/services/libs/aster-std/src/syscall/link.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/listen.rs b/services/libs/aster-std/src/syscall/listen.rs\n--- a/services/libs/aster-std/src/syscall/listen.rs\n+++ b/services/libs/aster-std/src/syscall/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/lseek.rs b/services/libs/aster-std/src/syscall/lseek.rs\n--- a/services/libs/aster-std/src/syscall/lseek.rs\n+++ b/services/libs/aster-std/src/syscall/lseek.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, utils::SeekFrom};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/madvise.rs b/services/libs/aster-std/src/syscall/madvise.rs\n--- a/services/libs/aster-std/src/syscall/madvise.rs\n+++ b/services/libs/aster-std/src/syscall/madvise.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::util::read_bytes_from_user;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/mkdir.rs b/services/libs/aster-std/src/syscall/mkdir.rs\n--- a/services/libs/aster-std/src/syscall/mkdir.rs\n+++ b/services/libs/aster-std/src/syscall/mkdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\n--- a/services/libs/aster-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This mod defines mmap flags and the handler to syscall mmap\n \n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\n--- a/services/libs/aster-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read the Cpu context content then dispatch syscall to corrsponding handler\n //! The each sub module contains functions that handle real syscall logic.\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/mprotect.rs b/services/libs/aster-std/src/syscall/mprotect.rs\n--- a/services/libs/aster-std/src/syscall/mprotect.rs\n+++ b/services/libs/aster-std/src/syscall/mprotect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/munmap.rs b/services/libs/aster-std/src/syscall/munmap.rs\n--- a/services/libs/aster-std/src/syscall/munmap.rs\n+++ b/services/libs/aster-std/src/syscall/munmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/open.rs b/services/libs/aster-std/src/syscall/open.rs\n--- a/services/libs/aster-std/src/syscall/open.rs\n+++ b/services/libs/aster-std/src/syscall/open.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_handle::FileLike,\n     file_table::FileDescripter,\ndiff --git a/services/libs/aster-std/src/syscall/pause.rs b/services/libs/aster-std/src/syscall/pause.rs\n--- a/services/libs/aster-std/src/syscall/pause.rs\n+++ b/services/libs/aster-std/src/syscall/pause.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::signal::Pauser;\ndiff --git a/services/libs/aster-std/src/syscall/pipe.rs b/services/libs/aster-std/src/syscall/pipe.rs\n--- a/services/libs/aster-std/src/syscall/pipe.rs\n+++ b/services/libs/aster-std/src/syscall/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::pipe::{PipeReader, PipeWriter};\n use crate::fs::utils::{Channel, StatusFlags};\ndiff --git a/services/libs/aster-std/src/syscall/poll.rs b/services/libs/aster-std/src/syscall/poll.rs\n--- a/services/libs/aster-std/src/syscall/poll.rs\n+++ b/services/libs/aster-std/src/syscall/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::Cell;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/syscall/prctl.rs b/services/libs/aster-std/src/syscall/prctl.rs\n--- a/services/libs/aster-std/src/syscall/prctl.rs\n+++ b/services/libs/aster-std/src/syscall/prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/pread64.rs b/services/libs/aster-std/src/syscall/pread64.rs\n--- a/services/libs/aster-std/src/syscall/pread64.rs\n+++ b/services/libs/aster-std/src/syscall/pread64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::SeekFrom;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/prlimit64.rs b/services/libs/aster-std/src/syscall/prlimit64.rs\n--- a/services/libs/aster-std/src/syscall/prlimit64.rs\n+++ b/services/libs/aster-std/src/syscall/prlimit64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::ResourceType;\n use crate::util::{read_val_from_user, write_val_to_user};\n use crate::{log_syscall_entry, prelude::*, process::Pid};\ndiff --git a/services/libs/aster-std/src/syscall/read.rs b/services/libs/aster-std/src/syscall/read.rs\n--- a/services/libs/aster-std/src/syscall/read.rs\n+++ b/services/libs/aster-std/src/syscall/read.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::util::write_bytes_to_user;\n use crate::{fs::file_table::FileDescripter, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/readlink.rs b/services/libs/aster-std/src/syscall/readlink.rs\n--- a/services/libs/aster-std/src/syscall/readlink.rs\n+++ b/services/libs/aster-std/src/syscall/readlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/recvfrom.rs b/services/libs/aster-std/src/syscall/recvfrom.rs\n--- a/services/libs/aster-std/src/syscall/recvfrom.rs\n+++ b/services/libs/aster-std/src/syscall/recvfrom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/rename.rs b/services/libs/aster-std/src/syscall/rename.rs\n--- a/services/libs/aster-std/src/syscall/rename.rs\n+++ b/services/libs/aster-std/src/syscall/rename.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rmdir.rs b/services/libs/aster-std/src/syscall/rmdir.rs\n--- a/services/libs/aster-std/src/syscall/rmdir.rs\n+++ b/services/libs/aster-std/src/syscall/rmdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigaction.rs b/services/libs/aster-std/src/syscall/rt_sigaction.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigaction.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigaction.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_RT_SIGPROCMASK};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/sched_yield.rs b/services/libs/aster-std/src/syscall/sched_yield.rs\n--- a/services/libs/aster-std/src/syscall/sched_yield.rs\n+++ b/services/libs/aster-std/src/syscall/sched_yield.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::thread::Thread;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/select.rs b/services/libs/aster-std/src/syscall/select.rs\n--- a/services/libs/aster-std/src/syscall/select.rs\n+++ b/services/libs/aster-std/src/syscall/select.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/sendto.rs b/services/libs/aster-std/src/syscall/sendto.rs\n--- a/services/libs/aster-std/src/syscall/sendto.rs\n+++ b/services/libs/aster-std/src/syscall/sendto.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/set_robust_list.rs b/services/libs/aster-std/src/syscall/set_robust_list.rs\n--- a/services/libs/aster-std/src/syscall/set_robust_list.rs\n+++ b/services/libs/aster-std/src/syscall/set_robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SET_ROBUST_LIST};\n use crate::{\n     log_syscall_entry,\ndiff --git a/services/libs/aster-std/src/syscall/set_tid_address.rs b/services/libs/aster-std/src/syscall/set_tid_address.rs\n--- a/services/libs/aster-std/src/syscall/set_tid_address.rs\n+++ b/services/libs/aster-std/src/syscall/set_tid_address.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_SET_TID_ADDRESS;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/setfsgid.rs b/services/libs/aster-std/src/syscall/setfsgid.rs\n--- a/services/libs/aster-std/src/syscall/setfsgid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setfsuid.rs b/services/libs/aster-std/src/syscall/setfsuid.rs\n--- a/services/libs/aster-std/src/syscall/setfsuid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setgid.rs b/services/libs/aster-std/src/syscall/setgid.rs\n--- a/services/libs/aster-std/src/syscall/setgid.rs\n+++ b/services/libs/aster-std/src/syscall/setgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setgroups.rs b/services/libs/aster-std/src/syscall/setgroups.rs\n--- a/services/libs/aster-std/src/syscall/setgroups.rs\n+++ b/services/libs/aster-std/src/syscall/setgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setpgid.rs b/services/libs/aster-std/src/syscall/setpgid.rs\n--- a/services/libs/aster-std/src/syscall/setpgid.rs\n+++ b/services/libs/aster-std/src/syscall/setpgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/setregid.rs b/services/libs/aster-std/src/syscall/setregid.rs\n--- a/services/libs/aster-std/src/syscall/setregid.rs\n+++ b/services/libs/aster-std/src/syscall/setregid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresgid.rs b/services/libs/aster-std/src/syscall/setresgid.rs\n--- a/services/libs/aster-std/src/syscall/setresgid.rs\n+++ b/services/libs/aster-std/src/syscall/setresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresuid.rs b/services/libs/aster-std/src/syscall/setresuid.rs\n--- a/services/libs/aster-std/src/syscall/setresuid.rs\n+++ b/services/libs/aster-std/src/syscall/setresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setreuid.rs b/services/libs/aster-std/src/syscall/setreuid.rs\n--- a/services/libs/aster-std/src/syscall/setreuid.rs\n+++ b/services/libs/aster-std/src/syscall/setreuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setsid.rs b/services/libs/aster-std/src/syscall/setsid.rs\n--- a/services/libs/aster-std/src/syscall/setsid.rs\n+++ b/services/libs/aster-std/src/syscall/setsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/setsockopt.rs b/services/libs/aster-std/src/syscall/setsockopt.rs\n--- a/services/libs/aster-std/src/syscall/setsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/setsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setuid.rs b/services/libs/aster-std/src/syscall/setuid.rs\n--- a/services/libs/aster-std/src/syscall/setuid.rs\n+++ b/services/libs/aster-std/src/syscall/setuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/shutdown.rs b/services/libs/aster-std/src/syscall/shutdown.rs\n--- a/services/libs/aster-std/src/syscall/shutdown.rs\n+++ b/services/libs/aster-std/src/syscall/shutdown.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SockShutdownCmd;\ndiff --git a/services/libs/aster-std/src/syscall/sigaltstack.rs b/services/libs/aster-std/src/syscall/sigaltstack.rs\n--- a/services/libs/aster-std/src/syscall/sigaltstack.rs\n+++ b/services/libs/aster-std/src/syscall/sigaltstack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/socket.rs b/services/libs/aster-std/src/syscall/socket.rs\n--- a/services/libs/aster-std/src/syscall/socket.rs\n+++ b/services/libs/aster-std/src/syscall/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_handle::FileLike;\n use crate::net::socket::ip::{DatagramSocket, StreamSocket};\n use crate::net::socket::unix::UnixStreamSocket;\ndiff --git a/services/libs/aster-std/src/syscall/socketpair.rs b/services/libs/aster-std/src/syscall/socketpair.rs\n--- a/services/libs/aster-std/src/syscall/socketpair.rs\n+++ b/services/libs/aster-std/src/syscall/socketpair.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::net::socket::unix::UnixStreamSocket;\n use crate::util::net::{CSocketAddrFamily, Protocol, SockFlags, SockType, SOCK_TYPE_MASK};\ndiff --git a/services/libs/aster-std/src/syscall/stat.rs b/services/libs/aster-std/src/syscall/stat.rs\n--- a/services/libs/aster-std/src/syscall/stat.rs\n+++ b/services/libs/aster-std/src/syscall/stat.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/statfs.rs b/services/libs/aster-std/src/syscall/statfs.rs\n--- a/services/libs/aster-std/src/syscall/statfs.rs\n+++ b/services/libs/aster-std/src/syscall/statfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::FsPath,\ndiff --git a/services/libs/aster-std/src/syscall/symlink.rs b/services/libs/aster-std/src/syscall/symlink.rs\n--- a/services/libs/aster-std/src/syscall/symlink.rs\n+++ b/services/libs/aster-std/src/syscall/symlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/sync.rs b/services/libs/aster-std/src/syscall/sync.rs\n--- a/services/libs/aster-std/src/syscall/sync.rs\n+++ b/services/libs/aster-std/src/syscall/sync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/tgkill.rs b/services/libs/aster-std/src/syscall/tgkill.rs\n--- a/services/libs/aster-std/src/syscall/tgkill.rs\n+++ b/services/libs/aster-std/src/syscall/tgkill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/time.rs b/services/libs/aster-std/src/syscall/time.rs\n--- a/services/libs/aster-std/src/syscall/time.rs\n+++ b/services/libs/aster-std/src/syscall/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::time::SystemTime;\ndiff --git a/services/libs/aster-std/src/syscall/umask.rs b/services/libs/aster-std/src/syscall/umask.rs\n--- a/services/libs/aster-std/src/syscall/umask.rs\n+++ b/services/libs/aster-std/src/syscall/umask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_UMASK;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/uname.rs b/services/libs/aster-std/src/syscall/uname.rs\n--- a/services/libs/aster-std/src/syscall/uname.rs\n+++ b/services/libs/aster-std/src/syscall/uname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_UNAME;\ndiff --git a/services/libs/aster-std/src/syscall/unlink.rs b/services/libs/aster-std/src/syscall/unlink.rs\n--- a/services/libs/aster-std/src/syscall/unlink.rs\n+++ b/services/libs/aster-std/src/syscall/unlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/utimens.rs b/services/libs/aster-std/src/syscall/utimens.rs\n--- a/services/libs/aster-std/src/syscall/utimens.rs\n+++ b/services/libs/aster-std/src/syscall/utimens.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, fs_resolver::FsPath};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/wait4.rs b/services/libs/aster-std/src/syscall/wait4.rs\n--- a/services/libs/aster-std/src/syscall/wait4.rs\n+++ b/services/libs/aster-std/src/syscall/wait4.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     process::{wait_child_exit, ProcessFilter},\ndiff --git a/services/libs/aster-std/src/syscall/waitid.rs b/services/libs/aster-std/src/syscall/waitid.rs\n--- a/services/libs/aster-std/src/syscall/waitid.rs\n+++ b/services/libs/aster-std/src/syscall/waitid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{wait_child_exit, ProcessFilter};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/write.rs b/services/libs/aster-std/src/syscall/write.rs\n--- a/services/libs/aster-std/src/syscall/write.rs\n+++ b/services/libs/aster-std/src/syscall/write.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/writev.rs b/services/libs/aster-std/src/syscall/writev.rs\n--- a/services/libs/aster-std/src/syscall/writev.rs\n+++ b/services/libs/aster-std/src/syscall/writev.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\n--- a/services/libs/aster-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\ndiff --git a/services/libs/aster-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\n--- a/services/libs/aster-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::CpuSet;\n use aster_frame::task::{Priority, TaskOptions};\n \ndiff --git a/services/libs/aster-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\n--- a/services/libs/aster-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Posix thread implementation\n \n use core::{\ndiff --git a/services/libs/aster-std/src/thread/status.rs b/services/libs/aster-std/src/thread/status.rs\n--- a/services/libs/aster-std/src/thread/status.rs\n+++ b/services/libs/aster-std/src/thread/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[derive(Debug, PartialEq, Clone, Copy)]\n pub enum ThreadStatus {\n     Init,\ndiff --git a/services/libs/aster-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\n--- a/services/libs/aster-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\ndiff --git a/services/libs/aster-std/src/thread/thread_table.rs b/services/libs/aster-std/src/thread/thread_table.rs\n--- a/services/libs/aster-std/src/thread/thread_table.rs\n+++ b/services/libs/aster-std/src/thread/thread_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Thread, Tid};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/aster-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use spin::Once;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n--- a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Weak;\n \n use super::worker_pool::{WorkerPool, WorkerScheduler};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n--- a/services/libs/aster-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\n--- a/services/libs/aster-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n--- a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\ndiff --git a/services/libs/aster-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\n--- a/services/libs/aster-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/aster-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n use time::{Date, Month, PrimitiveDateTime, Time};\ndiff --git a/services/libs/aster-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\n--- a/services/libs/aster-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n pub mod net;\ndiff --git a/services/libs/aster-std/src/util/net/addr.rs b/services/libs/aster-std/src/util/net/addr.rs\n--- a/services/libs/aster-std/src/util/net/addr.rs\n+++ b/services/libs/aster-std/src/util/net/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::Ipv4Address;\n use crate::net::socket::unix::UnixSocketAddr;\n use crate::net::socket::SocketAddr;\ndiff --git a/services/libs/aster-std/src/util/net/mod.rs b/services/libs/aster-std/src/util/net/mod.rs\n--- a/services/libs/aster-std/src/util/net/mod.rs\n+++ b/services/libs/aster-std/src/util/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod options;\n mod socket;\ndiff --git a/services/libs/aster-std/src/util/net/options/mod.rs b/services/libs/aster-std/src/util/net/options/mod.rs\n--- a/services/libs/aster-std/src/util/net/options/mod.rs\n+++ b/services/libs/aster-std/src/util/net/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module introduces utilities to support Linux get/setsockopt syscalls.\n //!\n //! These two syscalls are used to get/set options for a socket. These options can be at different\ndiff --git a/services/libs/aster-std/src/util/net/options/socket.rs b/services/libs/aster-std/src/util/net/options/socket.rs\n--- a/services/libs/aster-std/src/util/net/options/socket.rs\n+++ b/services/libs/aster-std/src/util/net/options/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::net::socket::options::{\n     Error, Linger, RecvBuf, ReuseAddr, ReusePort, SendBuf, SocketOption,\ndiff --git a/services/libs/aster-std/src/util/net/options/tcp.rs b/services/libs/aster-std/src/util/net/options/tcp.rs\n--- a/services/libs/aster-std/src/util/net/options/tcp.rs\n+++ b/services/libs/aster-std/src/util/net/options/tcp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::impl_raw_socket_option;\n use crate::net::socket::ip::stream::options::{Congestion, MaxSegment, NoDelay, WindowClamp};\ndiff --git a/services/libs/aster-std/src/util/net/options/utils.rs b/services/libs/aster-std/src/util/net/options/utils.rs\n--- a/services/libs/aster-std/src/util/net/options/utils.rs\n+++ b/services/libs/aster-std/src/util/net/options/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::socket::ip::stream::CongestionControl;\n use crate::net::socket::LingerOption;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/util/net/socket.rs b/services/libs/aster-std/src/util/net/socket.rs\n--- a/services/libs/aster-std/src/util/net/socket.rs\n+++ b/services/libs/aster-std/src/util/net/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Standard well-defined IP protocols.\ndiff --git a/services/libs/aster-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/aster-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Virtual Dynamic Shared Object (VDSO) module enables user space applications to access kernel space routines\n //! without the need for context switching. This is particularly useful for frequently invoked operations such as\n //! obtaining the current time, which can be more efficiently handled within the user space.\ndiff --git a/services/libs/aster-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\n--- a/services/libs/aster-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n //!\n //! There are two primary VM abstractions:\ndiff --git a/services/libs/aster-std/src/vm/page_fault_handler.rs b/services/libs/aster-std/src/vm/page_fault_handler.rs\n--- a/services/libs/aster-std/src/vm/page_fault_handler.rs\n+++ b/services/libs/aster-std/src/vm/page_fault_handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This trait is implemented by structs which can handle a user space page fault.\ndiff --git a/services/libs/aster-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\n--- a/services/libs/aster-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::VmPerm;\n use aster_rights::Rights;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::{Vaddr, VmIo};\n use aster_rights::Rights;\n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\n--- a/services/libs/aster-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Address Regions (VMARs).\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/aster-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating child VMARs.\n \n use aster_frame::config::PAGE_SIZE;\ndiff --git a/services/libs/aster-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/aster-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::Mutex;\n use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\ndiff --git a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/aster-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Objects (VMOs).\n \n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/aster-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating root and child VMOs.\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/aster-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\n--- a/services/libs/aster-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmFrame;\n \ndiff --git a/services/libs/aster-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/aster-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-util/src/coeff.rs b/services/libs/aster-util/src/coeff.rs\n--- a/services/libs/aster-util/src/coeff.rs\n+++ b/services/libs/aster-util/src/coeff.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides an abstraction `Coeff` to server for efficient and accurate calculation\n //! of fraction multiplication.\n \ndiff --git a/services/libs/aster-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\n--- a/services/libs/aster-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// This trait is a _fallible_ version of `Clone`.\n ///\n /// If any object of a type `T` is duplicable, then `T` should implement\ndiff --git a/services/libs/aster-util/src/id_allocator.rs b/services/libs/aster-util/src/id_allocator.rs\n--- a/services/libs/aster-util/src/id_allocator.rs\n+++ b/services/libs/aster-util/src/id_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n use core::fmt::Debug;\n \ndiff --git a/services/libs/aster-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\n--- a/services/libs/aster-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/aster-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::Paddr;\n use aster_frame::vm::{HasPaddr, VmIo};\n use aster_frame::Result;\ndiff --git a/services/libs/aster-util/src/slot_vec.rs b/services/libs/aster-util/src/slot_vec.rs\n--- a/services/libs/aster-util/src/slot_vec.rs\n+++ b/services/libs/aster-util/src/slot_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n /// SlotVec is the variant of Vector.\ndiff --git a/services/libs/aster-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\n--- a/services/libs/aster-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n use pod::Pod;\ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n--- a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n use std::collections::{BTreeMap, HashSet};\n use std::{env, fs, io, path::PathBuf};\n \ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n--- a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n #![feature(rustc_private)]\n \n extern crate rustc_ast;\ndiff --git a/services/libs/comp-sys/cargo-component/build.rs b/services/libs/comp-sys/cargo-component/build.rs\n--- a/services/libs/comp-sys/cargo-component/build.rs\n+++ b/services/libs/comp-sys/cargo-component/build.rs\n@@ -1,4 +1,7 @@\n-//! This implementation is from rust-clippy\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n fn main() {\n     // Forward the profile to the main compilation\ndiff --git a/services/libs/comp-sys/cargo-component/src/driver.rs b/services/libs/comp-sys/cargo-component/src/driver.rs\n--- a/services/libs/comp-sys/cargo-component/src/driver.rs\n+++ b/services/libs/comp-sys/cargo-component/src/driver.rs\n@@ -1,7 +1,8 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n-//! This implementation is from rust clippy. We modified the code.\n #![feature(rustc_private)]\n #![feature(once_cell)]\n \ndiff --git a/services/libs/comp-sys/cargo-component/src/main.rs b/services/libs/comp-sys/cargo-component/src/main.rs\n--- a/services/libs/comp-sys/cargo-component/src/main.rs\n+++ b/services/libs/comp-sys/cargo-component/src/main.rs\n@@ -1,7 +1,7 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n \n-//! This implementation is from rust clippy. We modified the code.\n+// This implementation is from rust clippy. We modified the code.\n \n use std::env;\n use std::path::PathBuf;\ndiff --git a/services/libs/comp-sys/component-macro/src/init_comp.rs b/services/libs/comp-sys/component-macro/src/init_comp.rs\n--- a/services/libs/comp-sys/component-macro/src/init_comp.rs\n+++ b/services/libs/comp-sys/component-macro/src/init_comp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{TokenStream, TokenTree};\n use quote::{ToTokens, TokenStreamExt};\n use syn::parse::Parse;\ndiff --git a/services/libs/comp-sys/component-macro/src/lib.rs b/services/libs/comp-sys/component-macro/src/lib.rs\n--- a/services/libs/comp-sys/component-macro/src/lib.rs\n+++ b/services/libs/comp-sys/component-macro/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the component system related macros.\n //!\n \ndiff --git a/services/libs/comp-sys/component-macro/src/priority.rs b/services/libs/comp-sys/component-macro/src/priority.rs\n--- a/services/libs/comp-sys/component-macro/src/priority.rs\n+++ b/services/libs/comp-sys/component-macro/src/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{collections::HashMap, fs::File, io::Read, ops::Add, process::Command, str::FromStr};\n \n use json::JsonValue;\ndiff --git a/services/libs/comp-sys/component/src/lib.rs b/services/libs/comp-sys/component/src/lib.rs\n--- a/services/libs/comp-sys/component/src/lib.rs\n+++ b/services/libs/comp-sys/component/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Component system\n //!\n \ndiff --git a/services/libs/comp-sys/controlled/src/lib.rs b/services/libs/comp-sys/controlled/src/lib.rs\n--- a/services/libs/comp-sys/controlled/src/lib.rs\n+++ b/services/libs/comp-sys/controlled/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate defines two attribute macros `controlled` and `uncontrolled`.\n //! This two macros are attached to functions or static variables to enable crate level access control.\n //! To use these two macros, a crate must at first registers a tool named `component_access_control`,\ndiff --git a/services/libs/cpio-decoder/src/error.rs b/services/libs/cpio-decoder/src/error.rs\n--- a/services/libs/cpio-decoder/src/error.rs\n+++ b/services/libs/cpio-decoder/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub type Result<T> = core::result::Result<T, self::Error>;\n \n /// Errors of CPIO decoder.\ndiff --git a/services/libs/cpio-decoder/src/lib.rs b/services/libs/cpio-decoder/src/lib.rs\n--- a/services/libs/cpio-decoder/src/lib.rs\n+++ b/services/libs/cpio-decoder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust CPIO (the newc format) decoder.\n //!\n //! # Example\ndiff --git a/services/libs/int-to-c-enum/derive/src/lib.rs b/services/libs/int-to-c-enum/derive/src/lib.rs\n--- a/services/libs/int-to-c-enum/derive/src/lib.rs\n+++ b/services/libs/int-to-c-enum/derive/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote, TokenStreamExt};\n use syn::{parse_macro_input, Attribute, Data, DataEnum, DeriveInput, Generics};\ndiff --git a/services/libs/int-to-c-enum/src/lib.rs b/services/libs/int-to-c-enum/src/lib.rs\n--- a/services/libs/int-to-c-enum/src/lib.rs\n+++ b/services/libs/int-to-c-enum/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate provides a derive macro named TryFromInt. This macro can be used to automatically implement TryFrom trait\n //! for [C-like enums](https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum/c_like.html).\n //!\ndiff --git a/services/libs/keyable-arc/src/lib.rs b/services/libs/keyable-arc/src/lib.rs\n--- a/services/libs/keyable-arc/src/lib.rs\n+++ b/services/libs/keyable-arc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Same as the standard `Arc`, except that it can be used as the key type of a hash table.\n //!\n //! # Motivation\ndiff --git a/services/libs/typeflags-util/src/assert.rs b/services/libs/typeflags-util/src/assert.rs\n--- a/services/libs/typeflags-util/src/assert.rs\n+++ b/services/libs/typeflags-util/src/assert.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! define macro assert_type_same\n \n use crate::same::SameAs;\ndiff --git a/services/libs/typeflags-util/src/bool.rs b/services/libs/typeflags-util/src/bool.rs\n--- a/services/libs/typeflags-util/src/bool.rs\n+++ b/services/libs/typeflags-util/src/bool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type level bools\n \n pub use core::ops::BitAnd as And;\ndiff --git a/services/libs/typeflags-util/src/extend.rs b/services/libs/typeflags-util/src/extend.rs\n--- a/services/libs/typeflags-util/src/extend.rs\n+++ b/services/libs/typeflags-util/src/extend.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{Cons, Nil};\n \n /// This trait will extend a set with another item.\ndiff --git a/services/libs/typeflags-util/src/if_.rs b/services/libs/typeflags-util/src/if_.rs\n--- a/services/libs/typeflags-util/src/if_.rs\n+++ b/services/libs/typeflags-util/src/if_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type Level If\n \n use crate::bool::{False, True};\ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\ndiff --git a/services/libs/typeflags-util/src/same.rs b/services/libs/typeflags-util/src/same.rs\n--- a/services/libs/typeflags-util/src/same.rs\n+++ b/services/libs/typeflags-util/src/same.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Traits used to check if two types are the same, returning a Bool.\n //! This check happens at compile time\n \ndiff --git a/services/libs/typeflags-util/src/set.rs b/services/libs/typeflags-util/src/set.rs\n--- a/services/libs/typeflags-util/src/set.rs\n+++ b/services/libs/typeflags-util/src/set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Common types and traits to deal with type-level sets\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/typeflags/src/flag_set.rs b/services/libs/typeflags/src/flag_set.rs\n--- a/services/libs/typeflags/src/flag_set.rs\n+++ b/services/libs/typeflags/src/flag_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use itertools::Itertools;\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\ndiff --git a/services/libs/typeflags/src/type_flag.rs b/services/libs/typeflags/src/type_flag.rs\n--- a/services/libs/typeflags/src/type_flag.rs\n+++ b/services/libs/typeflags/src/type_flag.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::TokenStream;\n use quote::quote;\n use syn::{\ndiff --git a/services/libs/typeflags/src/util.rs b/services/libs/typeflags/src/util.rs\n--- a/services/libs/typeflags/src/util.rs\n+++ b/services/libs/typeflags/src/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\n \ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n # This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n FROM ubuntu:22.04 as build-base\n \n SHELL [\"/bin/bash\", \"-c\"]\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n",
        "test_patch": "diff --git /dev/null b/.github/workflows/license_check.yml\nnew file mode 100644\n--- /dev/null\n+++ b/.github/workflows/license_check.yml\n@@ -0,0 +1,14 @@\n+name: Check License\n+on:\n+  pull_request:\n+  push:\n+    branches: \n+      - main\n+jobs:\n+  check-license-lines:\n+    runs-on: ubuntu-latest\n+    steps:\n+    - uses: actions/checkout@master\n+    - name: Check License\n+      # Check license lines of each file in this repository.\n+      uses: apache/skywalking-eyes@v0.5.0\ndiff --git /dev/null b/.licenserc.yaml\nnew file mode 100644\n--- /dev/null\n+++ b/.licenserc.yaml\n@@ -0,0 +1,61 @@\n+# This is the configuration file for github action License Eye Header. The action is used \n+# to check that each source file contains the license header lines. For the configuration \n+# details, see https://github.com/marketplace/actions/license-eye-header#configurations.\n+\n+header:\n+  # Files are licensed under MPL-2.0, by default.\n+  - paths: \n+      - '**/*.rs'\n+      - '**/*.S'\n+      - '**/*.s'\n+      - '**/*.c'\n+      - '**/*.sh'\n+      - '**/Makefile'\n+      - '**/Dockerfile.*'\n+    paths-ignore:\n+      # These directories are licensed under licenses other than MPL-2.0.\n+      - 'services/libs/comp-sys/cargo-component'\n+      - 'framework/libs/tdx-guest'\n+    license:\n+      content: |\n+        SPDX-License-Identifier: MPL-2.0\n+    language: \n+      # License Eye Header cannot recognize files with extension .S, so we add\n+      # the definition here.\n+      Assembly: \n+        extensions:\n+          - \".S\"\n+        comment_style_id: SlashAsterisk\n+\n+  # Files under tdx-guest are licensed under BSD-3-Clause license.\n+  - paths: \n+      - 'framework/libs/tdx-guest/**'\n+    paths-ignore:\n+      - 'Cargo.toml'\n+      - '.gitignore'\n+    license:\n+      content: |\n+        SPDX-License-Identifier: BSD-3-Clause\n+        Copyright(c) 2023-2024 Intel Corporation.\n+\n+  # Files under cargo-component are licensed under Apache-2.0 or MIT license.\n+  - paths:\n+      - 'services/libs/comp-sys/cargo-component/**'\n+    paths-ignore:\n+      - '**/*.md'\n+      - '**/*.toml'\n+      - 'Cargo.lock'\n+      - '.gitignore'\n+      # These directories do not contain test source code and are just for test input.\n+      - '**/tests/duplicate_lib_name_test/**'\n+      - '**/tests/missing_toml_test/**'\n+      - '**/tests/reexport_test/**'\n+      - '**/tests/regression_test/**'\n+      - '**/tests/trait_method_test/**'\n+      - '**/tests/violate_policy_test/**'\n+      \n+    license:\n+      content: |\n+        Licensed under the Apache License, Version 2.0 or the MIT License.\n+        Copyright (C) 2023-2024 Ant Group.\n+  \n\\ No newline at end of file\ndiff --git a/framework/libs/align_ext/src/lib.rs b/framework/libs/align_ext/src/lib.rs\n--- a/framework/libs/align_ext/src/lib.rs\n+++ b/framework/libs/align_ext/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![cfg_attr(not(test), no_std)]\n \n /// An extension trait for Rust integer types, including `u8`, `u16`, `u32`,\ndiff --git a/framework/libs/ktest-proc-macro/src/lib.rs b/framework/libs/ktest-proc-macro/src/lib.rs\n--- a/framework/libs/ktest-proc-macro/src/lib.rs\n+++ b/framework/libs/ktest-proc-macro/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![feature(proc_macro_span)]\n \n extern crate proc_macro2;\ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! # The kernel mode testing framework of Asterinas.\n //!\n //! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\ndiff --git a/framework/libs/ktest/src/path.rs b/framework/libs/ktest/src/path.rs\n--- a/framework/libs/ktest/src/path.rs\n+++ b/framework/libs/ktest/src/path.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{\n     collections::{vec_deque, BTreeMap, VecDeque},\n     string::{String, ToString},\ndiff --git a/framework/libs/ktest/src/runner.rs b/framework/libs/ktest/src/runner.rs\n--- a/framework/libs/ktest/src/runner.rs\n+++ b/framework/libs/ktest/src/runner.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Test runner enabling control over the tests.\n //!\n \ndiff --git a/framework/libs/ktest/src/tree.rs b/framework/libs/ktest/src/tree.rs\n--- a/framework/libs/ktest/src/tree.rs\n+++ b/framework/libs/ktest/src/tree.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The source module tree of ktests.\n //!\n //! In the `KtestTree`, the root is abstract, and the children of the root are the\ndiff --git a/regression/apps/execve/Makefile b/regression/apps/execve/Makefile\n--- a/regression/apps/execve/Makefile\n+++ b/regression/apps/execve/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/regression/apps/fork/Makefile b/regression/apps/fork/Makefile\n--- a/regression/apps/fork/Makefile\n+++ b/regression/apps/fork/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -nostdlib\ndiff --git a/regression/apps/fork_c/Makefile b/regression/apps/fork_c/Makefile\n--- a/regression/apps/fork_c/Makefile\n+++ b/regression/apps/fork_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/regression/apps/hello_c/Makefile b/regression/apps/hello_c/Makefile\n--- a/regression/apps/hello_c/Makefile\n+++ b/regression/apps/hello_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -mno-sse\ndiff --git a/regression/apps/hello_pie/Makefile b/regression/apps/hello_pie/Makefile\n--- a/regression/apps/hello_pie/Makefile\n+++ b/regression/apps/hello_pie/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/hello_world/Makefile b/regression/apps/hello_world/Makefile\n--- a/regression/apps/hello_world/Makefile\n+++ b/regression/apps/hello_world/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -nostdlib\ndiff --git a/regression/apps/network/Makefile b/regression/apps/network/Makefile\n--- a/regression/apps/network/Makefile\n+++ b/regression/apps/network/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/pthread/Makefile b/regression/apps/pthread/Makefile\n--- a/regression/apps/pthread/Makefile\n+++ b/regression/apps/pthread/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -lpthread\ndiff --git a/regression/apps/pthread/pthread_test.c b/regression/apps/pthread/pthread_test.c\n--- a/regression/apps/pthread/pthread_test.c\n+++ b/regression/apps/pthread/pthread_test.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n // This test file is from occlum pthread test.\n \n #include <sys/types.h>\ndiff --git a/regression/apps/pty/Makefile b/regression/apps/pty/Makefile\n--- a/regression/apps/pty/Makefile\n+++ b/regression/apps/pty/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/scripts/run_regression_test.sh b/regression/apps/scripts/run_regression_test.sh\n--- a/regression/apps/scripts/run_regression_test.sh\n+++ b/regression/apps/scripts/run_regression_test.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=/regression\ndiff --git a/regression/apps/signal_c/Makefile b/regression/apps/signal_c/Makefile\n--- a/regression/apps/signal_c/Makefile\n+++ b/regression/apps/signal_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/regression/apps/signal_c/signal_test.c b/regression/apps/signal_c/signal_test.c\n--- a/regression/apps/signal_c/signal_test.c\n+++ b/regression/apps/signal_c/signal_test.c\n@@ -1,4 +1,6 @@\n-// This test file is from occlum, to test whether we implement signal correctly.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+// This test file is from occlum signal test.\n \n #define _GNU_SOURCE\n #include <sys/types.h>\ndiff --git a/regression/apps/test_common.mk b/regression/apps/test_common.mk\n--- a/regression/apps/test_common.mk\n+++ b/regression/apps/test_common.mk\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MAIN_MAKEFILE := $(firstword $(MAKEFILE_LIST))\n INCLUDE_MAKEFILE := $(lastword $(MAKEFILE_LIST))\n CUR_DIR := $(shell dirname $(realpath $(MAIN_MAKEFILE)))\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n TESTS ?= chmod_test fsync_test getdents_test link_test lseek_test mkdir_test \\\n \t\topen_create_test open_test pty_test read_test rename_test stat_test \\\n \t\tstatfs_test symlink_test sync_test uidgid_test unlink_test \\\ndiff --git a/regression/syscall_test/run_syscall_test.sh b/regression/syscall_test/run_syscall_test.sh\n--- a/regression/syscall_test/run_syscall_test.sh\n+++ b/regression/syscall_test/run_syscall_test.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n SCRIPT_DIR=$(dirname \"$0\")\n TEST_TMP_DIR=${SYSCALL_TEST_DIR:-/tmp}\n TEST_BIN_DIR=$SCRIPT_DIR/tests\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! aster-runner is the Asterinas runner script to ease the pain of running\n //! and testing Asterinas inside a QEMU VM. It should be built and run as the\n //! cargo runner: https://doc.rust-lang.org/cargo/reference/config.html\ndiff --git a/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\n--- a/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if two components have same name, the compiler will panic.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/missing_toml.rs b/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\n--- a/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if Components.toml is missed, the compiler will panic.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/reexport.rs b/services/libs/comp-sys/cargo-component/tests/reexport.rs\n--- a/services/libs/comp-sys/cargo-component/tests/reexport.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/reexport.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if cargo-component can control reexported entry points.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/regression.rs b/services/libs/comp-sys/cargo-component/tests/regression.rs\n--- a/services/libs/comp-sys/cargo-component/tests/regression.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/regression.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that visiting controlled resources in whitelist is allowed.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs b/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\n--- a/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n #![allow(unused)]\n \n use std::path::PathBuf;\ndiff --git a/services/libs/comp-sys/cargo-component/tests/trait_method.rs b/services/libs/comp-sys/cargo-component/tests/trait_method.rs\n--- a/services/libs/comp-sys/cargo-component/tests/trait_method.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/trait_method.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if cargo-component can control method and trait method\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/violate_policy.rs b/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\n--- a/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\n@@ -1,4 +1,8 @@\n-//! This test checks that if controlled resource not in whitelist is visited, cargo-component will report warning message.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+//! This test checks that if controlled resource not in whitelist is visited, cargo-component will \n+//! report warning message.\n \n #![feature(once_cell)]\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\n--- a/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::Relaxed;\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\n--- a/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::{Ordering::Relaxed, AtomicBool};\n \n use component::init_component;\ndiff --git a/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\n--- a/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use second_init::HAS_INIT;\n use std::sync::atomic::Ordering::Relaxed;\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/src/main.rs b/services/libs/comp-sys/component/tests/init-order/src/main.rs\n--- a/services/libs/comp-sys/component/tests/init-order/src/main.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::{Ordering::Relaxed, AtomicBool};\n \n use component::init_component;\ndiff --git a/services/libs/comp-sys/component/tests/init-order/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/tests/test.rs\n--- a/services/libs/comp-sys/component/tests/init-order/tests/test.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/tests/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use first_init::HAS_INIT;\n use component::init_component;\n use std::sync::atomic::Ordering::Relaxed;\ndiff --git a/services/libs/cpio-decoder/src/test.rs b/services/libs/cpio-decoder/src/test.rs\n--- a/services/libs/cpio-decoder/src/test.rs\n+++ b/services/libs/cpio-decoder/src/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::error::*;\n use super::{CpioDecoder, FileType};\n use lending_iterator::LendingIterator;\ndiff --git a/services/libs/int-to-c-enum/tests/regression.rs b/services/libs/int-to-c-enum/tests/regression.rs\n--- a/services/libs/int-to-c-enum/tests/regression.rs\n+++ b/services/libs/int-to-c-enum/tests/regression.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use int_to_c_enum::TryFromInt;\n \n #[derive(TryFromInt, Debug, PartialEq, Eq)]\n",
        "problem_statement": "Add copyright and license info to the header of every file\nNeed to insert the copyright header to every source code file.\r\n\r\nHere is the header for each Rust file.\r\n\r\n```rust\r\n// SPDX-License-Identifier: MPL-2.0\r\n```\n",
        "hints_text": "As a side note, the MPL license is unfortunately hard-coded to allow implicit upgrades when the Mozilla Foundation releases a new license version. Not sure if we like that or not (or at least accept it).\r\n\r\n> 10.2. Effect of New Versions\r\n> \r\n> You may distribute the Covered Software under the terms of the version\r\n> of the License under which You originally received the Covered Software,\r\n> or under the terms of any subsequent version published by the license\r\n> steward.\r\n\r\nA similar statement in GPL-2.0 instead offers two choices, i.e., `GPL-2.0-only` or `GPL-2.0-or-later`.\r\n> 9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\r\n> Each version is given a distinguishing version number. *If the Program specifies a version number of this License which applies to it and \"any later version\",* you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\r\n\r\nLinux uses `GPL-2.0-only` because there are some problems with GPL-3.0, or at least Linus Torvalds does not like GPL-3.0.",
        "created_at": "2024-01-03T06:45:56Z",
        "version": "0.3"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 561,
        "instance_id": "asterinas__asterinas-561",
        "issue_numbers": [
            "551"
        ],
        "base_commit": "6dbf5d560deafea0dcec228e4cb2d5e53c756174",
        "patch": "diff --git a/.cargo/config.toml b/.cargo/config.toml\n--- a/.cargo/config.toml\n+++ b/.cargo/config.toml\n@@ -1,6 +1,6 @@\n \n [target.'cfg(target_os = \"none\")']\n-runner = \"cargo run --package jinux-runner --\"\n+runner = \"cargo run --package aster-runner --\"\n \n [alias]\n kcheck = \"check --target x86_64-custom.json -Zbuild-std=core,alloc,compiler_builtins -Zbuild-std-features=compiler-builtins-mem\"\ndiff --git a/.github/workflows/docker_build.yml b/.github/workflows/docker_build.yml\n--- a/.github/workflows/docker_build.yml\n+++ b/.github/workflows/docker_build.yml\n@@ -26,7 +26,7 @@ jobs:\n       - name: Fetch versions in the repo\n         id: fetch-versions\n         run: |\n-          echo \"jinux_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n+          echo \"aster_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n           echo \"rust_version=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' rust-toolchain.toml )\" >> \"$GITHUB_OUTPUT\"\n \n       - name: Build and push\ndiff --git a/.github/workflows/docker_build.yml b/.github/workflows/docker_build.yml\n--- a/.github/workflows/docker_build.yml\n+++ b/.github/workflows/docker_build.yml\n@@ -36,6 +36,6 @@ jobs:\n           file: ./tools/docker/Dockerfile.ubuntu22.04\n           platforms: linux/amd64\n           push: true\n-          tags: jinuxdev/jinux:${{ steps.fetch-versions.outputs.jinux_version }}\n+          tags: asterinas/asterinas:${{ steps.fetch-versions.outputs.aster_version }}\n           build-args: |\n-            \"JINUX_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\n+            \"ASTER_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\ndiff --git a/COPYRIGHT b/COPYRIGHT\n--- a/COPYRIGHT\n+++ b/COPYRIGHT\n@@ -1,9 +1,9 @@\n-The Jinux project licensed under the GNU General Public License version 2.\n+The Asterinas project licensed under the GNU General Public License version 2.\n \n-Copyrights in the Jinux project are retained by their contributors. No\n-copyright assignment is required to contribute to the Jinux project.\n+Copyrights in the Asterinas project are retained by their contributors. No\n+copyright assignment is required to contribute to the Asterinas project.\n For full authorship information, see the version control history.\n \n-Please note that certain files or directories within the Jinux project may \n+Please note that certain files or directories within the Asterinas project may \n contain explicit copyright notices and/or license notices differ\n from the project's general license terms.\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -552,7 +796,7 @@ dependencies = [\n [[package]]\n name = \"inherit-methods-macro\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n+source = \"git+https://github.com/asterinas/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n dependencies = [\n  \"darling\",\n  \"proc-macro2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -918,7 +918,7 @@ checksum = \"b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3\"\n [[package]]\n name = \"libflate\"\n version = \"1.4.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"adler32\",\n  \"core2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -929,7 +929,7 @@ dependencies = [\n [[package]]\n name = \"libflate_lz77\"\n version = \"1.2.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"core2\",\n  \"hashbrown 0.13.2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1059,7 +1059,7 @@ checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n [[package]]\n name = \"pod\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"pod-derive\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1067,7 +1067,7 @@ dependencies = [\n [[package]]\n name = \"pod-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1428,7 +1428,7 @@ dependencies = [\n [[package]]\n name = \"trapframe\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/jinzhao-dev/trapframe-rs?rev=9758a83#9758a83f769c8f4df35413c7ad28ef42c270187e\"\n+source = \"git+https://github.com/asterinas/trapframe-rs?rev=2f37590#2f375901398508edb554deb2f84749153a59bb4a\"\n dependencies = [\n  \"log\",\n  \"pod\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,21 +1,21 @@\n [package]\n-name = \"jinux\"\n+name = \"asterinas\"\n version = \"0.2.2\"\n edition = \"2021\"\n \n [[bin]]\n-name = \"jinux\"\n+name = \"asterinas\"\n path = \"kernel/main.rs\"\n \n [dependencies]\n-jinux-frame = { path = \"framework/jinux-frame\" }\n-jinux-std = { path = \"services/libs/jinux-std\" }\n+aster-frame = { path = \"framework/aster-frame\" }\n+aster-std = { path = \"services/libs/aster-std\" }\n component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\n-jinux-time = { path = \"services/comps/time\" }\n-jinux-framebuffer = { path = \"services/comps/framebuffer\" }\n+aster-time = { path = \"services/comps/time\" }\n+aster-framebuffer = { path = \"services/comps/framebuffer\" }\n \n [profile.dev]\n opt-level = 0\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -48,10 +48,10 @@ members = [\n     \"services/libs/cpio-decoder\",\n     \"services/libs/int-to-c-enum\",\n     \"services/libs/int-to-c-enum/derive\",\n-    \"services/libs/jinux-rights\",\n-    \"services/libs/jinux-rights-proc\",\n-    \"services/libs/jinux-std\",\n-    \"services/libs/jinux-util\",\n+    \"services/libs/aster-rights\",\n+    \"services/libs/aster-rights-proc\",\n+    \"services/libs/aster-std\",\n+    \"services/libs/aster-util\",\n     \"services/libs/keyable-arc\",\n     \"services/libs/typeflags\",\n     \"services/libs/typeflags-util\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -65,4 +65,4 @@ exclude = [\n ]\n \n [features]\n-intel_tdx = [\"jinux-frame/intel_tdx\", \"jinux-std/intel_tdx\"]\n+intel_tdx = [\"aster-frame/intel_tdx\", \"aster-std/intel_tdx\"]\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -1,14 +1,14 @@\n # template\n [components]\n-std = { name = \"jinux-std\" }\n-virtio = { name = \"jinux-virtio\" }\n-input = { name = \"jinux-input\" }\n-block = { name = \"jinux-block\" }\n-console = { name = \"jinux-console\" }\n-time = { name = \"jinux-time\" }\n-framebuffer = { name = \"jinux-framebuffer\" }\n-network = { name = \"jinux-network\" }\n-main = { name = \"jinux\" }\n+std = { name = \"aster-std\" }\n+virtio = { name = \"aster-virtio\" }\n+input = { name = \"aster-input\" }\n+block = { name = \"aster-block\" }\n+console = { name = \"aster-console\" }\n+time = { name = \"aster-time\" }\n+framebuffer = { name = \"aster-framebuffer\" }\n+network = { name = \"aster-network\" }\n+main = { name = \"asterinas\" }\n \n [whitelist]\n [whitelist.std.run_first_process]\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,4 +1,4 @@\n-# Make varaiables and defaults, you should refer to jinux-runner for more details\n+# Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\n BOOT_PROTOCOL ?= multiboot2\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -92,8 +92,8 @@ USERMODE_TESTABLE := \\\n     services/libs/cpio-decoder \\\n     services/libs/int-to-c-enum \\\n     services/libs/int-to-c-enum/derive \\\n-    services/libs/jinux-rights \\\n-    services/libs/jinux-rights-proc \\\n+    services/libs/aster-rights \\\n+    services/libs/aster-rights-proc \\\n     services/libs/keyable-arc \\\n     services/libs/typeflags \\\n     services/libs/typeflags-util\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -231,6 +231,6 @@ Jinux is under active development. The list below summarizes the progress of imp\n \n ## License\n \n-The Jinux project is proudly released as a free software\n+The Asterinas project is proudly released as a free software\n under the license of [GNU General Public License version 2](LICENSE-GPL).\n See [COPYRIGHT](COPYRIGHT) for details.\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -5,7 +5,7 @@ fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n     let linker_script_path = if target == \"x86_64\" {\n         PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap())\n             .join(\"framework\")\n-            .join(\"jinux-frame\")\n+            .join(\"aster-frame\")\n             .join(\"src\")\n             .join(\"arch\")\n             .join(\"x86\")\ndiff --git a/docs/README.md b/docs/README.md\n--- a/docs/README.md\n+++ b/docs/README.md\n@@ -1,4 +1,4 @@\n-# Jinux Documentation\n+# Asterinas Documentation\n \n The documentation is rendered as a book with [mdBook](https://rust-lang.github.io/mdBook/),\n which can be installed with `cargo`.\ndiff --git a/docs/book.toml b/docs/book.toml\n--- a/docs/book.toml\n+++ b/docs/book.toml\n@@ -3,7 +3,7 @@ authors = [\"Tate, Hongliang Tian\"]\n language = \"en\"\n multilingual = false\n src = \"src\"\n-title = \"Jinux: A Secure, Fast, and Modern OS in Rust\"\n+title = \"Asterinas: A Secure, Fast, and Modern OS in Rust\"\n \n [rust]\n edition = \"2021\"\ndiff --git a/docs/src/README.md b/docs/src/README.md\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -14,7 +14,7 @@\n \n # Introduction\n \n-This document describes Jinux, a secure, fast, and modern OS written in Rust.\n+This document describes Asterinas, a secure, fast, and modern OS written in Rust.\n \n As the project is a work in progress, this document is by no means complete.\n Despite the incompleteness, this evolving document serves several important purposes:\ndiff --git a/docs/src/README.md b/docs/src/README.md\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -50,7 +50,7 @@ OSes, e.g., [Kerla](https://github.com/nuta/kerla),\n and [zCore](https://github.com/rcore-os/zCore). Despite their varying degrees of\n success, none of them are general-purpose, industrial-strength OSes that are or\n will ever be competitive with Linux. Eventually, a winner will emerge out of this\n-market of Rust OSes, and Jinux is our bet for this competition.\n+market of Rust OSes, and Asterinas is our bet for this competition.\n \n Second, Rust OSes are a perfect fit for\n [Trusted Execution Environments (TEEs)](https://en.wikipedia.org/wiki/Trusted_execution_environment).\ndiff --git a/docs/src/capabilities/README.md b/docs/src/capabilities/README.md\n--- a/docs/src/capabilities/README.md\n+++ b/docs/src/capabilities/README.md\n@@ -20,12 +20,12 @@ capabilities in a limited fashion, mostly as a means to limit the access from\n external users (e.g., via syscall), rather than a mechanism to enforce advanced\n security policies internally (e.g., module-level isolation).\n \n-So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Jinux to enhance the security and robustness of the\n+So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Asterinas to enhance the security and robustness of the\n OS? Specifically, we propose a new principle called \"_everything is a capability_\".\n Here, \"everything\" refers to any type of OS resource, internal or external alike.\n In traditional OSes, treating everything as a capability is unrewarding \n because (1) capabilities themselves are unreliable due to memory safety problems\n-, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Jinux.\n+, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Asterinas.\n Because the odds of memory safety bugs are minimized and \n advanced Rust features like type-level programming allow us to implement\n capabilities as a zero-cost abstraction.\ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -1,6 +1,6 @@\n # Zero-Cost Capabilities\n \n-To strengthen the security of Jinux, we aim to implement all kinds of OS resources\n+To strengthen the security of Asterinas, we aim to implement all kinds of OS resources\n as capabilities. As the capabilities are going to be used throughout the OS,\n it is highly desirable to minimize their costs. For this purpose,\n we want to implement capabilities as a _zero-cost abstraction_.\ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -376,7 +376,7 @@ typeflags! {\n }\n ```\n \n-The `Jinux-rights-proc/lib.rs` file implements the `require` procedural macro.\n+The `aster-rights-proc/lib.rs` file implements the `require` procedural macro.\n See the channel capability example later for how `require` is used.\n \n ```rust\ndiff --git a/docs/src/privilege_separation/README.md b/docs/src/privilege_separation/README.md\n--- a/docs/src/privilege_separation/README.md\n+++ b/docs/src/privilege_separation/README.md\n@@ -1,15 +1,15 @@\n # Privilege Separation\n \n-One fundamental design goal of Jinux is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Jinux can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n+One fundamental design goal of Asterinas is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Asterinas can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n \n To put privilege separation into perspective, let's compare the architectures\n-of the monolithic kernels, microkernels, and Jinux.\n+of the monolithic kernels, microkernels, and Asterinas.\n \n ![Arch comparison](../images/arch_comparison.png)\n \n The diagram above highlights the characteristics of different OS architectures \n in terms of communication overheads and the TCB for memory safety.\n-Thanks to privilege separation, Jinux promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n+Thanks to privilege separation, Asterinas promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n \n Privilege separation is an interesting research problem, prompting us to \n answer a series of technical questions.\ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -22,7 +22,7 @@ Here are some of the elements in PCI-based Virtio devices that may involve `unsa\n ### Privileged part\n \n ```rust\n-// file: jinux-core-libs/pci-io-port/lib.rs\n+// file: aster-core-libs/pci-io-port/lib.rs\n use x86::IoPort;\n \n /// The I/O port to write an address in the PCI \ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -49,7 +49,7 @@ pub const PCI_DATA_PORT: IoPort<u32> = {\n ### Unprivileged part\n \n ```rust\n-// file: jinux-comps/pci/lib.rs\n+// file: aster-comps/pci/lib.rs\n use pci_io_port::{PCI_ADDR_PORT, PCI_DATA_PORT};\n \n /// The PCI configuration space, which enables the discovery,\ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -128,7 +128,7 @@ pub struct PciCapabilities {\n Most code of Virtio drivers can be unprivileged thanks to the abstractions of `VmPager` and `VmCell` provided by the OS core.\n \n ```rust\n-// file: jinux-comp-libs/virtio/transport.rs\n+// file: aster-comp-libs/virtio/transport.rs\n \n /// The transport layer for configuring a Virtio device.\n pub struct VirtioTransport {\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -138,7 +138,7 @@ impl<T, P: Write> UserPtr<T, P> {\n }\n ```\n \n-The examples reveal two important considerations in designing Jinux:\n+The examples reveal two important considerations in designing Asterinas:\n 1. Exposing _truly_ safe APIs. The privileged OS core must expose _truly safe_ APIs: however buggy or silly the unprivileged OS components may be written, they must _not_ cause undefined behaviors.\n 2. Handling _arbitrary_ pointers safely. The safe API of the OS core must provide a safe way to deal with arbitrary pointers.\n \ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -146,15 +146,15 @@ With the two points in mind, let's get back to our main goal of privilege separa\n \n ## Code organization with privilege separation\n \n-Our first step is to separate privileged and unprivileged code in the codebase of Jinux. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n+Our first step is to separate privileged and unprivileged code in the codebase of Asterinas. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n \n ```text\n .\n-\u251c\u2500\u2500 jinux\n+\u251c\u2500\u2500 asterinas\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core\n+\u251c\u2500\u2500 aster-core\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 lib.rs\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 syscall_handler.rs\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -162,7 +162,7 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502   \u2502       \u251c\u2500\u2500 vmo.rs\n \u2502   \u2502       \u2514\u2500\u2500 vmar.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core-libs\n+\u251c\u2500\u2500 aster-core-libs\n \u2502   \u251c\u2500\u2500 linux-abi-types\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 lib.rs\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -171,34 +171,34 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502      \u00a0\u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-comps\n+\u251c\u2500\u2500 aster-comps\n \u2502 \u00a0 \u2514\u2500\u2500 linux-syscall\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502     \u00a0\u00a0\u2514\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 jinux-comp-libs\n+\u2514\u2500\u2500 aster-comp-libs\n  \u00a0\u00a0 \u2514\u2500\u2500 linux-abi\n         \u251c\u2500\u2500 src\n       \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n      \u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml \n ```\n \n-The ultimate build target of the codebase is the `jinux` crate, which is an OS kernel that consists of a privileged OS core (crate `jinux-core`) and multiple OS components (the crates under `jinux-comps/`).\n+The ultimate build target of the codebase is the `asterinas` crate, which is an OS kernel that consists of a privileged OS core (crate `aster-core`) and multiple OS components (the crates under `aster-comps/`).\n \n-For the sake of privilege separation, only crate `jinux` and `jinux-core` along with the crates under `jinux-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `jinux-comps/` along with their dependent crates under `jinux-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `jinux-core` or the crates under `jinux-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `jinux` and `jinux-core` crate plus the crates under `jinux-core-libs/`.\n+For the sake of privilege separation, only crate `asterinas` and `aster-core` along with the crates under `aster-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `aster-comps/` along with their dependent crates under `aster-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `aster-core` or the crates under `aster-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `asterinas` and `aster-core` crate plus the crates under `aster-core-libs/`.\n \n-Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `jinux-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n+Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `aster-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n \n-## Crate `jinux-core`\n+## Crate `aster-core`\n \n-For our purposes here, the two most relevant APIs provided by `jinux-core` is the abstraction for syscall handlers and virtual memory (VM).\n+For our purposes here, the two most relevant APIs provided by `aster-core` is the abstraction for syscall handlers and virtual memory (VM).\n \n ### Syscall handlers\n \n The `SyscallHandler` abstraction enables the OS core to hide the low-level, architectural-dependent aspects of syscall handling workflow (e.g., user-kernel switching and CPU register manipulation) and allow the unprivileged OS components to implement system calls.\n \n ```rust\n-// file: jinux-core/src/syscall_handler.rs\n+// file: aster-core/src/syscall_handler.rs\n \n pub trait SyscallHandler {\n     fn handle_syscall(&self, ctx: &mut SyscallContext);\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -243,8 +243,8 @@ an important concept that we will elaborate on later. Basically, they are capabi\n Here we demonstrate how to leverage the APIs of `ksos-core` to implement system calls with safe Rust code in crate `linux-syscall`.\n \n ```rust\n-// file: jinux-comps/linux-syscall/src/lib.rs\n-use jinux_core::{SyscallContext, SyscallHandler, Vmar};\n+// file: aster-comps/linux-syscall/src/lib.rs\n+use aster_core::{SyscallContext, SyscallHandler, Vmar};\n use linux_abi::{SyscallNum::*, UserPtr, RawFd, RawTimeVal, RawTimeZone};\n \n pub struct SampleHandler;\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -315,7 +315,7 @@ impl SampleHandler {\n This crate defines a marker trait `Pod`, which represents plain-old data.\n \n ```rust\n-/// file: jinux-core-libs/pod/src/lib.rs\n+/// file: aster-core-libs/pod/src/lib.rs\n \n /// A marker trait for plain old data (POD).\n ///\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -388,7 +388,7 @@ unsafe impl<T: Pod, const N> [T; N] for Pod {}\n ## Crate `linux-abi-type`\n \n ```rust\n-// file: jinux-core-libs/linux-abi-types\n+// file: aster-core-libs/linux-abi-types\n use pod::Pod;\n \n pub type RawFd = i32;\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -404,7 +404,7 @@ unsafe impl Pod for RawTimeVal {}\n ## Crate `linux-abi`\n \n ```rust\n-// file: jinux-comp-libs/linux-abi\n+// file: aster-comp-libs/linux-abi\n pub use linux_abi_types::*;\n \n pub enum SyscallNum {\ndiff --git a/framework/jinux-frame/Cargo.toml b/framework/aster-frame/Cargo.toml\n--- a/framework/jinux-frame/Cargo.toml\n+++ b/framework/aster-frame/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame\"\n+name = \"aster-frame\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/framework/jinux-frame/build.rs b/framework/aster-frame/build.rs\n--- a/framework/jinux-frame/build.rs\n+++ b/framework/aster-frame/build.rs\n@@ -32,7 +32,7 @@ fn build_linux_setup_header(\n \n     let cargo = std::env::var(\"CARGO\").unwrap();\n     let mut cmd = std::process::Command::new(cargo);\n-    cmd.arg(\"install\").arg(\"jinux-frame-x86-boot-linux-setup\");\n+    cmd.arg(\"install\").arg(\"aster-frame-x86-boot-linux-setup\");\n     cmd.arg(\"--debug\");\n     cmd.arg(\"--locked\");\n     cmd.arg(\"--path\").arg(setup_crate_dir.to_str().unwrap());\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n@@ -3,7 +3,7 @@\n //! The bootloader will deliver the address of the `BootParams` struct\n //! as the argument of the kernel entrypoint. So we must define a Linux\n //! ABI compatible struct in Rust, despite that most of the fields are\n-//! currently not needed by Jinux.\n+//! currently not needed by Asterinas.\n //!\n \n #[derive(Copy, Clone, Debug)]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -152,5 +152,5 @@ unsafe extern \"sysv64\" fn __linux64_boot(params_ptr: *const boot_params::BootPar\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame-x86-boot-linux-setup\"\n+name = \"aster-frame-x86-boot-linux-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n@@ -9,8 +9,8 @@\n // Some of the fields filled with a 0xab* values should be filled\n // by the runner, which is the only tool after building and can\n // access the info of the payload.\n-// Jinux will use only a few of these fields, and some of them\n-// are filled by the loader and will be read by Jinux.\n+// Asterinas will use only a few of these fields, and some of them\n+// are filled by the loader and will be read by Asterinas.\n \n CODE32_START = 0x100000\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n@@ -24,6 +24,6 @@ pub fn load_elf(file: &[u8]) -> u32 {\n         }\n     }\n \n-    // Return the Linux 32-bit Boot Protocol entry point defined by Jinux.\n+    // Return the Linux 32-bit Boot Protocol entry point defined by Asterinas.\n     0x8001000\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n@@ -9,7 +9,7 @@ use core::arch::{asm, global_asm};\n \n global_asm!(include_str!(\"header.S\"));\n \n-unsafe fn call_jinux_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n+unsafe fn call_aster_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n     asm!(\"mov esi, {}\", in(reg) boot_params_ptr);\n     asm!(\"mov eax, {}\", in(reg) entrypoint);\n     asm!(\"jmp eax\");\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n@@ -34,7 +34,7 @@ pub extern \"cdecl\" fn _rust_setup_entry(boot_params_ptr: u32) -> ! {\n     println!(\"[setup] entrypoint: {:#x}\", entrypoint);\n \n     // Safety: the entrypoint and the ptr is valid.\n-    unsafe { call_jinux_entrypoint(entrypoint, boot_params_ptr) };\n+    unsafe { call_aster_entrypoint(entrypoint, boot_params_ptr) };\n }\n \n #[panic_handler]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,4 +1,4 @@\n-//! The x86 boot module defines the entrypoints of Jinux and\n+//! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\n //! We directly support\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -9,7 +9,7 @@\n //!\n //! without any additional configurations.\n //!\n-//! Jinux diffrentiates the boot protocol by the entry point\n+//! Asterinas diffrentiates the boot protocol by the entry point\n //! chosen by the boot loader. In each entry point function,\n //! the universal callback registeration method from\n //! `crate::boot` will be called. Thus the initialization of\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -339,5 +339,5 @@ unsafe extern \"sysv64\" fn __multiboot_entry(boot_magic: u32, boot_params: u64) -\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -172,5 +172,5 @@ unsafe extern \"sysv64\" fn __multiboot2_entry(boot_magic: u32, boot_params: u64)\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/jinux-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,6 +1,6 @@\n //! The module to parse kernel command-line arguments.\n //!\n-//! The format of the Jinux command line string conforms\n+//! The format of the Asterinas command line string conforms\n //! to the Linux kernel command line rules:\n //!\n //! https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html\ndiff --git a/framework/jinux-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\n--- a/framework/jinux-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -60,7 +60,7 @@ macro_rules! define_global_static_boot_arguments {\n         ///\n         /// For the introduction of a new boot protocol, the entry point could be a novel\n         /// one. The entry point function should register all the boot initialization\n-        /// methods before `jinux_main` is called. A boot initialization method takes a\n+        /// methods before `aster_main` is called. A boot initialization method takes a\n         /// reference of the global static boot information variable and initialize it,\n         /// so that the boot information it represents could be accessed in the kernel\n         /// anywhere.\ndiff --git a/framework/jinux-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/jinux-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framework part of Jinux.\n+//! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_maybe_uninit_zeroed)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/jinux-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\n--- a/framework/jinux-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -57,7 +57,7 @@ use crate::trap::DisabledLocalIrqGuard;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwLock;\n+/// use aster_frame::sync::RwLock;\n ///\n /// let lock = RwLock::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\n--- a/framework/jinux-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -46,7 +46,7 @@ use super::WaitQueue;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwMutex;\n+/// use aster_frame::sync::RwMutex;\n ///\n /// let mutex = RwMutex::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/jinux-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -98,7 +98,7 @@ impl Drop for IrqLine {\n /// # Example\n ///\n /// ``rust\n-/// use jinux_frame::irq;\n+/// use aster_frame::irq;\n ///\n /// {\n ///     let _ = irq::disable_local();\ndiff --git a/framework/jinux-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/jinux-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -48,7 +48,7 @@ impl UserSpace {\n \n /// Specific architectures need to implement this trait. This should only used in `UserMode`\n ///\n-/// Only visible in jinux-frame\n+/// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n     fn execute(&mut self) -> UserEvent;\ndiff --git a/framework/jinux-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/jinux-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -98,7 +98,7 @@ pub trait UserContextApi {\n /// Here is a sample code on how to use `UserMode`.\n ///  \n /// ```no_run\n-/// use jinux_frame::task::Task;\n+/// use aster_frame::task::Task;\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\ndiff --git a/framework/jinux-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/jinux-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -54,12 +54,12 @@ pub const fn is_page_aligned(p: usize) -> bool {\n     (p & (PAGE_SIZE - 1)) == 0\n }\n \n-/// Convert physical address to virtual address using offset, only available inside jinux-frame\n+/// Convert physical address to virtual address using offset, only available inside aster-frame\n pub(crate) fn paddr_to_vaddr(pa: usize) -> usize {\n     pa + PHYS_OFFSET\n }\n \n-/// Only available inside jinux-frame\n+/// Only available inside aster-frame\n pub(crate) static MEMORY_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\n \n pub static FRAMEBUFFER_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,17 +1,17 @@\n #![no_std]\n #![no_main]\n-// The `export_name` attribute for the `jinux_main` entrypoint requires the removal of safety check.\n+// The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\n // Please be aware that the kernel is not allowed to introduce any other unsafe operations.\n // #![forbid(unsafe_code)]\n-extern crate jinux_frame;\n+extern crate aster_frame;\n \n-use jinux_frame::early_println;\n+use aster_frame::early_println;\n \n-#[export_name = \"jinux_main\"]\n+#[export_name = \"aster_main\"]\n pub fn main() -> ! {\n-    jinux_frame::init();\n-    early_println!(\"[kernel] finish init jinux_frame\");\n+    aster_frame::init();\n+    early_println!(\"[kernel] finish init aster_frame\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    jinux_std::init();\n-    jinux_std::run_first_process();\n+    aster_std::init();\n+    aster_std::run_first_process();\n }\ndiff --git a/regression/Makefile b/regression/Makefile\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -39,7 +39,7 @@ $(INITRAMFS)/lib/x86_64-linux-gnu:\n \t@cp -L /lib/x86_64-linux-gnu/libz.so.1 $@\n \t@cp -L /usr/local/benchmark/iperf/lib/libiperf.so.0 $@\n \t@# TODO: use a custom compiled vdso.so file in the future.\n-\t@git clone https://github.com/jinzhao-dev/linux_vdso.git\n+\t@git clone https://github.com/asterinas/linux_vdso.git\n \t@cd ./linux_vdso && git checkout 2a6d2db 2>/dev/null\n \t@cp -L ./linux_vdso/vdso64.so $@\n \t@rm -rf ./linux_vdso \ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -31,7 +31,7 @@ find . -name \"*shell_cmd*\"\n mkdir foo\n rmdir foo \n \n-echo \"Hello world from jinux\" > hello.txt\n+echo \"Hello world from asterinas\" > hello.txt\n rm hello.txt\n \n cd ..\ndiff --git a/runner/Cargo.toml b/runner/Cargo.toml\n--- a/runner/Cargo.toml\n+++ b/runner/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-runner\"\n+name = \"aster-runner\"\n version = \"0.1.0\"\n edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\ndiff --git a/runner/grub/grub.cfg.template b/runner/grub/grub.cfg.template\n--- a/runner/grub/grub.cfg.template\n+++ b/runner/grub/grub.cfg.template\n@@ -7,7 +7,7 @@\n set timeout_style=#GRUB_TIMEOUT_STYLE#\n set timeout=#GRUB_TIMEOUT#\n \n-menuentry 'jinux' {\n+menuentry 'asterinas' {\n     #GRUB_CMD_KERNEL# #KERNEL# #KERNEL_COMMAND_LINE#\n     #GRUB_CMD_INITRAMFS# /boot/initramfs.cpio.gz\n     boot\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -21,7 +21,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n     let mut gdb_cmd = Command::new(\"gdb\");\n     // Set the architecture, otherwise GDB will complain about.\n     gdb_cmd.arg(\"-ex\").arg(\"set arch i386:x86-64:intel\");\n-    let grub_script = \"/tmp/jinux-gdb-grub-script\";\n+    let grub_script = \"/tmp/aster-gdb-grub-script\";\n     if gdb_grub {\n         let grub_dir = PathBuf::from(qemu_grub_efi::GRUB_PREFIX)\n             .join(\"lib\")\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -41,7 +41,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         for line in lines {\n             if line.contains(\"target remote :1234\") {\n                 // Connect to the GDB server.\n-                writeln!(f, \"target remote /tmp/jinux-gdb-socket\").unwrap();\n+                writeln!(f, \"target remote /tmp/aster-gdb-socket\").unwrap();\n             } else {\n                 writeln!(f, \"{}\", line).unwrap();\n             }\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -53,7 +53,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         // Connect to the GDB server.\n         gdb_cmd\n             .arg(\"-ex\")\n-            .arg(\"target remote /tmp/jinux-gdb-socket\");\n+            .arg(\"target remote /tmp/aster-gdb-socket\");\n     }\n     // Connect to the GDB server and run.\n     println!(\"running:{:#?}\", gdb_cmd);\ndiff --git a/runner/src/machine/qemu_grub_efi/linux_boot.rs b/runner/src/machine/qemu_grub_efi/linux_boot.rs\n--- a/runner/src/machine/qemu_grub_efi/linux_boot.rs\n+++ b/runner/src/machine/qemu_grub_efi/linux_boot.rs\n@@ -47,7 +47,7 @@ fn header_to_raw_binary(elf_file: &[u8]) -> Vec<u8> {\n /// This function sould be used when generating the Linux x86 Boot setup header.\n /// Some fields in the Linux x86 Boot setup header should be filled after assembled.\n /// And the filled fields must have the bytes with values of 0xAB. See\n-/// `framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n+/// `framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n /// info on this mechanism.\n fn fill_header_field(header: &mut [u8], offset: usize, value: &[u8]) {\n     let size = value.len();\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -70,13 +70,13 @@ pub const GRUB_PREFIX: &str = \"/usr/local/grub\";\n pub const GRUB_VERSION: &str = \"x86_64-efi\";\n \n pub fn create_bootdev_image(\n-    jinux_path: PathBuf,\n+    atser_path: PathBuf,\n     initramfs_path: PathBuf,\n     grub_cfg: String,\n     protocol: BootProtocol,\n     release_mode: bool,\n ) -> PathBuf {\n-    let target_dir = jinux_path.parent().unwrap();\n+    let target_dir = atser_path.parent().unwrap();\n     let iso_root = target_dir.join(\"iso_root\");\n \n     // Clear or make the iso dir.\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -96,24 +96,24 @@ pub fn create_bootdev_image(\n         BootProtocol::Linux => {\n             // Find the setup header in the build script output directory.\n             let bs_out_dir = if release_mode {\n-                glob(\"target/x86_64-custom/release/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/release/build/aster-frame-*\").unwrap()\n             } else {\n-                glob(\"target/x86_64-custom/debug/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/debug/build/aster-frame-*\").unwrap()\n             };\n             let header_path = Path::new(bs_out_dir.into_iter().next().unwrap().unwrap().as_path())\n                 .join(\"out\")\n                 .join(\"bin\")\n-                .join(\"jinux-frame-x86-boot-linux-setup\");\n+                .join(\"aster-frame-x86-boot-linux-setup\");\n             // Make the `bzImage`-compatible kernel image and place it in the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinuz\");\n-            linux_boot::make_bzimage(&target_path, &jinux_path.as_path(), &header_path.as_path())\n+            let target_path = iso_root.join(\"boot\").join(\"asterinaz\");\n+            linux_boot::make_bzimage(&target_path, &atser_path.as_path(), &header_path.as_path())\n                 .unwrap();\n             target_path\n         }\n         BootProtocol::Multiboot | BootProtocol::Multiboot2 => {\n             // Copy the kernel image to the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinux\");\n-            fs::copy(&jinux_path, &target_path).unwrap();\n+            let target_path = iso_root.join(\"boot\").join(\"atserinas\");\n+            fs::copy(&atser_path, &target_path).unwrap();\n             target_path\n         }\n     };\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -164,15 +164,15 @@ pub fn generate_grub_cfg(\n     let buffer = match protocol {\n         BootProtocol::Multiboot => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module --nounzip\"),\n         BootProtocol::Multiboot2 => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot2\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module2 --nounzip\"),\n         BootProtocol::Linux => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"linux\")\n-            .replace(\"#KERNEL#\", \"/boot/jinuz\")\n+            .replace(\"#KERNEL#\", \"/boot/asterinaz\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"initrd\"),\n     };\n \ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -40,7 +40,7 @@ pub enum BootProtocol {\n #[command(author, version, about, long_about = None)]\n struct Args {\n     // Positional arguments.\n-    /// The Jinux binary path.\n+    /// The Asterinas binary path.\n     path: PathBuf,\n \n     /// Provide the kernel commandline, which specifies\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -117,7 +117,7 @@ pub fn random_hostfwd_ports() -> (u16, u16) {\n \n pub const GDB_ARGS: &[&str] = &[\n     \"-chardev\",\n-    \"socket,path=/tmp/jinux-gdb-socket,server=on,wait=off,id=gdb0\",\n+    \"socket,path=/tmp/aster-gdb-socket,server=on,wait=off,id=gdb0\",\n     \"-gdb\",\n     \"chardev:gdb0\",\n     \"-S\",\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -145,13 +145,13 @@ fn main() {\n         port1, port2\n     ));\n     println!(\n-        \"[jinux-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n+        \"[aster-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n         port1, 22, port2, 8080\n     );\n \n     if args.halt_for_gdb {\n         if args.enable_kvm {\n-            println!(\"[jinux-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n+            println!(\"[aster-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n             return;\n         }\n         qemu_cmd.args(GDB_ARGS);\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -206,17 +206,18 @@ fn main() {\n         qemu_cmd.arg(bootdev_image.as_os_str());\n     }\n \n-    println!(\"[jinux-runner] Running: {:#?}\", qemu_cmd);\n+    println!(\"[aster-runner] Running: {:#?}\", qemu_cmd);\n \n     let exit_status = qemu_cmd.status().unwrap();\n-\n-    // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n-    let qemu_exit_code = exit_status.code().unwrap();\n-    let kernel_exit_code = qemu_exit_code >> 1;\n-    match kernel_exit_code {\n-        0x10 /* jinux_frame::QemuExitCode::Success */ => { std::process::exit(0); },\n-        0x20 /* jinux_frame::QemuExitCode::Failed */ => { std::process::exit(1); },\n-        _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+    if !exit_status.success() {\n+        // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n+        let qemu_exit_code = exit_status.code().unwrap();\n+        let kernel_exit_code = qemu_exit_code >> 1;\n+        match kernel_exit_code {\n+            0x10 /*aster_frame::QemuExitCode::Success*/ => { std::process::exit(0); },\n+            0x20 /*aster_frame::QemuExitCode::Failed*/ => { std::process::exit(1); },\n+            _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+        }\n     }\n }\n \ndiff --git a/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-block\"\n+name = \"aster-block\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The block devices of jinux\n+//! The block devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n use component::init_component;\n use component::ComponentInitError;\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub const BLK_SIZE: usize = 512;\ndiff --git a/services/comps/console/Cargo.toml b/services/comps/console/Cargo.toml\n--- a/services/comps/console/Cargo.toml\n+++ b/services/comps/console/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-console\"\n+name = \"aster-console\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/console/Cargo.toml b/services/comps/console/Cargo.toml\n--- a/services/comps/console/Cargo.toml\n+++ b/services/comps/console/Cargo.toml\n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The console device of jinux\n+//! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -8,8 +8,8 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, fmt::Debug, string::String, sync::Arc, vec::Vec};\n use core::any::Any;\n \n+use aster_frame::sync::SpinLock;\n use component::{init_component, ComponentInitError};\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub type ConsoleCallback = dyn Fn(&[u8]) + Send + Sync;\ndiff --git a/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\n--- a/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -1,12 +1,12 @@\n [package]\n-name = \"jinux-framebuffer\"\n+name = \"aster-framebuffer\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framebuffer of jinux\n+//! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(strict_provenance)]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -6,13 +6,13 @@\n extern crate alloc;\n \n use alloc::vec::Vec;\n+use aster_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use component::{init_component, ComponentInitError};\n use core::{\n     fmt,\n     ops::{Index, IndexMut},\n };\n use font8x8::UnicodeFonts;\n-use jinux_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use spin::Once;\n \n #[init_component]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -28,7 +28,7 @@ pub(crate) fn init() {\n         let framebuffer = boot::framebuffer_arg();\n         let mut writer = None;\n         let mut size = 0;\n-        for i in jinux_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n+        for i in aster_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n             size = i.len() as usize;\n         }\n \ndiff --git a/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-input\"\n+name = \"aster-input\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -8,9 +8,9 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The input devices of jinux\n+//! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -14,7 +14,7 @@ use alloc::vec::Vec;\n use component::init_component;\n use component::ComponentInitError;\n \n-use jinux_frame::sync::SpinLock;\n+use aster_frame::sync::SpinLock;\n use spin::Once;\n use virtio_input_decoder::DecodeType;\n \ndiff --git a/services/comps/network/Cargo.toml b/services/comps/network/Cargo.toml\n--- a/services/comps/network/Cargo.toml\n+++ b/services/comps/network/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-network\"\n+name = \"aster-network\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/network/Cargo.toml b/services/comps/network/Cargo.toml\n--- a/services/comps/network/Cargo.toml\n+++ b/services/comps/network/Cargo.toml\n@@ -7,13 +7,13 @@ edition = \"2021\"\n \n [dependencies]\n component = { path = \"../../libs/comp-sys/component\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n bytes = { version = \"1.4.0\", default-features = false }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -13,14 +13,14 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n+use aster_util::safe_ptr::Pod;\n use buffer::RxBuffer;\n use buffer::TxBuffer;\n use component::init_component;\n use component::ComponentInitError;\n use core::any::Any;\n use core::fmt::Debug;\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::safe_ptr::Pod;\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\n--- a/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -1,13 +1,13 @@\n [package]\n-name = \"jinux-time\"\n+name = \"aster-time\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -6,9 +6,9 @@\n //! It can be integrated into larger systems to provide timing capabilities, or used standalone for time tracking and elapsed time measurements.\n \n use alloc::sync::Arc;\n+use aster_frame::sync::SpinLock;\n+use aster_util::coeff::Coeff;\n use core::{cmp::max, ops::Add, time::Duration};\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::coeff::Coeff;\n \n use crate::NANOS_PER_SECOND;\n \ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,13 +1,13 @@\n-//! The system time of jinux\n+//! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \n extern crate alloc;\n \n use alloc::sync::Arc;\n+use aster_frame::sync::Mutex;\n use component::{init_component, ComponentInitError};\n use core::{sync::atomic::Ordering::Relaxed, time::Duration};\n-use jinux_frame::sync::Mutex;\n use spin::Once;\n \n use clocksource::ClockSource;\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\n-use jinux_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n \n pub(crate) static CENTURY_REGISTER: AtomicU8 = AtomicU8::new(0);\n \ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -2,9 +2,9 @@\n //!\n //! Use `init` to initialize this module.\n use alloc::sync::Arc;\n+use aster_frame::arch::{read_tsc, x86::tsc_freq};\n+use aster_frame::timer::Timer;\n use core::time::Duration;\n-use jinux_frame::arch::{read_tsc, x86::tsc_freq};\n-use jinux_frame::timer::Timer;\n use spin::Once;\n \n use crate::clocksource::{ClockSource, Instant};\ndiff --git a/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-virtio\"\n+name = \"aster-virtio\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -11,15 +11,15 @@ spin = \"0.9.4\"\n virtio-input-decoder = \"0.1.4\"\n bytes = { version = \"1.4.0\", default-features = false }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-jinux-input = { path = \"../input\" }\n-jinux-block = { path = \"../block\" }\n-jinux-network = { path = \"../network\" }\n-jinux-console = { path = \"../console\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-input = { path = \"../input\" }\n+aster-block = { path = \"../block\" }\n+aster-network = { path = \"../network\" }\n+aster-console = { path = \"../console\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,8 +1,8 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, string::ToString, sync::Arc};\n-use jinux_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::info;\n use pod::Pod;\n \ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -97,7 +97,7 @@ impl BlockDevice {\n             .unwrap();\n \n         fn handle_block_device(_: &TrapFrame) {\n-            jinux_block::get_device(super::DEVICE_NAME)\n+            aster_block::get_device(super::DEVICE_NAME)\n                 .unwrap()\n                 .handle_irq();\n         }\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -107,7 +107,7 @@ impl BlockDevice {\n         }\n         device.transport.finish_init();\n \n-        jinux_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -120,7 +120,7 @@ impl BlockDevice {\n     }\n }\n \n-impl jinux_block::BlockDevice for BlockDevice {\n+impl aster_block::BlockDevice for BlockDevice {\n     fn read_block(&self, block_id: usize, buf: &mut [u8]) {\n         self.read(block_id, buf);\n     }\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,9 +1,9 @@\n pub mod device;\n \n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,9 +1,9 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\n-use jinux_console::{AnyConsoleDevice, ConsoleCallback};\n-use jinux_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_console::{AnyConsoleDevice, ConsoleCallback};\n+use aster_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::debug;\n \n use crate::{\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -130,14 +130,14 @@ impl ConsoleDevice {\n             .unwrap();\n         device.transport.finish_init();\n \n-        jinux_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\n }\n \n fn handle_console_input(_: &TrapFrame) {\n-    jinux_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n+    aster_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n }\n \n fn config_space_change(_: &TrapFrame) {\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -7,9 +7,9 @@ use alloc::{\n     sync::Arc,\n     vec::Vec,\n };\n+use aster_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n-use jinux_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{debug, info};\n use pod::Pod;\n use virtio_input_decoder::{DecodeType, Decoder};\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -112,7 +112,7 @@ impl InputDevice {\n \n         fn handle_input(_: &TrapFrame) {\n             debug!(\"Handle Virtio input interrupt\");\n-            let device = jinux_input::get_device(super::DEVICE_NAME).unwrap();\n+            let device = aster_input::get_device(super::DEVICE_NAME).unwrap();\n             device.handle_irq().unwrap();\n         }\n \ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -131,7 +131,7 @@ impl InputDevice {\n \n         device.transport.finish_init();\n \n-        jinux_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -183,7 +183,7 @@ impl InputDevice {\n     }\n }\n \n-impl jinux_input::InputDevice for InputDevice {\n+impl aster_input::InputDevice for InputDevice {\n     fn handle_irq(&self) -> Option<()> {\n         // one interrupt may contains serval input, so it should loop\n         loop {\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -26,8 +26,8 @@\n \n pub mod device;\n use crate::transport::VirtioTransport;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n pub static DEVICE_NAME: &str = \"Virtio-Input\";\ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::io_mem::IoMem;\n+use aster_network::EthernetAddr;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_network::EthernetAddr;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,12 +1,12 @@\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\n-use jinux_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_network::{\n+use aster_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_network::{\n     buffer::{RxBuffer, TxBuffer},\n     AnyNetworkDevice, EthernetAddr, NetDeviceIrqHandler, VirtioNetError,\n };\n-use jinux_util::{field_ptr, slot_vec::SlotVec};\n+use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n use pod::Pod;\n use smoltcp::phy::{DeviceCapabilities, Medium};\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -87,7 +87,7 @@ impl NetworkDevice {\n \n         /// Interrupt handler if network device receives some packet\n         fn handle_network_event(_: &TrapFrame) {\n-            jinux_network::handle_recv_irq(super::DEVICE_NAME);\n+            aster_network::handle_recv_irq(super::DEVICE_NAME);\n         }\n \n         device\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -99,7 +99,7 @@ impl NetworkDevice {\n             .register_queue_callback(QUEUE_RECV, Box::new(handle_network_event), false)\n             .unwrap();\n \n-        jinux_network::register_device(\n+        aster_network::register_device(\n             super::DEVICE_NAME.to_string(),\n             Arc::new(SpinLock::new(Box::new(device))),\n         );\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The virtio of jinux\n+//! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -3,18 +3,18 @@\n use crate::transport::VirtioTransport;\n \n use alloc::vec::Vec;\n+use aster_frame::{\n+    io_mem::IoMem,\n+    offset_of,\n+    vm::{DmaCoherent, VmAllocOptions},\n+};\n+use aster_rights::{Dup, TRightSet, TRights, Write};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n use core::{\n     mem::size_of,\n     sync::atomic::{fence, Ordering},\n };\n-use jinux_frame::{\n-    io_mem::IoMem,\n-    offset_of,\n-    vm::{DmaCoherent, VmAllocOptions},\n-};\n-use jinux_rights::{Dup, TRightSet, TRights, Write};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::debug;\n use pod::Pod;\n \ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -372,7 +372,7 @@ fn set_buf(ptr: &SafePtr<Descriptor, &DmaCoherent, TRightSet<TRights![Dup, Write\n     // FIXME: use `DmaSteam` for buf. Now because the upper device driver lacks the\n     // ability to safely construct DmaStream from slice, slice is still used here.\n     let va = buf.as_ptr() as usize;\n-    let pa = jinux_frame::vm::vaddr_to_paddr(va).unwrap();\n+    let pa = aster_frame::vm::vaddr_to_paddr(va).unwrap();\n     field_ptr!(ptr, Descriptor, addr)\n         .write(&(pa as u64))\n         .unwrap();\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,6 +1,5 @@\n use alloc::{boxed::Box, sync::Arc};\n-use core::mem::size_of;\n-use jinux_frame::{\n+use aster_frame::{\n     bus::mmio::{\n         bus::MmioDevice,\n         device::{MmioCommonDevice, VirtioMmioVersion},\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -12,8 +11,9 @@ use jinux_frame::{\n     trap::IrqCallbackFunction,\n     vm::DmaCoherent,\n };\n-use jinux_rights::{ReadOp, WriteOp};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n+use aster_rights::{ReadOp, WriteOp};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n+use core::mem::size_of;\n use log::warn;\n \n use crate::{\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -33,7 +33,7 @@ pub struct VirtioMmioDevice {\n pub struct VirtioMmioTransport {\n     layout: SafePtr<VirtioMmioLayout, IoMem>,\n     device: Arc<VirtioMmioDevice>,\n-    common_device: jinux_frame::bus::mmio::device::MmioCommonDevice,\n+    common_device: aster_frame::bus::mmio::device::MmioCommonDevice,\n     multiplex: Arc<RwLock<MultiplexIrq>>,\n }\n \ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         mmio::{\n             bus::{MmioDevice, MmioDriver},\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::mmio::MMIO_BUS;\n+use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\n \n use self::driver::VirtioMmioDriver;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,13 +1,13 @@\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     io_mem::IoMem,\n     sync::RwLock,\n     trap::{IrqCallbackFunction, IrqLine, TrapFrame},\n };\n-use jinux_rights::{ReadOp, TRightSet, WriteOp};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_rights::{ReadOp, TRightSet, WriteOp};\n+use aster_util::safe_ptr::SafePtr;\n \n /// Multiplexing Irqs. The two interrupt types (configuration space change and queue interrupt)\n /// of the virtio-mmio device share the same IRQ, so `MultiplexIrq` are used to distinguish them.\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,8 +1,8 @@\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\n-use jinux_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n+use aster_util::safe_ptr::SafePtr;\n \n use crate::{\n     queue::{AvailRing, Descriptor, UsedRing},\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::{\n+use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\n     cfg_space::{Bar, IoBar, MemoryBar},\n     common_device::BarManager,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::PciDevice, capability::CapabilityData, common_device::PciCommonDevice, PciDeviceId,\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -12,8 +12,8 @@ use jinux_frame::{\n };\n \n use alloc::{boxed::Box, sync::Arc};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use core::fmt::Debug;\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{info, warn};\n \n use super::{common_cfg::VirtioPciCommonCfg, msix::VirtioMsixManager};\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::{PciDevice, PciDriver},\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -5,7 +5,7 @@ pub mod driver;\n pub(super) mod msix;\n \n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::PCI_BUS;\n+use aster_frame::bus::pci::PCI_BUS;\n use spin::Once;\n \n use self::driver::VirtioPciDriver;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,5 +1,5 @@\n use alloc::vec::Vec;\n-use jinux_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n+use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \n pub struct VirtioMsixManager {\n     config_msix_vector: u16,\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -17,7 +17,7 @@ impl VirtioMsixManager {\n     pub fn new(mut msix: CapabilityMsixData) -> Self {\n         let mut msix_vector_list: Vec<u16> = (0..msix.table_size()).collect();\n         for i in msix_vector_list.iter() {\n-            let irq = jinux_frame::trap::IrqLine::alloc().unwrap();\n+            let irq = aster_frame::trap::IrqLine::alloc().unwrap();\n             msix.set_interrupt_vector(irq, *i);\n         }\n         let config_msix_vector = msix_vector_list.pop().unwrap();\ndiff --git a/services/libs/jinux-rights-proc/Cargo.toml b/services/libs/aster-rights-proc/Cargo.toml\n--- a/services/libs/jinux-rights-proc/Cargo.toml\n+++ b/services/libs/aster-rights-proc/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights-proc\"\n+name = \"aster-rights-proc\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/libs/jinux-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\n--- a/services/libs/jinux-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the require procedural macros to implement capability for jinux.\n+//\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\n //! The require macro are used to ensure that an object has the enough capability to call the function.\ndiff --git a/services/libs/jinux-rights/Cargo.toml b/services/libs/aster-rights/Cargo.toml\n--- a/services/libs/jinux-rights/Cargo.toml\n+++ b/services/libs/aster-rights/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights\"\n+name = \"aster-rights\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/libs/jinux-rights/Cargo.toml b/services/libs/aster-rights/Cargo.toml\n--- a/services/libs/jinux-rights/Cargo.toml\n+++ b/services/libs/aster-rights/Cargo.toml\n@@ -9,6 +9,6 @@ edition = \"2021\"\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n bitflags = \"1.3\"\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n \n [features]\ndiff --git a/services/libs/jinux-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\n--- a/services/libs/jinux-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -58,7 +58,7 @@ pub type FullOp = TRights![Read, Write, Dup];\n /// Example:\n ///\n /// ```rust\n-/// use jinux_rights::{Rights, TRights, TRightSet};\n+/// use aster_rights::{Rights, TRights, TRightSet};\n ///\n /// pub struct Vmo<R=Rights>(R);\n ///\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/aster-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/aster-std/Cargo.toml\n@@ -1,26 +1,26 @@\n [package]\n-name = \"jinux-std\"\n+name = \"aster-std\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n-jinux-input = { path = \"../../comps/input\" }\n-jinux-block = { path = \"../../comps/block\" }\n-jinux-network = { path = \"../../comps/network\" }\n-jinux-console = { path = \"../../comps/console\" }\n-jinux-time = { path = \"../../comps/time\" }\n-jinux-virtio = { path = \"../../comps/virtio\" }\n-jinux-rights = { path = \"../jinux-rights\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n+aster-input = { path = \"../../comps/input\" }\n+aster-block = { path = \"../../comps/block\" }\n+aster-network = { path = \"../../comps/network\" }\n+aster-console = { path = \"../../comps/console\" }\n+aster-time = { path = \"../../comps/time\" }\n+aster-virtio = { path = \"../../comps/virtio\" }\n+aster-rights = { path = \"../aster-rights\" }\n controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n-jinux-util = { path = \"../jinux-util\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n+aster-util = { path = \"../aster-util\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n cpio-decoder = { path = \"../cpio-decoder\" }\n virtio-input-decoder = \"0.1.4\"\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/aster-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/aster-std/Cargo.toml\n@@ -52,7 +52,7 @@ bitflags = \"1.3\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n keyable-arc = { path = \"../keyable-arc\" }\n # unzip initramfs\n-libflate = { git = \"https://github.com/jinzhao-dev/libflate\", rev = \"b781da6\", features = [\n+libflate = { git = \"https://github.com/asterinas/libflate\", rev = \"b781da6\", features = [\n     \"no_std\",\n ] }\n core2 = { version = \"0.4\", default_features = false, features = [\"alloc\"] }\ndiff --git a/services/libs/jinux-std/src/console.rs b/services/libs/aster-std/src/console.rs\n--- a/services/libs/jinux-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -9,7 +9,7 @@ struct VirtioConsolesPrinter;\n \n impl Write for VirtioConsolesPrinter {\n     fn write_str(&mut self, s: &str) -> core::fmt::Result {\n-        for (_, device) in jinux_console::all_devices() {\n+        for (_, device) in aster_console::all_devices() {\n             device.send(s.as_bytes());\n         }\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/jinux-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,4 +1,4 @@\n-pub use jinux_frame::arch::console::register_console_input_callback;\n+pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \n use crate::{\ndiff --git a/services/libs/jinux-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/jinux-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -9,7 +9,7 @@ use crate::{\n pub static TTY_DRIVER: Once<Arc<TtyDriver>> = Once::new();\n \n pub(super) fn init() {\n-    for (_, device) in jinux_console::all_devices() {\n+    for (_, device) in aster_console::all_devices() {\n         device.register_callback(&console_input_callback)\n     }\n     let tty_driver = Arc::new(TtyDriver::new());\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -6,7 +6,7 @@ use crate::process::signal::{Pollee, Poller};\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n use alloc::format;\n-use jinux_frame::trap::disable_local;\n+use aster_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\ndiff --git a/services/libs/jinux-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/jinux-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -178,15 +178,15 @@ impl From<Errno> for Error {\n     }\n }\n \n-impl From<jinux_frame::Error> for Error {\n-    fn from(frame_error: jinux_frame::Error) -> Self {\n+impl From<aster_frame::Error> for Error {\n+    fn from(frame_error: aster_frame::Error) -> Self {\n         match frame_error {\n-            jinux_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n-            jinux_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n-            jinux_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n-            jinux_frame::Error::IoError => Error::new(Errno::EIO),\n-            jinux_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n-            jinux_frame::Error::PageFault => Error::new(Errno::EFAULT),\n+            aster_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n+            aster_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n+            aster_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n+            aster_frame::Error::IoError => Error::new(Errno::EIO),\n+            aster_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n+            aster_frame::Error::PageFault => Error::new(Errno::EFAULT),\n         }\n     }\n }\ndiff --git a/services/libs/jinux-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/jinux-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -237,16 +237,16 @@ impl From<cpio_decoder::error::Error> for Error {\n     }\n }\n \n-impl From<Error> for jinux_frame::Error {\n+impl From<Error> for aster_frame::Error {\n     fn from(error: Error) -> Self {\n         match error.errno {\n-            Errno::EACCES => jinux_frame::Error::AccessDenied,\n-            Errno::EIO => jinux_frame::Error::IoError,\n-            Errno::ENOMEM => jinux_frame::Error::NoMemory,\n-            Errno::EFAULT => jinux_frame::Error::PageFault,\n-            Errno::EINVAL => jinux_frame::Error::InvalidArgs,\n-            Errno::EBUSY => jinux_frame::Error::NotEnoughResources,\n-            _ => jinux_frame::Error::InvalidArgs,\n+            Errno::EACCES => aster_frame::Error::AccessDenied,\n+            Errno::EIO => aster_frame::Error::IoError,\n+            Errno::ENOMEM => aster_frame::Error::NoMemory,\n+            Errno::EFAULT => aster_frame::Error::PageFault,\n+            Errno::EINVAL => aster_frame::Error::InvalidArgs,\n+            Errno::EBUSY => aster_frame::Error::NotEnoughResources,\n+            _ => aster_frame::Error::InvalidArgs,\n         }\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -6,9 +6,9 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n \n+use aster_frame::vm::VmFrame;\n+use aster_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n-use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -2,8 +2,8 @@ use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\n \n+use aster_util::slot_vec::SlotVec;\n use core::cell::Cell;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::file_handle::FileLike;\n use super::fs_resolver::{FsPath, FsResolver, AT_FDCWD};\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,7 +1,7 @@\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -13,7 +13,7 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[derive(Debug)]\n pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n-use jinux_rights::{Read, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_rights::{Read, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,5 +1,5 @@\n+use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n-use jinux_util::slot_vec::SlotVec;\n \n use crate::fs::device::Device;\n use crate::fs::utils::{DirentVisitor, FileSystem, Inode, InodeMode, InodeType, Metadata};\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,10 +1,10 @@\n use alloc::str;\n+use aster_frame::sync::{RwLock, RwLockWriteGuard};\n+use aster_frame::vm::{VmFrame, VmIo};\n+use aster_rights::Full;\n+use aster_util::slot_vec::SlotVec;\n use core::sync::atomic::{AtomicUsize, Ordering};\n use core::time::Duration;\n-use jinux_frame::sync::{RwLock, RwLockWriteGuard};\n-use jinux_frame::vm::{VmFrame, VmIo};\n-use jinux_rights::Full;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::*;\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\n--- a/services/libs/jinux-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[allow(non_camel_case_types)]\n #[derive(Clone, Copy, Debug)]\ndiff --git a/services/libs/jinux-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\n--- a/services/libs/jinux-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,12 +1,12 @@\n+use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n-use jinux_rights_proc::require;\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\n \n use crate::events::IoEvents;\n use crate::events::Observer;\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n-use jinux_rights::{Read, ReadOp, TRights, Write, WriteOp};\n+use aster_rights::{Read, ReadOp, TRights, Write, WriteOp};\n \n use super::StatusFlags;\n \ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,7 +1,7 @@\n use super::Inode;\n use crate::prelude::*;\n \n-use jinux_util::slot_vec::SlotVec;\n+use aster_util::slot_vec::SlotVec;\n \n pub trait DirEntryVecExt {\n     /// If the entry is not found by `name`, use `f` to get the inode, then put the entry into vec.\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::vm::VmFrame;\n+use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\n-use jinux_frame::vm::VmFrame;\n-use jinux_rights::Full;\n \n use super::{DirentVisitor, FileSystem, IoctlCmd, SuperBlock};\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\n--- a/services/libs/jinux-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,10 +1,10 @@\n use super::Inode;\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n-use jinux_rights::Full;\n+use aster_rights::Full;\n \n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n use core::ops::Range;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n use lru::LruCache;\n \n pub struct PageCache {\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The std library of jinux\n+//! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -28,7 +28,7 @@ use crate::{\n         Thread,\n     },\n };\n-use jinux_frame::{\n+use aster_frame::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n     boot,\n };\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -82,7 +82,7 @@ fn init_thread() {\n     }));\n     thread.join();\n     info!(\n-        \"[jinux-std/lib.rs] spawn kernel thread, tid = {}\",\n+        \"[aster-std/lib.rs] spawn kernel thread, tid = {}\",\n         thread.tid()\n     );\n     thread::work_queue::init();\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -125,12 +125,10 @@ fn print_banner() {\n     println!(\"\\x1B[36m\");\n     println!(\n         r\"\n-       __   __  .__   __.  __    __  ___   ___ \n-      |  | |  | |  \\ |  | |  |  |  | \\  \\ /  / \n-      |  | |  | |   \\|  | |  |  |  |  \\  V  /  \n-.--.  |  | |  | |  . `  | |  |  |  |   >   <   \n-|  `--'  | |  | |  |\\   | |  `--'  |  /  .  \\  \n- \\______/  |__| |__| \\__|  \\______/  /__/ \\__\\                                                                                            \n+   _   ___ _____ ___ ___ ___ _  _   _   ___ \n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/                                                                                                                                    \n \"\n     );\n     println!(\"\\x1B[0m\");\ndiff --git a/services/libs/jinux-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\n--- a/services/libs/jinux-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\n     let millis = read_monotonic_milli_seconds();\ndiff --git a/services/libs/jinux-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\n--- a/services/libs/jinux-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/jinux-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n-use jinux_frame::sync::SpinLock;\n-use jinux_network::AnyNetworkDevice;\n-use jinux_virtio::device::network::DEVICE_NAME;\n+use aster_frame::sync::SpinLock;\n+use aster_network::AnyNetworkDevice;\n+use aster_virtio::device::network::DEVICE_NAME;\n use smoltcp::{\n     iface::{Config, Routes, SocketHandle, SocketSet},\n     socket::dhcpv4,\ndiff --git a/services/libs/jinux-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/jinux-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -19,7 +19,7 @@ pub struct IfaceVirtio {\n \n impl IfaceVirtio {\n     pub fn new() -> Arc<Self> {\n-        let virtio_net = jinux_network::get_device(DEVICE_NAME).unwrap();\n+        let virtio_net = aster_network::get_device(DEVICE_NAME).unwrap();\n         let interface = {\n             let mac_addr = virtio_net.lock().mac_addr();\n             let ip_addr = IpCidr::new(wire::IpAddress::Ipv4(wire::Ipv4Address::UNSPECIFIED), 0);\ndiff --git a/services/libs/jinux-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\n--- a/services/libs/jinux-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -18,8 +18,8 @@ pub fn init() {\n         vec![iface_virtio, iface_loopback]\n     });\n \n-    for (name, _) in jinux_network::all_devices() {\n-        jinux_network::register_recv_callback(&name, || {\n+    for (name, _) in aster_network::all_devices() {\n+        aster_network::register_recv_callback(&name, || {\n             // TODO: further check that the irq num is the same as iface's irq num\n             let iface_virtio = &IFACES.get().unwrap()[0];\n             iface_virtio.poll();\ndiff --git a/services/libs/jinux-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\n--- a/services/libs/jinux-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -12,14 +12,14 @@ pub(crate) use alloc::sync::Arc;\n pub(crate) use alloc::sync::Weak;\n pub(crate) use alloc::vec;\n pub(crate) use alloc::vec::Vec;\n+pub(crate) use aster_frame::config::PAGE_SIZE;\n+pub(crate) use aster_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n+pub(crate) use aster_frame::vm::Vaddr;\n pub(crate) use bitflags::bitflags;\n pub(crate) use core::any::Any;\n pub(crate) use core::ffi::CStr;\n pub(crate) use core::fmt::Debug;\n pub(crate) use int_to_c_enum::TryFromInt;\n-pub(crate) use jinux_frame::config::PAGE_SIZE;\n-pub(crate) use jinux_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n-pub(crate) use jinux_frame::vm::Vaddr;\n pub(crate) use log::{debug, error, info, trace, warn};\n pub(crate) use pod::Pod;\n \ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -10,10 +10,10 @@ use crate::prelude::*;\n use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n use crate::util::write_val_to_user;\n use crate::vm::vmar::Vmar;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::user::UserSpace;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::Full;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::user::UserSpace;\n+use aster_frame::vm::VmIo;\n+use aster_rights::Full;\n \n bitflags! {\n     pub struct CloneFlags: u32 {\ndiff --git a/services/libs/jinux-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\n--- a/services/libs/jinux-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -2,7 +2,7 @@ use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n \n #[derive(Debug)]\n pub(super) struct Credentials_ {\ndiff --git a/services/libs/jinux-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\n--- a/services/libs/jinux-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -4,8 +4,8 @@ mod static_cap;\n mod user;\n \n use crate::prelude::*;\n+use aster_rights::{FullOp, ReadOp, WriteOp};\n use credentials_::Credentials_;\n-use jinux_rights::{FullOp, ReadOp, WriteOp};\n \n pub use group::Gid;\n pub use user::Uid;\ndiff --git a/services/libs/jinux-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\n--- a/services/libs/jinux-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,9 +1,9 @@\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n-use jinux_rights::{Dup, Read, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_rights::{Dup, Read, TRights, Write};\n+use aster_rights_proc::require;\n \n impl<R: TRights> Credentials<R> {\n     /// Creates a root `Credentials`. This method can only be used when creating the first process\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::user::UserSpace;\n+use aster_frame::user::UserSpace;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,6 +1,6 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n \n-use jinux_frame::cpu::num_cpus;\n+use aster_frame::cpu::num_cpus;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -10,8 +10,8 @@ use crate::prelude::*;\n use crate::process::signal::constants::SIGCONT;\n use crate::thread::{thread_table, Tid};\n use crate::util::write_val_to_user;\n+use aster_rights::{ReadOp, WriteOp};\n use futex::futex_wake;\n-use jinux_rights::{ReadOp, WriteOp};\n use robust_list::wake_robust_futex;\n \n mod builder;\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace};\n+use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\n     fs::fs_resolver::{FsPath, FsResolver, AT_FDCWD},\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -23,8 +23,8 @@ mod process_group;\n mod session;\n mod terminal;\n \n+use aster_rights::Full;\n pub use builder::ProcessBuilder;\n-use jinux_rights::Full;\n pub use job_control::JobControl;\n pub use process_group::ProcessGroup;\n pub use session::Session;\ndiff --git a/services/libs/jinux-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\n--- a/services/libs/jinux-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -6,7 +6,7 @@\n \n pub mod user_heap;\n \n-use jinux_rights::Full;\n+use aster_rights::Full;\n use user_heap::UserHeap;\n \n use crate::vm::vmar::Vmar;\ndiff --git a/services/libs/jinux-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n--- a/services/libs/jinux-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -7,7 +7,7 @@ use crate::{\n     vm::vmo::{VmoFlags, VmoOptions},\n };\n use align_ext::AlignExt;\n-use jinux_rights::{Full, Rights};\n+use aster_rights::{Full, Rights};\n \n pub const USER_HEAP_BASE: Vaddr = 0x0000_0000_1000_0000;\n pub const USER_HEAP_SIZE_LIMIT: usize = PAGE_SIZE * 1000;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n--- a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -8,9 +8,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::VmoOptions},\n };\n use align_ext::AlignExt;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use core::mem;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n \n use super::aux_vec::{AuxKey, AuxVec};\n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n--- a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -13,9 +13,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::Vmo},\n };\n use align_ext::AlignExt;\n-use jinux_frame::task::Task;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n+use aster_frame::task::Task;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use xmas_elf::program::{self, ProgramHeader64};\n \n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\n--- a/services/libs/jinux-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,8 +1,8 @@\n #![allow(non_camel_case_types)]\n use core::mem;\n \n-use jinux_frame::cpu::GeneralRegs;\n-use jinux_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n+use aster_frame::cpu::GeneralRegs;\n+use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\n--- a/services/libs/jinux-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -17,9 +17,9 @@ pub use poll::{Pollee, Poller};\n pub use sig_stack::{SigStack, SigStackFlags, SigStackStatus};\n \n use align_ext::AlignExt;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::task::Task;\n use core::mem;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::task::Task;\n \n use super::posix_thread::{PosixThread, PosixThreadExt};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\n--- a/services/libs/jinux-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,7 +1,7 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \n-use jinux_frame::sync::WaitQueue;\n+use aster_frame::sync::WaitQueue;\n \n use crate::events::Observer;\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\n--- a/services/libs/jinux-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::{CpuException, CpuExceptionInfo};\n-use jinux_frame::cpu::{\n+use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n+use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\n     INVALID_OPCODE, PAGE_FAULT, SIMD_FLOATING_POINT_EXCEPTION, X87_FLOATING_POINT_EXCEPTION,\n };\ndiff --git a/services/libs/jinux-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\n--- a/services/libs/jinux-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n+use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\n-use jinux_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n \n pub fn init() {\n     let preempt_scheduler = Box::new(PreemptScheduler::new());\ndiff --git a/services/libs/jinux-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\n--- a/services/libs/jinux-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/jinux-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\n--- a/services/libs/jinux-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\n use crate::process::{clone_child, CloneArgs, CloneFlags};\ndiff --git a/services/libs/jinux-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\n--- a/services/libs/jinux-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::UserContext;\n-use jinux_rights::WriteOp;\n+use aster_frame::cpu::UserContext;\n+use aster_rights::WriteOp;\n \n use super::{constants::*, SyscallReturn};\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/jinux-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\n--- a/services/libs/jinux-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -3,7 +3,7 @@ use crate::{\n     prelude::*,\n     process::{clone_child, CloneArgs},\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_FORK;\n \ndiff --git a/services/libs/jinux-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\n--- a/services/libs/jinux-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -5,8 +5,8 @@ use crate::vm::perms::VmPerms;\n use crate::vm::vmo::{VmoChildOptions, VmoOptions, VmoRightsOp};\n use crate::{log_syscall_entry, prelude::*};\n use align_ext::AlignExt;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n \n use crate::syscall::SYS_MMAP;\n \ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -69,7 +69,7 @@ use crate::syscall::wait4::sys_wait4;\n use crate::syscall::waitid::sys_waitid;\n use crate::syscall::write::sys_write;\n use crate::syscall::writev::sys_writev;\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use self::accept::sys_accept;\n use self::bind::sys_bind;\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n--- a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -4,7 +4,7 @@ use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::constants::{SIGKILL, SIGSTOP};\n use crate::process::signal::sig_mask::SigMask;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n pub fn sys_rt_sigprocmask(\n     how: u32,\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n--- a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -4,7 +4,7 @@ use crate::{\n     process::{posix_thread::PosixThreadExt, signal::c_types::ucontext_t},\n     util::read_val_from_user,\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use super::{SyscallReturn, SYS_RT_SIGRETRUN};\n \ndiff --git a/services/libs/jinux-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\n--- a/services/libs/jinux-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,8 +1,8 @@\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\n-use jinux_frame::cpu::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::cpu::*;\n+use aster_frame::vm::VmIo;\n \n /// We can't handle most exceptions, just send self a fault signal before return to user space.\n pub fn handle_exception(context: &UserContext) {\ndiff --git a/services/libs/jinux-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\n--- a/services/libs/jinux-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::{Priority, TaskOptions};\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::{Priority, TaskOptions};\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\n--- a/services/libs/jinux-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -5,7 +5,7 @@ use core::{\n     sync::atomic::{AtomicU32, Ordering},\n };\n \n-use jinux_frame::task::Task;\n+use aster_frame::task::Task;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\n--- a/services/libs/jinux-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n     user::{UserContextApi, UserEvent, UserMode, UserSpace},\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::cpu::CpuSet;\n+use aster_frame::cpu::CpuSet;\n use spin::Once;\n use work_item::WorkItem;\n use worker_pool::WorkerPool;\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -60,7 +60,7 @@ static WORKQUEUE_GLOBAL_HIGH_PRI: Once<Arc<WorkQueue>> = Once::new();\n /// Certainly, users can also create a dedicated WorkQueue and WorkerPool.\n ///\n /// ```rust\n-/// use jinux_frame::cpu::CpuSet;\n+/// use aster_frame::cpu::CpuSet;\n /// use crate::thread::work_queue::{WorkQueue, WorkerPool, WorkItem};\n ///\n /// fn deferred_task(){\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\n use core::sync::atomic::Ordering;\n-use jinux_frame::cpu::CpuSet;\n \n /// A task to be executed by a worker thread.\n pub struct WorkItem {\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -2,8 +2,8 @@ use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::Priority;\n \n /// A worker thread. A `Worker` will attempt to retrieve unfinished\n /// work items from its corresponding `WorkerPool`. If there are none,\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -4,9 +4,9 @@ use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPri\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::sync::WaitQueue;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::sync::WaitQueue;\n+use aster_frame::task::Priority;\n \n /// A pool of workers.\n ///\ndiff --git a/services/libs/jinux-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\n--- a/services/libs/jinux-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -3,7 +3,7 @@ use core::time::Duration;\n \n use crate::prelude::*;\n \n-use jinux_time::read_monotonic_time;\n+use aster_time::read_monotonic_time;\n \n mod system_time;\n \ndiff --git a/services/libs/jinux-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/jinux-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,5 +1,5 @@\n+use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n-use jinux_time::{read_monotonic_time, read_start_time};\n use time::{Date, Month, PrimitiveDateTime, Time};\n \n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/jinux-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -68,8 +68,8 @@ impl SystemTime {\n     }\n }\n \n-/// convert jinux_frame::time::Time to System time\n-fn convert_system_time(system_time: jinux_time::SystemTime) -> Result<SystemTime> {\n+/// convert aster_frame::time::Time to System time\n+fn convert_system_time(system_time: aster_time::SystemTime) -> Result<SystemTime> {\n     let month = match Month::try_from(system_time.month) {\n         Ok(month) => month,\n         Err(_) => return_errno_with_message!(Errno::EINVAL, \"unknown month in system time\"),\ndiff --git a/services/libs/jinux-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\n--- a/services/libs/jinux-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n pub mod net;\n \n /// copy bytes from user space of current process. The bytes len is the len of dest.\ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -11,10 +11,10 @@\n \n use alloc::boxed::Box;\n use alloc::sync::Arc;\n-use jinux_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n-use jinux_rights::Rights;\n-use jinux_time::Instant;\n-use jinux_util::coeff::Coeff;\n+use aster_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n+use aster_rights::Rights;\n+use aster_time::Instant;\n+use aster_util::coeff::Coeff;\n use pod::Pod;\n use spin::Once;\n \ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -108,7 +108,7 @@ impl VdsoData {\n \n     /// Init vdso data based on the default clocksource.\n     fn init(&mut self) {\n-        let clocksource = jinux_time::default_clocksource();\n+        let clocksource = aster_time::default_clocksource();\n         let coeff = clocksource.coeff();\n         self.set_clock_mode(DEFAULT_CLOCK_MODE);\n         self.set_coeff(coeff);\ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -249,7 +249,7 @@ fn init_vdso() {\n pub(super) fn init() {\n     init_start_secs_count();\n     init_vdso();\n-    jinux_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n+    aster_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n }\n \n /// Return the vdso vmo.\ndiff --git a/services/libs/jinux-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\n--- a/services/libs/jinux-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -10,8 +10,8 @@\n //! [Zircon](https://fuchsia.dev/fuchsia-src/reference/kernel_objects/vm_object).\n //! As capabilities, the two abstractions are aligned with our goal\n //! of everything-is-a-capability, although their specifications and\n-//! implementations in C/C++ cannot apply directly to Jinux.\n-//! In Jinux, VMARs and VMOs, as well as other capabilities, are implemented\n+//! implementations in C/C++ cannot apply directly to Asterinas.\n+//! In Asterinas, VMARs and VMOs, as well as other capabilities, are implemented\n //! as zero-cost capabilities.\n \n pub mod page_fault_handler;\ndiff --git a/services/libs/jinux-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\n--- a/services/libs/jinux-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n use bitflags::bitflags;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n \n bitflags! {\n     /// The memory access permissions of memory mappings.\ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::{Vaddr, VmIo};\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::{Vaddr, VmIo};\n-use jinux_rights::Rights;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -23,8 +23,8 @@ impl Vmar<Rights> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -156,13 +156,13 @@ impl Vmar<Rights> {\n }\n \n impl VmIo for Vmar<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::sync::Arc;\n use alloc::sync::Weak;\n use alloc::vec::Vec;\n+use aster_frame::vm::VmSpace;\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::VmSpace;\n-use jinux_rights::Rights;\n \n use self::vm_mapping::VmMapping;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,7 +1,7 @@\n //! Options for allocating child VMARs.\n \n-use jinux_frame::config::PAGE_SIZE;\n-use jinux_frame::{Error, Result};\n+use aster_frame::config::PAGE_SIZE;\n+use aster_frame::{Error, Result};\n \n use super::Vmar;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -13,7 +13,7 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -28,8 +28,8 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar: Vmar<Full> = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,9 +1,9 @@\n use core::ops::Range;\n \n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::{Dup, Rights, TRightSet, TRights};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::VmIo;\n+use aster_rights::{Dup, Rights, TRightSet, TRights};\n+use aster_rights_proc::require;\n \n use crate::vm::{page_fault_handler::PageFaultHandler, vmo::Vmo};\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -28,8 +28,8 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::<RightsWrapper<Full>>::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -177,13 +177,13 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmar<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::sync::Mutex;\n+use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n use core::ops::Range;\n-use jinux_frame::sync::Mutex;\n-use jinux_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n \n use crate::vm::{\n     vmo::get_page_idx_range,\ndiff --git a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -2,9 +2,9 @@ use core::ops::Range;\n \n use crate::prelude::*;\n \n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::VmoRightsOp;\n use super::{\ndiff --git a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -150,13 +150,13 @@ impl Vmo<Rights> {\n }\n \n impl VmIo for Vmo<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -3,8 +3,8 @@\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n-use jinux_rights::Rights;\n+use aster_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n+use aster_rights::Rights;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -66,7 +66,7 @@ pub use pager::Pager;\n /// # Implementation\n ///\n /// `Vmo` provides high-level APIs for address space management by wrapping\n-/// around its low-level counterpart `jinux_frame::vm::VmFrames`.\n+/// around its low-level counterpart `aster_frame::vm::VmFrames`.\n /// Compared with `VmFrames`,\n /// `Vmo` is easier to use (by offering more powerful APIs) and\n /// harder to misuse (thanks to its nature of being capability).\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -4,15 +4,15 @@ use core::marker::PhantomData;\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n+use aster_rights_proc::require;\n use typeflags_util::{SetExtend, SetExtendOp};\n \n use crate::prelude::*;\n \n use crate::vm::vmo::get_inherited_frames_from_parent;\n use crate::vm::vmo::{VmoInner, Vmo_};\n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{Pager, Vmo, VmoFlags};\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -23,7 +23,7 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _dynamic_ capability with full access rights:\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -32,8 +32,8 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _static_ capability with all access rights:\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::<Full>::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -44,7 +44,7 @@ use super::{Pager, Vmo, VmoFlags};\n /// physically contiguous:\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n ///\n /// let vmo = VmoOptions::new(10 * PAGE_SIZE)\n ///     .flags(VmoFlags::RESIZABLE)\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -164,7 +164,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -178,8 +178,8 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo: Vmo<Full> = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -196,7 +196,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// right regardless of whether the parent is writable or not.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -211,7 +211,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// The above rule for COW VMO children also applies to static capabilities.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::<TRights![Read, Dup]>::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -227,7 +227,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// Note that a slice VMO child and its parent cannot not be resizable.\n ///\n /// ```rust\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\n--- a/services/libs/jinux-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmFrame;\n+use aster_frame::vm::VmFrame;\n \n /// Pagers provide frame to a VMO.\n ///\ndiff --git a/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,9 +1,9 @@\n use crate::prelude::*;\n+use aster_frame::vm::VmIo;\n+use aster_rights_proc::require;\n use core::ops::Range;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights_proc::require;\n \n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{\ndiff --git a/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -145,13 +145,13 @@ impl<R: TRights> Vmo<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmo<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\n--- a/services/libs/jinux-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -9,5 +9,5 @@\n /// _exclusively_ to one another. In other words, a type should not implement\n /// both traits.\n pub trait Dup: Sized {\n-    fn dup(&self) -> jinux_frame::Result<Self>;\n+    fn dup(&self) -> aster_frame::Result<Self>;\n }\ndiff --git a/services/libs/jinux-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\n--- a/services/libs/jinux-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The util of jinux\n+//! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \ndiff --git a/services/libs/jinux-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/jinux-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,10 +1,10 @@\n+use aster_frame::vm::Paddr;\n+use aster_frame::vm::{HasPaddr, VmIo};\n+use aster_frame::Result;\n+use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n use core::fmt::Debug;\n use core::marker::PhantomData;\n-use jinux_frame::vm::Paddr;\n-use jinux_frame::vm::{HasPaddr, VmIo};\n-use jinux_frame::Result;\n-use jinux_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \ndiff --git a/services/libs/jinux-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/jinux-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -358,14 +358,14 @@ impl<T, M: Debug, R> Debug for SafePtr<T, M, R> {\n #[macro_export]\n macro_rules! field_ptr {\n     ($ptr:expr, $type:ty, $($field:tt)+) => {{\n-        use jinux_frame::offset_of;\n-        use jinux_frame::vm::VmIo;\n-        use jinux_rights::Dup;\n-        use jinux_rights::TRightSet;\n-        use jinux_rights::TRights;\n-        use jinux_util::safe_ptr::Pod;\n-        use jinux_util::safe_ptr::SetContain;\n-        use jinux_util::safe_ptr::SafePtr;\n+        use aster_frame::offset_of;\n+        use aster_frame::vm::VmIo;\n+        use aster_rights::Dup;\n+        use aster_rights::TRightSet;\n+        use aster_rights::TRights;\n+        use aster_util::safe_ptr::Pod;\n+        use aster_util::safe_ptr::SetContain;\n+        use aster_util::safe_ptr::SafePtr;\n \n         #[inline]\n         fn new_field_ptr<T, M, R, U>(\ndiff --git a/services/libs/jinux-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\n--- a/services/libs/jinux-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -35,7 +35,7 @@ macro_rules! read_union_fields {\n         union_read_ptr.read_at(offset)\n     });\n     ($container:ident.$($field:ident).*) => ({\n-        let field_offset = jinux_frame::value_offset!($container.$($field).*);\n+        let field_offset = aster_frame::value_offset!($container.$($field).*);\n         let union_read_ptr = UnionReadPtr::new(&*$container);\n         union_read_ptr.read_at(field_offset)\n     });\ndiff --git a/services/libs/comp-sys/cargo-component/README.md b/services/libs/comp-sys/cargo-component/README.md\n--- a/services/libs/comp-sys/cargo-component/README.md\n+++ b/services/libs/comp-sys/cargo-component/README.md\n@@ -1,15 +1,15 @@\n ## Overview\n-The crate contains cargo-component, a cargo subcommand to enable component-level access control in Jinux. For more info about Jinux component system, see the [RFC](https://github.com/jinzhao-dev/jinux/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n+The crate contains cargo-component, a cargo subcommand to enable component-level access control in Asterinas. For more info about Asterinas component system, see the [RFC](https://github.com/asterinas/Asterinas/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n \n ## install\n-After running `make setup` for jinux, this crate can be created with cargo.\n+After running `make setup` for Asterinas, this crate can be created with cargo.\n ```shell\n cargo install --path .\n ```\n This will install two binaries `cargo-component` and `component-driver` at `$HOME/.cargo/bin`(by default, it depends on the cargo config).\n \n ## Usage\n-Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For jinux, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n+Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For Asterinas, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n \n ### Two notes:\n - The directory **where you run the command** should contains a `Components.toml` config file, where defines all components and whitelist. \ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,7 +1,7 @@\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\n-//! When use jinux-typeflags or jinux-rights-poc, this crate should also be added as a dependency.\n+//! When use typeflags or aster-rights-poc, this crate should also be added as a dependency.\n #![no_std]\n pub mod assert;\n pub mod bool;\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the procedural macro typeflags to implement capability for jinux.\n+//\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\n //! So we leave the common type-level operations and structures defined in typeflags-util.\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,6 +1,6 @@\n #!/bin/bash\n \n-# This script is used to update Jinux version numbers in all relevant files in the repository.\n+# This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \n # Update Cargo style versions (`version = \"{version}\"`) in file $1\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -9,16 +9,16 @@ update_cargo_versions() {\n     sed -i \"s/^version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"$/version = \\\"${new_version}\\\"/g\" $1\n }\n \n-# Update Docker image versions (`jinuxdev/jinux:{version}`) in file $1\n+# Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\n-    sed -i \"s/jinuxdev\\/jinux:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/jinuxdev\\/jinux:${new_version}/g\" $1\n+    sed -i \"s/asterinas\\/asterinas:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/asterinas\\/asterinas:${new_version}/g\" $1\n }\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/..\n-CARGO_TOML_PATH=${JINUX_SRC_DIR}/Cargo.toml\n-VERSION_PATH=${JINUX_SRC_DIR}/VERSION\n+ASTER_SRC_DIR=${SCRIPT_DIR}/..\n+CARGO_TOML_PATH=${ASTER_SRC_DIR}/Cargo.toml\n+VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n # Get and check the new version number\n if [[ $1 =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -32,14 +32,14 @@ fi\n update_cargo_versions ${CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p jinux --precise $new_version\n+cargo update -p asterinas --precise $new_version\n \n # Update Docker image versions in README files\n-update_image_versions ${JINUX_SRC_DIR}/README.md\n+update_image_versions ${ASTER_SRC_DIR}/README.md\n update_image_versions ${SCRIPT_DIR}/docker/README.md\n \n # Update Docker image versions in workflows\n-WORKFLOWS=$(find \"${JINUX_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n+WORKFLOWS=$(find \"${ASTER_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n for workflow in $WORKFLOWS; do\n     update_image_versions $workflow\n done\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -47,4 +47,4 @@ done\n # Create or update VERSION\n echo \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Jinux version to $new_version\"\n+echo \"Bumped Asterinas version to $new_version\"\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -182,15 +182,15 @@ RUN make defconfig \\\n     && sed -i \"s/# CONFIG_FEATURE_SH_STANDALONE is not set/CONFIG_FEATURE_SH_STANDALONE=y/g\" .config \\\n     && make -j\n \n-#= The final stages to produce the Jinux development image ====================\n+#= The final stages to produce the Asterinas development image ====================\n \n FROM build-base as rust\n \n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n-ARG JINUX_RUST_VERSION\n+ARG ASTER_RUST_VERSION\n RUN curl https://sh.rustup.rs -sSf | \\\n-        sh -s -- --default-toolchain ${JINUX_RUST_VERSION} -y \\\n+        sh -s -- --default-toolchain ${ASTER_RUST_VERSION} -y \\\n     && rm -rf /root/.cargo/registry && rm -rf /root/.cargo/git \\\n     && cargo -V \\\n     && rustup component add rust-src rustc-dev llvm-tools-preview\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -202,7 +202,7 @@ RUN cargo install \\\n \n FROM rust\n \n-# Install all Jinux dependent packages\n+# Install all Asterinas dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -249,9 +249,9 @@ COPY --from=busybox /root/busybox/busybox /bin/busybox\n # Install benchmarks built from the previous stages\n COPY --from=build-benchmarks /usr/local/benchmark /usr/local/benchmark\n \n-# Add the path of jinux tools\n-ENV PATH=\"/root/jinux/target/bin:${PATH}\"\n+# Add the path of Asterinas tools\n+ENV PATH=\"/root/asterinas/target/bin:${PATH}\"\n \n-VOLUME [ \"/root/jinux\" ]\n+VOLUME [ \"/root/asterinas\" ]\n \n-WORKDIR /root/jinux\n+WORKDIR /root/asterinas\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -3,9 +3,9 @@\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/../..\n+ASTER_SRC_DIR=${SCRIPT_DIR}/../..\n CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n-VERSION=$( cat ${JINUX_SRC_DIR}/VERSION )\n-IMAGE_NAME=jinuxdev/jinux:${VERSION}\n+VERSION=$( cat ${ASTER_SRC_DIR}/VERSION )\n+IMAGE_NAME=asterinas/asterinas:${VERSION}\n \n-docker run -it --privileged --network=host --device=/dev/kvm -v ${JINUX_SRC_DIR}:/root/jinux ${IMAGE_NAME}\n+docker run -it --privileged --network=host --device=/dev/kvm -v ${ASTER_SRC_DIR}:/root/asterinas ${IMAGE_NAME}\n",
        "test_patch": "diff --git a/.github/workflows/cargo_check.yml b/.github/workflows/cargo_check.yml\n--- a/.github/workflows/cargo_check.yml\n+++ b/.github/workflows/cargo_check.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/.github/workflows/integration_test.yml b/.github/workflows/integration_test.yml\n--- a/.github/workflows/integration_test.yml\n+++ b/.github/workflows/integration_test.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 30\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/.github/workflows/unit_test.yml b/.github/workflows/unit_test.yml\n--- a/.github/workflows/unit_test.yml\n+++ b/.github/workflows/unit_test.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -113,6 +113,250 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d92bec98840b8f03a5ff5413de5293bfcd8bf96467cf5452609f939ec6f5de16\"\n \n+[[package]]\n+name = \"aster-block\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-console\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-frame\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"acpi\",\n+ \"align_ext\",\n+ \"aml\",\n+ \"bit_field\",\n+ \"bitflags 1.3.2\",\n+ \"bitvec\",\n+ \"buddy_system_allocator\",\n+ \"cfg-if\",\n+ \"gimli\",\n+ \"inherit-methods-macro\",\n+ \"int-to-c-enum\",\n+ \"intrusive-collections\",\n+ \"ktest\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"multiboot2\",\n+ \"pod\",\n+ \"rsdp\",\n+ \"spin 0.9.8\",\n+ \"static_assertions\",\n+ \"tdx-guest\",\n+ \"trapframe\",\n+ \"unwinding\",\n+ \"volatile\",\n+ \"x86\",\n+ \"x86_64\",\n+]\n+\n+[[package]]\n+name = \"aster-frame-x86-boot-linux-setup\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"uart_16550\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-framebuffer\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"component\",\n+ \"font8x8\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-input\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+ \"virtio-input-decoder\",\n+]\n+\n+[[package]]\n+name = \"aster-network\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"bytes\",\n+ \"component\",\n+ \"int-to-c-enum\",\n+ \"log\",\n+ \"pod\",\n+ \"ringbuf\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-rights\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-rights-proc\",\n+ \"bitflags 1.3.2\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-rights-proc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"aster-runner\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"clap\",\n+ \"glob\",\n+ \"rand\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-std\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"ascii\",\n+ \"aster-block\",\n+ \"aster-console\",\n+ \"aster-frame\",\n+ \"aster-input\",\n+ \"aster-network\",\n+ \"aster-rights\",\n+ \"aster-rights-proc\",\n+ \"aster-time\",\n+ \"aster-util\",\n+ \"aster-virtio\",\n+ \"bitflags 1.3.2\",\n+ \"controlled\",\n+ \"core2\",\n+ \"cpio-decoder\",\n+ \"getrandom\",\n+ \"int-to-c-enum\",\n+ \"intrusive-collections\",\n+ \"keyable-arc\",\n+ \"ktest\",\n+ \"lazy_static\",\n+ \"lending-iterator\",\n+ \"libflate\",\n+ \"log\",\n+ \"lru\",\n+ \"pod\",\n+ \"ringbuf\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+ \"tdx-guest\",\n+ \"time\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+ \"virtio-input-decoder\",\n+ \"vte\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-time\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"component\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-util\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-rights-proc\",\n+ \"bitvec\",\n+ \"ktest\",\n+ \"pod\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-virtio\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"aster-block\",\n+ \"aster-console\",\n+ \"aster-frame\",\n+ \"aster-input\",\n+ \"aster-network\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bit_field\",\n+ \"bitflags 1.3.2\",\n+ \"bytes\",\n+ \"component\",\n+ \"int-to-c-enum\",\n+ \"log\",\n+ \"pod\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+ \"typeflags-util\",\n+ \"virtio-input-decoder\",\n+]\n+\n+[[package]]\n+name = \"asterinas\"\n+version = \"0.2.2\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-framebuffer\",\n+ \"aster-std\",\n+ \"aster-time\",\n+ \"component\",\n+ \"x86_64\",\n+]\n+\n [[package]]\n name = \"atomic-polyfill\"\n version = \"0.1.11\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -603,250 +847,6 @@ dependencies = [\n  \"either\",\n ]\n \n-[[package]]\n-name = \"jinux\"\n-version = \"0.2.2\"\n-dependencies = [\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-framebuffer\",\n- \"jinux-std\",\n- \"jinux-time\",\n- \"x86_64\",\n-]\n-\n-[[package]]\n-name = \"jinux-block\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"lazy_static\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-console\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-frame\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"acpi\",\n- \"align_ext\",\n- \"aml\",\n- \"bit_field\",\n- \"bitflags 1.3.2\",\n- \"bitvec\",\n- \"buddy_system_allocator\",\n- \"cfg-if\",\n- \"gimli\",\n- \"inherit-methods-macro\",\n- \"int-to-c-enum\",\n- \"intrusive-collections\",\n- \"ktest\",\n- \"lazy_static\",\n- \"log\",\n- \"multiboot2\",\n- \"pod\",\n- \"rsdp\",\n- \"spin 0.9.8\",\n- \"static_assertions\",\n- \"tdx-guest\",\n- \"trapframe\",\n- \"unwinding\",\n- \"volatile\",\n- \"x86\",\n- \"x86_64\",\n-]\n-\n-[[package]]\n-name = \"jinux-frame-x86-boot-linux-setup\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"uart_16550\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-framebuffer\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"component\",\n- \"font8x8\",\n- \"jinux-frame\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-input\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"lazy_static\",\n- \"log\",\n- \"spin 0.9.8\",\n- \"virtio-input-decoder\",\n-]\n-\n-[[package]]\n-name = \"jinux-network\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"bitflags 1.3.2\",\n- \"bytes\",\n- \"component\",\n- \"int-to-c-enum\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"log\",\n- \"pod\",\n- \"ringbuf\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-rights\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"jinux-rights-proc\",\n- \"typeflags\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"jinux-rights-proc\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n-[[package]]\n-name = \"jinux-runner\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anyhow\",\n- \"clap\",\n- \"glob\",\n- \"rand\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-std\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"ascii\",\n- \"bitflags 1.3.2\",\n- \"controlled\",\n- \"core2\",\n- \"cpio-decoder\",\n- \"getrandom\",\n- \"int-to-c-enum\",\n- \"intrusive-collections\",\n- \"jinux-block\",\n- \"jinux-console\",\n- \"jinux-frame\",\n- \"jinux-input\",\n- \"jinux-network\",\n- \"jinux-rights\",\n- \"jinux-rights-proc\",\n- \"jinux-time\",\n- \"jinux-util\",\n- \"jinux-virtio\",\n- \"keyable-arc\",\n- \"ktest\",\n- \"lazy_static\",\n- \"lending-iterator\",\n- \"libflate\",\n- \"log\",\n- \"lru\",\n- \"pod\",\n- \"ringbuf\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n- \"tdx-guest\",\n- \"time\",\n- \"typeflags\",\n- \"typeflags-util\",\n- \"virtio-input-decoder\",\n- \"vte\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-time\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-util\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitvec\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-rights-proc\",\n- \"ktest\",\n- \"pod\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"jinux-virtio\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"bit_field\",\n- \"bitflags 1.3.2\",\n- \"bytes\",\n- \"component\",\n- \"int-to-c-enum\",\n- \"jinux-block\",\n- \"jinux-console\",\n- \"jinux-frame\",\n- \"jinux-input\",\n- \"jinux-network\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"log\",\n- \"pod\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n- \"typeflags-util\",\n- \"virtio-input-decoder\",\n-]\n-\n [[package]]\n name = \"json\"\n version = \"0.12.4\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -33,8 +33,8 @@ panic = \"unwind\"\n \n members = [\n     \"runner\",\n-    \"framework/jinux-frame\",\n-    \"framework/jinux-frame/src/arch/x86/boot/linux_boot/setup\",\n+    \"framework/aster-frame\",\n+    \"framework/aster-frame/src/arch/x86/boot/linux_boot/setup\",\n     \"framework/libs/align_ext\",\n     \"framework/libs/ktest\",\n     \"framework/libs/tdx-guest\",\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -1,45 +1,45 @@\n-# Jinux\n+# Asterinas\n \n-Jinux is a _secure_, _fast_, and _general-purpose_ OS kernel, written in Rust and providing Linux-compatible ABI.\n+Asterinas is a _secure_, _fast_, and _general-purpose_ OS kernel, written in Rust and providing Linux-compatible ABI.\n \n-Jinux is designed and implemented with an emphasis on security, rendering it highly attractive for usage scenarios where Linux ABI is indispensable, but Linux itself is deemed insecure given its sheer size of TCB and its nature of being memory unsafe. An instance of such usage is employing Jinux as the guest OS for VM TEEs (e.g., [AMD SEV](https://www.amd.com/en/developer/sev.html) and [Intel TDX](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html)).\n+Asterinas is designed and implemented with an emphasis on security, rendering it highly attractive for usage scenarios where Linux ABI is indispensable, but Linux itself is deemed insecure given its sheer size of TCB and its nature of being memory unsafe. An instance of such usage is employing Asterinas as the guest OS for VM TEEs (e.g., [AMD SEV](https://www.amd.com/en/developer/sev.html) and [Intel TDX](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html)).\n \n-## What's unique about Jinux\n+## What's unique about Asterinas\n \n-Jinux is a _zero-cost_, _least-privilege_ OS kernel. A least-privilege OS is one that adheres to the principle of least privileges, which mandates that every unit (e.g., a subsystem, a module, a function, or even an object) of the OS has the minimum authority and permissions required to perform its tasks. This approach reduces the security risk associated with any single element's bugs or flaws. By \"zero-cost\", we means the same as in Rust's philosophy of zero-cost abstractions, which emphasizes that high-level abstractions (like those that enable least privilege principles) should be available to developers to use, but not come at the cost of performance. Thus, a zero-cost, least-privilege OS enhances its security without compromising its performance.\n+Asterinas is a _zero-cost_, _least-privilege_ OS kernel. A least-privilege OS is one that adheres to the principle of least privileges, which mandates that every unit (e.g., a subsystem, a module, a function, or even an object) of the OS has the minimum authority and permissions required to perform its tasks. This approach reduces the security risk associated with any single element's bugs or flaws. By \"zero-cost\", we means the same as in Rust's philosophy of zero-cost abstractions, which emphasizes that high-level abstractions (like those that enable least privilege principles) should be available to developers to use, but not come at the cost of performance. Thus, a zero-cost, least-privilege OS enhances its security without compromising its performance.\n \n Some prior OSes do abide by the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), but come with considerable performance costs. Take [seL4](https://sel4.systems/) as an example. A [seL4-based multi-server OS](https://docs.sel4.systems/projects/camkes/) minimizes the scope of the OS running in the privileged CPU mode to the seL4 microkernel. The bulk of OS functionalities are implemented by process-based servers, which are separated by process boundary and only allowed to communicate with each other through well-defined interfaces, usually based on RPC. Each service can only access kernel resources represented by [seL4 capabilities](), each of which is restricted with respect to its scope and permissions. All these security measures contribute to the enhanced security of the OS, but result in a considerable runtime costs due to context switching, message passing, and runtime checks.\n \n-Jinux is unique in practicing the principle of least privilege without sacrificing the performance. This is achieved by realizing the full potential of Rust, which, compared to the traditional system programming language like C/C++, offers unique features like an expressive type system, memory safety with unsafe extensions, powerful macros, and a customizable toolchain. By leveraging these unique features, Jinux is able to construct zero-cost abstractions that enable least privileges at the following three levels.\n+Asterinas is unique in practicing the principle of least privilege without sacrificing the performance. This is achieved by realizing the full potential of Rust, which, compared to the traditional system programming language like C/C++, offers unique features like an expressive type system, memory safety with unsafe extensions, powerful macros, and a customizable toolchain. By leveraging these unique features, Asterinas is able to construct zero-cost abstractions that enable least privileges at the following three levels.\n \n-1. The architectural level. Jinux is architected as a _framekernel_, where the entire OS resides in a single address space and unsafe Rust code is restricted to a tiny portion of the OS called Jinux Framework. The Framework exposes safe APIs to the rest of Jinux, which implements the most of OS functionalities in safe Rust code completely. Thanks to the framekernel architecture, Jinux's TCB for memory safety is minimized.\n+1. The architectural level. Asterinas is architected as a _framekernel_, where the entire OS resides in a single address space and unsafe Rust code is restricted to a tiny portion of the OS called Asterinas Framework. The Framework exposes safe APIs to the rest of Asterinas, which implements the most of OS functionalities in safe Rust code completely. Thanks to the framekernel architecture, Asterinas's TCB for memory safety is minimized.\n \n ![Architecture](docs/src/images/arch_comparison.png)\n \n-2. The component level. Upon Jinux Framework is a set of OS components, each of which is responsible for a particular OS functionality, feature, or device. These OS components are Rust crates with two traits: (1) containing safe Rust code, as demanded by the framekernel architecture, and (2) being governed by Jinux Component System, which can enforce a fine-grained access control to their public APIs. The access control policy is specified in a configuration file and enforced at compile time, using a static analysis tool.\n+2. The component level. Upon Asterinas Framework is a set of OS components, each of which is responsible for a particular OS functionality, feature, or device. These OS components are Rust crates with two traits: (1) containing safe Rust code, as demanded by the framekernel architecture, and (2) being governed by Asterinas Component System, which can enforce a fine-grained access control to their public APIs. The access control policy is specified in a configuration file and enforced at compile time, using a static analysis tool.\n \n-3. The object level. Jinux promotes the philosophy of _everything-is-a-capability_, which means all kernel resources, from files to threads, from virtual memory to physical pages, should be accessed through [capabilities](https://en.wikipedia.org/wiki/Capability-based_security). In Jinux, capabilities are implemented as Rust objects that are constrained in their creation, acquisition, and usage. One common form of capabilities is those with access rights. Wherever possible, access rights are encoded in types (rather than values) so that they can be checked at compile time, eliminating any runtime costs.\n+3. The object level. Asterinas promotes the philosophy of _everything-is-a-capability_, which means all kernel resources, from files to threads, from virtual memory to physical pages, should be accessed through [capabilities](https://en.wikipedia.org/wiki/Capability-based_security). In Asterinas, capabilities are implemented as Rust objects that are constrained in their creation, acquisition, and usage. One common form of capabilities is those with access rights. Wherever possible, access rights are encoded in types (rather than values) so that they can be checked at compile time, eliminating any runtime costs.\n \n-As a zero-cost, least-privilege OS, Jinux provides the best of both worlds: the performance of a monolithic kernel and the security of a microkernel. Like a monolithic kernel, the different parts of Jinux can communicate with the most efficient means, e.g., function calls and memory sharing. In the same spirit as a microkernel, the fundamental security properties of the OS depend on a minimum amount of code (i.e., Jinux Framework).\n+As a zero-cost, least-privilege OS, Asterinas provides the best of both worlds: the performance of a monolithic kernel and the security of a microkernel. Like a monolithic kernel, the different parts of Asterinas can communicate with the most efficient means, e.g., function calls and memory sharing. In the same spirit as a microkernel, the fundamental security properties of the OS depend on a minimum amount of code (i.e., Asterinas Framework).\n \n-## Build, test and debug Jinux\n+## Build, test and debug Asterinas\n \n While most of the code is written in Rust, the project-scope build process is governed by Makefile. The development environment is managed with Docker. Please ensure Docker is installed and can be run without sudo privilege.\n \n ### Preparation\n-1. Download the latest source code of jinux.\n+1. Download the latest source code of asterinas.\n ```bash\n git clone [repository url]\n ```\n \n 2. After downloading the source code, run the following command to pull the development image.\n ```bash\n-docker pull jinuxdev/jinux:0.2.2\n+docker pull asterinas/asterinas:0.2.2\n ```\n \n 3. Start the development container.\n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v `pwd`:/root/jinux jinuxdev/jinux:0.2.2\n+docker run -it --privileged --network=host --device=/dev/kvm -v `pwd`:/root/asterinas asterinas/asterinas:0.2.2\n ```\n \n **All build and test commands should be run inside the development container.**\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -70,14 +70,14 @@ Nevertheless, you could enter the directory of a specific crate and invoke `carg\n \n #### Kernel mode unit tests\n \n-We can run unit tests in kernel mode for crates like `jinux-frame` or `jinux-std`. This is powered by our [ktest](framework/libs/ktest) framework.\n+We can run unit tests in kernel mode for crates like `aster-frame` or `aster-std`. This is powered by our [ktest](framework/libs/ktest) framework.\n ```bash\n make run KTEST=1\n ```\n \n You could also specify tests in a crate or a subset of tests to run.\n ```bash\n-make run KTEST=1 KTEST_WHITELIST=failing_assertion,jinux_frame::test::expect_panic KTEST_CRATES=jinux-frame\n+make run KTEST=1 KTEST_WHITELIST=failing_assertion,aster_frame::test::expect_panic KTEST_CRATES=aster-frame\n ```\n \n #### Component check\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -96,33 +96,33 @@ cargo component-check\n \n #### Regression Test\n \n-This command will automatically run Jinux with the test binaries in `regression/apps` directory.\n+This command will automatically run Asterinas with the test binaries in `regression/apps` directory.\n ```bash\n make run AUTO_TEST=regression\n ```\n \n #### Syscall Test\n \n-This command will build the syscall test binary and automatically run Jinux with the tests using QEMU.\n+This command will build the syscall test binary and automatically run Asterinas with the tests using QEMU.\n ```bash\n make run AUTO_TEST=syscall\n ```\n \n-Alternatively, if you wish to test it interactively inside a shell in Jinux.\n+Alternatively, if you wish to test it interactively inside a shell in Asterinas.\n ```bash\n make run BUILD_SYSCALL_TEST=1\n ```\n \n-Then, we can run the following script using the Jinux shell to run all syscall test cases.\n+Then, we can run the following script using the Asterinas shell to run all syscall test cases.\n ```bash\n /opt/syscall_test/run_syscall_test.sh\n ```\n \n ### Debug\n \n-To debug Jinux using [QEMU GDB remote debugging](https://qemu-project.gitlab.io/qemu/system/gdb.html), you could compile Jinux in debug mode, start a Jinux instance and run the GDB interactive shell in another terminal.\n+To debug Asterinas using [QEMU GDB remote debugging](https://qemu-project.gitlab.io/qemu/system/gdb.html), you could compile Asterinas in debug mode, start a Asterinas instance and run the GDB interactive shell in another terminal.\n \n-To start a QEMU Jinux VM and wait for debugging connection:\n+To start a QEMU Asterinas VM and wait for debugging connection:\n ```bash\n make run GDB_SERVER=1 ENABLE_KVM=0\n ```\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -132,33 +132,33 @@ To get the GDB interactive shell:\n make run GDB_CLIENT=1\n ```\n \n-Currently, the Jinux runner's debugging interface is exposed by unix socket. Thus there shouldn't be multiple debugging instances in the same container. To add debug symbols for the underlying infrastructures such as UEFI firmware or bootloader, please check the runner's source code for details.\n+Currently, the Asterinas runner's debugging interface is exposed by unix socket. Thus there shouldn't be multiple debugging instances in the same container. To add debug symbols for the underlying infrastructures such as UEFI firmware or bootloader, please check the runner's source code for details.\n \n ## Code organization\n \n-The codebase of Jinux is organized as below.\n+The codebase of Asterinas is organized as below.\n \n-* `runner/`: creating a bootable Jinux kernel image along with an initramfs image. It also supports `cargo run` since it is the only package with `main()`.\n-* `kernel/`: defining the entry point of the Jinux kernel.\n-* `framework/`: the privileged half of Jinux (allowed to use `unsafe` keyword)\n-    * `jinux-frame`: providing the safe Rust abstractions for low-level resources like CPU, memory, interrupts, etc;\n+* `runner/`: creating a bootable Asterinas kernel image along with an initramfs image. It also supports `cargo run` since it is the only package with `main()`.\n+* `kernel/`: defining the entry point of the Asterinas kernel.\n+* `framework/`: the privileged half of Asterinas (allowed to use `unsafe` keyword)\n+    * `aster-frame`: providing the safe Rust abstractions for low-level resources like CPU, memory, interrupts, etc;\n     * `libs`: Privileged libraries.\n-* `services/`: the unprivileged half of Jinux (not allowed to use `unsafe` directly), implementing most of the OS functionalities.\n-    * `comps/`: Jinux OS components;\n-    * `libs/`: Jinux OS libraries;\n-        * `jinux-std`: this is where system calls are implemented. Currently, this crate is too big. It will eventually be decomposed into smaller crates.\n+* `services/`: the unprivileged half of Asterinas (not allowed to use `unsafe` directly), implementing most of the OS functionalities.\n+    * `comps/`: Asterinas OS components;\n+    * `libs/`: Asterinas OS libraries;\n+        * `aster-std`: this is where system calls are implemented. Currently, this crate is too big. It will eventually be decomposed into smaller crates.\n * `tests/`: providing integration tests written in Rust.\n * `regression/`: providing user-space tests written in C.\n-* `docs/`: The Jinux book (needs a major update).\n+* `docs/`: The Asterinas book (needs a major update).\n \n ## Development status\n \n-Jinux is under active development. The list below summarizes the progress of important planned features.\n+Asterinas is under active development. The list below summarizes the progress of important planned features.\n \n * Technical novelty\n-    - [X] Jinux Framework\n-    - [X] Jinux Component System\n-    - [X] Jinux Capabilities\n+    - [X] Asterinas Framework\n+    - [X] Asterinas Component System\n+    - [X] Asterinas Capabilities\n * High-level stuff\n     * Process management\n         - [X] Essential system calls (fork, execve, etc.)\ndiff --git a/docs/src/README.md b/docs/src/README.md\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -79,24 +79,24 @@ relational databases:\n [Oracle and IBM are losing ground as Chinese vendors catch up with their US counterparts](https://www.theregister.com/2022/07/06/international_database_vendors_are_losing/).\n Can such success stories be repeated in the field of OSes? I think so.\n There are some China's home-grown OSes like [openKylin](https://www.openkylin.top/index.php?lang=en), but all of them are based on Linux and lack a self-developed\n-OS _kernel_. The long-term goal of Jinux is to fill this key missing core of the home-grown OSes.\n+OS _kernel_. The long-term goal of Asterinas is to fill this key missing core of the home-grown OSes.\n \n ## Architecture Overview\n \n-Here is an overview of the architecture of Jinux.\n+Here is an overview of the architecture of Asterinas.\n \n ![architecture overview](images/arch_overview.png)\n \n ## Features\n \n-**1. Security by design.** Security is our top priority in the design of Jinux. As such, we adopt the widely acknowledged security best practice of [least privilege principle](https://en.wikipedia.org/wiki/Principle_of_least_privilege) and enforce it in a fashion that leverages the full strengths of Rust. To do so, we partition Jinux into two halves: a _privileged_ OS core and _unprivileged_ OS components. All OS components are written entirely in _safe_ Rust and only the privileged OS core\n+**1. Security by design.** Security is our top priority in the design of Asterinas. As such, we adopt the widely acknowledged security best practice of [least privilege principle](https://en.wikipedia.org/wiki/Principle_of_least_privilege) and enforce it in a fashion that leverages the full strengths of Rust. To do so, we partition Asterinas into two halves: a _privileged_ OS core and _unprivileged_ OS components. All OS components are written entirely in _safe_ Rust and only the privileged OS core\n is allowed to have _unsafe_ Rust code. Furthermore, we propose the idea of _everything-is-a-capability_, which elevates the status of [capabilities](https://en.wikipedia.org/wiki/Capability-based_security) to the level of a ubiquitous security primitive used throughout the OS. We make novel use of Rust's advanced features (e.g., [type-level programming](https://willcrichton.net/notes/type-level-programming/)) to make capabilities more accessible and efficient. The net result is improved security and uncompromised performance.\n \n-**2. Trustworthy OS-level virtualization.** OS-level virtualization mechanisms (like Linux's cgroups and namespaces) enable containers, a more lightweight and arguably more popular alternative to virtual machines (VMs). But there is one problem with containers: they are not as secure as VMs (see [StackExchange](https://security.stackexchange.com/questions/169642/what-makes-docker-more-secure-than-vms-or-bare-metal), [LWN](https://lwn.net/Articles/796700/), and [AWS](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/security-tasks-containers.html)). There is a real risk that malicious containers may exploit privilege escalation bugs in the OS kernel to attack the host. [A study](https://dl.acm.org/doi/10.1145/3274694.3274720) found that 11 out of 88 kernel exploits are effective in breaking the container sandbox. The seemingly inherent insecurity of OS kernels leads to a new breed of container implementations (e.g., [Kata](https://katacontainers.io/) and [gVisor](https://gvisor.dev/)) that are based on VMs, instead of kernels, for isolation and sandboxing. We argue that this unfortunate retreat from OS-level virtualization to VM-based one is unwarranted---if the OS kernels are secure enough. And this is exactly what we plan to achieve with Jinux. We aim to provide a trustworthy OS-level virtualization mechanism on Jinux.\n+**2. Trustworthy OS-level virtualization.** OS-level virtualization mechanisms (like Linux's cgroups and namespaces) enable containers, a more lightweight and arguably more popular alternative to virtual machines (VMs). But there is one problem with containers: they are not as secure as VMs (see [StackExchange](https://security.stackexchange.com/questions/169642/what-makes-docker-more-secure-than-vms-or-bare-metal), [LWN](https://lwn.net/Articles/796700/), and [AWS](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/security-tasks-containers.html)). There is a real risk that malicious containers may exploit privilege escalation bugs in the OS kernel to attack the host. [A study](https://dl.acm.org/doi/10.1145/3274694.3274720) found that 11 out of 88 kernel exploits are effective in breaking the container sandbox. The seemingly inherent insecurity of OS kernels leads to a new breed of container implementations (e.g., [Kata](https://katacontainers.io/) and [gVisor](https://gvisor.dev/)) that are based on VMs, instead of kernels, for isolation and sandboxing. We argue that this unfortunate retreat from OS-level virtualization to VM-based one is unwarranted---if the OS kernels are secure enough. And this is exactly what we plan to achieve with Asterinas. We aim to provide a trustworthy OS-level virtualization mechanism on Asterinas.\n \n-**3. Fast user-mode development.** Traditional OS kernels like Linux are hard to develop, test, and debug. Kernel development involves countless rounds of programming, failing, and rebooting on bare-metal or virtual machines. This way of life is unproductive and painful. Such a pain point is also recognized and partially addressed by [research work](https://www.usenix.org/conference/fast21/presentation/miller), but we think we can do more. In this spirit, we design the OS core to provide high-level APIs that are largely independent of the underlying hardware and implement it with two targets: one target is as part of a regular OS in kernel space and the other is as a library OS in user space. This way, all the OS components of Jinux, which are stacked above the OS core, can be developed, tested, and debugged in user space, which is more friendly to developers than kernel space.\n+**3. Fast user-mode development.** Traditional OS kernels like Linux are hard to develop, test, and debug. Kernel development involves countless rounds of programming, failing, and rebooting on bare-metal or virtual machines. This way of life is unproductive and painful. Such a pain point is also recognized and partially addressed by [research work](https://www.usenix.org/conference/fast21/presentation/miller), but we think we can do more. In this spirit, we design the OS core to provide high-level APIs that are largely independent of the underlying hardware and implement it with two targets: one target is as part of a regular OS in kernel space and the other is as a library OS in user space. This way, all the OS components of Asterinas, which are stacked above the OS core, can be developed, tested, and debugged in user space, which is more friendly to developers than kernel space.\n \n-**4. High-fidelity Linux ABI.** An OS without usable applications is useless. So we believe it is important for Jinux to fit in an established and thriving ecosystem of software, such as the one around Linux. This is why we conclude that Jinux should aim at implementing high-fidelity Linux ABI, including the system calls, the proc file system, etc.\n+**4. High-fidelity Linux ABI.** An OS without usable applications is useless. So we believe it is important for Asterinas to fit in an established and thriving ecosystem of software, such as the one around Linux. This is why we conclude that Asterinas should aim at implementing high-fidelity Linux ABI, including the system calls, the proc file system, etc.\n \n **5. TEEs as top-tier targets.** (Todo)\n \ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -351,7 +351,7 @@ mod test {\n \n ### Implement access rights with typeflags\n \n-The `Jinux-rights/lib.rs` file implements access rights.\n+The `aster-rights/lib.rs` file implements access rights.\n \n ```rust\n //! Access rights.\ndiff --git a/framework/README.md b/framework/README.md\n--- a/framework/README.md\n+++ b/framework/README.md\n@@ -1,20 +1,20 @@\n-# Jinux Framework\n+# Asterinas Framework\n \n-Jinux Framework is a Rust OS framework that facilitates the development of and innovation in OS kernels written in Rust.\n+Asterinas Framework is a Rust OS framework that facilitates the development of and innovation in OS kernels written in Rust.\n \n ## An overview\n \n-Jinux Framework provides a solid foundation for Rust developers to build their own OS kernels. While Jinux Framework origins from Jinux, the first ever framekernel, Jinux Framework is well suited for building OS kernels of any architecture, be it a framekernel, a monolithic kernel, or a microkernel.\n+Asterinas Framework provides a solid foundation for Rust developers to build their own OS kernels. While Asterinas Framework origins from Asterinas, the first ever framekernel, Asterinas Framework is well suited for building OS kernels of any architecture, be it a framekernel, a monolithic kernel, or a microkernel.\n \n-Jinux Framework offers the following key values.\n+Asterinas Framework offers the following key values.\n \n-1. **Lowering the entry bar for OS innovation.** Building an OS from scratch is not easy. Not to mention a novel one. Before adding any novel or interesting feature, an OS developer must first have something runnable, which must include basic functionalities for managing CPU, memory, and interrupts. Jinux Framework has laid this groundwork so that OS developers do not have to deal with the most low-level, error-prone, architecture-specific aspects of OS development themselves.\n+1. **Lowering the entry bar for OS innovation.** Building an OS from scratch is not easy. Not to mention a novel one. Before adding any novel or interesting feature, an OS developer must first have something runnable, which must include basic functionalities for managing CPU, memory, and interrupts. Asterinas Framework has laid this groundwork so that OS developers do not have to deal with the most low-level, error-prone, architecture-specific aspects of OS development themselves.\n \n-2. **Enhancing the memory safety of Rust OSes.** Jinux Framework encapsulates low-level, machine-oriented unsafe Rust code into high-level, machine-agnostic safe APIs. These APIs are carefully designed and implemented to be sound and minimal, ensuring the memory safety of any safe Rust callers. Our experience in building Jinux has shown that Jinux Framework is powerful enough to allow a feature-rich, Linux-compatible kernel to be completely written in safe Rust, including its device drivers.\n+2. **Enhancing the memory safety of Rust OSes.** Asterinas Framework encapsulates low-level, machine-oriented unsafe Rust code into high-level, machine-agnostic safe APIs. These APIs are carefully designed and implemented to be sound and minimal, ensuring the memory safety of any safe Rust callers. Our experience in building Asterinas has shown that Asterinas Framework is powerful enough to allow a feature-rich, Linux-compatible kernel to be completely written in safe Rust, including its device drivers.\n \n-3. **Promoting code reuse across Rust OS projects.** Shipped as crates, Rust code can be reused across projects---except when they are OSes. A crate that implements a feature or driver for OS A can hardly be reused by OS B because the crate must be [`no_std`](https://docs.rust-embedded.org/book/intro/no-std.html#summary) and depend on the infrastructure APIs provided by OS A, which are obviously different from that provided by OS B. This incompatibility problem can be resolved by Jinux Framework as it can serve as a common ground across different Rust OS projects, as long as they are built upon Jinux Framework.\n+3. **Promoting code reuse across Rust OS projects.** Shipped as crates, Rust code can be reused across projects---except when they are OSes. A crate that implements a feature or driver for OS A can hardly be reused by OS B because the crate must be [`no_std`](https://docs.rust-embedded.org/book/intro/no-std.html#summary) and depend on the infrastructure APIs provided by OS A, which are obviously different from that provided by OS B. This incompatibility problem can be resolved by Asterinas Framework as it can serve as a common ground across different Rust OS projects, as long as they are built upon Asterinas Framework.\n \n-4. **Boost productivity with user-mode development.** Traditionally, developing a kernel feature involves countless rounds of coding, failing, and rebooting on bare-metal or virtual machines, which is a painfully slow process. Jinux Framework accelerates the process by allowing high-level OS features like file systems and network stacks to be quickly tested in user mode, making the experience of OS development as smooth as that of application development. To support user-mode development, Jinux Framework is implemented for the Linux platform, in addition to bare-mental or virtual machine environments.\n+4. **Boost productivity with user-mode development.** Traditionally, developing a kernel feature involves countless rounds of coding, failing, and rebooting on bare-metal or virtual machines, which is a painfully slow process. Asterinas Framework accelerates the process by allowing high-level OS features like file systems and network stacks to be quickly tested in user mode, making the experience of OS development as smooth as that of application development. To support user-mode development, Asterinas Framework is implemented for the Linux platform, in addition to bare-mental or virtual machine environments.\n \n ## Framework APIs\n \ndiff --git a/framework/jinux-frame/Cargo.toml b/framework/aster-frame/Cargo.toml\n--- a/framework/jinux-frame/Cargo.toml\n+++ b/framework/aster-frame/Cargo.toml\n@@ -13,17 +13,17 @@ bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n buddy_system_allocator = \"0.9.0\"\n cfg-if = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n-inherit-methods-macro = { git = \"https://github.com/jinzhao-dev/inherit-methods-macro\", rev = \"98f7e3e\" }\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n int-to-c-enum = { path = \"../../services/libs/int-to-c-enum\" }\n intrusive-collections = \"0.9.5\"\n ktest = { path = \"../libs/ktest\" }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n log = \"0.4\"\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n spin = \"0.9.4\"\n static_assertions = \"1.1.0\"\n tdx-guest = { path = \"../libs/tdx-guest\", optional = true }\n-trapframe = { git = \"https://github.com/jinzhao-dev/trapframe-rs\", rev = \"9758a83\" }\n+trapframe = { git = \"https://github.com/asterinas/trapframe-rs\", rev = \"2f37590\" }\n unwinding = { version = \"0.2.1\", default-features = false, features = [\"fde-static\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n \ndiff --git a/framework/jinux-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\n--- a/framework/jinux-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -103,17 +103,17 @@ pub fn init() {\n \n /// Call the framework-user defined entrypoint of the actual kernel.\n ///\n-/// Any kernel that uses the jinux-frame crate should define a function named\n-/// `jinux_main` as the entrypoint.\n-pub fn call_jinux_main() -> ! {\n+/// Any kernel that uses the aster-frame crate should define a function named\n+/// `aster_main` as the entrypoint.\n+pub fn call_aster_main() -> ! {\n     #[cfg(not(ktest))]\n     unsafe {\n         // The entry point of kernel code, which should be defined by the package that\n-        // uses jinux-frame.\n+        // uses aster-frame.\n         extern \"Rust\" {\n-            fn jinux_main() -> !;\n+            fn aster_main() -> !;\n         }\n-        jinux_main();\n+        aster_main();\n     }\n     #[cfg(ktest)]\n     {\ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -1,10 +1,10 @@\n-//! # The kernel mode testing framework of Jinux.\n+//! # The kernel mode testing framework of Asterinas.\n //!\n //! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\n //! `cargo test`-like experience for any `#![no_std]` bare metal crates.\n //!\n-//! In Jinux, all the tests written in the source tree of the crates will be run\n-//! immediately after the initialization of jinux-frame. Thus you can use any\n+//! In Asterinas, all the tests written in the source tree of the crates will be run\n+//! immediately after the initialization of aster-frame. Thus you can use any\n //! feature provided by the frame including the heap allocator, etc.\n //!\n //! By all means, ktest is an individule crate that only requires:\ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -39,7 +39,7 @@\n //! }\n //! ```\n //!\n-//! And also, any crates using the ktest framework should be linked with jinux-frame\n+//! And also, any crates using the ktest framework should be linked with aster-frame\n //! and import the `ktest` crate:\n //!\n //! ```toml\ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -67,14 +67,14 @@\n //! This is achieved by a whitelist filter on the test name.\n //!\n //! ```bash\n-//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,jinux_frame::test::expect_panic\n+//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,aster_frame::test::expect_panic\n //! ```\n //!\n //! `KTEST_CRATES` variable is used to specify in which crates the tests to be run.\n //! This is achieved by conditionally compiling the test module using the `#[cfg]`.\n //!\n //! ```bash\n-//! make run KTEST=1 KTEST_CRATES=jinux-frame\n+//! make run KTEST=1 KTEST_CRATES=aster-frame\n //! ``\n //!\n //! We support the `#[should_panic]` attribute just in the same way as the standard\ndiff --git a/regression/apps/signal_c/signal_test.c b/regression/apps/signal_c/signal_test.c\n--- a/regression/apps/signal_c/signal_test.c\n+++ b/regression/apps/signal_c/signal_test.c\n@@ -184,7 +184,7 @@ int test_handle_sigfpe() {\n     c = div_maybe_zero(a, b);\n     fxsave(y);\n \n-    // jinux does not save and restore fpregs now, so we emit this check.\n+    // Asterinas does not save and restore fpregs now, so we emit this check.\n     // if (memcmp(x, y, 512) != 0) {\n     //     THROW_ERROR(\"floating point registers are modified\");\n     // }\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -3,8 +3,8 @@ TESTS ?= open_test read_test statfs_test chmod_test pty_test uidgid_test vdso_cl\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n BUILD_DIR ?= $(CUR_DIR)/../build\n-ifdef JINUX_PREBUILT_SYSCALL_TEST\n-\tBIN_DIR := $(JINUX_PREBUILT_SYSCALL_TEST)\n+ifdef ASTER_PREBUILT_SYSCALL_TEST\n+\tBIN_DIR := $(ASTER_PREBUILT_SYSCALL_TEST)\n else\n \tBIN_DIR := $(BUILD_DIR)/syscall_test_bins\n \tSRC_DIR := $(BUILD_DIR)/gvisor_src\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -21,7 +21,7 @@ all: $(TESTS)\n $(TESTS): $(BIN_DIR) $(TARGET_DIR)\n \t@cp -f $</$@ $(TARGET_DIR)/tests\n \n-ifndef JINUX_PREBUILT_SYSCALL_TEST\n+ifndef ASTER_PREBUILT_SYSCALL_TEST\n $(BIN_DIR): $(SRC_DIR)\n \t@if ! type bazel > /dev/null; then \\\n \t\techo \"bazel is not installed, please run $(CUR_DIR)/install_bazel.sh with sudo permission to install it.\"; \\\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -33,7 +33,7 @@ $(BIN_DIR): $(SRC_DIR)\n \n $(SRC_DIR):\n \t@rm -rf $@ && mkdir -p $@\n-\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n+\t@cd $@ && git clone -b 20200921.0 https://github.com/asterinas/gvisor.git .\n endif\n \n $(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST)\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -1,8 +1,8 @@\n-//! jinux-runner is the Jinux runner script to ease the pain of running\n-//! and testing Jinux inside a QEMU VM. It should be built and run as the\n+//! aster-runner is the Asterinas runner script to ease the pain of running\n+//! and testing Asterinas inside a QEMU VM. It should be built and run as the\n //! cargo runner: https://doc.rust-lang.org/cargo/reference/config.html\n //!\n-//! The runner will generate the filesystem image for starting Jinux. If\n+//! The runner will generate the filesystem image for starting Asterinas. If\n //! we should use the runner in the default mode, which invokes QEMU with\n //! a GRUB boot device image, the runner would be responsible for generating\n //! the appropriate kernel image and the boot device image. It also supports\ndiff --git a/services/libs/jinux-std/src/driver/mod.rs b/services/libs/aster-std/src/driver/mod.rs\n--- a/services/libs/jinux-std/src/driver/mod.rs\n+++ b/services/libs/aster-std/src/driver/mod.rs\n@@ -2,14 +2,14 @@ use log::info;\n \n pub fn init() {\n     // print all the input device to make sure input crate will compile\n-    for (name, _) in jinux_input::all_devices() {\n+    for (name, _) in aster_input::all_devices() {\n         info!(\"Found Input device, name:{}\", name);\n     }\n }\n \n #[allow(unused)]\n fn block_device_test() {\n-    for (_, device) in jinux_block::all_devices() {\n+    for (_, device) in aster_block::all_devices() {\n         let mut write_buffer = [0u8; 512];\n         let mut read_buffer = [0u8; 512];\n         info!(\"write_buffer address:{:x}\", write_buffer.as_ptr() as usize);\ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -139,8 +139,8 @@ mod test {\n     use crate::vm::perms::VmPerms;\n     use crate::vm::vmo::VmoRightsOp;\n     use crate::vm::{vmar::ROOT_VMAR_HIGHEST_ADDR, vmo::VmoOptions};\n-    use jinux_frame::vm::VmIo;\n-    use jinux_rights::Full;\n+    use aster_frame::vm::VmIo;\n+    use aster_rights::Full;\n \n     #[ktest]\n     fn root_vmar() {\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -519,8 +519,8 @@ impl VmoChildType for VmoCowChild {}\n #[if_cfg_ktest]\n mod test {\n     use super::*;\n-    use jinux_frame::vm::VmIo;\n-    use jinux_rights::Full;\n+    use aster_frame::vm::VmIo;\n+    use aster_rights::Full;\n \n     #[ktest]\n     fn alloc_vmo() {\ndiff --git a/services/libs/jinux-util/Cargo.toml b/services/libs/aster-util/Cargo.toml\n--- a/services/libs/jinux-util/Cargo.toml\n+++ b/services/libs/aster-util/Cargo.toml\n@@ -1,16 +1,16 @@\n [package]\n-name = \"jinux-util\"\n+name = \"aster-util\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n typeflags-util = { path = \"../typeflags-util\" }\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n-jinux-rights = { path = \"../jinux-rights\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n+aster-rights = { path = \"../aster-rights\" }\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n ktest = { path = \"../../../framework/libs/ktest\" }\n [features]\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -226,7 +226,7 @@ RUN apt clean && rm -rf /var/lib/apt/lists/*\n \n # Prepare the system call test suite\n COPY --from=syscall_test /root/syscall_test/build/syscall_test_bins /root/syscall_test_bins\n-ENV JINUX_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n+ENV ASTER_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n \n # Install QEMU built from the previous stages\n COPY --from=qemu /usr/local/qemu /usr/local/qemu\ndiff --git a/tools/docker/README.md b/tools/docker/README.md\n--- a/tools/docker/README.md\n+++ b/tools/docker/README.md\n@@ -1,35 +1,35 @@\n-# Jinux Development Docker Images\n+# Asterinas Development Docker Images\n \n-Jinux development Docker images are provided to facilitate developing and testing Jinux project. These images can be found in the [jinuxdev/jinux](https://hub.docker.com/r/jinuxdev/jinux/) repository on DockerHub.\n+Asterinas development Docker images are provided to facilitate developing and testing Asterinas project. These images can be found in the [asterinas/asterinas](https://hub.docker.com/r/asterinas/asterinas/) repository on DockerHub.\n \n ## Building Docker Images\n \n-To build a Docker image for Jinux and test it on your local machine, navigate to the root directory of the Jinux source code tree and execute the following command:\n+To build a Docker image for Asterinas and test it on your local machine, navigate to the root directory of the Asterinas source code tree and execute the following command:\n \n ```bash\n docker buildx build \\\n     -f tools/docker/Dockerfile.ubuntu22.04 \\\n-    --build-arg JINUX_RUST_VERSION=$RUST_VERSION \\\n-    -t jinuxdev/jinux:$JINUX_VERSION \\\n+    --build-arg ASTER_RUST_VERSION=$RUST_VERSION \\\n+    -t asterinas/asterinas:$ASTER_VERSION \\\n     .\n ```\n \n The meanings of the two environment variables in the command are as follows:\n \n-- `$JINUX_VERSION`: Represents the version number of Jinux. You can find this in the `VERSION` file.\n+- `$ASTER_VERSION`: Represents the version number of Asterinas. You can find this in the `VERSION` file.\n - `$RUST_VERSION`: Denotes the required Rust toolchain version, as specified in the `rust-toolchain` file.\n \n ## Tagging Docker Images\n \n-It's essential for each Jinux Docker image to have a distinct tag. By convention, the tag is assigned with the version number of the Jinux project itself. This methodology ensures clear correspondence between a commit of the source code and its respective Docker image.\n+It's essential for each Asterinas Docker image to have a distinct tag. By convention, the tag is assigned with the version number of the Asterinas project itself. This methodology ensures clear correspondence between a commit of the source code and its respective Docker image.\n \n If a commit needs to create a new Docker image, it should\n \n 1. Update the Dockerfile as well as other materials relevant to the Docker image, and\n-2. Run [`tools/bump_version.sh`](../bump_version.sh) tool to update the Jinux project's version number.\n+2. Run [`tools/bump_version.sh`](../bump_version.sh) tool to update the Asterinas project's version number.\n  \n For bug fixes or small changes, increment the last number of a [SemVer](https://semver.org/) by one. For major features or releases, increment the second number. All changes made in the two steps should be included in the commit.\n \n ## Uploading Docker Images\n \n-New versions of Jinux's Docker images are automatically uploaded to DockerHub through Github Actions. Simply submit your PR that updates Jinux's Docker image for review. After getting the project maintainers' approval, the [Docker image building workflow](../../.github/workflows/docker_build.yml) will be started, building the new Docker image and pushing it to DockerHub.\n\\ No newline at end of file\n+New versions of Asterinas's Docker images are automatically uploaded to DockerHub through Github Actions. Simply submit your PR that updates Asterinas's Docker image for review. After getting the project maintainers' approval, the [Docker image building workflow](../../.github/workflows/docker_build.yml) will be started, building the new Docker image and pushing it to DockerHub.\n\\ No newline at end of file\n",
        "problem_statement": "Rename the project name from Jinux to Asterinas\nThe project's official name will be Asterinas. The renaming process consists of the following steps:\r\n1. The Github repo will be renamed to `asterinas` and moved to the `asterinas` Github org. \r\n2. The DockerHub Image will be moved to `asterinas/asterinas`.\r\n3. All occurrences of `Jinux` in the codebase should be renamed to `Asterinas`.\r\n4. All occurrences of `jinux-` (or `jinux_`) as in the codebase should be renamed to `aster-` (or `aster_`).\r\n5. The ascii-art LOGO should be replaced accordingly.\r\n\r\nWe will make the project open source as long as we are given the green light by the management. Renaming will be done the first day when the project is open sourced.\r\n\n",
        "hints_text": "",
        "created_at": "2023-12-25T03:34:33Z",
        "version": "0.2"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 395,
        "instance_id": "asterinas__asterinas-395",
        "issue_numbers": [
            "254"
        ],
        "base_commit": "576578baf4025686ae4c2893c2aafbc8d1e14722",
        "patch": "diff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -12,6 +12,8 @@ pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \n+use self::tty::get_n_tty;\n+\n /// Init the device node in fs, must be called after mounting rootfs.\n pub fn init() -> Result<()> {\n     let null = Arc::new(null::Null);\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -19,7 +21,9 @@ pub fn init() -> Result<()> {\n     let zero = Arc::new(zero::Zero);\n     add_node(zero, \"zero\")?;\n     tty::init();\n-    let tty = tty::get_n_tty().clone();\n+    let console = get_n_tty().clone();\n+    add_node(console, \"console\")?;\n+    let tty = Arc::new(tty::TtyDevice);\n     add_node(tty, \"tty\")?;\n     let random = Arc::new(random::Random);\n     add_node(random, \"random\")?;\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Null;\n \ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -12,7 +15,9 @@ impl Device for Null {\n         // Same value with Linux\n         DeviceId::new(1, 3)\n     }\n+}\n \n+impl FileIo for Null {\n     fn read(&self, _buf: &mut [u8]) -> Result<usize> {\n         Ok(0)\n     }\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -20,4 +25,9 @@ impl Device for Null {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/jinux-std/src/device/pty/mod.rs\n--- a/services/libs/jinux-std/src/device/pty/mod.rs\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -33,7 +33,7 @@ pub fn init() -> Result<()> {\n \n pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n     debug!(\"pty index = {}\", index);\n-    let master = Arc::new(PtyMaster::new(ptmx, index));\n-    let slave = Arc::new(PtySlave::new(master.clone()));\n+    let master = PtyMaster::new(ptmx, index);\n+    let slave = PtySlave::new(&master);\n     Ok((master, slave))\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -2,16 +2,18 @@ use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \n use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::device::tty::new_job_control_and_ldisc;\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n-use crate::fs::file_handle::FileLike;\n+use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::FsPath;\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::{AccessMode, Inode, InodeMode, IoctlCmd};\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n+use crate::process::{JobControl, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n-const PTS_DIR: &str = \"/dev/pts\";\n const BUFFER_CAPACITY: usize = 4096;\n \n /// Pesudo terminal master.\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -23,19 +25,24 @@ pub struct PtyMaster {\n     index: u32,\n     output: Arc<LineDiscipline>,\n     input: SpinLock<HeapRb<u8>>,\n+    job_control: Arc<JobControl>,\n     /// The state of input buffer\n     pollee: Pollee,\n+    weak_self: Weak<Self>,\n }\n \n impl PtyMaster {\n-    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n-        Self {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| PtyMaster {\n             ptmx,\n             index,\n-            output: LineDiscipline::new(),\n+            output: ldisc,\n             input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            job_control,\n             pollee: Pollee::new(IoEvents::OUT),\n-        }\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -46,16 +53,12 @@ impl PtyMaster {\n         &self.ptmx\n     }\n \n-    pub(super) fn slave_push_byte(&self, byte: u8) {\n+    pub(super) fn slave_push_char(&self, ch: u8) {\n         let mut input = self.input.lock_irq_disabled();\n-        input.push_overwrite(byte);\n+        input.push_overwrite(ch);\n         self.update_state(&input);\n     }\n \n-    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.output.read(buf)\n-    }\n-\n     pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         let mut poll_status = IoEvents::empty();\n \ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -87,7 +90,7 @@ impl PtyMaster {\n     }\n }\n \n-impl FileLike for PtyMaster {\n+impl FileIo for PtyMaster {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         // TODO: deal with nonblocking read\n         if buf.is_empty() {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -122,7 +125,6 @@ impl FileLike for PtyMaster {\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut input = self.input.lock();\n-\n         for character in buf {\n             self.output.push_char(*character, |content| {\n                 for byte in content.as_bytes() {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -193,29 +195,35 @@ impl FileLike for PtyMaster {\n                 self.output.set_window_size(winsize);\n                 Ok(0)\n             }\n-            IoctlCmd::TIOCSCTTY => {\n-                // TODO: reimplement when adding session.\n-                let foreground = {\n-                    let current = current!();\n-                    let process_group = current.process_group().unwrap();\n-                    Arc::downgrade(&process_group)\n-                };\n-                self.output.set_fg(foreground);\n-                Ok(0)\n-            }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                let Some(foreground) = self.foreground() else {\n                     return_errno_with_message!(\n                         Errno::ESRCH,\n                         \"the foreground process group does not exist\"\n                     );\n                 };\n+                let fg_pgid = foreground.pgid();\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO: reimplement when adding session.\n-                self.output.set_fg(Weak::new());\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -246,15 +254,47 @@ impl FileLike for PtyMaster {\n     }\n }\n \n-pub struct PtySlave(Arc<PtyMaster>);\n+impl Terminal for PtyMaster {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Drop for PtyMaster {\n+    fn drop(&mut self) {\n+        let fs = self.ptmx.fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.index;\n+        devpts.remove_slave(index);\n+    }\n+}\n+\n+pub struct PtySlave {\n+    master: Weak<PtyMaster>,\n+    job_control: JobControl,\n+    weak_self: Weak<Self>,\n+}\n \n impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Self {\n-        PtySlave(master)\n+    pub fn new(master: &Arc<PtyMaster>) -> Arc<Self> {\n+        Arc::new_cyclic(|weak_ref| PtySlave {\n+            master: Arc::downgrade(master),\n+            job_control: JobControl::new(),\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n-        self.0.index()\n+        self.master().index()\n+    }\n+\n+    fn master(&self) -> Arc<PtyMaster> {\n+        self.master.upgrade().unwrap()\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -266,50 +306,91 @@ impl Device for PtySlave {\n     fn id(&self) -> crate::fs::device::DeviceId {\n         DeviceId::new(88, self.index())\n     }\n+}\n \n+impl Terminal for PtySlave {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl FileIo for PtySlave {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.0.slave_read(buf)\n+        self.job_control.wait_until_in_foreground()?;\n+        self.master().output.read(buf)\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let master = self.master();\n         for ch in buf {\n             // do we need to add '\\r' here?\n             if *ch == b'\\n' {\n-                self.0.slave_push_byte(b'\\r');\n-                self.0.slave_push_byte(b'\\n');\n+                master.slave_push_char(b'\\r');\n+                master.slave_push_char(b'\\n');\n             } else {\n-                self.0.slave_push_byte(*ch);\n+                master.slave_push_char(*ch);\n             }\n         }\n         Ok(buf.len())\n     }\n \n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.master().slave_poll(mask, poller)\n+    }\n+\n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n         match cmd {\n             IoctlCmd::TCGETS\n             | IoctlCmd::TCSETS\n-            | IoctlCmd::TIOCGPGRP\n             | IoctlCmd::TIOCGPTN\n             | IoctlCmd::TIOCGWINSZ\n-            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            | IoctlCmd::TIOCSWINSZ => self.master().ioctl(cmd, arg),\n+            IoctlCmd::TIOCGPGRP => {\n+                if !self.is_controlling_terminal() {\n+                    return_errno_with_message!(Errno::ENOTTY, \"slave is not controlling terminal\");\n+                }\n+\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+\n+                let fg_pgid = foreground.pgid();\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCSCTTY => {\n-                // TODO:\n+                self.set_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO:\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n-                let buffer_len = self.0.slave_buf_len() as i32;\n+                let buffer_len = self.master().slave_buf_len() as i32;\n                 write_val_to_user(arg, &buffer_len)?;\n                 Ok(0)\n             }\n             _ => Ok(0),\n         }\n     }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.slave_poll(mask, poller)\n-    }\n }\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Random;\n \ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -19,7 +22,9 @@ impl Device for Random {\n         // The same value as Linux\n         DeviceId::new(1, 8)\n     }\n+}\n \n+impl FileIo for Random {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -27,6 +32,11 @@ impl Device for Random {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n \n impl From<getrandom::Error> for Error {\ndiff --git /dev/null b/services/libs/jinux-std/src/device/tty/device.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/tty/device.rs\n@@ -0,0 +1,47 @@\n+use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::signal::Poller;\n+\n+/// Corresponds to `/dev/tty` in the file system. This device represents the controlling terminal\n+/// of the session of current process.\n+pub struct TtyDevice;\n+\n+impl Device for TtyDevice {\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let current = current!();\n+        let session = current.session().unwrap();\n+\n+        let Some(terminal) = session.terminal() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the session does not have controlling terminal\"\n+            );\n+        };\n+\n+        Ok(Some(terminal as Arc<dyn FileIo>))\n+    }\n+\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        DeviceId::new(5, 0)\n+    }\n+}\n+\n+impl FileIo for TtyDevice {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read tty device\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write tty device\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -1,13 +1,10 @@\n use crate::events::IoEvents;\n+use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::{Pollee, Poller};\n-use crate::process::ProcessGroup;\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n-use crate::{\n-    prelude::*,\n-    process::{signal::signals::kernel::KernelSignal, Pgid},\n-};\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -19,19 +16,21 @@ use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n const BUFFER_CAPACITY: usize = 4096;\n \n+pub type LdiscSignalSender = Arc<dyn Fn(KernelSignal) + Send + Sync + 'static>;\n+\n pub struct LineDiscipline {\n     /// current line\n     current_line: SpinLock<CurrentLine>,\n     /// The read buffer\n     read_buffer: SpinLock<StaticRb<u8, BUFFER_CAPACITY>>,\n-    /// The foreground process group\n-    foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n     /// Windows size,\n     winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n+    /// Used to send signal for foreground processes, when some char comes.\n+    send_signal: LdiscSignalSender,\n     /// work item\n     work_item: Arc<WorkItem>,\n     /// Parameters used by a work item.\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -76,8 +75,8 @@ impl CurrentLine {\n \n impl LineDiscipline {\n     /// Create a new line discipline\n-    pub fn new() -> Arc<Self> {\n-        Arc::new_cyclic(|line_ref: &Weak<LineDiscipline>| {\n+    pub fn new(send_signal: LdiscSignalSender) -> Arc<Self> {\n+        Arc::new_cyclic(move |line_ref: &Weak<LineDiscipline>| {\n             let line_discipline = line_ref.clone();\n             let work_item = Arc::new(WorkItem::new(Box::new(move || {\n                 if let Some(line_discipline) = line_discipline.upgrade() {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -87,10 +86,10 @@ impl LineDiscipline {\n             Self {\n                 current_line: SpinLock::new(CurrentLine::new()),\n                 read_buffer: SpinLock::new(StaticRb::default()),\n-                foreground: SpinLock::new(Weak::new()),\n                 termios: SpinLock::new(KernelTermios::default()),\n                 winsize: SpinLock::new(WinSize::default()),\n                 pollee: Pollee::new(IoEvents::empty()),\n+                send_signal,\n                 work_item,\n                 work_item_para: Arc::new(SpinLock::new(LineDisciplineWorkPara::new())),\n             }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -98,7 +97,7 @@ impl LineDiscipline {\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char<F: FnMut(&str)>(&self, ch: u8, echo_callback: F) {\n+    pub fn push_char<F2: FnMut(&str)>(&self, ch: u8, echo_callback: F2) {\n         let termios = self.termios.lock_irq_disabled();\n \n         let ch = if termios.contains_icrnl() && ch == b'\\r' {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -107,7 +106,7 @@ impl LineDiscipline {\n             ch\n         };\n \n-        if self.may_send_signal_to_foreground(&termios, ch) {\n+        if self.may_send_signal(&termios, ch) {\n             // The char is already dealt with, so just return\n             return;\n         }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -158,22 +157,14 @@ impl LineDiscipline {\n         self.update_readable_state_deferred();\n     }\n \n-    fn may_send_signal_to_foreground(&self, termios: &KernelTermios, ch: u8) -> bool {\n-        if !termios.contains_isig() {\n+    fn may_send_signal(&self, termios: &KernelTermios, ch: u8) -> bool {\n+        if !termios.is_canonical_mode() || !termios.contains_isig() {\n             return false;\n         }\n \n-        let Some(foreground) = self.foreground.lock().upgrade() else {\n-            return false;\n-        };\n-\n         let signal = match ch {\n-            item if item == *termios.get_special_char(CC_C_CHAR::VINTR) => {\n-                KernelSignal::new(SIGINT)\n-            }\n-            item if item == *termios.get_special_char(CC_C_CHAR::VQUIT) => {\n-                KernelSignal::new(SIGQUIT)\n-            }\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VINTR) => KernelSignal::new(SIGINT),\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VQUIT) => KernelSignal::new(SIGQUIT),\n             _ => return false,\n         };\n         // `kernel_signal()` may cause sleep, so only construct parameters here.\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -182,7 +173,7 @@ impl LineDiscipline {\n         true\n     }\n \n-    fn update_readable_state(&self) {\n+    pub fn update_readable_state(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n         if !buffer.is_empty() {\n             self.pollee.add_events(IoEvents::IN);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -193,7 +184,6 @@ impl LineDiscipline {\n \n     fn update_readable_state_deferred(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n-        let pollee = self.pollee.clone();\n         // add/del events may sleep, so only construct parameters here.\n         if !buffer.is_empty() {\n             self.work_item_para.lock_irq_disabled().pollee_type = Some(PolleeType::Add);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -206,11 +196,7 @@ impl LineDiscipline {\n     /// include all operations that may cause sleep, and processes by a work queue.\n     fn update_readable_state_after(&self) {\n         if let Some(signal) = self.work_item_para.lock_irq_disabled().kernel_signal.take() {\n-            self.foreground\n-                .lock()\n-                .upgrade()\n-                .unwrap()\n-                .kernel_signal(signal)\n+            (self.send_signal)(signal);\n         };\n         if let Some(pollee_type) = self.work_item_para.lock_irq_disabled().pollee_type.take() {\n             match pollee_type {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -243,42 +229,24 @@ impl LineDiscipline {\n         }\n     }\n \n-    /// read all bytes buffered to dst, return the actual read length.\n-    pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let mut poller = None;\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         loop {\n-            let res = self.try_read(dst);\n+            let res = self.try_read(buf);\n             match res {\n-                Ok(read_len) => {\n-                    return Ok(read_len);\n-                }\n-                Err(e) => {\n-                    if e.error() != Errno::EAGAIN {\n-                        return Err(e);\n+                Ok(len) => return Ok(len),\n+                Err(e) if e.error() != Errno::EAGAIN => return Err(e),\n+                Err(_) => {\n+                    let poller = Some(Poller::new());\n+                    if self.poll(IoEvents::IN, poller.as_ref()).is_empty() {\n+                        poller.as_ref().unwrap().wait()?\n                     }\n                 }\n             }\n-\n-            // Wait for read event\n-            let need_poller = if poller.is_none() {\n-                poller = Some(Poller::new());\n-                poller.as_ref()\n-            } else {\n-                None\n-            };\n-            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n-            if revents.is_empty() {\n-                // FIXME: deal with ldisc read timeout\n-                poller.as_ref().unwrap().wait()?;\n-            }\n         }\n     }\n \n-    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n-        if !self.current_can_read() {\n-            return_errno!(Errno::EAGAIN);\n-        }\n-\n+    /// read all bytes buffered to dst, return the actual read length.\n+    fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n         let (vmin, vtime) = {\n             let termios = self.termios.lock_irq_disabled();\n             let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -326,7 +294,8 @@ impl LineDiscipline {\n                 if termios.is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if is_line_terminator(next_char, &termios) {\n-                        if !should_not_be_read(next_char, &termios) {\n+                        // The eof should not be read\n+                        if !is_eof(next_char, &termios) {\n                             *dst_i = next_char;\n                             read_len += 1;\n                         }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -368,31 +337,6 @@ impl LineDiscipline {\n         todo!()\n     }\n \n-    /// Determine whether current process can read the line discipline. If current belongs to the foreground process group.\n-    /// or the foreground process group is None, returns true.\n-    fn current_can_read(&self) -> bool {\n-        let current = current!();\n-        let Some(foreground) = self.foreground.lock_irq_disabled().upgrade() else {\n-            return true;\n-        };\n-        foreground.contains_process(current.pid())\n-    }\n-\n-    /// set foreground process group\n-    pub fn set_fg(&self, foreground: Weak<ProcessGroup>) {\n-        *self.foreground.lock_irq_disabled() = foreground;\n-        // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n-        self.update_readable_state();\n-    }\n-\n-    /// get foreground process group id\n-    pub fn fg_pgid(&self) -> Option<Pgid> {\n-        self.foreground\n-            .lock_irq_disabled()\n-            .upgrade()\n-            .map(|foreground| foreground.pgid())\n-    }\n-\n     /// whether there is buffered data\n     pub fn is_empty(&self) -> bool {\n         self.read_buffer.lock_irq_disabled().len() == 0\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -439,8 +383,7 @@ fn is_line_terminator(item: u8, termios: &KernelTermios) -> bool {\n     false\n }\n \n-/// The special char should not be read by reading process\n-fn should_not_be_read(ch: u8, termios: &KernelTermios) -> bool {\n+fn is_eof(ch: u8, termios: &KernelTermios) -> bool {\n     ch == *termios.get_special_char(CC_C_CHAR::VEOF)\n }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -467,6 +410,7 @@ enum PolleeType {\n }\n \n struct LineDisciplineWorkPara {\n+    #[allow(clippy::type_complexity)]\n     kernel_signal: Option<KernelSignal>,\n     pollee_type: Option<PolleeType>,\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -2,23 +2,28 @@ use spin::Once;\n \n use self::driver::TtyDriver;\n use self::line_discipline::LineDiscipline;\n-use super::*;\n use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::IoctlCmd;\n use crate::prelude::*;\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::Poller;\n-use crate::process::{process_table, ProcessGroup};\n+use crate::process::{JobControl, Process, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n+mod device;\n pub mod driver;\n pub mod line_discipline;\n pub mod termio;\n \n+pub use device::TtyDevice;\n+\n static N_TTY: Once<Arc<Tty>> = Once::new();\n \n pub(super) fn init() {\n     let name = CString::new(\"console\").unwrap();\n-    let tty = Arc::new(Tty::new(name));\n+    let tty = Tty::new(name);\n     N_TTY.call_once(|| tty);\n     driver::init();\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -28,44 +33,36 @@ pub struct Tty {\n     name: CString,\n     /// line discipline\n     ldisc: Arc<LineDiscipline>,\n+    job_control: Arc<JobControl>,\n     /// driver\n     driver: SpinLock<Weak<TtyDriver>>,\n+    weak_self: Weak<Self>,\n }\n \n impl Tty {\n-    pub fn new(name: CString) -> Self {\n-        Tty {\n+    pub fn new(name: CString) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| Tty {\n             name,\n-            ldisc: LineDiscipline::new(),\n+            ldisc,\n+            job_control,\n             driver: SpinLock::new(Weak::new()),\n-        }\n-    }\n-\n-    /// Set foreground process group\n-    pub fn set_fg(&self, process_group: Weak<ProcessGroup>) {\n-        self.ldisc.set_fg(process_group);\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn set_driver(&self, driver: Weak<TtyDriver>) {\n         *self.driver.lock_irq_disabled() = driver;\n     }\n \n-    pub fn receive_char(&self, item: u8) {\n-        self.ldisc.push_char(item, |content| print!(\"{}\", content));\n+    pub fn receive_char(&self, ch: u8) {\n+        self.ldisc.push_char(ch, |content| print!(\"{}\", content));\n     }\n }\n \n-impl Device for Tty {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        // Same value with Linux\n-        DeviceId::new(5, 0)\n-    }\n-\n+impl FileIo for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.job_control.wait_until_in_foreground()?;\n         self.ldisc.read(buf)\n     }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -92,23 +89,28 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.ldisc.fg_pgid() else {\n-                    return_errno_with_message!(Errno::ENOENT, \"No fg process group\")\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(Errno::ESRCH, \"No fg process group\")\n                 };\n+                let fg_pgid = foreground.pgid();\n                 debug!(\"fg_pgid = {}\", fg_pgid);\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCSPGRP => {\n                 // Set the process group id of fg progress group\n-                let pgid = read_val_from_user::<i32>(arg)?;\n-                if pgid < 0 {\n-                    return_errno_with_message!(Errno::EINVAL, \"invalid pgid\");\n-                }\n-                match process_table::pgid_to_process_group(pgid as u32) {\n-                    None => self.ldisc.set_fg(Weak::new()),\n-                    Some(process_group) => self.ldisc.set_fg(Arc::downgrade(&process_group)),\n-                }\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                // Some background processes may be waiting on the wait queue,\n+                // when set_fg, the background processes may be able to read.\n+                self.ldisc.update_readable_state();\n                 Ok(0)\n             }\n             IoctlCmd::TCSETS => {\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -143,12 +145,73 @@ impl Device for Tty {\n                 self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             _ => todo!(),\n         }\n     }\n }\n \n-/// FIXME: should we maintain a static console?\n+impl Terminal for Tty {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Device for Tty {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        // The same value as /dev/console in linux.\n+        DeviceId::new(88, 0)\n+    }\n+}\n+\n+pub fn new_job_control_and_ldisc() -> (Arc<JobControl>, Arc<LineDiscipline>) {\n+    let job_control = Arc::new(JobControl::new());\n+\n+    let send_signal = {\n+        let cloned_job_control = job_control.clone();\n+        move |signal: KernelSignal| {\n+            let Some(foreground) = cloned_job_control.foreground() else {\n+                return;\n+            };\n+\n+            foreground.broadcast_signal(signal);\n+        }\n+    };\n+\n+    let ldisc = LineDiscipline::new(Arc::new(send_signal));\n+\n+    (job_control, ldisc)\n+}\n+\n pub fn get_n_tty() -> &'static Arc<Tty> {\n     N_TTY.get().unwrap()\n }\n+\n+/// Open `N_TTY` as the controlling terminal for the process. This method should\n+/// only be called when creating the init process.\n+pub fn open_ntty_as_controlling_terminal(process: &Process) -> Result<()> {\n+    let tty = get_n_tty();\n+\n+    let session = &process.session().unwrap();\n+    let process_group = process.process_group().unwrap();\n+\n+    session.set_terminal(|| {\n+        tty.job_control.set_session(session);\n+        Ok(tty.clone())\n+    })?;\n+\n+    tty.job_control.set_foreground(Some(&process_group))?;\n+\n+    Ok(())\n+}\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Urandom;\n \ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -19,7 +22,9 @@ impl Device for Urandom {\n         // The same value as Linux\n         DeviceId::new(1, 9)\n     }\n+}\n \n+impl FileIo for Urandom {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -27,4 +32,9 @@ impl Device for Urandom {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Zero;\n \ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -12,7 +15,9 @@ impl Device for Zero {\n         // Same value with Linux\n         DeviceId::new(1, 5)\n     }\n+}\n \n+impl FileIo for Zero {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         for byte in buf.iter_mut() {\n             *byte = 0;\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -23,4 +28,9 @@ impl Device for Zero {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/device.rs b/services/libs/jinux-std/src/fs/device.rs\n--- a/services/libs/jinux-std/src/fs/device.rs\n+++ b/services/libs/jinux-std/src/fs/device.rs\n@@ -1,33 +1,21 @@\n-use crate::events::IoEvents;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n-use crate::fs::utils::{InodeMode, InodeType, IoctlCmd};\n+use crate::fs::utils::{InodeMode, InodeType};\n use crate::prelude::*;\n-use crate::process::signal::Poller;\n+\n+use super::inode_handle::FileIo;\n \n /// The abstract of device\n-pub trait Device: Sync + Send {\n+pub trait Device: Sync + Send + FileIo {\n     /// Return the device type.\n     fn type_(&self) -> DeviceType;\n \n     /// Return the device ID.\n     fn id(&self) -> DeviceId;\n \n-    /// Read from the device.\n-    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n-\n-    /// Write to the device.\n-    fn write(&self, buf: &[u8]) -> Result<usize>;\n-\n-    /// Poll on the device.\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        let events = IoEvents::IN | IoEvents::OUT;\n-        events & mask\n-    }\n-\n-    /// Ioctl on the device.\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    /// Open a device.\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        Ok(None)\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-use crate::events::IoEvents;\n-use crate::fs::file_handle::FileLike;\n-use crate::prelude::*;\n-use crate::process::signal::Poller;\n-\n-use super::*;\n-\n-use crate::device::PtyMaster;\n-\n-/// Pty master inode for the master device.\n-pub struct PtyMasterInode(Arc<PtyMaster>);\n-\n-impl PtyMasterInode {\n-    pub fn new(device: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self(device))\n-    }\n-}\n-\n-impl Drop for PtyMasterInode {\n-    fn drop(&mut self) {\n-        // Remove the slave from fs.\n-        let fs = self.0.ptmx().fs();\n-        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n-\n-        let index = self.0.index();\n-        devpts.remove_slave(index);\n-    }\n-}\n-\n-impl Inode for PtyMasterInode {\n-    /// Do not cache dentry in DCACHE.\n-    ///\n-    /// Each file descriptor obtained by opening \"/dev/ptmx\" is an independent pty master\n-    /// with its own associated pty slave.\n-    fn is_dentry_cacheable(&self) -> bool {\n-        false\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.0.ptmx().metadata().size\n-    }\n-\n-    fn resize(&self, new_size: usize) {}\n-\n-    fn metadata(&self) -> Metadata {\n-        self.0.ptmx().metadata()\n-    }\n-\n-    fn type_(&self) -> InodeType {\n-        self.0.ptmx().metadata().type_\n-    }\n-\n-    fn mode(&self) -> InodeMode {\n-        self.0.ptmx().metadata().mode\n-    }\n-\n-    fn set_mode(&self, mode: InodeMode) {}\n-\n-    fn atime(&self) -> Duration {\n-        self.0.ptmx().metadata().atime\n-    }\n-\n-    fn set_atime(&self, time: Duration) {}\n-\n-    fn mtime(&self) -> Duration {\n-        self.0.ptmx().metadata().mtime\n-    }\n-\n-    fn set_mtime(&self, time: Duration) {}\n-\n-    fn read_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn write_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_direct_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn write_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_direct_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.0.ioctl(cmd, arg)\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.poll(mask, poller)\n-    }\n-\n-    fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().fs()\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,4 @@\n+use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\n     DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,11 +10,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\n \n-mod master;\n mod ptmx;\n mod slave;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -52,7 +51,7 @@ impl DevPts {\n     }\n \n     /// Create the master and slave pair.\n-    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMasterInode>, Arc<PtySlaveInode>)> {\n+    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMaster>, Arc<PtySlaveInode>)> {\n         let index = self\n             .index_alloc\n             .lock()\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -61,17 +60,16 @@ impl DevPts {\n \n         let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n-        let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\n         self.root.add_slave(index.to_string(), slave_inode.clone());\n \n-        Ok((master_inode, slave_inode))\n+        Ok((master, slave_inode))\n     }\n \n     /// Remove the slave from fs.\n     ///\n     /// This is called when the master is being dropped.\n-    fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n+    pub fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n         let removed_slave = self.root.remove_slave(&index.to_string());\n         if removed_slave.is_some() {\n             self.index_alloc.lock().free(index as usize);\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -241,7 +239,7 @@ impl Inode for RootInode {\n         let inode = match name {\n             \".\" | \"..\" => self.fs().root_inode(),\n             // Call the \"open\" method of ptmx to create a master and slave pair.\n-            \"ptmx\" => self.ptmx.open()?,\n+            \"ptmx\" => self.ptmx.clone(),\n             slave => self\n                 .slaves\n                 .read()\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -1,4 +1,8 @@\n+use crate::device::PtyMaster;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -14,12 +18,14 @@ const PTMX_MINOR_NUM: u32 = 2;\n pub struct Ptmx {\n     inner: Inner,\n     metadata: Metadata,\n-    fs: Weak<DevPts>,\n }\n \n+#[derive(Clone)]\n+struct Inner(Weak<DevPts>);\n+\n impl Ptmx {\n     pub fn new(sb: &SuperBlock, fs: Weak<DevPts>) -> Arc<Self> {\n-        let inner = Inner;\n+        let inner = Inner(fs);\n         Arc::new(Self {\n             metadata: Metadata::new_device(\n                 PTMX_INO,\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -28,20 +34,19 @@ impl Ptmx {\n                 &inner,\n             ),\n             inner,\n-            fs,\n         })\n     }\n \n     /// The open method for ptmx.\n     ///\n     /// Creates a master and slave pair and returns the master inode.\n-    pub fn open(&self) -> Result<Arc<PtyMasterInode>> {\n+    pub fn open(&self) -> Result<Arc<PtyMaster>> {\n         let (master, _) = self.devpts().create_master_slave_pair()?;\n         Ok(master)\n     }\n \n     pub fn devpts(&self) -> Arc<DevPts> {\n-        self.fs.upgrade().unwrap()\n+        self.inner.0.upgrade().unwrap()\n     }\n \n     pub fn device_type(&self) -> DeviceType {\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -119,9 +124,11 @@ impl Inode for Ptmx {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.devpts()\n     }\n-}\n \n-struct Inner;\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(Arc::new(self.inner.clone()))\n+    }\n+}\n \n impl Device for Inner {\n     fn type_(&self) -> DeviceType {\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -132,13 +139,23 @@ impl Device for Inner {\n         DeviceId::new(PTMX_MAJOR_NUM, PTMX_MINOR_NUM)\n     }\n \n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let devpts = self.0.upgrade().unwrap();\n+        let (master, _) = devpts.create_master_slave_pair()?;\n+        Ok(Some(master as _))\n+    }\n+}\n+\n+impl FileIo for Inner {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        // do nothing because it should not be used to read.\n-        Ok(0)\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read ptmx\");\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n-        // do nothing because it should not be used to write.\n-        Ok(buf.len())\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write ptmx\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -1,4 +1,5 @@\n use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -107,4 +108,8 @@ impl Inode for PtySlaveInode {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.fs.upgrade().unwrap()\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(self.device.clone())\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -1,6 +1,7 @@\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\n+use crate::fs::device::Device;\n use crate::fs::utils::{AccessMode, IoctlCmd, Metadata, SeekFrom, StatusFlags};\n use crate::net::socket::Socket;\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -73,6 +74,10 @@ pub trait FileLike: Send + Sync + Any {\n     fn as_socket(&self) -> Option<&dyn Socket> {\n         None\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n }\n \n impl dyn FileLike {\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -27,7 +27,7 @@ impl FileTable {\n     pub fn new_with_stdio() -> Self {\n         let mut table = SlotVec::new();\n         let fs_resolver = FsResolver::new();\n-        let tty_path = FsPath::new(AT_FDCWD, \"/dev/tty\").expect(\"cannot find tty\");\n+        let tty_path = FsPath::new(AT_FDCWD, \"/dev/console\").expect(\"cannot find tty\");\n         let stdin = {\n             let flags = AccessMode::O_RDONLY as u32;\n             let mode = InodeMode::S_IRUSR;\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -21,8 +21,16 @@ impl InodeHandle<Rights> {\n         if access_mode.is_writable() && inode.type_() == InodeType::Dir {\n             return_errno_with_message!(Errno::EISDIR, \"Directory cannot open to write\");\n         }\n+\n+        let file_io = if let Some(device) = inode.as_device() {\n+            device.open()?\n+        } else {\n+            None\n+        };\n+\n         let inner = Arc::new(InodeHandle_ {\n             dentry,\n+            file_io,\n             offset: Mutex::new(0),\n             access_mode,\n             status_flags: AtomicU32::new(status_flags.bits()),\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -42,6 +50,7 @@ impl InodeHandle<Rights> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n         }\n+\n         self.0.read_to_end(buf)\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -75,11 +84,11 @@ impl FileLike for InodeHandle<Rights> {\n     }\n \n     fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.dentry().inode().poll(mask, poller)\n+        self.0.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.dentry().inode().ioctl(cmd, arg)\n+        self.0.ioctl(cmd, arg)\n     }\n \n     fn metadata(&self) -> Metadata {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -107,4 +116,8 @@ impl FileLike for InodeHandle<Rights> {\n         // Close does not guarantee that the data has been successfully saved to disk.\n         Ok(())\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.dentry().inode().as_device()\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -5,11 +5,14 @@ mod static_cap;\n \n use core::sync::atomic::{AtomicU32, Ordering};\n \n+use crate::events::IoEvents;\n+use crate::fs::device::Device;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::{\n     AccessMode, Dentry, DirentVisitor, InodeType, IoctlCmd, Metadata, SeekFrom, StatusFlags,\n };\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n use jinux_rights::Rights;\n \n #[derive(Debug)]\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -17,6 +20,10 @@ pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\n \n struct InodeHandle_ {\n     dentry: Arc<Dentry>,\n+    /// `file_io` is Similar to `file_private` field in `file` structure in linux. If\n+    /// `file_io` is Some, typical file operations including `read`, `write`, `poll`,\n+    /// `ioctl` will be provided by `file_io`, instead of `dentry`.\n+    file_io: Option<Arc<dyn FileIo>>,\n     offset: Mutex<usize>,\n     access_mode: AccessMode,\n     status_flags: AtomicU32,\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -25,6 +32,11 @@ struct InodeHandle_ {\n impl InodeHandle_ {\n     pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.read(buf);\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_at(*offset, buf)?\n         } else {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -37,6 +49,11 @@ impl InodeHandle_ {\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.write(buf);\n+        }\n+\n         if self.status_flags().contains(StatusFlags::O_APPEND) {\n             *offset = self.dentry.inode_len();\n         }\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -51,6 +68,10 @@ impl InodeHandle_ {\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        if self.file_io.is_some() {\n+            return_errno_with_message!(Errno::EINVAL, \"file io does not support read to end\");\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_to_end(buf)?\n         } else {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -117,6 +138,22 @@ impl InodeHandle_ {\n         *offset += read_cnt;\n         Ok(read_cnt)\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.poll(mask, poller);\n+        }\n+\n+        self.dentry.inode().poll(mask, poller)\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.ioctl(cmd, arg);\n+        }\n+\n+        self.dentry.inode().ioctl(cmd, arg)\n+    }\n }\n \n impl Debug for InodeHandle_ {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -136,3 +173,15 @@ impl<R> InodeHandle<R> {\n         &self.0.dentry\n     }\n }\n+\n+pub trait FileIo: Send + Sync + 'static {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize>;\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents;\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/jinux-std/src/fs/procfs/mod.rs\n--- a/services/libs/jinux-std/src/fs/procfs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/mod.rs\n@@ -91,7 +91,7 @@ impl DirOps for RootDirOps {\n             SelfSymOps::new_inode(this_ptr.clone())\n         } else if let Ok(pid) = name.parse::<Pid>() {\n             let process_ref =\n-                process_table::pid_to_process(pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n+                process_table::get_process(&pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n             PidDirOps::new_inode(process_ref, this_ptr.clone())\n         } else {\n             return_errno!(Errno::ENOENT);\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -574,6 +574,10 @@ impl Inode for RamInode {\n         Ok(device_inode)\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.0.read().inner.as_device().cloned()\n+    }\n+\n     fn create(&self, name: &str, type_: InodeType, mode: InodeMode) -> Result<Arc<dyn Inode>> {\n         if self.0.read().metadata.type_ != InodeType::Dir {\n             return_errno_with_message!(Errno::ENOTDIR, \"self is not dir\");\ndiff --git a/services/libs/jinux-std/src/fs/rootfs.rs b/services/libs/jinux-std/src/fs/rootfs.rs\n--- a/services/libs/jinux-std/src/fs/rootfs.rs\n+++ b/services/libs/jinux-std/src/fs/rootfs.rs\n@@ -84,7 +84,7 @@ pub fn init(initramfs_buf: &[u8]) -> Result<()> {\n \n static ROOT_MOUNT: Once<Arc<MountNode>> = Once::new();\n \n-fn init_root_mount() {\n+pub fn init_root_mount() {\n     ROOT_MOUNT.call_once(|| -> Arc<MountNode> {\n         let rootfs = RamFS::new();\n         MountNode::new_root(rootfs)\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -285,6 +285,10 @@ pub trait Inode: Any + Sync + Send {\n         Err(Error::new(Errno::ENOTDIR))\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n+\n     fn readdir_at(&self, offset: usize, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         Err(Error::new(Errno::ENOTDIR))\n     }\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -1,26 +1,20 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace, vm::VmIo};\n-\n+use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n+use super::process_vm::ProcessVm;\n+use super::signal::sig_disposition::SigDispositions;\n+use super::{process_table, Process, ProcessBuilder};\n+use crate::current_thread;\n+use crate::fs::file_table::FileTable;\n+use crate::fs::fs_resolver::FsResolver;\n+use crate::fs::utils::FileCreationMask;\n+use crate::prelude::*;\n+use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n+use crate::util::write_val_to_user;\n+use crate::vm::vmar::Vmar;\n+use jinux_frame::cpu::UserContext;\n+use jinux_frame::user::UserSpace;\n+use jinux_frame::vm::VmIo;\n use jinux_rights::Full;\n \n-use crate::{\n-    current_thread,\n-    fs::file_table::FileTable,\n-    fs::{fs_resolver::FsResolver, utils::FileCreationMask},\n-    prelude::*,\n-    process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt, ThreadName},\n-        process_table,\n-    },\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n-    util::write_val_to_user,\n-    vm::vmar::Vmar,\n-};\n-\n-use super::{\n-    posix_thread::PosixThread, process_vm::ProcessVm, signal::sig_disposition::SigDispositions,\n-    Process, ProcessBuilder,\n-};\n-\n bitflags! {\n     pub struct CloneFlags: u32 {\n         const CLONE_VM      = 0x00000100;       /* Set if VM shared between processes.  */\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -275,16 +269,13 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n             .file_table(child_file_table)\n             .fs(child_fs)\n             .umask(child_umask)\n-            .sig_dispositions(child_sig_dispositions)\n-            .process_group(current.process_group().unwrap());\n+            .sig_dispositions(child_sig_dispositions);\n \n         process_builder.build()?\n     };\n \n-    current!().add_child(child.clone());\n-    process_table::add_process(child.clone());\n-\n-    let child_thread = thread_table::tid_to_thread(child_tid).unwrap();\n+    // Deals with clone flags\n+    let child_thread = thread_table::get_thread(child_tid).unwrap();\n     let child_posix_thread = child_thread.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -296,6 +287,10 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n         clone_args.child_tidptr,\n         clone_flags,\n     )?;\n+\n+    // Sets parent process and group for child process.\n+    set_parent_and_group(&current, &child);\n+\n     Ok(child)\n }\n \ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -414,3 +409,19 @@ fn clone_sysvsem(clone_flags: CloneFlags) -> Result<()> {\n     }\n     Ok(())\n }\n+\n+fn set_parent_and_group(parent: &Arc<Process>, child: &Arc<Process>) {\n+    let process_group = parent.process_group().unwrap();\n+\n+    let mut process_table_mut = process_table::process_table_mut();\n+    let mut group_inner = process_group.inner.lock();\n+    let mut child_group_mut = child.process_group.lock();\n+    let mut children_mut = parent.children().lock();\n+\n+    children_mut.insert(child.pid(), child.clone());\n+\n+    group_inner.processes.insert(child.pid(), child.clone());\n+    *child_group_mut = Arc::downgrade(&process_group);\n+\n+    process_table_mut.insert(child.pid(), child.clone());\n+}\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -37,9 +37,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     // Move children to the init process\n     if !is_init_process(&current) {\n         if let Some(init_process) = get_init_process() {\n+            let mut init_children = init_process.children().lock();\n             for (_, child_process) in current.children().lock().extract_if(|_, _| true) {\n-                child_process.set_parent(Arc::downgrade(&init_process));\n-                init_process.add_child(child_process);\n+                let mut parent = child_process.parent.lock();\n+                init_children.insert(child_process.pid(), child_process.clone());\n+                *parent = Arc::downgrade(&init_process);\n             }\n         }\n     }\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -56,7 +58,7 @@ const INIT_PROCESS_PID: Pid = 1;\n \n /// Get the init process\n fn get_init_process() -> Option<Arc<Process>> {\n-    process_table::pid_to_process(INIT_PROCESS_PID)\n+    process_table::get_process(&INIT_PROCESS_PID)\n }\n \n fn is_init_process(process: &Process) -> bool {\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -4,7 +4,6 @@ pub mod posix_thread;\n #[allow(clippy::module_inception)]\n mod process;\n mod process_filter;\n-mod process_group;\n pub mod process_table;\n mod process_vm;\n mod program_loader;\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -17,9 +16,10 @@ mod wait;\n pub use clone::{clone_child, CloneArgs, CloneFlags};\n pub use exit::do_exit_group;\n pub use process::ProcessBuilder;\n-pub use process::{current, ExitCode, Pgid, Pid, Process};\n+pub use process::{\n+    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessGroup, Session, Sid, Terminal,\n+};\n pub use process_filter::ProcessFilter;\n-pub use process_group::ProcessGroup;\n pub use program_loader::{check_executable_file, load_program_to_vm};\n pub use rlimit::ResourceType;\n pub use term_status::TermStatus;\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -1,12 +1,10 @@\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\n-use crate::process::posix_thread::PosixThreadBuilder;\n-use crate::process::process_group::ProcessGroup;\n-use crate::process::process_table;\n+use crate::process::posix_thread::{PosixThreadBuilder, PosixThreadExt};\n use crate::process::process_vm::ProcessVm;\n use crate::process::rlimit::ResourceLimits;\n-use crate::process::{posix_thread::PosixThreadExt, signal::sig_disposition::SigDispositions};\n+use crate::process::signal::sig_disposition::SigDispositions;\n use crate::thread::Thread;\n \n use super::{Pid, Process};\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -23,7 +21,6 @@ pub struct ProcessBuilder<'a> {\n     argv: Option<Vec<CString>>,\n     envp: Option<Vec<CString>>,\n     process_vm: Option<ProcessVm>,\n-    process_group: Option<Arc<ProcessGroup>>,\n     file_table: Option<Arc<Mutex<FileTable>>>,\n     fs: Option<Arc<RwLock<FsResolver>>>,\n     umask: Option<Arc<RwLock<FileCreationMask>>>,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -41,7 +38,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv: None,\n             envp: None,\n             process_vm: None,\n-            process_group: None,\n             file_table: None,\n             fs: None,\n             umask: None,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -60,11 +56,6 @@ impl<'a> ProcessBuilder<'a> {\n         self\n     }\n \n-    pub fn process_group(&mut self, process_group: Arc<ProcessGroup>) -> &mut Self {\n-        self.process_group = Some(process_group);\n-        self\n-    }\n-\n     pub fn file_table(&mut self, file_table: Arc<Mutex<FileTable>>) -> &mut Self {\n         self.file_table = Some(file_table);\n         self\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -126,7 +117,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv,\n             envp,\n             process_vm,\n-            process_group,\n             file_table,\n             fs,\n             umask,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -136,10 +126,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         let process_vm = process_vm.or_else(|| Some(ProcessVm::alloc())).unwrap();\n \n-        let process_group_ref = process_group\n-            .as_ref()\n-            .map_or_else(Weak::new, Arc::downgrade);\n-\n         let file_table = file_table\n             .or_else(|| Some(Arc::new(Mutex::new(FileTable::new_with_stdio()))))\n             .unwrap();\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -168,7 +154,6 @@ impl<'a> ProcessBuilder<'a> {\n                 threads,\n                 executable_path.to_string(),\n                 process_vm,\n-                process_group_ref,\n                 file_table,\n                 fs,\n                 umask,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -194,15 +179,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         process.threads().lock().push(thread);\n \n-        if let Some(process_group) = process_group {\n-            process_group.add_process(process.clone());\n-        } else {\n-            let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-            let pgid = new_process_group.pgid();\n-            process.set_process_group(Arc::downgrade(&new_process_group));\n-            process_table::add_process_group(new_process_group);\n-        }\n-\n         process.set_runnable();\n \n         Ok(process)\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/job_control.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/job_control.rs\n@@ -0,0 +1,161 @@\n+use crate::prelude::*;\n+use crate::process::signal::constants::{SIGCONT, SIGHUP};\n+use crate::process::signal::signals::kernel::KernelSignal;\n+use crate::process::signal::Pauser;\n+use crate::process::{ProcessGroup, Session};\n+\n+/// The job control for terminals like tty and pty.\n+///\n+/// This struct is used to support shell job control, which allows users to\n+/// run commands in the foreground or in the background. This struct manages\n+/// the session and foreground process group for a terminal.\n+pub struct JobControl {\n+    foreground: SpinLock<Weak<ProcessGroup>>,\n+    session: SpinLock<Weak<Session>>,\n+    pauser: Arc<Pauser>,\n+}\n+\n+impl JobControl {\n+    /// Creates a new `TtyJobControl`\n+    pub fn new() -> Self {\n+        Self {\n+            foreground: SpinLock::new(Weak::new()),\n+            session: SpinLock::new(Weak::new()),\n+            pauser: Pauser::new(),\n+        }\n+    }\n+\n+    // *************** Session ***************\n+\n+    /// Returns the session whose controlling terminal is the terminal.\n+    fn session(&self) -> Option<Arc<Session>> {\n+        self.session.lock().upgrade()\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the `session`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This terminal should not belong to any session.\n+    pub fn set_session(&self, session: &Arc<Session>) {\n+        debug_assert!(self.session().is_none());\n+        *self.session.lock() = Arc::downgrade(session);\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn set_current_session(&self) -> Result<()> {\n+        if self.session().is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal is already controlling terminal of another session\"\n+            );\n+        }\n+\n+        let current = current!();\n+\n+        let process_group = current.process_group().unwrap();\n+        *self.foreground.lock() = Arc::downgrade(&process_group);\n+\n+        let session = current.session().unwrap();\n+        *self.session.lock() = Arc::downgrade(&session);\n+\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Releases the current session from this terminal.\n+    pub fn release_current_session(&self) -> Result<()> {\n+        let Some(session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the terminal is not controlling terminal now\"\n+            );\n+        };\n+\n+        if let Some(foreground) = self.foreground() {\n+            foreground.broadcast_signal(KernelSignal::new(SIGHUP));\n+            foreground.broadcast_signal(KernelSignal::new(SIGCONT));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // *************** Foreground process group ***************\n+\n+    /// Returns the foreground process group\n+    pub fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.foreground.lock().upgrade()\n+    }\n+\n+    /// Sets the foreground process group.\n+    ///\n+    /// # Panic\n+    ///\n+    /// The process group should belong to one session.\n+    pub fn set_foreground(&self, process_group: Option<&Arc<ProcessGroup>>) -> Result<()> {\n+        let Some(process_group) = process_group else {\n+            // FIXME: should we allow this branch?\n+            *self.foreground.lock() = Weak::new();\n+            return Ok(());\n+        };\n+\n+        let session = process_group.session().unwrap();\n+        let Some(terminal_session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal does not become controlling terminal of one session.\"\n+            );\n+        };\n+\n+        if !Arc::ptr_eq(&terminal_session, &session) {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the process proup belongs to different session\"\n+            );\n+        }\n+\n+        *self.foreground.lock() = Arc::downgrade(process_group);\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Wait until the current process is the foreground process group. If\n+    /// the foreground process group is None, returns true.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn wait_until_in_foreground(&self) -> Result<()> {\n+        // Fast path\n+        if self.current_belongs_to_foreground() {\n+            return Ok(());\n+        }\n+\n+        // Slow path\n+        self.pauser.pause_until(|| {\n+            if self.current_belongs_to_foreground() {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn current_belongs_to_foreground(&self) -> bool {\n+        let Some(foreground) = self.foreground() else {\n+            return true;\n+        };\n+\n+        foreground.contains_process(current!().pid())\n+    }\n+}\n+\n+impl Default for JobControl {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -1,7 +1,4 @@\n-mod builder;\n-\n use super::posix_thread::PosixThreadExt;\n-use super::process_group::ProcessGroup;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\n use super::rlimit::ResourceLimits;\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -13,7 +10,7 @@ use super::signal::signals::Signal;\n use super::signal::{Pauser, SigEvents, SigEventsFilter};\n use super::status::ProcessStatus;\n use super::{process_table, TermStatus};\n-use crate::device::tty::get_n_tty;\n+use crate::device::tty::open_ntty_as_controlling_terminal;\n use crate::events::Observer;\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -23,10 +20,25 @@ use crate::thread::{allocate_tid, Thread};\n use crate::vm::vmar::Vmar;\n use jinux_rights::Full;\n \n+mod builder;\n+mod job_control;\n+mod process_group;\n+mod session;\n+mod terminal;\n+\n pub use builder::ProcessBuilder;\n+pub use job_control::JobControl;\n+pub use process_group::ProcessGroup;\n+pub use session::Session;\n+pub use terminal::Terminal;\n \n+/// Process id.\n pub type Pid = u32;\n+/// Process group id.\n pub type Pgid = u32;\n+/// Session Id.\n+pub type Sid = u32;\n+\n pub type ExitCode = i32;\n \n /// Process stands for a set of threads that shares the same userspace.\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -46,11 +58,11 @@ pub struct Process {\n     /// Process status\n     status: Mutex<ProcessStatus>,\n     /// Parent process\n-    parent: Mutex<Weak<Process>>,\n+    pub(super) parent: Mutex<Weak<Process>>,\n     /// Children processes\n     children: Mutex<BTreeMap<Pid, Arc<Process>>>,\n     /// Process group\n-    process_group: Mutex<Weak<ProcessGroup>>,\n+    pub(super) process_group: Mutex<Weak<ProcessGroup>>,\n     /// File table\n     file_table: Arc<Mutex<FileTable>>,\n     /// FsResolver\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -75,7 +87,6 @@ impl Process {\n         threads: Vec<Arc<Thread>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n-        process_group: Weak<ProcessGroup>,\n         file_table: Arc<Mutex<FileTable>>,\n         fs: Arc<RwLock<FsResolver>>,\n         umask: Arc<RwLock<FileCreationMask>>,\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -99,7 +110,7 @@ impl Process {\n             status: Mutex::new(ProcessStatus::Uninit),\n             parent: Mutex::new(parent),\n             children: Mutex::new(BTreeMap::new()),\n-            process_group: Mutex::new(process_group),\n+            process_group: Mutex::new(Weak::new()),\n             file_table,\n             fs,\n             umask,\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -118,11 +129,9 @@ impl Process {\n         // spawn user process should give an absolute path\n         debug_assert!(executable_path.starts_with('/'));\n         let process = Process::create_user_process(executable_path, argv, envp)?;\n-        // FIXME: How to determine the fg process group?\n-        let process_group = Weak::clone(&process.process_group.lock());\n-        // FIXME: tty should be a parameter?\n-        let tty = get_n_tty();\n-        tty.set_fg(process_group);\n+\n+        open_ntty_as_controlling_terminal(&process)?;\n+\n         process.run();\n         Ok(process)\n     }\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -141,7 +150,25 @@ impl Process {\n         };\n \n         let process = process_builder.build()?;\n-        process_table::add_process(process.clone());\n+\n+        // Lock order: session table -> group table -> process table -> group of process\n+        // -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut process_table_mut = process_table::process_table_mut();\n+\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+        group_table_mut.insert(group.pgid(), group.clone());\n+\n+        // Creates new session\n+        let session = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&session);\n+        session.inner.lock().leader = Some(process.clone());\n+        session_table_mut.insert(session.sid(), session);\n+\n+        process_table_mut.insert(process.pid(), process.clone());\n         Ok(process)\n     }\n \ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -180,30 +207,25 @@ impl Process {\n     }\n \n     // *********** Parent and child ***********\n-\n-    pub fn add_child(&self, child: Arc<Process>) {\n-        let child_pid = child.pid();\n-        self.children.lock().insert(child_pid, child);\n-    }\n-\n-    pub fn set_parent(&self, parent: Weak<Process>) {\n-        *self.parent.lock() = parent;\n-    }\n-\n     pub fn parent(&self) -> Option<Arc<Process>> {\n         self.parent.lock().upgrade()\n     }\n \n-    pub fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n+    pub(super) fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n         &self.children\n     }\n \n+    pub fn has_child(&self, pid: &Pid) -> bool {\n+        self.children.lock().contains_key(pid)\n+    }\n+\n     pub fn children_pauser(&self) -> &Arc<Pauser> {\n         &self.children_pauser\n     }\n \n-    // *********** Process group ***********\n+    // *********** Process group & Session***********\n \n+    /// Returns the process group id of the process.\n     pub fn pgid(&self) -> Pgid {\n         if let Some(process_group) = self.process_group.lock().upgrade() {\n             process_group.pgid()\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -212,17 +234,237 @@ impl Process {\n         }\n     }\n \n-    /// Set process group for current process. If old process group exists,\n-    /// remove current process from old process group.\n-    pub fn set_process_group(&self, process_group: Weak<ProcessGroup>) {\n-        if let Some(old_process_group) = self.process_group() {\n-            old_process_group.remove_process(self.pid());\n+    /// Returns the process group which the process belongs to.\n+    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n+        self.process_group.lock().upgrade()\n+    }\n+\n+    /// Returns whether `self` is the leader of process group.\n+    fn is_group_leader(self: &Arc<Self>) -> bool {\n+        let Some(process_group) = self.process_group() else {\n+            return false;\n+        };\n+\n+        let Some(leader) = process_group.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leader)\n+    }\n+\n+    /// Returns the session which the process belongs to.\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        let process_group = self.process_group()?;\n+        process_group.session()\n+    }\n+\n+    /// Returns whether the process is session leader.\n+    pub fn is_session_leader(self: &Arc<Self>) -> bool {\n+        let session = self.session().unwrap();\n+\n+        let Some(leading_process) = session.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leading_process)\n+    }\n+\n+    /// Moves the process to the new session.\n+    ///\n+    /// If the process is already session leader, this method does nothing.\n+    ///\n+    /// Otherwise, this method creates a new process group in a new session\n+    /// and moves the process to the session, returning the new session.\n+    ///\n+    /// This method may return the following errors:\n+    /// * `EPERM`, if the process is a process group leader, or some existing session\n+    /// or process group has the same id as the process.\n+    pub fn to_new_session(self: &Arc<Self>) -> Result<Arc<Session>> {\n+        if self.is_session_leader() {\n+            return Ok(self.session().unwrap());\n+        }\n+\n+        if self.is_group_leader() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"process group leader cannot be moved to new session.\"\n+            );\n+        }\n+\n+        let session = self.session().unwrap();\n+\n+        // Lock order: session table -> group table -> group of process -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        if session_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create new session\");\n+        }\n+\n+        if group_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create process group\");\n+        }\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                session_inner.process_groups.remove(&old_group.pgid());\n+\n+                if session_inner.is_empty() {\n+                    session_table_mut.remove(&session.sid());\n+                }\n+            }\n         }\n-        *self.process_group.lock() = process_group;\n+\n+        // Creates a new process group\n+        let new_group = ProcessGroup::new(self.clone());\n+        *self_group_mut = Arc::downgrade(&new_group);\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        // Creates a new session\n+        let new_session = Session::new(new_group.clone());\n+        let mut new_group_inner = new_group.inner.lock();\n+        new_group_inner.session = Arc::downgrade(&new_session);\n+        new_session.inner.lock().leader = Some(self.clone());\n+        session_table_mut.insert(new_session.sid(), new_session.clone());\n+\n+        // Removes the process from session.\n+        let mut session_inner = session.inner.lock();\n+        session_inner.remove_process(self);\n+\n+        Ok(new_session)\n+    }\n+\n+    /// Moves the process to other process group.\n+    ///\n+    /// * If the group already exists, the process and the group should belong to the same session.\n+    /// * If the group does not exist, this method creates a new group for the process and move the\n+    /// process to the group. The group is added to the session of the process.\n+    ///\n+    /// This method may return `EPERM` in following cases:\n+    /// * The process is session leader;\n+    /// * The group already exists, but the group does not belong to the same session as the process;\n+    /// * The group does not exist, but `pgid` is not equal to `pid` of the process.\n+    pub fn to_other_group(self: &Arc<Self>, pgid: Pgid) -> Result<()> {\n+        // if the process already belongs to the process group\n+        if self.pgid() == pgid {\n+            return Ok(());\n+        }\n+\n+        if self.is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"the process cannot be a session leader\");\n+        }\n+\n+        if let Some(process_group) = process_table::get_process_group(&pgid) {\n+            let session = self.session().unwrap();\n+            if !session.contains_process_group(&process_group) {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the group and process does not belong to same session\"\n+                );\n+            }\n+            self.to_specified_group(&process_group)?;\n+        } else {\n+            if pgid != self.pid() {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the new process group should have the same id as the process.\"\n+                );\n+            }\n+\n+            self.to_new_group()?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Creates a new process group and moves the process to the group.\n+    ///\n+    /// The new group will be added to the same session as the process.\n+    fn to_new_group(self: &Arc<Self>) -> Result<()> {\n+        let session = self.session().unwrap();\n+        // Lock order: group table -> group of process -> group inner -> session inner\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                // The old session won't be empty, since we will add a new group to the session.\n+                session_inner.process_groups.remove(&old_group.pgid());\n+            }\n+        }\n+\n+        // Creates a new process group. Adds the new group to group table and session.\n+        let new_group = ProcessGroup::new(self.clone());\n+\n+        let mut new_group_inner = new_group.inner.lock();\n+        let mut session_inner = session.inner.lock();\n+\n+        *self_group_mut = Arc::downgrade(&new_group);\n+\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        new_group_inner.session = Arc::downgrade(&session);\n+        session_inner\n+            .process_groups\n+            .insert(new_group.pgid(), new_group.clone());\n+\n+        Ok(())\n     }\n \n-    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n-        self.process_group.lock().upgrade()\n+    /// Moves the process to a specified group.\n+    ///\n+    /// The caller needs to ensure that the process and the group belongs to the same session.\n+    fn to_specified_group(self: &Arc<Process>, group: &Arc<ProcessGroup>) -> Result<()> {\n+        // Lock order: group table -> group of process -> group inner (small pgid -> big pgid)\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        let mut group_inner = if let Some(old_group) = self_group_mut.upgrade() {\n+            // Lock order: group with smaller pgid first\n+            let (mut old_group_inner, group_inner) = match old_group.pgid().cmp(&group.pgid()) {\n+                core::cmp::Ordering::Equal => return Ok(()),\n+                core::cmp::Ordering::Less => (old_group.inner.lock(), group.inner.lock()),\n+                core::cmp::Ordering::Greater => {\n+                    let group_inner = group.inner.lock();\n+                    let old_group_inner = old_group.inner.lock();\n+                    (old_group_inner, group_inner)\n+                }\n+            };\n+            old_group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if old_group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+            }\n+\n+            group_inner\n+        } else {\n+            group.inner.lock()\n+        };\n+\n+        // Adds the process to the specified group\n+        group_inner.processes.insert(self.pid, self.clone());\n+        *self_group_mut = Arc::downgrade(group);\n+\n+        Ok(())\n     }\n \n     // ************** Virtual Memory *************\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/process_group.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/process_group.rs\n@@ -0,0 +1,84 @@\n+use super::{Pgid, Pid, Process, Session};\n+use crate::prelude::*;\n+use crate::process::signal::signals::Signal;\n+\n+/// `ProcessGroup` represents a set of processes. Each `ProcessGroup` has a unique\n+/// identifier `pgid`.\n+pub struct ProcessGroup {\n+    pgid: Pgid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) processes: BTreeMap<Pid, Arc<Process>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) session: Weak<Session>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn remove_process(&mut self, pid: &Pid) {\n+        let Some(process) = self.processes.remove(pid) else {\n+            return;\n+        };\n+\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, &process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.processes.is_empty()\n+    }\n+}\n+\n+impl ProcessGroup {\n+    /// Creates a new process group with one process. The pgid is the same as the process\n+    /// id. The process will become the leading process of the new process group.\n+    ///\n+    /// The caller needs to ensure that the process does not belong to any group.\n+    pub(in crate::process) fn new(process: Arc<Process>) -> Arc<Self> {\n+        let pid = process.pid();\n+\n+        let inner = {\n+            let mut processes = BTreeMap::new();\n+            processes.insert(pid, process.clone());\n+            Inner {\n+                processes,\n+                leader: Some(process.clone()),\n+                session: Weak::new(),\n+            }\n+        };\n+\n+        Arc::new(ProcessGroup {\n+            pgid: pid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns whether self contains a process with `pid`.\n+    pub(in crate::process) fn contains_process(&self, pid: Pid) -> bool {\n+        self.inner.lock().processes.contains_key(&pid)\n+    }\n+\n+    /// Returns the process group identifier\n+    pub fn pgid(&self) -> Pgid {\n+        self.pgid\n+    }\n+\n+    /// Broadcasts signal to all processes in the group.\n+    pub fn broadcast_signal(&self, signal: impl Signal + Clone + 'static) {\n+        for process in self.inner.lock().processes.values() {\n+            process.enqueue_signal(Box::new(signal.clone()));\n+        }\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns the session which the group belongs to\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        self.inner.lock().session.upgrade()\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/session.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/session.rs\n@@ -0,0 +1,133 @@\n+use crate::prelude::*;\n+\n+use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\n+\n+/// A `Session` is a collection of related process groups. Each session has a\n+/// unique identifier `sid`. Process groups and sessions form a two-level\n+/// hierarchical relationship between processes.\n+///\n+/// **Leader**: A *session leader* is the process that creates a new session and whose process\n+/// ID becomes the session ID.\n+///\n+/// **Controlling terminal**: The terminal can be used to manage all processes in the session. The\n+/// controlling terminal is established when the session leader first opens a terminal.\n+pub struct Session {\n+    sid: Sid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) process_groups: BTreeMap<Pgid, Arc<ProcessGroup>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) terminal: Option<Arc<dyn Terminal>>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.process_groups.is_empty()\n+    }\n+\n+    pub(in crate::process) fn remove_process(&mut self, process: &Arc<Process>) {\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn remove_process_group(&mut self, pgid: &Pgid) {\n+        self.process_groups.remove(pgid);\n+    }\n+}\n+\n+impl Session {\n+    /// Creates a new session for the process group. The process group becomes the member of\n+    /// the new session.\n+    ///\n+    /// The caller needs to ensure that the group does not belong to any session, and the caller\n+    /// should set the leader process after creating the session.\n+    pub(in crate::process) fn new(group: Arc<ProcessGroup>) -> Arc<Self> {\n+        let sid = group.pgid();\n+        let inner = {\n+            let mut process_groups = BTreeMap::new();\n+            process_groups.insert(group.pgid(), group);\n+\n+            Inner {\n+                process_groups,\n+                leader: None,\n+                terminal: None,\n+            }\n+        };\n+        Arc::new(Self {\n+            sid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns the session id\n+    pub fn sid(&self) -> Sid {\n+        self.sid\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns whether `self` contains the `process_group`\n+    pub(in crate::process) fn contains_process_group(\n+        self: &Arc<Self>,\n+        process_group: &Arc<ProcessGroup>,\n+    ) -> bool {\n+        self.inner\n+            .lock()\n+            .process_groups\n+            .contains_key(&process_group.pgid())\n+    }\n+\n+    /// Sets terminal as the controlling terminal of the session. The `get_terminal` method\n+    /// should set the session for the terminal and returns the session.\n+    ///\n+    /// If the session already has controlling terminal, this method will return `Err(EPERM)`.\n+    pub fn set_terminal<F>(&self, get_terminal: F) -> Result<()>\n+    where\n+        F: Fn() -> Result<Arc<dyn Terminal>>,\n+    {\n+        let mut inner = self.inner.lock();\n+\n+        if inner.terminal.is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"current session already has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = get_terminal()?;\n+        inner.terminal = Some(terminal);\n+        Ok(())\n+    }\n+\n+    /// Releases the controlling terminal of the session.\n+    ///\n+    /// If the session does not have controlling terminal, this method will return `ENOTTY`.\n+    pub fn release_terminal<F>(&self, release_session: F) -> Result<()>\n+    where\n+        F: Fn(&Arc<dyn Terminal>) -> Result<()>,\n+    {\n+        let mut inner = self.inner.lock();\n+        if inner.terminal.is_none() {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"current session does not has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = inner.terminal.as_ref().unwrap();\n+        release_session(terminal)?;\n+        inner.terminal = None;\n+        Ok(())\n+    }\n+\n+    /// Returns the controlling terminal of `self`.\n+    pub fn terminal(&self) -> Option<Arc<dyn Terminal>> {\n+        self.inner.lock().terminal.clone()\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/terminal.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/terminal.rs\n@@ -0,0 +1,104 @@\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, ProcessGroup};\n+\n+use super::JobControl;\n+\n+/// A termial is used to interact with system. A terminal can support the shell\n+/// job control.\n+///\n+/// We currently support two kinds of terminal, the tty and pty.\n+pub trait Terminal: Send + Sync + FileIo {\n+    // *************** Foreground ***************\n+\n+    /// Returns the foreground process group\n+    fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.job_control().foreground()\n+    }\n+\n+    /// Sets the foreground process group of this terminal.\n+    ///\n+    /// If the terminal is not controlling terminal, this method returns `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn set_foreground(&self, pgid: &Pgid) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"self is not controlling terminal\");\n+        }\n+\n+        let foreground = process_table::get_process_group(pgid);\n+\n+        self.job_control().set_foreground(foreground.as_ref())\n+    }\n+\n+    // *************** Session and controlling terminal ***************\n+\n+    /// Returns whether the terminal is the controlling terminal of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn is_controlling_terminal(&self) -> bool {\n+        let session = current!().session().unwrap();\n+        let Some(terminal) = session.terminal() else {\n+            return false;\n+        };\n+\n+        let arc_self = self.arc_self();\n+        Arc::ptr_eq(&terminal, &arc_self)\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// If self is not session leader, or the terminal is controlling terminal of other session,\n+    /// or the session already has controlling terminal, this method returns `EPERM`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn set_current_session(&self) -> Result<()> {\n+        if !current!().is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"current process is not session leader\");\n+        }\n+\n+        let get_terminal = || {\n+            self.job_control().set_current_session()?;\n+            Ok(self.arc_self())\n+        };\n+\n+        let session = current!().session().unwrap();\n+        session.set_terminal(get_terminal)\n+    }\n+\n+    /// Releases the terminal from the session of current process if the terminal is the controlling\n+    /// terminal of the session.\n+    ///\n+    /// If the terminal is not the controlling terminal of the session, this method will return `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn release_current_session(&self) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"release wrong tty\");\n+        }\n+\n+        let current = current!();\n+        if !current.is_session_leader() {\n+            warn!(\"TODO: release tty for process that is not session leader\");\n+            return Ok(());\n+        }\n+\n+        let release_session = |_: &Arc<dyn Terminal>| self.job_control().release_current_session();\n+\n+        let session = current.session().unwrap();\n+        session.release_terminal(release_session)\n+    }\n+\n+    /// Returns the job control of the terminal.\n+    fn job_control(&self) -> &JobControl;\n+\n+    fn arc_self(&self) -> Arc<dyn Terminal>;\n+}\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs /dev/null\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ /dev/null\n@@ -1,85 +0,0 @@\n-use super::{\n-    process_table,\n-    signal::signals::{kernel::KernelSignal, user::UserSignal},\n-    Pgid, Pid, Process,\n-};\n-use crate::prelude::*;\n-\n-pub struct ProcessGroup {\n-    inner: Mutex<ProcessGroupInner>,\n-}\n-\n-struct ProcessGroupInner {\n-    pgid: Pgid,\n-    processes: BTreeMap<Pid, Arc<Process>>,\n-    leader_process: Option<Arc<Process>>,\n-}\n-\n-impl ProcessGroup {\n-    fn default() -> Self {\n-        ProcessGroup {\n-            inner: Mutex::new(ProcessGroupInner {\n-                pgid: 0,\n-                processes: BTreeMap::new(),\n-                leader_process: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new(process: Arc<Process>) -> Self {\n-        let process_group = ProcessGroup::default();\n-        let pid = process.pid();\n-        process_group.set_pgid(pid);\n-        process_group.add_process(process.clone());\n-        process_group.set_leader_process(process);\n-        process_group\n-    }\n-\n-    pub fn set_pgid(&self, pgid: Pgid) {\n-        self.inner.lock().pgid = pgid;\n-    }\n-\n-    pub fn set_leader_process(&self, leader_process: Arc<Process>) {\n-        self.inner.lock().leader_process = Some(leader_process);\n-    }\n-\n-    pub fn add_process(&self, process: Arc<Process>) {\n-        self.inner.lock().processes.insert(process.pid(), process);\n-    }\n-\n-    pub fn contains_process(&self, pid: Pid) -> bool {\n-        self.inner.lock().processes.contains_key(&pid)\n-    }\n-\n-    /// remove a process from this process group.\n-    /// If this group contains no processes now, the group itself will be deleted from global table.\n-    pub fn remove_process(&self, pid: Pid) {\n-        let mut inner_lock = self.inner.lock();\n-        inner_lock.processes.remove(&pid);\n-        let len = inner_lock.processes.len();\n-        let pgid = inner_lock.pgid;\n-        // if self contains no process, remove self from table\n-        if len == 0 {\n-            // this must be the last statement\n-            process_table::remove_process_group(pgid);\n-        }\n-    }\n-\n-    pub fn pgid(&self) -> Pgid {\n-        self.inner.lock().pgid\n-    }\n-\n-    /// send kernel signal to all processes in the group\n-    pub fn kernel_signal(&self, signal: KernelSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-\n-    /// send user signal to all processes in the group\n-    pub fn user_signal(&self, signal: UserSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -5,35 +5,25 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n-use super::{process_group::ProcessGroup, Pgid, Pid, Process};\n+use super::{Pgid, Pid, Process, ProcessGroup, Session, Sid};\n \n-lazy_static! {\n-    static ref PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n-    static ref PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> =\n-        Mutex::new(BTreeMap::new());\n-    static ref PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n-}\n-\n-/// add a process to global table\n-pub fn add_process(process: Arc<Process>) {\n-    let pid = process.pid();\n-    PROCESS_TABLE.lock().insert(pid, process);\n-}\n+static PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n+static SESSION_TABLE: Mutex<BTreeMap<Sid, Arc<Session>>> = Mutex::new(BTreeMap::new());\n \n-/// remove a process from global table\n-pub fn remove_process(pid: Pid) {\n-    PROCESS_TABLE.lock().remove(&pid);\n+// ************ Process *************\n \n-    let events = PidEvent::Exit(pid);\n-    PROCESS_TABLE_SUBJECT.notify_observers(&events);\n+/// Gets a process with pid\n+pub fn get_process(pid: &Pid) -> Option<Arc<Process>> {\n+    PROCESS_TABLE.lock().get(pid).cloned()\n }\n \n-/// get a process with pid\n-pub fn pid_to_process(pid: Pid) -> Option<Arc<Process>> {\n-    PROCESS_TABLE.lock().get(&pid).cloned()\n+pub(super) fn process_table_mut() -> MutexGuard<'static, BTreeMap<Pid, Arc<Process>>> {\n+    PROCESS_TABLE.lock()\n }\n \n-/// get all processes\n+/// Gets all processes\n pub fn get_all_processes() -> Vec<Arc<Process>> {\n     PROCESS_TABLE\n         .lock()\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -42,26 +32,41 @@ pub fn get_all_processes() -> Vec<Arc<Process>> {\n         .collect()\n }\n \n-/// add process group to global table\n-pub fn add_process_group(process_group: Arc<ProcessGroup>) {\n-    let pgid = process_group.pgid();\n-    PROCESS_GROUP_TABLE.lock().insert(pgid, process_group);\n+// ************ Process Group *************\n+\n+/// Gets a process group with `pgid`\n+pub fn get_process_group(pgid: &Pgid) -> Option<Arc<ProcessGroup>> {\n+    PROCESS_GROUP_TABLE.lock().get(pgid).cloned()\n+}\n+\n+/// Returns whether process table contains process group with pgid\n+pub fn contain_process_group(pgid: &Pgid) -> bool {\n+    PROCESS_GROUP_TABLE.lock().contains_key(pgid)\n }\n \n-/// remove process group from global table\n-pub fn remove_process_group(pgid: Pgid) {\n-    PROCESS_GROUP_TABLE.lock().remove(&pgid);\n+pub(super) fn group_table_mut() -> MutexGuard<'static, BTreeMap<Pgid, Arc<ProcessGroup>>> {\n+    PROCESS_GROUP_TABLE.lock()\n }\n \n-/// get a process group with pgid\n-pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n-    PROCESS_GROUP_TABLE.lock().get(&pgid).cloned()\n+// ************ Session *************\n+\n+/// Gets a session with `sid`.\n+pub fn get_session(sid: &Sid) -> Option<Arc<Session>> {\n+    SESSION_TABLE.lock().get(sid).map(Arc::clone)\n }\n \n+pub(super) fn session_table_mut() -> MutexGuard<'static, BTreeMap<Sid, Arc<Session>>> {\n+    SESSION_TABLE.lock()\n+}\n+\n+// ************ Observer *************\n+\n+/// Registers an observer which watches `PidEvent`.\n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n+/// Unregisters an observer which watches `PidEvent`.\n pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\ndiff --git a/services/libs/jinux-std/src/process/wait.rs b/services/libs/jinux-std/src/process/wait.rs\n--- a/services/libs/jinux-std/src/process/wait.rs\n+++ b/services/libs/jinux-std/src/process/wait.rs\n@@ -80,9 +80,33 @@ fn reap_zombie_child(process: &Process, pid: Pid) -> u32 {\n     for thread in &*child_process.threads().lock() {\n         thread_table::remove_thread(thread.tid());\n     }\n-    process_table::remove_process(child_process.pid());\n-    if let Some(process_group) = child_process.process_group() {\n-        process_group.remove_process(child_process.pid());\n+\n+    // Lock order: session table -> group table -> process table -> group of process\n+    // -> group inner -> session inner\n+    let mut session_table_mut = process_table::session_table_mut();\n+    let mut group_table_mut = process_table::group_table_mut();\n+    let mut process_table_mut = process_table::process_table_mut();\n+\n+    let mut child_group_mut = child_process.process_group.lock();\n+\n+    let process_group = child_group_mut.upgrade().unwrap();\n+    let mut group_inner = process_group.inner.lock();\n+    let session = group_inner.session.upgrade().unwrap();\n+    let mut session_inner = session.inner.lock();\n+\n+    group_inner.remove_process(&child_process.pid());\n+    session_inner.remove_process(&child_process);\n+    *child_group_mut = Weak::new();\n+\n+    if group_inner.is_empty() {\n+        group_table_mut.remove(&process_group.pgid());\n+        session_inner.remove_process_group(&process_group.pgid());\n+\n+        if session_inner.is_empty() {\n+            session_table_mut.remove(&session.sid());\n+        }\n     }\n+\n+    process_table_mut.remove(&child_process.pid());\n     child_process.exit_code().unwrap()\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/getsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/getsid.rs\n@@ -0,0 +1,30 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pid};\n+\n+use super::{SyscallReturn, SYS_GETSID};\n+\n+pub fn sys_getsid(pid: Pid) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_GETSID);\n+    debug!(\"pid = {}\", pid);\n+\n+    let session = current!().session().unwrap();\n+    let sid = session.sid();\n+\n+    if pid == 0 {\n+        return Ok(SyscallReturn::Return(sid as _));\n+    }\n+\n+    let Some(process) = process_table::get_process(&pid) else {\n+        return_errno_with_message!(Errno::ESRCH, \"the process does not exist\")\n+    };\n+\n+    if !Arc::ptr_eq(&session, &process.session().unwrap()) {\n+        return_errno_with_message!(\n+            Errno::EPERM,\n+            \"the process and current process does not belong to the same session\"\n+        );\n+    }\n+\n+    Ok(SyscallReturn::Return(sid as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/jinux-std/src/syscall/kill.rs\n--- a/services/libs/jinux-std/src/syscall/kill.rs\n+++ b/services/libs/jinux-std/src/syscall/kill.rs\n@@ -34,15 +34,15 @@ pub fn do_sys_kill(filter: ProcessFilter, sig_num: SigNum) -> Result<()> {\n             }\n         }\n         ProcessFilter::WithPid(pid) => {\n-            if let Some(process) = process_table::pid_to_process(pid) {\n+            if let Some(process) = process_table::get_process(&pid) {\n                 process.enqueue_signal(Box::new(signal));\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process in process table\");\n             }\n         }\n         ProcessFilter::WithPgid(pgid) => {\n-            if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-                process_group.user_signal(signal);\n+            if let Some(process_group) = process_table::get_process_group(&pgid) {\n+                process_group.broadcast_signal(signal);\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process group in process table\");\n             }\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -77,12 +77,14 @@ use self::connect::sys_connect;\n use self::execve::sys_execveat;\n use self::getpeername::sys_getpeername;\n use self::getrandom::sys_getrandom;\n+use self::getsid::sys_getsid;\n use self::getsockname::sys_getsockname;\n use self::getsockopt::sys_getsockopt;\n use self::listen::sys_listen;\n use self::pread64::sys_pread64;\n use self::recvfrom::sys_recvfrom;\n use self::sendto::sys_sendto;\n+use self::setsid::sys_setsid;\n use self::setsockopt::sys_setsockopt;\n use self::shutdown::sys_shutdown;\n use self::socket::sys_socket;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -119,6 +121,7 @@ mod getpgrp;\n mod getpid;\n mod getppid;\n mod getrandom;\n+mod getsid;\n mod getsockname;\n mod getsockopt;\n mod gettid;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -155,6 +158,7 @@ mod sendto;\n mod set_robust_list;\n mod set_tid_address;\n mod setpgid;\n+mod setsid;\n mod setsockopt;\n mod shutdown;\n mod socket;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -274,6 +278,8 @@ define_syscall_nums!(\n     SYS_SETPGID = 109,\n     SYS_GETPPID = 110,\n     SYS_GETPGRP = 111,\n+    SYS_SETSID = 112,\n+    SYS_GETSID = 124,\n     SYS_STATFS = 137,\n     SYS_FSTATFS = 138,\n     SYS_PRCTL = 157,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -435,6 +441,8 @@ pub fn syscall_dispatch(\n         SYS_SETPGID => syscall_handler!(2, sys_setpgid, args),\n         SYS_GETPPID => syscall_handler!(0, sys_getppid),\n         SYS_GETPGRP => syscall_handler!(0, sys_getpgrp),\n+        SYS_SETSID => syscall_handler!(0, sys_setsid),\n+        SYS_GETSID => syscall_handler!(1, sys_getsid, args),\n         SYS_STATFS => syscall_handler!(2, sys_statfs, args),\n         SYS_FSTATFS => syscall_handler!(2, sys_fstatfs, args),\n         SYS_PRCTL => syscall_handler!(5, sys_prctl, args),\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -1,8 +1,6 @@\n-use crate::{\n-    log_syscall_entry,\n-    prelude::*,\n-    process::{process_table, Pgid, Pid, ProcessGroup},\n-};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, Pid};\n \n use super::{SyscallReturn, SYS_SETPGID};\n \ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -15,7 +13,7 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     let pgid = if pgid == 0 { pid } else { pgid };\n     debug!(\"pid = {}, pgid = {}\", pid, pgid);\n \n-    if pid != current.pid() && !current.children().lock().contains_key(&pid) {\n+    if pid != current.pid() && !current.has_child(&pid) {\n         return_errno_with_message!(\n             Errno::ESRCH,\n             \"cannot set pgid for process other than current or children of current\"\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -25,27 +23,14 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     // How can we determine a child process has called execve?\n \n     // only can move process to an existing group or self\n-    if pgid != pid && process_table::pgid_to_process_group(pgid).is_none() {\n+    if pgid != pid && !process_table::contain_process_group(&pgid) {\n         return_errno_with_message!(Errno::EPERM, \"process group must exist\");\n     }\n \n-    let process = process_table::pid_to_process(pid)\n+    let process = process_table::get_process(&pid)\n         .ok_or(Error::with_message(Errno::ESRCH, \"process does not exist\"))?;\n \n-    // if the process already belongs to the process group\n-    if process.pgid() == pgid {\n-        return Ok(SyscallReturn::Return(0));\n-    }\n-\n-    if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-        process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&process_group));\n-    } else {\n-        let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-        // new_process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&new_process_group));\n-        process_table::add_process_group(new_process_group);\n-    }\n+    process.to_other_group(pgid)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/setsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/setsid.rs\n@@ -0,0 +1,13 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+\n+use super::{SyscallReturn, SYS_SETSID};\n+\n+pub fn sys_setsid() -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_SETSID);\n+\n+    let current = current!();\n+    let session = current.to_new_session()?;\n+\n+    Ok(SyscallReturn::Return(session.sid() as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/jinux-std/src/syscall/tgkill.rs\n--- a/services/libs/jinux-std/src/syscall/tgkill.rs\n+++ b/services/libs/jinux-std/src/syscall/tgkill.rs\n@@ -16,8 +16,8 @@ pub fn sys_tgkill(tgid: Pid, tid: Tid, sig_num: u8) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_TGKILL);\n     let sig_num = SigNum::from_u8(sig_num);\n     info!(\"tgid = {}, pid = {}, sig_num = {:?}\", tgid, tid, sig_num);\n-    let target_thread = thread_table::tid_to_thread(tid)\n-        .ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n+    let target_thread =\n+        thread_table::get_thread(tid).ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n     let posix_thread = target_thread.as_posix_thread().unwrap();\n     let pid = posix_thread.process().pid();\n     if pid != tgid {\ndiff --git a/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/jinux-std/src/thread/thread_table.rs\n--- a/services/libs/jinux-std/src/thread/thread_table.rs\n+++ b/services/libs/jinux-std/src/thread/thread_table.rs\n@@ -15,6 +15,6 @@ pub fn remove_thread(tid: Tid) {\n     THREAD_TABLE.lock().remove(&tid);\n }\n \n-pub fn tid_to_thread(tid: Tid) -> Option<Arc<Thread>> {\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n     THREAD_TABLE.lock().get(&tid).cloned()\n }\n",
        "test_patch": "diff --git a/regression/syscall_test/blocklists/pty_test b/regression/syscall_test/blocklists/pty_test\n--- a/regression/syscall_test/blocklists/pty_test\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -21,22 +21,8 @@ PtyTest.SwitchNoncanonToCanonNoNewlineBig\n PtyTest.NoncanonBigWrite\n PtyTest.SwitchNoncanonToCanonMultiline\n PtyTest.SwitchTwiceMultiline\n-JobControlTest.SetTTYMaster\n-JobControlTest.SetTTY\n-JobControlTest.SetTTYNonLeader\n JobControlTest.SetTTYBadArg\n JobControlTest.SetTTYDifferentSession\n-JobControlTest.ReleaseTTY\n-JobControlTest.ReleaseUnsetTTY\n-JobControlTest.ReleaseWrongTTY\n-JobControlTest.ReleaseTTYNonLeader\n-JobControlTest.ReleaseTTYDifferentSession\n JobControlTest.ReleaseTTYSignals\n-JobControlTest.GetForegroundProcessGroup\n-JobControlTest.GetForegroundProcessGroupNonControlling\n JobControlTest.SetForegroundProcessGroup\n-JobControlTest.SetForegroundProcessGroupWrongTTY\n-JobControlTest.SetForegroundProcessGroupNegPgid\n-JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n-JobControlTest.SetForegroundProcessGroupDifferentSession\n-JobControlTest.OrphanRegression\n\\ No newline at end of file\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n\\ No newline at end of file\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -319,3 +561,100 @@ pub fn current() -> Arc<Process> {\n         panic!(\"[Internal error]The current thread does not belong to a process\");\n     }\n }\n+\n+#[if_cfg_ktest]\n+mod test {\n+    use super::*;\n+\n+    fn new_process(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        crate::fs::rootfs::init_root_mount();\n+        let pid = allocate_tid();\n+        let parent = if let Some(parent) = parent {\n+            Arc::downgrade(&parent)\n+        } else {\n+            Weak::new()\n+        };\n+        Arc::new(Process::new(\n+            pid,\n+            parent,\n+            vec![],\n+            String::new(),\n+            ProcessVm::alloc(),\n+            Arc::new(Mutex::new(FileTable::new())),\n+            Arc::new(RwLock::new(FsResolver::new())),\n+            Arc::new(RwLock::new(FileCreationMask::default())),\n+            Arc::new(Mutex::new(SigDispositions::default())),\n+            ResourceLimits::default(),\n+        ))\n+    }\n+\n+    fn new_process_in_session(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        // Lock order: session table -> group table -> group of process -> group inner\n+        // -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+\n+        let process = new_process(parent);\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+\n+        // Creates new session\n+        let sess = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&sess);\n+        sess.inner.lock().leader = Some(process.clone());\n+\n+        group_table_mut.insert(group.pgid(), group);\n+        session_table_mut.insert(sess.sid(), sess);\n+\n+        process\n+    }\n+\n+    fn remove_session_and_group(process: Arc<Process>) {\n+        // Lock order: session table -> group table\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        if let Some(sess) = process.session() {\n+            session_table_mut.remove(&sess.sid());\n+        }\n+\n+        if let Some(group) = process.process_group() {\n+            group_table_mut.remove(&group.pgid());\n+        }\n+    }\n+\n+    #[ktest]\n+    fn init_process() {\n+        let process = new_process(None);\n+        assert!(process.process_group().is_none());\n+        assert!(process.session().is_none());\n+    }\n+\n+    #[ktest]\n+    fn init_process_in_session() {\n+        let process = new_process_in_session(None);\n+        assert!(process.is_group_leader());\n+        assert!(process.is_session_leader());\n+        remove_session_and_group(process);\n+    }\n+\n+    #[ktest]\n+    fn to_new_session() {\n+        let process = new_process_in_session(None);\n+        let sess = process.session().unwrap();\n+        sess.inner.lock().leader = None;\n+\n+        assert!(!process.is_session_leader());\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+\n+        let group = process.process_group().unwrap();\n+        group.inner.lock().leader = None;\n+        assert!(!process.is_group_leader());\n+\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_queues.rs b/services/libs/jinux-std/src/process/signal/sig_queues.rs\n--- a/services/libs/jinux-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/jinux-std/src/process/signal/sig_queues.rs\n@@ -81,8 +81,11 @@ impl SigQueues {\n         // POSIX leaves unspecified which to deliver first if there are multiple\n         // pending standard signals. So we are free to define our own. The\n         // principle is to give more urgent signals higher priority (like SIGKILL).\n+\n+        // FIXME: the gvisor pty_test JobControlTest::ReleaseTTY requires that\n+        // the SIGHUP signal should be handled before SIGCONT.\n         const ORDERED_STD_SIGS: [SigNum; COUNT_STD_SIGS] = [\n-            SIGKILL, SIGTERM, SIGSTOP, SIGCONT, SIGSEGV, SIGILL, SIGHUP, SIGINT, SIGQUIT, SIGTRAP,\n+            SIGKILL, SIGTERM, SIGSTOP, SIGSEGV, SIGILL, SIGHUP, SIGCONT, SIGINT, SIGQUIT, SIGTRAP,\n             SIGABRT, SIGBUS, SIGFPE, SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGSTKFLT, SIGCHLD,\n             SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH,\n             SIGIO, SIGPWR, SIGSYS,\n",
        "problem_statement": "Implement session for shell job control\nProcess groups and sessions form a two-level hierarchical relationship between processes. A session is a collection of process groups. A process\u2019s session membership is determined by its session identifier (SID). All of the processes in a session share a single controlling terminal. \r\n\r\nThe related syscalls are getsid and setsid\n",
        "hints_text": "",
        "created_at": "2023-08-30T11:25:32Z",
        "version": "0.2"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1362,
        "instance_id": "asterinas__asterinas-1362",
        "issue_numbers": [
            "964"
        ],
        "base_commit": "f7932595125a0bba8230b5f8d3b110c687d6f3b2",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,13 +1,14 @@\n # SPDX-License-Identifier: MPL-2.0\n \n-# Global options.\n+# =========================== Makefile options. ===============================\n+\n+# Global build options.\n ARCH ?= x86_64\n BENCHMARK ?= none\n BOOT_METHOD ?= grub-rescue-iso\n BOOT_PROTOCOL ?= multiboot2\n BUILD_SYSCALL_TEST ?= 0\n ENABLE_KVM ?= 1\n-GDB_TCP_PORT ?= 1234\n INTEL_TDX ?= 0\n MEM ?= 8G\n RELEASE ?= 0\ndiff --git a/docs/src/osdk/reference/commands/debug.md b/docs/src/osdk/reference/commands/debug.md\n--- a/docs/src/osdk/reference/commands/debug.md\n+++ b/docs/src/osdk/reference/commands/debug.md\n@@ -2,29 +2,39 @@\n \n ## Overview\n \n-`cargo osdk debug` is used to debug a remote target via GDB.\n-The usage is as follows:\n+`cargo osdk debug` is used to debug a remote target via GDB. You need to start\n+a running server to debug with. This is accomplished by the `run` subcommand\n+with `--gdb-server`. Then you can use the following command to attach to the\n+server and do debugging.\n \n ```bash\n cargo osdk debug [OPTIONS]\n ```\n \n+Note that when KVM is enabled, hardware-assisted break points (`hbreak`) are\n+needed instead of the normal break points (`break`/`b`) in GDB.\n+\n ## Options\n \n `--remote <REMOTE>`:\n-Specify the address of the remote target [default: .aster-gdb-socket].\n+Specify the address of the remote target [default: .osdk-gdb-socket].\n The address can be either a path for the UNIX domain socket\n or a TCP port on an IP address.\n \n ## Examples\n \n-- To debug a remote target via a\n-[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html),\n-    - connect to an unix socket, e.g., `./debug`;\n-    ```bash\n-    cargo osdk debug --remote ./debug\n-    ```\n-    - connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`.\n-    ```bash\n-    cargo osdk debug --remote localhost:1234\n-    ```\n+To debug a remote target started with\n+[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html) or the `run`\n+subcommand, use the following commands.\n+\n+Connect to an unix socket, e.g., `./debug`:\n+\n+```bash\n+cargo osdk debug --remote ./debug\n+```\n+\n+Connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`:\n+\n+```bash\n+cargo osdk debug --remote localhost:1234\n+```\ndiff --git /dev/null b/docs/src/osdk/reference/commands/profile.md\nnew file mode 100644\n--- /dev/null\n+++ b/docs/src/osdk/reference/commands/profile.md\n@@ -0,0 +1,75 @@\n+# cargo osdk profile\n+\n+## Overview\n+\n+The profile command is used to collect stack traces when running the target\n+kernel in QEMU. It attaches to the GDB server initiated with the run subcommand\n+and collects the stack trace periodically. The collected information can be\n+used to directly generate a flame graph, or be stored for later analysis using\n+[the original flame graph tool](https://github.com/brendangregg/FlameGraph).\n+\n+## Options\n+\n+`--remote <REMOTE>`:\n+\n+Specify the address of the remote target.\n+By default this is `.osdk-gdb-socket`\n+\n+`--samples <SAMPLES>`:\n+\n+The number of samples to collect (default 200).\n+It is recommended to go beyond 100 for performance analysis.\n+\n+`--interval <INTERVAL>`:\n+\n+The interval between samples in seconds (default 0.1).\n+\n+`--parse <PATH>`:\n+\n+Parse a collected JSON profile file into other formats.\n+\n+`--format <FORMAT>`:\n+\n+Possible values:\n+    - `json`:   The parsed stack trace log from GDB in JSON.\n+    - `folded`: The folded stack trace for flame graph.\n+    - `flame-graph`: A SVG flame graph.\n+\n+If the user does not specify the format, it will be inferred from the\n+output file extension. If the output file does not have an extension,\n+the default format is flame graph.\n+\n+`--cpu-mask <CPU_MASK>`:\n+\n+The mask of the CPU to generate traces for in the output profile data\n+(default first 128 cores). This mask is presented as an integer.\n+\n+`--output <PATH>`:\n+\n+The path to the output profile data file.\n+\n+If the user does not specify the output path, it will be generated from\n+the crate name, current time stamp and the format.\n+\n+## Examples\n+\n+To profile a remote QEMU GDB server running some workload for flame graph, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01\n+```\n+\n+If wanted a detailed analysis, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01 --output trace.json\n+```\n+\n+When you get the above detailed analysis, you can also use the JSON file\n+to generate the folded format for flame graph.\n+\n+```bash\n+cargo osdk profile --parse trace.json --output trace.folded\n+```\ndiff --git a/docs/src/osdk/reference/commands/run.md b/docs/src/osdk/reference/commands/run.md\n--- a/docs/src/osdk/reference/commands/run.md\n+++ b/docs/src/osdk/reference/commands/run.md\n@@ -15,34 +15,34 @@ Most options are the same as those of `cargo osdk build`.\n Refer to the [documentation](build.md) of `cargo osdk build`\n for more details.\n \n-Options related with debugging:\n+Additionally, when running the kernel using QEMU, we can setup the QEMU as a\n+debug server using option `--gdb-server`. This option supports an additional\n+comma separated configuration list:\n \n-- `-G, --enable-gdb`: Enable QEMU GDB server for debugging.\n-- `--vsc`: Generate a '.vscode/launch.json' for debugging kernel with Visual Studio Code\n-(only works when QEMU GDB server is enabled, i.e., `--enable-gdb`).\n-Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb).\n-- `--gdb-server-addr <ADDR>`: The network address on which the GDB server listens,\n-it can be either a path for the UNIX domain socket or a TCP port on an IP address.\n-[default: `.aster-gdb-socket`(a local UNIX socket)]\n+ - `addr=ADDR`: the network or unix socket address on which the GDB server listens\n+    (default: `.osdk-gdb-socket`, a local UNIX socket);\n+ - `wait-client`: let the GDB server wait for the GDB client before execution;\n+ - `vscode`: generate a '.vscode/launch.json' for debugging with Visual Studio Code\n+    (Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)).\n \n See [Debug Command](debug.md) to interact with the GDB server in terminal.\n \n ## Examples\n \n-- Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n+Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr .debug\n+cargo osdk run --gdb-server addr=.debug\n ```\n \n-- Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n+Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr :1234\n+cargo osdk run --gdb-server addr=:1234\n ```\n \n-- Launch a debug server via QEMU and use VSCode to interact:\n+Launch a debug server via QEMU and use VSCode to interact with:\n \n ```bash\n-cargo osdk run --enable-gdb --vsc --gdb-server-addr :1234\n+cargo osdk run --gdb-server wait-client,vscode,addr=:1234\n ```\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -15,6 +15,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011\"\n dependencies = [\n  \"cfg-if\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n  \"zerocopy\",\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -35,6 +36,21 @@ version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f\"\n \n+[[package]]\n+name = \"android-tzdata\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0\"\n+\n+[[package]]\n+name = \"android_system_properties\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"anstream\"\n version = \"0.6.12\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -83,6 +99,12 @@ dependencies = [\n  \"windows-sys\",\n ]\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50\"\n+\n [[package]]\n name = \"assert_cmd\"\n version = \"2.0.14\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -98,12 +120,24 @@ dependencies = [\n  \"wait-timeout\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"2.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de\"\n+\n [[package]]\n name = \"block-buffer\"\n version = \"0.10.4\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -124,6 +158,12 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.16.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c\"\n+\n [[package]]\n name = \"bytemuck\"\n version = \"1.17.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -149,9 +189,12 @@ name = \"cargo-osdk\"\n version = \"0.8.3\"\n dependencies = [\n  \"assert_cmd\",\n+ \"chrono\",\n  \"clap\",\n  \"env_logger\",\n  \"indexmap\",\n+ \"indicatif\",\n+ \"inferno\",\n  \"lazy_static\",\n  \"linux-bzimage-builder\",\n  \"log\",\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -166,12 +209,35 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"cc\"\n+version = \"1.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07b1695e2c7e8fc85310cde85aeaab7e3097f593c91d209d3f9df76c928100f0\"\n+dependencies = [\n+ \"shlex\",\n+]\n+\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"chrono\"\n+version = \"0.4.38\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401\"\n+dependencies = [\n+ \"android-tzdata\",\n+ \"iana-time-zone\",\n+ \"js-sys\",\n+ \"num-traits\",\n+ \"wasm-bindgen\",\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"clap\"\n version = \"4.5.1\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -218,6 +284,25 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7\"\n \n+[[package]]\n+name = \"console\"\n+version = \"0.15.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0e1f83fc076bd6dd27517eacdf25fef6c4dfe5f1d7448bafaaf3a26f13b5e4eb\"\n+dependencies = [\n+ \"encode_unicode\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"unicode-width\",\n+ \"windows-sys\",\n+]\n+\n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.8.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\"\n+\n [[package]]\n name = \"core2\"\n version = \"0.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -245,6 +330,21 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.20\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80\"\n+\n [[package]]\n name = \"crypto-common\"\n version = \"0.1.6\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -261,6 +361,20 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7762d17f1241643615821a8455a0b2c3e803784b058693d990b11f2dce25a0ca\"\n \n+[[package]]\n+name = \"dashmap\"\n+version = \"6.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+ \"hashbrown\",\n+ \"lock_api\",\n+ \"once_cell\",\n+ \"parking_lot_core\",\n+]\n+\n [[package]]\n name = \"difflib\"\n version = \"0.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -283,6 +397,12 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10\"\n \n+[[package]]\n+name = \"encode_unicode\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n+\n [[package]]\n name = \"env_filter\"\n version = \"0.1.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -322,6 +442,17 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.14.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -338,12 +469,41 @@ version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc\"\n+\n [[package]]\n name = \"humantime\"\n version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n+[[package]]\n+name = \"iana-time-zone\"\n+version = \"0.1.61\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220\"\n+dependencies = [\n+ \"android_system_properties\",\n+ \"core-foundation-sys\",\n+ \"iana-time-zone-haiku\",\n+ \"js-sys\",\n+ \"wasm-bindgen\",\n+ \"windows-core\",\n+]\n+\n+[[package]]\n+name = \"iana-time-zone-haiku\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"indexmap\"\n version = \"2.2.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -354,12 +514,77 @@ dependencies = [\n  \"hashbrown\",\n ]\n \n+[[package]]\n+name = \"indicatif\"\n+version = \"0.17.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"763a5a8f45087d6bcea4222e7b72c291a054edf80e4ef6efd2a4979878c7bea3\"\n+dependencies = [\n+ \"console\",\n+ \"instant\",\n+ \"number_prefix\",\n+ \"portable-atomic\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"inferno\"\n+version = \"0.11.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"232929e1d75fe899576a3d5c7416ad0d88dbfbb3c3d6aa00873a7408a50ddb88\"\n+dependencies = [\n+ \"ahash\",\n+ \"clap\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-utils\",\n+ \"dashmap\",\n+ \"env_logger\",\n+ \"indexmap\",\n+ \"is-terminal\",\n+ \"itoa\",\n+ \"log\",\n+ \"num-format\",\n+ \"once_cell\",\n+ \"quick-xml\",\n+ \"rgb\",\n+ \"str_stack\",\n+]\n+\n+[[package]]\n+name = \"instant\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"is-terminal\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"1.0.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c\"\n \n+[[package]]\n+name = \"js-sys\"\n+version = \"0.3.70\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a\"\n+dependencies = [\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -368,9 +593,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.153\"\n+version = \"0.2.159\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd\"\n+checksum = \"561d97a539a36e26a9a5fad1ea11a3039a67714694aaa379433e580854bc3dc5\"\n \n [[package]]\n name = \"libflate\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -400,13 +625,23 @@ dependencies = [\n name = \"linux-bzimage-builder\"\n version = \"0.2.0\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"bytemuck\",\n  \"libflate\",\n  \"serde\",\n  \"xmas-elf\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\n+dependencies = [\n+ \"autocfg\",\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.20\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -419,12 +654,56 @@ version = \"2.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n+[[package]]\n+name = \"num-format\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a652d9771a63711fd3c3deb670acfbe5c30a4072e664d7a3bf5a9e1056ac72c3\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"itoa\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.2.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"number_prefix\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.9.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"portable-atomic\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d30538d42559de6b034bc76fd6dd4c38961b1ee5c6c56e3808c50128fdbc22ce\"\n+\n [[package]]\n name = \"predicates\"\n version = \"3.1.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -461,6 +740,15 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"quick-xml\"\n+version = \"0.26.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7f50b1c63b38611e7d4d7f68b82d3ad0cc71a2ad2e7f61fc10f1328d917c93cd\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.35\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -470,6 +758,15 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.5.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"355ae415ccd3a04315d3f8246e86d67689ea74d88d915576e1589a351062a13b\"\n+dependencies = [\n+ \"bitflags 2.6.0\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"1.10.4\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -508,6 +805,15 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"rgb\"\n+version = \"0.8.50\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"57397d16646700483b67d2dd6511d79318f9d057fdbd21a4066aeac8b41d310a\"\n+dependencies = [\n+ \"bytemuck\",\n+]\n+\n [[package]]\n name = \"rle-decode-fast\"\n version = \"1.0.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -520,6 +826,12 @@ version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1\"\n \n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.197\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -577,6 +889,18 @@ version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.13.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n+\n+[[package]]\n+name = \"str_stack\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9091b6114800a5f2141aee1d1b9d6ca3592ac062dc5decb3764ec5895a47b4eb\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.11.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -647,6 +971,12 @@ version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n \n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af\"\n+\n [[package]]\n name = \"utf8parse\"\n version = \"0.2.1\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -668,6 +998,76 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n+\n+[[package]]\n+name = \"wasm-bindgen\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+ \"wasm-bindgen-macro\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-backend\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b\"\n+dependencies = [\n+ \"bumpalo\",\n+ \"log\",\n+ \"once_cell\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf\"\n+dependencies = [\n+ \"quote\",\n+ \"wasm-bindgen-macro-support\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro-support\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-backend\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-shared\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484\"\n+\n+[[package]]\n+name = \"windows-core\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.52.0\"\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -19,8 +19,11 @@ version = \"0.2.0\"\n \n [dependencies]\n clap = { version = \"4.4.17\", features = [\"cargo\", \"derive\"] }\n+chrono = \"0.4.38\"\n env_logger = \"0.11.0\"\n+inferno = \"0.11.21\"\n indexmap = \"2.2.1\"\n+indicatif = \"0.17.8\" # For a commandline progress bar\n lazy_static = \"1.4.0\"\n log = \"0.4.20\"\n quote = \"1.0.35\"\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -37,7 +37,7 @@ pub fn main() {\n         OsdkSubcommand::Run(run_args) => {\n             execute_run_command(\n                 &load_config(&run_args.common_args),\n-                &run_args.gdb_server_args,\n+                run_args.gdb_server.as_deref(),\n             );\n         }\n         OsdkSubcommand::Debug(debug_args) => {\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -160,49 +168,150 @@ pub struct BuildArgs {\n \n #[derive(Debug, Parser)]\n pub struct RunArgs {\n+    #[arg(\n+        long = \"gdb-server\",\n+        help = \"Enable the QEMU GDB server for debugging\\n\\\n+                This option supports an additional comma separated configuration list:\\n\\t \\\n+                    addr=ADDR:   the network or unix socket address on which the GDB server listens, \\\n+                                 `.osdk-gdb-socket` by default;\\n\\t \\\n+                    wait-client: let the GDB server wait for the GDB client before execution;\\n\\t \\\n+                    vscode:      generate a '.vscode/launch.json' for debugging with Visual Studio Code.\",\n+        value_name = \"[addr=ADDR][,wait-client][,vscode]\",\n+        default_missing_value = \"\"\n+    )]\n+    pub gdb_server: Option<String>,\n     #[command(flatten)]\n-    pub gdb_server_args: GdbServerArgs,\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Debug, Parser)]\n+pub struct DebugArgs {\n+    #[arg(\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n+    )]\n+    pub remote: String,\n     #[command(flatten)]\n     pub common_args: CommonArgs,\n }\n \n-#[derive(Debug, Args, Clone, Default)]\n-pub struct GdbServerArgs {\n-    /// Whether to enable QEMU GDB server for debugging\n+#[derive(Debug, Parser)]\n+pub struct ProfileArgs {\n     #[arg(\n-        long = \"enable-gdb\",\n-        short = 'G',\n-        help = \"Enable QEMU GDB server for debugging\",\n-        default_value_t\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n     )]\n-    pub is_gdb_enabled: bool,\n+    pub remote: String,\n+    #[arg(long, help = \"The number of samples to collect\", default_value = \"200\")]\n+    pub samples: usize,\n     #[arg(\n-        long = \"vsc\",\n-        help = \"Generate a '.vscode/launch.json' for debugging with Visual Studio Code \\\n-                (only works when '--enable-gdb' is enabled)\",\n-        default_value_t\n+        long,\n+        help = \"The interval between samples in seconds\",\n+        default_value = \"0.1\"\n     )]\n-    pub vsc_launch_file: bool,\n+    pub interval: f64,\n     #[arg(\n-        long = \"gdb-server-addr\",\n-        help = \"The network address on which the GDB server listens, \\\n-        it can be either a path for the UNIX domain socket or a TCP port on an IP address.\",\n-        value_name = \"ADDR\",\n-        default_value = \".aster-gdb-socket\"\n+        long,\n+        help = \"Parse a collected JSON profile file into other formats\",\n+        value_name = \"PATH\",\n+        conflicts_with = \"samples\",\n+        conflicts_with = \"interval\"\n     )]\n-    pub gdb_server_addr: String,\n+    pub parse: Option<PathBuf>,\n+    #[command(flatten)]\n+    pub out_args: DebugProfileOutArgs,\n+    #[command(flatten)]\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Clone, Copy, Debug, ValueEnum)]\n+pub enum ProfileFormat {\n+    /// The raw stack trace log parsed from GDB in JSON\n+    Json,\n+    /// The folded stack trace for generating a flame graph later using\n+    /// [the original tool](https://github.com/brendangregg/FlameGraph)\n+    Folded,\n+    /// A SVG flame graph\n+    FlameGraph,\n+}\n+\n+impl ProfileFormat {\n+    pub fn file_extension(&self) -> &'static str {\n+        match self {\n+            ProfileFormat::Json => \"json\",\n+            ProfileFormat::Folded => \"folded\",\n+            ProfileFormat::FlameGraph => \"svg\",\n+        }\n+    }\n }\n \n #[derive(Debug, Parser)]\n-pub struct DebugArgs {\n+pub struct DebugProfileOutArgs {\n+    #[arg(long, help = \"The output format for the profile data\")]\n+    format: Option<ProfileFormat>,\n     #[arg(\n         long,\n-        help = \"Specify the address of the remote target\",\n-        default_value = \".aster-gdb-socket\"\n+        help = \"The mask of the CPU to generate traces for in the output profile data\",\n+        default_value_t = u128::MAX\n     )]\n-    pub remote: String,\n-    #[command(flatten)]\n-    pub common_args: CommonArgs,\n+    pub cpu_mask: u128,\n+    #[arg(\n+        long,\n+        help = \"The path to the output profile data file\",\n+        value_name = \"PATH\"\n+    )]\n+    output: Option<PathBuf>,\n+}\n+\n+impl DebugProfileOutArgs {\n+    /// Get the output format for the profile data.\n+    ///\n+    /// If the user does not specify the format, it will be inferred from the\n+    /// output file extension. If the output file does not have an extension,\n+    /// the default format is flame graph.\n+    pub fn format(&self) -> ProfileFormat {\n+        self.format.unwrap_or_else(|| {\n+            if self.output.is_some() {\n+                match self.output.as_ref().unwrap().extension() {\n+                    Some(ext) if ext == \"folded\" => ProfileFormat::Folded,\n+                    Some(ext) if ext == \"json\" => ProfileFormat::Json,\n+                    Some(ext) if ext == \"svg\" => ProfileFormat::FlameGraph,\n+                    _ => ProfileFormat::FlameGraph,\n+                }\n+            } else {\n+                ProfileFormat::FlameGraph\n+            }\n+        })\n+    }\n+\n+    /// Get the output path for the profile data.\n+    ///\n+    /// If the user does not specify the output path, it will be generated from\n+    /// the current time stamp and the format. The caller can provide a hint\n+    /// output path to the file to override the file name.\n+    pub fn output_path(&self, hint: Option<&PathBuf>) -> PathBuf {\n+        self.output.clone().unwrap_or_else(|| {\n+            use chrono::{offset::Local, DateTime};\n+            let file_stem = if let Some(hint) = hint {\n+                format!(\n+                    \"{}\",\n+                    hint.parent()\n+                        .unwrap()\n+                        .join(hint.file_stem().unwrap())\n+                        .display()\n+                )\n+            } else {\n+                let crate_name = crate::util::get_current_crate_info().name;\n+                let time_stamp = std::time::SystemTime::now();\n+                let time_stamp: DateTime<Local> = time_stamp.into();\n+                let time_stamp = time_stamp.format(\"%H%M%S\");\n+                format!(\"{}-profile-{}\", crate_name, time_stamp)\n+            };\n+            PathBuf::from(format!(\"{}.{}\", file_stem, self.format().file_extension()))\n+        })\n+    }\n }\n \n #[derive(Debug, Parser)]\ndiff --git a/osdk/src/commands/debug.rs b/osdk/src/commands/debug.rs\n--- a/osdk/src/commands/debug.rs\n+++ b/osdk/src/commands/debug.rs\n@@ -18,10 +18,9 @@ pub fn execute_debug_command(_profile: &str, args: &DebugArgs) {\n \n     let mut gdb = Command::new(\"gdb\");\n     gdb.args([\n+        format!(\"{}\", file_path.display()).as_str(),\n         \"-ex\",\n         format!(\"target remote {}\", remote).as_str(),\n-        \"-ex\",\n-        format!(\"file {}\", file_path.display()).as_str(),\n     ]);\n     gdb.status().unwrap();\n }\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -1,60 +1,29 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::process::exit;\n+\n+use vsc::VscLaunchConfig;\n+\n use super::{build::create_base_and_cached_build, util::DEFAULT_TARGET_RELPATH};\n use crate::{\n-    cli::GdbServerArgs,\n     config::{scheme::ActionChoice, Config},\n+    error::Errno,\n+    error_msg,\n     util::{get_current_crate_info, get_target_directory},\n };\n \n-pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n-    if gdb_server_args.is_gdb_enabled {\n-        use std::env;\n-        env::set_var(\n-            \"RUSTFLAGS\",\n-            env::var(\"RUSTFLAGS\").unwrap_or_default() + \" -g\",\n-        );\n-    }\n-\n+pub fn execute_run_command(config: &Config, gdb_server_args: Option<&str>) {\n     let cargo_target_directory = get_target_directory();\n     let osdk_output_directory = cargo_target_directory.join(DEFAULT_TARGET_RELPATH);\n     let target_name = get_current_crate_info().name;\n \n     let mut config = config.clone();\n-    if gdb_server_args.is_gdb_enabled {\n-        let qemu_gdb_args = {\n-            let gdb_stub_addr = gdb_server_args.gdb_server_addr.as_str();\n-            match gdb::stub_type_of(gdb_stub_addr) {\n-                gdb::StubAddrType::Unix => {\n-                    format!(\n-                        \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0 -S\",\n-                        gdb_stub_addr\n-                    )\n-                }\n-                gdb::StubAddrType::Tcp => {\n-                    format!(\n-                        \" -gdb tcp:{} -S\",\n-                        gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n-                    )\n-                }\n-            }\n-        };\n-        config.run.qemu.args += &qemu_gdb_args;\n-\n-        // Ensure debug info added when debugging in the release profile.\n-        if config.run.build.profile.contains(\"release\") {\n-            config\n-                .run\n-                .build\n-                .override_configs\n-                .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n-        }\n-    }\n-    let _vsc_launch_file = gdb_server_args.vsc_launch_file.then(|| {\n-        vsc::check_gdb_config(gdb_server_args);\n-        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n-        vsc::VscLaunchConfig::new(profile, &gdb_server_args.gdb_server_addr)\n-    });\n+\n+    let _vsc_launch_file = if let Some(gdb_server_str) = gdb_server_args {\n+        adapt_for_gdb_server(&mut config, gdb_server_str)\n+    } else {\n+        None\n+    };\n \n     let default_bundle_directory = osdk_output_directory.join(target_name);\n     let bundle = create_base_and_cached_build(\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -69,6 +38,82 @@ pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n     bundle.run(&config, ActionChoice::Run);\n }\n \n+fn adapt_for_gdb_server(config: &mut Config, gdb_server_str: &str) -> Option<VscLaunchConfig> {\n+    let gdb_server_args = GdbServerArgs::from_str(gdb_server_str);\n+\n+    // Add GDB server arguments to QEMU.\n+    let qemu_gdb_args = {\n+        let gdb_stub_addr = gdb_server_args.host_addr.as_str();\n+        match gdb::stub_type_of(gdb_stub_addr) {\n+            gdb::StubAddrType::Unix => {\n+                format!(\n+                    \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0\",\n+                    gdb_stub_addr\n+                )\n+            }\n+            gdb::StubAddrType::Tcp => {\n+                format!(\n+                    \" -gdb tcp:{}\",\n+                    gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n+                )\n+            }\n+        }\n+    };\n+    config.run.qemu.args += &qemu_gdb_args;\n+\n+    if gdb_server_args.wait_client {\n+        config.run.qemu.args += \" -S\";\n+    }\n+\n+    // Ensure debug info added when debugging in the release profile.\n+    if config.run.build.profile.contains(\"release\") {\n+        config\n+            .run\n+            .build\n+            .override_configs\n+            .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n+    }\n+\n+    gdb_server_args.vsc_launch_file.then(|| {\n+        vsc::check_gdb_config(&gdb_server_args);\n+        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n+        vsc::VscLaunchConfig::new(profile, &gdb_server_args.host_addr)\n+    })\n+}\n+\n+struct GdbServerArgs {\n+    host_addr: String,\n+    wait_client: bool,\n+    vsc_launch_file: bool,\n+}\n+\n+impl GdbServerArgs {\n+    fn from_str(args: &str) -> Self {\n+        let mut host_addr = \".osdk-gdb-socket\".to_string();\n+        let mut wait_client = false;\n+        let mut vsc_launch_file = false;\n+\n+        for arg in args.split(\",\") {\n+            let kv = arg.split('=').collect::<Vec<_>>();\n+            match kv.as_slice() {\n+                [\"addr\", addr] => host_addr = addr.to_string(),\n+                [\"wait-client\"] => wait_client = true,\n+                [\"vscode\"] => vsc_launch_file = true,\n+                _ => {\n+                    error_msg!(\"Invalid GDB server argument: {}\", arg);\n+                    exit(Errno::Cli as _);\n+                }\n+            }\n+        }\n+\n+        GdbServerArgs {\n+            host_addr,\n+            wait_client,\n+            vsc_launch_file,\n+        }\n+    }\n+}\n+\n mod gdb {\n     #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n     pub enum StubAddrType {\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -111,7 +156,6 @@ mod gdb {\n \n mod vsc {\n     use crate::{\n-        cli::GdbServerArgs,\n         commands::util::bin_file_name,\n         util::{get_cargo_metadata, get_current_crate_info},\n     };\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -121,7 +165,7 @@ mod vsc {\n         path::Path,\n     };\n \n-    use super::gdb;\n+    use super::{gdb, GdbServerArgs};\n \n     const VSC_DIR: &str = \".vscode\";\n \ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -170,6 +214,7 @@ mod vsc {\n             }\n         }\n     }\n+\n     impl Drop for VscLaunchConfig {\n         fn drop(&mut self) {\n             // remove generated files\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -205,22 +250,16 @@ mod vsc {\n         use crate::{error::Errno, error_msg};\n         use std::process::exit;\n \n-        if !args.is_gdb_enabled {\n-            error_msg!(\n-                \"No need for a VSCode launch file without launching GDB server,\\\n-                    pass '-h' for help\"\n-            );\n-            exit(Errno::ParseMetadata as _);\n-        }\n-\n         // check GDB server address\n-        let gdb_stub_addr = args.gdb_server_addr.as_str();\n+        let gdb_stub_addr = args.host_addr.as_str();\n         if gdb_stub_addr.is_empty() {\n             error_msg!(\"GDB server address is required to generate a VSCode launch file\");\n             exit(Errno::ParseMetadata as _);\n         }\n         if gdb::stub_type_of(gdb_stub_addr) != gdb::StubAddrType::Tcp {\n-            error_msg!(\"Non-TCP GDB server address is not supported under '--vsc' currently\");\n+            error_msg!(\n+                \"Non-TCP GDB server address is not supported under '--gdb-server vscode' currently\"\n+            );\n             exit(Errno::ParseMetadata as _);\n         }\n     }\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -3,14 +3,15 @@\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Errno {\n-    CreateCrate = 1,\n-    GetMetadata = 2,\n-    AddRustToolchain = 3,\n-    ParseMetadata = 4,\n-    ExecuteCommand = 5,\n-    BuildCrate = 6,\n-    RunBundle = 7,\n-    BadCrateName = 8,\n+    Cli = 1,\n+    CreateCrate = 2,\n+    GetMetadata = 3,\n+    AddRustToolchain = 4,\n+    ParseMetadata = 5,\n+    ExecuteCommand = 6,\n+    BuildCrate = 7,\n+    RunBundle = 8,\n+    BadCrateName = 9,\n }\n \n /// Print error message to console\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -16,7 +17,14 @@ LOG_LEVEL ?= error\n SCHEME ?= \"\"\n SMP ?= 1\n OSTD_TASK_STACK_SIZE_IN_PAGES ?= 64\n-# End of global options.\n+# End of global build options.\n+\n+# GDB debugging and profiling options.\n+GDB_TCP_PORT ?= 1234\n+GDB_PROFILE_FORMAT ?= flame-graph\n+GDB_PROFILE_COUNT ?= 200\n+GDB_PROFILE_INTERVAL ?= 0.1\n+# End of GDB options.\n \n # The Makefile provides a way to run arbitrary tests in the kernel\n # mode using the kernel command line.\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -26,6 +34,8 @@ EXTRA_BLOCKLISTS_DIRS ?= \"\"\n SYSCALL_TEST_DIR ?= /tmp\n # End of auto test features.\n \n+# ========================= End of Makefile options. ==========================\n+\n CARGO_OSDK := ~/.cargo/bin/cargo-osdk\n \n CARGO_OSDK_ARGS := --target-arch=$(ARCH) --kcmd-args=\"ostd.log_level=$(LOG_LEVEL)\"\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -189,11 +199,20 @@ endif\n \n .PHONY: gdb_server\n gdb_server: initramfs $(CARGO_OSDK)\n-\t@cargo osdk run $(CARGO_OSDK_ARGS) -G --vsc --gdb-server-addr :$(GDB_TCP_PORT)\n+\t@cargo osdk run $(CARGO_OSDK_ARGS) --gdb-server wait-client,vscode,addr=:$(GDB_TCP_PORT)\n \n .PHONY: gdb_client\n gdb_client: $(CARGO_OSDK)\n-\t@cd kernel && cargo osdk debug $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT)\n+\t@cargo osdk debug $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT)\n+\n+.PHONY: profile_server\n+profile_server: initramfs $(CARGO_OSDK)\n+\t@cargo osdk run $(CARGO_OSDK_ARGS) --gdb-server addr=:$(GDB_TCP_PORT)\n+\n+.PHONY: profile_client\n+profile_client: $(CARGO_OSDK)\n+\t@cargo osdk profile $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT) \\\n+\t\t--samples $(GDB_PROFILE_COUNT) --interval $(GDB_PROFILE_INTERVAL) --format $(GDB_PROFILE_FORMAT)\n \n .PHONY: test\n test:\ndiff --git a/docs/src/osdk/reference/commands/README.md b/docs/src/osdk/reference/commands/README.md\n--- a/docs/src/osdk/reference/commands/README.md\n+++ b/docs/src/osdk/reference/commands/README.md\n@@ -11,6 +11,7 @@ Currently, OSDK supports the following subcommands:\n - **run**: Run the kernel with a VMM\n - **test**: Execute kernel mode unit test by starting a VMM\n - **debug**: Debug a remote target via GDB\n+- **profile**: Profile a remote GDB debug target to collect stack traces\n - **check**: Analyze the current package and report errors\n - **clippy**: Check the current package and catch common mistakes\n \ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -2,13 +2,13 @@\n \n use std::path::PathBuf;\n \n-use clap::{crate_version, Args, Parser};\n+use clap::{crate_version, Args, Parser, ValueEnum};\n \n use crate::{\n     arch::Arch,\n     commands::{\n         execute_build_command, execute_debug_command, execute_forwarded_command,\n-        execute_new_command, execute_run_command, execute_test_command,\n+        execute_new_command, execute_profile_command, execute_run_command, execute_test_command,\n     },\n     config::{\n         manifest::{ProjectType, TomlManifest},\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -46,6 +46,12 @@ pub fn main() {\n                 debug_args,\n             );\n         }\n+        OsdkSubcommand::Profile(profile_args) => {\n+            execute_profile_command(\n+                &load_config(&profile_args.common_args).run.build.profile,\n+                profile_args,\n+            );\n+        }\n         OsdkSubcommand::Test(test_args) => {\n             execute_test_command(&load_config(&test_args.common_args), test_args);\n         }\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -79,6 +85,8 @@ pub enum OsdkSubcommand {\n     Run(RunArgs),\n     #[command(about = \"Debug a remote target via GDB\")]\n     Debug(DebugArgs),\n+    #[command(about = \"Profile a remote GDB debug target to collect stack traces for flame graph\")]\n+    Profile(ProfileArgs),\n     #[command(about = \"Execute kernel mode unit test by starting a VMM\")]\n     Test(TestArgs),\n     #[command(about = \"Check a local package and all of its dependencies for errors\")]\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -5,13 +5,14 @@\n mod build;\n mod debug;\n mod new;\n+mod profile;\n mod run;\n mod test;\n mod util;\n \n pub use self::{\n     build::execute_build_command, debug::execute_debug_command, new::execute_new_command,\n-    run::execute_run_command, test::execute_test_command,\n+    profile::execute_profile_command, run::execute_run_command, test::execute_test_command,\n };\n \n use crate::arch::get_default_arch;\ndiff --git /dev/null b/osdk/src/commands/profile.rs\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/src/commands/profile.rs\n@@ -0,0 +1,383 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! OSDK profile command implementation.\n+//!\n+//! The profile command is used to collect stack traces when running the target\n+//! kernel in QEMU. It attaches to the GDB server initiated with [`super::run`]\n+//! and collects the stack trace periodically. The collected data can be\n+//! further analyzed using tools like\n+//! [flame graph](https://github.com/brendangregg/FlameGraph).\n+\n+use inferno::flamegraph;\n+\n+use crate::{\n+    cli::{ProfileArgs, ProfileFormat},\n+    commands::util::bin_file_name,\n+    util::{get_current_crate_info, get_target_directory},\n+};\n+use regex::Regex;\n+use std::{collections::HashMap, fs::File, io::Write, path::PathBuf, process::Command};\n+\n+pub fn execute_profile_command(_profile: &str, args: &ProfileArgs) {\n+    if let Some(parse_input) = &args.parse {\n+        do_parse_stack_traces(parse_input, args);\n+    } else {\n+        do_collect_stack_traces(args);\n+    }\n+}\n+\n+fn do_parse_stack_traces(target_file: &PathBuf, args: &ProfileArgs) {\n+    let out_args = &args.out_args;\n+    let in_file = File::open(target_file).expect(\"Failed to open input file\");\n+    let profile: Profile =\n+        serde_json::from_reader(in_file).expect(\"Failed to parse the input JSON file\");\n+    let out_file = File::create(out_args.output_path(Some(target_file)))\n+        .expect(\"Failed to create output file\");\n+\n+    let out_format = out_args.format();\n+    if matches!(out_format, ProfileFormat::Json) {\n+        println!(\"Warning: parsing JSON profile to the same format.\");\n+        return;\n+    }\n+    profile.serialize_to(out_format, out_args.cpu_mask, out_file);\n+}\n+\n+fn do_collect_stack_traces(args: &ProfileArgs) {\n+    let file_path = get_target_directory()\n+        .join(\"osdk\")\n+        .join(get_current_crate_info().name)\n+        .join(bin_file_name());\n+\n+    let remote = &args.remote;\n+    let samples = &args.samples;\n+    let interval = &args.interval;\n+\n+    let mut profile_buffer = ProfileBuffer::new();\n+\n+    println!(\"Profiling \\\"{}\\\" at \\\"{}\\\".\", file_path.display(), remote);\n+    use indicatif::{ProgressIterator, ProgressStyle};\n+    let style = ProgressStyle::default_bar().progress_chars(\"#>-\");\n+    for _ in (0..*samples).progress_with_style(style) {\n+        // Use GDB to halt the remote, get stack traces, and resume\n+        let output = Command::new(\"gdb\")\n+            .args([\n+                \"-batch\",\n+                \"-ex\",\n+                \"set pagination 0\",\n+                \"-ex\",\n+                &format!(\"file {}\", file_path.display()),\n+                \"-ex\",\n+                &format!(\"target remote {}\", remote),\n+                \"-ex\",\n+                \"thread apply all bt -frame-arguments presence -frame-info short-location\",\n+            ])\n+            .output()\n+            .expect(\"Failed to execute gdb\");\n+\n+        for line in String::from_utf8_lossy(&output.stdout).lines() {\n+            profile_buffer.append_raw_line(line);\n+        }\n+\n+        // Sleep between samples\n+        std::thread::sleep(std::time::Duration::from_secs_f64(*interval));\n+    }\n+\n+    let out_args = &args.out_args;\n+    let out_path = out_args.output_path(None);\n+    println!(\n+        \"Profile data collected. Writing the output to \\\"{}\\\".\",\n+        out_path.display()\n+    );\n+\n+    let out_file = File::create(out_path).expect(\"Failed to create output file\");\n+    profile_buffer\n+        .cur_profile\n+        .serialize_to(out_args.format(), out_args.cpu_mask, out_file);\n+}\n+\n+#[derive(Debug, Default, Serialize, Deserialize)]\n+struct Profile {\n+    // Index 0: capture; Index 1: CPU ID; Index 2: stack frame\n+    stack_traces: Vec<HashMap<u32, Vec<String>>>,\n+}\n+\n+impl Profile {\n+    fn serialize_to<W: Write>(&self, format: ProfileFormat, cpu_mask: u128, mut target: W) {\n+        match format {\n+            ProfileFormat::Folded => {\n+                let folded = self.fold(cpu_mask);\n+\n+                // Write the folded traces to the target text writer.\n+                for (key, count) in folded {\n+                    writeln!(&mut target, \"{} {}\", key, count)\n+                        .expect(\"Failed to write folded output\");\n+                }\n+            }\n+            ProfileFormat::Json => {\n+                let filtered = self.filter_cpu(cpu_mask);\n+\n+                serde_json::to_writer(target, &filtered).expect(\"Failed to write JSON output\");\n+            }\n+            ProfileFormat::FlameGraph => {\n+                let folded = self.fold(cpu_mask);\n+\n+                // Generate the flame graph folded text lines.\n+                let lines = folded\n+                    .iter()\n+                    .map(|(key, count)| format!(\"{} {}\", key, count))\n+                    .collect::<Vec<_>>();\n+\n+                // Generate the flame graph to the target SVG writer.\n+                let mut opt = flamegraph::Options::default();\n+                flamegraph::from_lines(&mut opt, lines.iter().map(|s| s.as_str()), target).unwrap();\n+            }\n+        }\n+    }\n+\n+    fn filter_cpu(&self, cpu_mask: u128) -> Profile {\n+        let filtered_traces = self\n+            .stack_traces\n+            .iter()\n+            .map(|capture| {\n+                capture\n+                    .iter()\n+                    .filter(|(cpu_id, _)| **cpu_id < 128 && cpu_mask & (1u128 << **cpu_id) != 0)\n+                    .map(|(cpu_id, stack)| (*cpu_id, stack.clone()))\n+                    .collect::<HashMap<_, _>>()\n+            })\n+            .collect::<Vec<_>>();\n+\n+        Self {\n+            stack_traces: filtered_traces,\n+        }\n+    }\n+\n+    fn fold(&self, cpu_mask: u128) -> HashMap<String, u32> {\n+        let mut folded = HashMap::new();\n+\n+        for capture in &self.stack_traces {\n+            for (cpu_id, stack) in capture {\n+                if *cpu_id >= 128 || cpu_mask & (1u128 << *cpu_id) == 0 {\n+                    continue;\n+                }\n+\n+                let folded_key = stack.iter().rev().cloned().collect::<Vec<_>>().join(\";\");\n+                *folded.entry(folded_key).or_insert(0) += 1;\n+            }\n+        }\n+\n+        folded\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ProfileBuffer {\n+    cur_profile: Profile,\n+    // Pre-compile regex patterns for cleaning the input.\n+    hex_in_pattern: Regex,\n+    impl_pattern: Regex,\n+    // The state\n+    cur_cpu: Option<u32>,\n+}\n+\n+impl ProfileBuffer {\n+    fn new() -> Self {\n+        Self {\n+            cur_profile: Profile::default(),\n+            hex_in_pattern: Regex::new(r\"0x[0-9a-f]+ in\").unwrap(),\n+            impl_pattern: Regex::new(r\"::\\{.*?\\}\").unwrap(),\n+            cur_cpu: None,\n+        }\n+    }\n+\n+    fn append_raw_line(&mut self, line: &str) {\n+        // Lines starting with '#' are stack frames\n+        if !line.starts_with('#') {\n+            // Otherwise it may initiate a new capture or a new CPU stack trace\n+\n+            // Check if this is a new CPU trace (starts with `Thread` and contains `CPU#N`)\n+            if line.starts_with(\"Thread\") {\n+                let cpu_id_idx = line.find(\"CPU#\").unwrap();\n+                let cpu_id = line[cpu_id_idx + 4..]\n+                    .split_whitespace()\n+                    .next()\n+                    .unwrap()\n+                    .parse::<u32>()\n+                    .unwrap();\n+                self.cur_cpu = Some(cpu_id);\n+\n+                // if the new CPU id is already in the stack traces, start a new capture\n+                match self.cur_profile.stack_traces.last() {\n+                    Some(capture) => {\n+                        if capture.contains_key(&cpu_id) {\n+                            self.cur_profile.stack_traces.push(HashMap::new());\n+                        }\n+                    }\n+                    None => {\n+                        self.cur_profile.stack_traces.push(HashMap::new());\n+                    }\n+                }\n+            }\n+\n+            return;\n+        }\n+\n+        // Clean the input line\n+        let mut processed = line.trim().to_string();\n+\n+        // Remove everything between angle brackets '<...>'\n+        processed = Self::remove_generics(&processed);\n+\n+        // Remove \"::impl{}\" and hex addresses\n+        processed = self.impl_pattern.replace_all(&processed, \"\").to_string();\n+        processed = self.hex_in_pattern.replace_all(&processed, \"\").to_string();\n+\n+        // Remove unnecessary parts like \"()\" and \"(...)\"\n+        processed = processed.replace(\"(...)\", \"\");\n+        processed = processed.replace(\"()\", \"\");\n+\n+        // Split the line by spaces and expect the second part to be the function name\n+        let parts: Vec<&str> = processed.split_whitespace().collect();\n+        if parts.len() > 1 {\n+            let func_name = parts[1].to_string();\n+\n+            // Append the function name to the latest stack trace\n+            let current_capture = self.cur_profile.stack_traces.last_mut().unwrap();\n+            let cur_cpu = self.cur_cpu.unwrap();\n+            current_capture.entry(cur_cpu).or_default().push(func_name);\n+        }\n+    }\n+\n+    fn remove_generics(line: &str) -> String {\n+        let mut result = String::new();\n+        let mut bracket_depth = 0;\n+\n+        for c in line.chars() {\n+            match c {\n+                '<' => bracket_depth += 1,\n+                '>' => {\n+                    if bracket_depth > 0 {\n+                        bracket_depth -= 1;\n+                    }\n+                }\n+                _ => {\n+                    if bracket_depth == 0 {\n+                        result.push(c);\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_profile_parse_raw() {\n+    let test_case = r#\"\n+0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (self=0xffffffff88489808 <_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072+992480>) at src/sched/priority_scheduler.rs:156\n+156\t        let next_entity = if !self.real_time_entities.is_empty() {\n+\n+Thread 2 (Thread 1.2 (CPU#1 [running])):\n+#0  ostd::sync::spin::SpinLock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled>::acquire_lock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled> (...)\n+#1  ostd::sync::spin::SpinLock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled>::lock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled> (...)\n+#2  aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#3  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#4  ostd::task::scheduler::yield_now ()\n+#5  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#6  aster_nix::thread::Thread::yield_now ()\n+#7  aster_nix::ap_init::ap_idle_thread ()\n+#8  core::ops::function::Fn::call<fn(), ()> ()\n+#9  0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#10 aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#11 0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#12 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#13 0x0000000000000000 in ?? ()\n+\n+Thread 1 (Thread 1.1 (CPU#0 [running])):\n+#0  aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#1  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#2  ostd::task::scheduler::yield_now ()\n+#3  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#4  aster_nix::thread::Thread::yield_now ()\n+#5  aster_nix::ap_init::ap_idle_thread ()\n+#6  core::ops::function::Fn::call<fn(), ()> ()\n+#7  0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#8  aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#9  0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#10 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#11 0x0000000000000000 in ?? ()\n+[Inferior 1 (process 1) detached]\n+0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (self=0xffffffff88489808 <_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072+992480>) at src/sched/priority_scheduler.rs:156\n+156\t        let next_entity = if !self.real_time_entities.is_empty() {\n+\n+Thread 2 (Thread 1.2 (CPU#1 [running])):\n+#0  0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (...)\n+#1  0xffffffff8826b3e0 in ostd::task::scheduler::yield_now::{closure#0} (...)\n+#2  ostd::task::scheduler::reschedule::{closure#0}<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#3  0xffffffff880b0cff in aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#4  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#5  ostd::task::scheduler::yield_now ()\n+#6  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#7  aster_nix::thread::Thread::yield_now ()\n+#8  aster_nix::ap_init::ap_idle_thread ()\n+#9  core::ops::function::Fn::call<fn(), ()> ()\n+#10 0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#11 aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#12 0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#13 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#14 0x0000000000000000 in ?? ()\n+\n+Thread 1 (Thread 1.1 (CPU#0 [running])):\n+#0  ostd::arch::x86::interrupts_ack (...)\n+#1  0xffffffff8828d704 in ostd::trap::handler::call_irq_callback_functions (...)\n+#2  0xffffffff88268e48 in ostd::arch::x86::trap::trap_handler (...)\n+#3  0xffffffff88274db6 in __from_kernel ()\n+#4  0x0000000000000001 in ?? ()\n+#5  0x0000000000000001 in ?? ()\n+#6  0x00000000000001c4 in ?? ()\n+#7  0xffffffff882c8580 in ?? ()\n+#8  0x0000000000000002 in ?? ()\n+#9  0xffffffff88489808 in _ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072 ()\n+#10 0x0000000000000000 in ?? ()\n+[Inferior 1 (process 1) detached]\n+\"#;\n+\n+    let mut buffer = ProfileBuffer::new();\n+    for line in test_case.lines() {\n+        buffer.append_raw_line(line);\n+    }\n+\n+    let profile = &buffer.cur_profile;\n+    assert_eq!(profile.stack_traces.len(), 2);\n+    assert_eq!(profile.stack_traces[0].len(), 2);\n+    assert_eq!(profile.stack_traces[1].len(), 2);\n+\n+    let stack00 = profile.stack_traces[0].get(&0).unwrap();\n+    assert_eq!(stack00.len(), 12);\n+    assert_eq!(\n+        stack00[0],\n+        \"aster_nix::sched::priority_scheduler::local_mut_rq_with\"\n+    );\n+    assert_eq!(stack00[11], \"??\");\n+\n+    let stack01 = profile.stack_traces[0].get(&1).unwrap();\n+    assert_eq!(stack01.len(), 14);\n+    assert_eq!(stack01[9], \"alloc::boxed::call\");\n+\n+    let stack10 = profile.stack_traces[1].get(&0).unwrap();\n+    assert_eq!(stack10.len(), 11);\n+    assert_eq!(\n+        stack10[9],\n+        \"_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072\"\n+    );\n+\n+    let stack11 = profile.stack_traces[1].get(&1).unwrap();\n+    assert_eq!(stack11.len(), 15);\n+    assert_eq!(\n+        stack11[0],\n+        \"aster_nix::sched::priority_scheduler::pick_next_current\"\n+    );\n+    assert_eq!(stack11[14], \"??\");\n+}\ndiff --git a/osdk/tests/commands/run.rs b/osdk/tests/commands/run.rs\n--- a/osdk/tests/commands/run.rs\n+++ b/osdk/tests/commands/run.rs\n@@ -79,7 +79,11 @@ mod qemu_gdb_feature {\n             path.to_string_lossy().to_string()\n         };\n \n-        let mut instance = cargo_osdk([\"run\", \"-G\", \"--gdb-server-addr\", unix_socket.as_str()]);\n+        let mut instance = cargo_osdk([\n+            \"run\",\n+            \"--gdb-server\",\n+            format!(\"addr={},wait-client\", unix_socket.as_str()).as_str(),\n+        ]);\n         instance.current_dir(&workspace.os_dir());\n \n         let sock = unix_socket.clone();\ndiff --git a/osdk/tests/commands/run.rs b/osdk/tests/commands/run.rs\n--- a/osdk/tests/commands/run.rs\n+++ b/osdk/tests/commands/run.rs\n@@ -106,8 +110,8 @@ mod qemu_gdb_feature {\n         let mut gdb = Command::new(\"gdb\");\n         gdb.args([\"-ex\", format!(\"target remote {}\", addr).as_str()]);\n         gdb.write_stdin(\"\\n\")\n-            .write_stdin(\"c\\n\")\n-            .write_stdin(\"quit\\n\");\n+            .write_stdin(\"quit\\n\")\n+            .write_stdin(\"y\\n\");\n         gdb.assert().success();\n     }\n     mod vsc {\ndiff --git a/osdk/tests/commands/run.rs b/osdk/tests/commands/run.rs\n--- a/osdk/tests/commands/run.rs\n+++ b/osdk/tests/commands/run.rs\n@@ -123,14 +127,18 @@ mod qemu_gdb_feature {\n             let workspace = workspace::WorkSpace::new(WORKSPACE, kernel_name);\n             let addr = \":50001\";\n \n-            let mut instance = cargo_osdk([\"run\", \"-G\", \"--vsc\", \"--gdb-server-addr\", addr]);\n+            let mut instance = cargo_osdk([\n+                \"run\",\n+                \"--gdb-server\",\n+                format!(\"wait-client,vscode,addr={}\", addr).as_str(),\n+            ]);\n             instance.current_dir(&workspace.os_dir());\n \n             let dir = workspace.os_dir();\n             let bin_file_path = Path::new(&workspace.os_dir())\n                 .join(\"target\")\n-                .join(\"x86_64-unknown-none\")\n-                .join(\"debug\")\n+                .join(\"osdk\")\n+                .join(kernel_name)\n                 .join(format!(\"{}-osdk-bin\", kernel_name));\n             let _gdb = std::thread::spawn(move || {\n                 while !bin_file_path.exists() {\n",
        "problem_statement": "[Perf Guide] Flame graph scripts on Asterinas\n[Flame graph](https://github.com/brendangregg/FlameGraph) is a well known and powerful tool for performance (bottoleneck) analysis. It's based on sampling. If you inspect the call stack 100 times per second, the function that appears more often, would like to consume more time. The flame graph helps you to visualize it.\r\n\r\nHere's my experience about how to capture a flame graph for Asterinas.\r\n\r\nJust like what's proposed in #691, the first step is to launch a GDB server (`make gdb_server RELEASE=1`), attach to it (`make gdb_client`) and quit to leave the kernel running.\r\n\r\nThen, use the following script to sample call stacks using GDB:\r\n\r\n<details><summary>script to sample</summary>\r\n<p>\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\n# Number of samples\r\nnsamples=100\r\n# Sleep time between samples (in seconds)\r\nsleeptime=0.1\r\n\r\n# Hostname or IP address of the machine running QEMU with GDB server\r\nremote_host=\"localhost\"\r\n# Port number where QEMU GDB server is listening\r\nremote_port=\"1234\"\r\n\r\nsleep 0.1\r\n\r\nfor x in $(seq 1 $nsamples)\r\ndo\r\n\tgdb -batch \\\r\n\t\t-ex \"set pagination 0\" \\\r\n\t\t-ex \"file target/osdk/aster-nix/aster-nix-osdk-bin\" \\\r\n\t\t-ex \"target remote $remote_host:$remote_port\" \\\r\n\t\t-ex \"bt -frame-arguments presence -frame-info short-location\" >> gdb_perf.log\r\n\tsleep $sleeptime\r\ndone\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nAfter that, the text log is dumped to `gdb_perf.log`. Use a python script to generate folded stack traces for the flame graph:\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n```python\r\nimport re\r\n\r\ndef process_stack_trace(file_path):\r\n    with open(file_path, 'r') as file:\r\n        lines = file.readlines()\r\n\r\n    captures = []\r\n    current_capture = []\r\n\r\n    for line in lines:\r\n        if not line.startswith('#'):\r\n            continue\r\n        if line.startswith('#0'):\r\n            if current_capture:\r\n                captures.append(current_capture)\r\n                current_capture = []\r\n        processed = line.strip()\r\n        # remove all things between < and >, use bracket matching\r\n        cut_generic = ''\r\n        cnt = 0\r\n        for c in processed:\r\n            if c == '<':\r\n                cnt += 1\r\n            if cnt == 0:\r\n                cut_generic += c\r\n            if c == '>':\r\n                cnt -= 1\r\n        processed = cut_generic\r\n        # remove all things like \"::{impl#70}\"\r\n        processed = re.sub(r'::\\{.*?\\}', '', processed)\r\n        # remove all \"(...)\"\r\n        processed = processed.replace('(...)', '')\r\n        # remove all \"()\"\r\n        processed = processed.replace('()', '')\r\n        # remove all things like \"0xffffffff8819d0fb in\"\r\n        processed = re.sub(r'0x[0-9a-f]+ in', '', processed)\r\n\r\n        # split by spaces, the first is number and the second is function name\r\n        parts = [s for s in processed.split(' ') if s != '']\r\n\r\n        current_capture.append(parts[1])\r\n\r\n    if current_capture:\r\n        captures.append(current_capture)\r\n\r\n    folded = {} # { bt: value }\r\n\r\n    for capture in captures:\r\n        bt_from_butt = []\r\n        for frame in reversed(capture):\r\n            bt_from_butt.append(frame)\r\n        folded_key = ';'.join(bt_from_butt)\r\n        if folded_key in folded:\r\n            folded[folded_key] += 1\r\n        else:\r\n            folded[folded_key] = 1\r\n\r\n    with open('out.folded', 'w') as out_file:\r\n        for key, v in folded.items():\r\n            out_file.write(f\"{key} {v}\\n\")\r\n\r\nif __name__ == \"__main__\":\r\n    process_stack_trace('gdb_perf.log')\r\n\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nThis script generates a file `out.folded`. Then the file is ready to be processed using [Flame graph](https://github.com/brendangregg/FlameGraph). Follow the guide to have an SVG.\r\n\r\nTLDR:\r\n\r\n```shell\r\n./FlameGraph/flamegraph.pl ./asterinas/out.folded > kernel.svg\r\n```\r\n\r\nHere's an example on the unixbench spawn benchmark (on [c75a373](https://github.com/asterinas/asterinas/commit/c75a3732b9a6a7f0dbf11a839affaf2c126ecdc5)):\r\n\r\n![kernel](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d))\r\n\r\nHere's also another example using #895 to optimize it:\r\n\r\n![kernel_vmspacerw](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215))\r\n\r\nYou can clearly see that when the bottleneck `read_val_from_user` is optimized, the performance boosts significantly and the bottleneck becomes the `ProcessBuilder`.\r\n\n",
        "hints_text": "",
        "created_at": "2024-09-21T13:48:03Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1328,
        "instance_id": "asterinas__asterinas-1328",
        "issue_numbers": [
            "1244"
        ],
        "base_commit": "42e28763c59202486af4298d5305e5c5e5ab9b54",
        "patch": "diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -133,10 +133,7 @@ fn ap_init() -> ! {\n }\n \n fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n+    println!(\"[kernel] Spawn init thread\");\n     // Work queue should be initialized before interrupt is enabled,\n     // in case any irq handler uses work queue as bottom half\n     thread::work_queue::init();\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -4,11 +4,12 @@ use core::sync::atomic::Ordering;\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \n use super::{\n-    posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n+    posix_thread::{thread_table, PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n     process_table,\n     process_vm::ProcessVm,\n     signal::sig_disposition::SigDispositions,\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -18,7 +19,8 @@ use crate::{\n     cpu::LinuxAbi,\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n+    process::posix_thread::allocate_posix_tid,\n+    thread::{Thread, Tid},\n };\n \n bitflags! {\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -132,7 +134,8 @@ pub fn clone_child(\n ) -> Result<Tid> {\n     clone_args.clone_flags.check_unsupported_flags()?;\n     if clone_args.clone_flags.contains(CloneFlags::CLONE_THREAD) {\n-        let child_thread = clone_child_thread(ctx, parent_context, clone_args)?;\n+        let child_task = clone_child_task(ctx, parent_context, clone_args)?;\n+        let child_thread = Thread::borrow_from_task(&child_task);\n         child_thread.run();\n \n         let child_tid = child_thread.tid();\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -146,11 +149,11 @@ pub fn clone_child(\n     }\n }\n \n-fn clone_child_thread(\n+fn clone_child_task(\n     ctx: &Context,\n     parent_context: &UserContext,\n     clone_args: CloneArgs,\n-) -> Result<Arc<Thread>> {\n+) -> Result<Arc<Task>> {\n     let Context {\n         process,\n         posix_thread,\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -180,8 +183,8 @@ fn clone_child_thread(\n     // Inherit sigmask from current thread\n     let sig_mask = posix_thread.sig_mask().load(Ordering::Relaxed).into();\n \n-    let child_tid = allocate_tid();\n-    let child_thread = {\n+    let child_tid = allocate_posix_tid();\n+    let child_task = {\n         let credentials = {\n             let credentials = ctx.posix_thread.credentials();\n             Credentials::new_from(&credentials)\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -193,13 +196,13 @@ fn clone_child_thread(\n         thread_builder.build()\n     };\n \n-    process.threads().lock().push(child_thread.clone());\n+    process.tasks().lock().push(child_task.clone());\n \n-    let child_posix_thread = child_thread.as_posix_thread().unwrap();\n+    let child_posix_thread = child_task.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n     clone_child_settid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n-    Ok(child_thread)\n+    Ok(child_task)\n }\n \n fn clone_child_process(\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -262,7 +265,7 @@ fn clone_child_process(\n     // inherit parent's nice value\n     let child_nice = process.nice().load(Ordering::Relaxed);\n \n-    let child_tid = allocate_tid();\n+    let child_tid = allocate_posix_tid();\n \n     let child = {\n         let child_elf_path = process.executable_path();\ndiff --git a/kernel/src/process/exit.rs b/kernel/src/process/exit.rs\n--- a/kernel/src/process/exit.rs\n+++ b/kernel/src/process/exit.rs\n@@ -4,9 +4,10 @@ use super::{process_table, Pid, Process, TermStatus};\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::do_exit,\n+        posix_thread::{do_exit, PosixThreadExt},\n         signal::{constants::SIGCHLD, signals::kernel::KernelSignal},\n     },\n+    thread::Thread,\n };\n \n pub fn do_exit_group(term_status: TermStatus) {\ndiff --git a/kernel/src/process/exit.rs b/kernel/src/process/exit.rs\n--- a/kernel/src/process/exit.rs\n+++ b/kernel/src/process/exit.rs\n@@ -18,9 +19,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     current.set_zombie(term_status);\n \n     // Exit all threads\n-    let threads = current.threads().lock().clone();\n-    for thread in threads {\n-        if let Err(e) = do_exit(thread, term_status) {\n+    let tasks = current.tasks().lock().clone();\n+    for task in tasks {\n+        let thread = Thread::borrow_from_task(&task);\n+        let posix_thread = thread.as_posix_thread().unwrap();\n+        if let Err(e) = do_exit(thread, posix_thread, term_status) {\n             debug!(\"Ignore error when call exit: {:?}\", e);\n         }\n     }\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -1,7 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{thread_table, PosixThreadExt},\n     process_table,\n     signal::{\n         constants::SIGCONT,\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -10,10 +10,7 @@ use super::{\n     },\n     Pgid, Pid, Process, Sid, Uid,\n };\n-use crate::{\n-    prelude::*,\n-    thread::{thread_table, Tid},\n-};\n+use crate::{prelude::*, thread::Tid};\n \n /// Sends a signal to a process, using the current process as the sender.\n ///\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -120,14 +117,14 @@ pub fn kill_all(signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n }\n \n fn kill_process(process: &Process, signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n-    let threads = process.threads().lock();\n+    let tasks = process.tasks().lock();\n \n     let signum = signal.map(|signal| signal.num());\n     let sender_ids = current_thread_sender_ids(signum.as_ref(), ctx);\n \n     let mut permitted_thread = None;\n-    for thread in threads.iter() {\n-        let posix_thread = thread.as_posix_thread().unwrap();\n+    for task in tasks.iter() {\n+        let posix_thread = task.as_posix_thread().unwrap();\n \n         // First check permission\n         if posix_thread\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -2,9 +2,9 @@\n \n #![allow(dead_code)]\n \n-use ostd::user::UserSpace;\n+use ostd::{task::Task, user::UserSpace};\n \n-use super::PosixThread;\n+use super::{thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -12,7 +12,7 @@ use crate::{\n         signal::{sig_mask::AtomicSigMask, sig_queues::SigQueues},\n         Credentials, Process,\n     },\n-    thread::{status::ThreadStatus, task, thread_table, Thread, Tid},\n+    thread::{status::ThreadStatus, task, Thread, Tid},\n     time::{clocks::ProfClock, TimerManager},\n };\n \ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -72,7 +72,7 @@ impl PosixThreadBuilder {\n         self\n     }\n \n-    pub fn build(self) -> Arc<Thread> {\n+    pub fn build(self) -> Arc<Task> {\n         let Self {\n             tid,\n             user_space,\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -85,34 +85,36 @@ impl PosixThreadBuilder {\n             sig_queues,\n         } = self;\n \n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let task = task::create_new_user_task(user_space, thread_ref.clone());\n-            let status = ThreadStatus::Init;\n-\n-            let prof_clock = ProfClock::new();\n-            let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n-            let prof_timer_manager = TimerManager::new(prof_clock.clone());\n-\n-            let posix_thread = PosixThread {\n-                process,\n-                name: Mutex::new(thread_name),\n-                set_child_tid: Mutex::new(set_child_tid),\n-                clear_child_tid: Mutex::new(clear_child_tid),\n-                credentials,\n-                sig_mask,\n-                sig_queues,\n-                sig_context: Mutex::new(None),\n-                sig_stack: Mutex::new(None),\n-                signalled_waker: SpinLock::new(None),\n-                robust_list: Mutex::new(None),\n-                prof_clock,\n-                virtual_timer_manager,\n-                prof_timer_manager,\n+        Arc::new_cyclic(|weak_task| {\n+            let posix_thread = {\n+                let prof_clock = ProfClock::new();\n+                let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n+                let prof_timer_manager = TimerManager::new(prof_clock.clone());\n+\n+                PosixThread {\n+                    process,\n+                    tid,\n+                    name: Mutex::new(thread_name),\n+                    set_child_tid: Mutex::new(set_child_tid),\n+                    clear_child_tid: Mutex::new(clear_child_tid),\n+                    credentials,\n+                    sig_mask,\n+                    sig_queues,\n+                    sig_context: Mutex::new(None),\n+                    sig_stack: Mutex::new(None),\n+                    signalled_waker: SpinLock::new(None),\n+                    robust_list: Mutex::new(None),\n+                    prof_clock,\n+                    virtual_timer_manager,\n+                    prof_timer_manager,\n+                }\n             };\n \n-            Thread::new(tid, task, posix_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n+            let status = ThreadStatus::Init;\n+            let thread = Arc::new(Thread::new(weak_task.clone(), posix_thread, status));\n+\n+            thread_table::add_thread(tid, thread.clone());\n+            task::create_new_user_task(user_space, thread)\n+        })\n     }\n }\ndiff --git a/kernel/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\n--- a/kernel/src/process/posix_thread/exit.rs\n+++ b/kernel/src/process/posix_thread/exit.rs\n@@ -1,10 +1,10 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use super::{futex::futex_wake, robust_list::wake_robust_futex, PosixThread, PosixThreadExt};\n+use super::{futex::futex_wake, robust_list::wake_robust_futex, thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{do_exit_group, TermStatus},\n-    thread::{thread_table, Thread, Tid},\n+    thread::{Thread, Tid},\n };\n \n /// Exits the thread if the thread is a POSIX thread.\ndiff --git a/kernel/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\n--- a/kernel/src/process/posix_thread/exit.rs\n+++ b/kernel/src/process/posix_thread/exit.rs\n@@ -12,15 +12,13 @@ use crate::{\n /// # Panics\n ///\n /// If the thread is not a POSIX thread, this method will panic.\n-pub fn do_exit(thread: Arc<Thread>, term_status: TermStatus) -> Result<()> {\n+pub fn do_exit(thread: &Thread, posix_thread: &PosixThread, term_status: TermStatus) -> Result<()> {\n     if thread.status().is_exited() {\n         return Ok(());\n     }\n     thread.exit();\n \n-    let tid = thread.tid();\n-\n-    let posix_thread = thread.as_posix_thread().unwrap();\n+    let tid = posix_thread.tid;\n \n     let mut clear_ctid = posix_thread.clear_child_tid().lock();\n     // If clear_ctid !=0 ,do a futex wake and write zero to the clear_ctid addr.\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -2,7 +2,7 @@\n \n #![allow(dead_code)]\n \n-use core::sync::atomic::Ordering;\n+use core::sync::atomic::{AtomicU32, Ordering};\n \n use aster_rights::{ReadOp, WriteOp};\n use ostd::sync::Waker;\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -22,7 +22,7 @@ use crate::{\n     events::Observer,\n     prelude::*,\n     process::signal::constants::SIGCONT,\n-    thread::Tid,\n+    thread::{Thread, Tid},\n     time::{clocks::ProfClock, Timer, TimerManager},\n };\n \ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -32,16 +32,19 @@ pub mod futex;\n mod name;\n mod posix_thread_ext;\n mod robust_list;\n+pub mod thread_table;\n \n pub use builder::PosixThreadBuilder;\n pub use exit::do_exit;\n pub use name::{ThreadName, MAX_THREAD_NAME_LEN};\n-pub use posix_thread_ext::PosixThreadExt;\n+pub use posix_thread_ext::{create_posix_task_from_executable, PosixThreadExt};\n pub use robust_list::RobustListHead;\n \n pub struct PosixThread {\n     // Immutable part\n     process: Weak<Process>,\n+    tid: Tid,\n+\n     // Mutable part\n     name: Mutex<Option<ThreadName>>,\n \ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -87,6 +90,11 @@ impl PosixThread {\n         Weak::clone(&self.process)\n     }\n \n+    /// Returns the thread id\n+    pub fn tid(&self) -> Tid {\n+        self.tid\n+    }\n+\n     pub fn thread_name(&self) -> &Mutex<Option<ThreadName>> {\n         &self.name\n     }\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -266,12 +274,10 @@ impl PosixThread {\n \n     fn is_last_thread(&self) -> bool {\n         let process = self.process.upgrade().unwrap();\n-        let threads = process.threads().lock();\n-        threads\n+        let tasks = process.tasks().lock();\n+        tasks\n             .iter()\n-            .filter(|thread| !thread.status().is_exited())\n-            .count()\n-            == 0\n+            .any(|task| !Thread::borrow_from_task(task).status().is_exited())\n     }\n \n     /// Gets the read-only credentials of the thread.\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -292,3 +298,10 @@ impl PosixThread {\n         self.credentials.dup().restrict()\n     }\n }\n+\n+static POSIX_TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n+\n+/// Allocates a new tid for the new posix thread\n+pub fn allocate_posix_tid() -> Tid {\n+    POSIX_TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n+}\ndiff --git a/kernel/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\n--- a/kernel/src/process/posix_thread/posix_thread_ext.rs\n+++ b/kernel/src/process/posix_thread/posix_thread_ext.rs\n@@ -2,6 +2,7 @@\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \ndiff --git a/kernel/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\n--- a/kernel/src/process/posix_thread/posix_thread_ext.rs\n+++ b/kernel/src/process/posix_thread/posix_thread_ext.rs\n@@ -13,52 +14,57 @@ use crate::{\n     thread::{Thread, Tid},\n };\n pub trait PosixThreadExt {\n+    /// Returns the thread id.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If the thread is not posix thread, this method will panic.\n+    fn tid(&self) -> Tid {\n+        self.as_posix_thread().unwrap().tid()\n+    }\n     fn as_posix_thread(&self) -> Option<&PosixThread>;\n-    #[allow(clippy::too_many_arguments)]\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>>;\n }\n \n impl PosixThreadExt for Thread {\n-    /// This function should only be called when launch shell()\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>> {\n-        let elf_file = {\n-            let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n-            fs_resolver.lookup(&fs_path)?\n-        };\n-        let (_, elf_load_info) =\n-            load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n-\n-        let vm_space = process_vm.root_vmar().vm_space().clone();\n-        let mut cpu_ctx = UserContext::default();\n-        cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n-        cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n-        let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n-        let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n-        let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n-            .thread_name(thread_name)\n-            .process(process);\n-        Ok(thread_builder.build())\n+    fn as_posix_thread(&self) -> Option<&PosixThread> {\n+        self.data().downcast_ref::<PosixThread>()\n     }\n+}\n \n+impl PosixThreadExt for Arc<Task> {\n     fn as_posix_thread(&self) -> Option<&PosixThread> {\n-        self.data().downcast_ref::<PosixThread>()\n+        Thread::borrow_from_task(self).as_posix_thread()\n     }\n }\n+\n+/// Creates a task for running an executable file.\n+///\n+/// This function should _only_ be used to create the init user task.\n+#[allow(clippy::too_many_arguments)]\n+pub fn create_posix_task_from_executable(\n+    tid: Tid,\n+    credentials: Credentials,\n+    process_vm: &ProcessVm,\n+    fs_resolver: &FsResolver,\n+    executable_path: &str,\n+    process: Weak<Process>,\n+    argv: Vec<CString>,\n+    envp: Vec<CString>,\n+) -> Result<Arc<Task>> {\n+    let elf_file = {\n+        let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n+        fs_resolver.lookup(&fs_path)?\n+    };\n+    let (_, elf_load_info) = load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n+\n+    let vm_space = process_vm.root_vmar().vm_space().clone();\n+    let mut cpu_ctx = UserContext::default();\n+    cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n+    cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n+    let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n+    let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n+    let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n+        .thread_name(thread_name)\n+        .process(process);\n+    Ok(thread_builder.build())\n+}\ndiff --git /dev/null b/kernel/src/process/posix_thread/thread_table.rs\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/src/process/posix_thread/thread_table.rs\n@@ -0,0 +1,22 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use super::{Thread, Tid};\n+use crate::{prelude::*, process::posix_thread::PosixThreadExt};\n+\n+static THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n+\n+/// Adds a posix thread to global thread table\n+pub fn add_thread(tid: Tid, thread: Arc<Thread>) {\n+    debug_assert_eq!(tid, thread.tid());\n+    THREAD_TABLE.lock().insert(tid, thread);\n+}\n+\n+/// Removes a posix thread to global thread table\n+pub fn remove_thread(tid: Tid) {\n+    THREAD_TABLE.lock().remove(&tid);\n+}\n+\n+/// Gets a posix thread from the global thread table\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n+    THREAD_TABLE.lock().get(&tid).cloned()\n+}\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -7,14 +7,13 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt},\n+        posix_thread::{create_posix_task_from_executable, PosixThreadBuilder},\n         process_vm::ProcessVm,\n         rlimit::ResourceLimits,\n         signal::sig_disposition::SigDispositions,\n         Credentials,\n     },\n     sched::nice::Nice,\n-    thread::Thread,\n };\n \n pub struct ProcessBuilder<'a> {\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -190,11 +189,11 @@ impl<'a> ProcessBuilder<'a> {\n             )\n         };\n \n-        let thread = if let Some(thread_builder) = main_thread_builder {\n+        let task = if let Some(thread_builder) = main_thread_builder {\n             let builder = thread_builder.process(Arc::downgrade(&process));\n             builder.build()\n         } else {\n-            Thread::new_posix_thread_from_executable(\n+            create_posix_task_from_executable(\n                 pid,\n                 credentials.unwrap(),\n                 process.vm(),\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -206,7 +205,7 @@ impl<'a> ProcessBuilder<'a> {\n             )?\n         };\n \n-        process.threads().lock().push(thread);\n+        process.tasks().lock().push(task);\n \n         process.set_runnable();\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -4,7 +4,7 @@ use core::sync::atomic::Ordering;\n \n use self::timer_manager::PosixTimerManager;\n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{allocate_posix_tid, PosixThreadExt},\n     process_table,\n     process_vm::{Heap, InitStackReader, ProcessVm},\n     rlimit::ResourceLimits,\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -21,7 +21,7 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     sched::nice::Nice,\n-    thread::{allocate_tid, Thread},\n+    thread::Thread,\n     time::clocks::ProfClock,\n     vm::vmar::Vmar,\n };\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -37,7 +37,7 @@ use aster_rights::Full;\n use atomic::Atomic;\n pub use builder::ProcessBuilder;\n pub use job_control::JobControl;\n-use ostd::sync::WaitQueue;\n+use ostd::{sync::WaitQueue, task::Task};\n pub use process_group::ProcessGroup;\n pub use session::Session;\n pub use terminal::Terminal;\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -68,7 +68,7 @@ pub struct Process {\n     /// The executable path.\n     executable_path: RwLock<String>,\n     /// The threads\n-    threads: Mutex<Vec<Arc<Thread>>>,\n+    tasks: Mutex<Vec<Arc<Task>>>,\n     /// Process status\n     status: ProcessStatus,\n     /// Parent process\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -167,14 +167,20 @@ impl Process {\n     ///  - the function is called in the bootstrap context;\n     ///  - or if the current task is not associated with a process.\n     pub fn current() -> Option<Arc<Process>> {\n-        Some(Thread::current()?.as_posix_thread()?.process())\n+        Some(\n+            Task::current()?\n+                .data()\n+                .downcast_ref::<Arc<Thread>>()?\n+                .as_posix_thread()?\n+                .process(),\n+        )\n     }\n \n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\n         parent: Weak<Process>,\n-        threads: Vec<Arc<Thread>>,\n+        tasks: Vec<Arc<Task>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -194,7 +200,7 @@ impl Process {\n \n         Arc::new_cyclic(|process_ref: &Weak<Process>| Self {\n             pid,\n-            threads: Mutex::new(threads),\n+            tasks: Mutex::new(tasks),\n             executable_path: RwLock::new(executable_path),\n             process_vm,\n             children_wait_queue,\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -236,7 +242,7 @@ impl Process {\n         envp: Vec<CString>,\n     ) -> Result<Arc<Self>> {\n         let process_builder = {\n-            let pid = allocate_tid();\n+            let pid = allocate_posix_tid();\n             let parent = Weak::new();\n \n             let credentials = Credentials::new_root();\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -271,13 +277,14 @@ impl Process {\n \n     /// start to run current process\n     pub fn run(&self) {\n-        let threads = self.threads.lock();\n+        let tasks = self.tasks.lock();\n         // when run the process, the process should has only one thread\n-        debug_assert!(threads.len() == 1);\n+        debug_assert!(tasks.len() == 1);\n         debug_assert!(self.is_runnable());\n-        let thread = threads[0].clone();\n+        let task = tasks[0].clone();\n         // should not hold the lock when run thread\n-        drop(threads);\n+        drop(tasks);\n+        let thread = Thread::borrow_from_task(&task);\n         thread.run();\n     }\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -297,8 +304,8 @@ impl Process {\n         &self.timer_manager\n     }\n \n-    pub fn threads(&self) -> &Mutex<Vec<Arc<Thread>>> {\n-        &self.threads\n+    pub fn tasks(&self) -> &Mutex<Vec<Arc<Task>>> {\n+        &self.tasks\n     }\n \n     pub fn executable_path(&self) -> String {\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -318,10 +325,11 @@ impl Process {\n     }\n \n     pub fn main_thread(&self) -> Option<Arc<Thread>> {\n-        self.threads\n+        self.tasks\n             .lock()\n             .iter()\n-            .find(|thread| thread.tid() == self.pid)\n+            .find(|task| task.tid() == self.pid)\n+            .map(Thread::borrow_from_task)\n             .cloned()\n     }\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -644,7 +652,7 @@ impl Process {\n         // TODO: check that the signal is not user signal\n \n         // Enqueue signal to the first thread that does not block the signal\n-        let threads = self.threads.lock();\n+        let threads = self.tasks.lock();\n         for thread in threads.iter() {\n             let posix_thread = thread.as_posix_thread().unwrap();\n             if !posix_thread.has_signal_blocked(signal.num()) {\ndiff --git a/kernel/src/process/signal/pause.rs b/kernel/src/process/signal/pause.rs\n--- a/kernel/src/process/signal/pause.rs\n+++ b/kernel/src/process/signal/pause.rs\n@@ -86,16 +86,9 @@ impl Pause for Waiter {\n             return Ok(res);\n         }\n \n-        let current_thread = self\n-            .task()\n-            .data()\n-            .downcast_ref::<Weak<Thread>>()\n-            .and_then(|thread| thread.upgrade());\n-\n-        let Some(posix_thread) = current_thread\n-            .as_ref()\n-            .and_then(|thread| thread.as_posix_thread())\n-        else {\n+        let current_thread = self.task().data().downcast_ref::<Arc<Thread>>();\n+\n+        let Some(posix_thread) = current_thread.and_then(|thread| thread.as_posix_thread()) else {\n             if let Some(timeout) = timeout {\n                 return self.wait_until_or_timeout(cond, timeout);\n             } else {\ndiff --git a/kernel/src/process/wait.rs b/kernel/src/process/wait.rs\n--- a/kernel/src/process/wait.rs\n+++ b/kernel/src/process/wait.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use super::{\n-    process_filter::ProcessFilter,\n-    signal::{constants::SIGCHLD, with_signal_blocked},\n-    ExitCode, Pid, Process,\n+use super::{process_filter::ProcessFilter, signal::constants::SIGCHLD, ExitCode, Pid, Process};\n+use crate::{\n+    prelude::*,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+        signal::with_signal_blocked,\n+    },\n };\n-use crate::{prelude::*, process::process_table, thread::thread_table};\n \n // The definition of WaitOptions is from Occlum\n bitflags! {\ndiff --git a/kernel/src/process/wait.rs b/kernel/src/process/wait.rs\n--- a/kernel/src/process/wait.rs\n+++ b/kernel/src/process/wait.rs\n@@ -85,8 +88,8 @@ pub fn wait_child_exit(\n fn reap_zombie_child(process: &Process, pid: Pid) -> ExitCode {\n     let child_process = process.children().lock().remove(&pid).unwrap();\n     assert!(child_process.is_zombie());\n-    for thread in &*child_process.threads().lock() {\n-        thread_table::remove_thread(thread.tid());\n+    for task in &*child_process.tasks().lock() {\n+        thread_table::remove_thread(task.tid());\n     }\n \n     // Lock order: session table -> group table -> process table -> group of process\ndiff --git a/kernel/src/syscall/clock_gettime.rs b/kernel/src/syscall/clock_gettime.rs\n--- a/kernel/src/syscall/clock_gettime.rs\n+++ b/kernel/src/syscall/clock_gettime.rs\n@@ -7,8 +7,10 @@ use int_to_c_enum::TryFromInt;\n use super::SyscallReturn;\n use crate::{\n     prelude::*,\n-    process::{posix_thread::PosixThreadExt, process_table},\n-    thread::thread_table,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+    },\n     time::{\n         clockid_t,\n         clocks::{\ndiff --git a/kernel/src/syscall/exit.rs b/kernel/src/syscall/exit.rs\n--- a/kernel/src/syscall/exit.rs\n+++ b/kernel/src/syscall/exit.rs\n@@ -6,12 +6,11 @@ use crate::{\n     syscall::SyscallReturn,\n };\n \n-pub fn sys_exit(exit_code: i32, _ctx: &Context) -> Result<SyscallReturn> {\n+pub fn sys_exit(exit_code: i32, ctx: &Context) -> Result<SyscallReturn> {\n     debug!(\"exid code = {}\", exit_code);\n \n-    let current_thread = current_thread!();\n     let term_status = TermStatus::Exited(exit_code as _);\n-    do_exit(current_thread, term_status)?;\n+    do_exit(ctx.thread, ctx.posix_thread, term_status)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/kernel/src/syscall/futex.rs b/kernel/src/syscall/futex.rs\n--- a/kernel/src/syscall/futex.rs\n+++ b/kernel/src/syscall/futex.rs\n@@ -71,6 +71,6 @@ pub fn sys_futex(\n         _ => panic!(\"Unsupported futex operations\"),\n     }?;\n \n-    debug!(\"futex returns, tid= {} \", ctx.thread.tid());\n+    debug!(\"futex returns, tid= {} \", ctx.posix_thread.tid());\n     Ok(SyscallReturn::Return(res as _))\n }\ndiff --git a/kernel/src/syscall/gettid.rs b/kernel/src/syscall/gettid.rs\n--- a/kernel/src/syscall/gettid.rs\n+++ b/kernel/src/syscall/gettid.rs\n@@ -4,6 +4,6 @@ use super::SyscallReturn;\n use crate::prelude::*;\n \n pub fn sys_gettid(ctx: &Context) -> Result<SyscallReturn> {\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/mod.rs b/kernel/src/syscall/mod.rs\n--- a/kernel/src/syscall/mod.rs\n+++ b/kernel/src/syscall/mod.rs\n@@ -345,7 +345,10 @@ macro_rules! log_syscall_entry {\n         if log::log_enabled!(log::Level::Info) {\n             let syscall_name_str = stringify!($syscall_name);\n             let pid = $crate::current!().pid();\n-            let tid = $crate::current_thread!().tid();\n+            let tid = {\n+                use $crate::process::posix_thread::PosixThreadExt;\n+                $crate::current_thread!().tid()\n+            };\n             log::info!(\n                 \"[pid={}][tid={}][id={}][{}]\",\n                 pid,\ndiff --git a/kernel/src/syscall/set_tid_address.rs b/kernel/src/syscall/set_tid_address.rs\n--- a/kernel/src/syscall/set_tid_address.rs\n+++ b/kernel/src/syscall/set_tid_address.rs\n@@ -13,6 +13,6 @@ pub fn sys_set_tid_address(tidptr: Vaddr, ctx: &Context) -> Result<SyscallReturn\n     } else {\n         *clear_child_tid = tidptr;\n     }\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\n--- a/kernel/src/syscall/timer_create.rs\n+++ b/kernel/src/syscall/timer_create.rs\n@@ -7,7 +7,7 @@ use super::{\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::PosixThreadExt,\n+        posix_thread::{thread_table, PosixThreadExt},\n         process_table,\n         signal::{\n             c_types::{sigevent_t, SigNotify},\ndiff --git a/kernel/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\n--- a/kernel/src/syscall/timer_create.rs\n+++ b/kernel/src/syscall/timer_create.rs\n@@ -17,10 +17,7 @@ use crate::{\n         },\n     },\n     syscall::ClockId,\n-    thread::{\n-        thread_table,\n-        work_queue::{submit_work_item, work_item::WorkItem},\n-    },\n+    thread::work_queue::{submit_work_item, work_item::WorkItem},\n     time::{\n         clockid_t,\n         clocks::{BootTimeClock, MonotonicClock, RealTimeClock},\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -2,23 +2,22 @@\n \n use ostd::{\n     cpu::CpuSet,\n-    task::{Priority, TaskOptions},\n+    task::{Priority, Task, TaskOptions},\n };\n \n-use super::{allocate_tid, status::ThreadStatus, thread_table, Thread};\n+use super::{status::ThreadStatus, Thread};\n use crate::prelude::*;\n \n /// The inner data of a kernel thread\n pub struct KernelThread;\n \n pub trait KernelThreadExt {\n-    /// get the kernel_thread structure\n+    /// Gets the kernel_thread structure\n     fn as_kernel_thread(&self) -> Option<&KernelThread>;\n-    /// create a new kernel thread structure, **NOT** run the thread.\n-    fn new_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread>;\n-    /// create a new kernel thread structure, and then run the thread.\n+    /// Creates a new kernel thread, and then run the thread.\n     fn spawn_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread> {\n-        let thread = Self::new_kernel_thread(thread_options);\n+        let task = create_new_kernel_task(thread_options);\n+        let thread = Thread::borrow_from_task(&task).clone();\n         thread.run();\n         thread\n     }\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -31,31 +30,6 @@ impl KernelThreadExt for Thread {\n         self.data().downcast_ref::<KernelThread>()\n     }\n \n-    fn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\n-        let task_fn = thread_options.take_func();\n-        let thread_fn = move || {\n-            task_fn();\n-            let current_thread = current_thread!();\n-            // ensure the thread is exit\n-            current_thread.exit();\n-        };\n-        let tid = allocate_tid();\n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let weal_thread = thread_ref.clone();\n-            let task = TaskOptions::new(thread_fn)\n-                .data(weal_thread)\n-                .priority(thread_options.priority)\n-                .cpu_affinity(thread_options.cpu_affinity)\n-                .build()\n-                .unwrap();\n-            let status = ThreadStatus::Init;\n-            let kernel_thread = KernelThread;\n-            Thread::new(tid, task, kernel_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n-    }\n-\n     fn join(&self) {\n         loop {\n             if self.status().is_exited() {\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -67,6 +41,31 @@ impl KernelThreadExt for Thread {\n     }\n }\n \n+/// Creates a new task of kernel thread, **NOT** run the thread.\n+pub fn create_new_kernel_task(mut thread_options: ThreadOptions) -> Arc<Task> {\n+    let task_fn = thread_options.take_func();\n+    let thread_fn = move || {\n+        task_fn();\n+        // Ensures the thread is exit\n+        current_thread!().exit();\n+    };\n+\n+    Arc::new_cyclic(|weak_task| {\n+        let thread = {\n+            let kernel_thread = KernelThread;\n+            let status = ThreadStatus::Init;\n+            Arc::new(Thread::new(weak_task.clone(), kernel_thread, status))\n+        };\n+\n+        TaskOptions::new(thread_fn)\n+            .data(thread)\n+            .priority(thread_options.priority)\n+            .cpu_affinity(thread_options.cpu_affinity)\n+            .build()\n+            .unwrap()\n+    })\n+}\n+\n /// Options to create or spawn a new thread.\n pub struct ThreadOptions {\n     func: Option<Box<dyn Fn() + Send + Sync>>,\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -2,7 +2,7 @@\n \n //! Posix thread implementation\n \n-use core::sync::atomic::{AtomicU32, Ordering};\n+use core::sync::atomic::Ordering;\n \n use ostd::task::Task;\n \ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -13,20 +13,15 @@ pub mod exception;\n pub mod kernel_thread;\n pub mod status;\n pub mod task;\n-pub mod thread_table;\n pub mod work_queue;\n \n pub type Tid = u32;\n \n-static TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n-\n /// A thread is a wrapper on top of task.\n pub struct Thread {\n     // immutable part\n-    /// Thread id\n-    tid: Tid,\n     /// Low-level info\n-    task: Arc<Task>,\n+    task: Weak<Task>,\n     /// Data: Posix thread info/Kernel thread Info\n     data: Box<dyn Send + Sync + Any>,\n \ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -36,14 +31,8 @@ pub struct Thread {\n \n impl Thread {\n     /// Never call these function directly\n-    pub fn new(\n-        tid: Tid,\n-        task: Arc<Task>,\n-        data: impl Send + Sync + Any,\n-        status: ThreadStatus,\n-    ) -> Self {\n+    pub fn new(task: Weak<Task>, data: impl Send + Sync + Any, status: ThreadStatus) -> Self {\n         Thread {\n-            tid,\n             task,\n             data: Box::new(data),\n             status: AtomicThreadStatus::new(status),\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -57,18 +46,23 @@ impl Thread {\n     pub fn current() -> Option<Arc<Self>> {\n         Task::current()?\n             .data()\n-            .downcast_ref::<Weak<Thread>>()?\n-            .upgrade()\n+            .downcast_ref::<Arc<Thread>>()\n+            .cloned()\n     }\n \n-    pub(in crate::thread) fn task(&self) -> &Arc<Task> {\n-        &self.task\n+    /// Gets the Thread from task's data.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the task is not a thread.\n+    pub fn borrow_from_task(task: &Arc<Task>) -> &Arc<Self> {\n+        task.data().downcast_ref::<Arc<Thread>>().unwrap()\n     }\n \n     /// Runs this thread at once.\n     pub fn run(&self) {\n         self.set_status(ThreadStatus::Running);\n-        self.task.run();\n+        self.task.upgrade().unwrap().run();\n     }\n \n     pub(super) fn exit(&self) {\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -94,10 +88,6 @@ impl Thread {\n         Task::yield_now()\n     }\n \n-    pub fn tid(&self) -> Tid {\n-        self.tid\n-    }\n-\n     /// Returns the associated data.\n     ///\n     /// The return type must be borrowed box, otherwise the `downcast_ref` will fail.\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -106,8 +96,3 @@ impl Thread {\n         &self.data\n     }\n }\n-\n-/// Allocates a new tid for the new thread\n-pub fn allocate_tid() -> Tid {\n-    TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n-}\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -16,12 +16,12 @@ use crate::{\n };\n \n /// create new task with userspace and parent process\n-pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n+pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Arc<Thread>) -> Task {\n     fn user_task_entry() {\n         let current_thread = current_thread!();\n         let current_posix_thread = current_thread.as_posix_thread().unwrap();\n         let current_process = current_posix_thread.process();\n-        let current_task = current_thread.task();\n+        let current_task = Task::current().unwrap();\n \n         let user_space = current_task\n             .user_space()\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -47,7 +47,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         // in the child process.\n         if is_userspace_vaddr(child_tid_ptr) {\n             CurrentUserSpace::get()\n-                .write_val(child_tid_ptr, &current_thread.tid())\n+                .write_val(child_tid_ptr, &current_posix_thread.tid())\n                 .unwrap();\n         }\n \ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -77,7 +77,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             // If current is suspended, wait for a signal to wake up self\n             while current_thread.status().is_stopped() {\n                 Thread::yield_now();\n-                debug!(\"{} is suspended.\", current_thread.tid());\n+                debug!(\"{} is suspended.\", current_posix_thread.tid());\n                 handle_pending_signal(user_ctx, &current_thread).unwrap();\n             }\n             if current_thread.status().is_exited() {\ndiff --git a/kernel/src/thread/thread_table.rs /dev/null\n--- a/kernel/src/thread/thread_table.rs\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use super::{Thread, Tid};\n-use crate::prelude::*;\n-\n-lazy_static! {\n-    static ref THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n-}\n-\n-pub fn add_thread(thread: Arc<Thread>) {\n-    let tid = thread.tid();\n-    THREAD_TABLE.lock().insert(tid, thread);\n-}\n-\n-pub fn remove_thread(tid: Tid) {\n-    THREAD_TABLE.lock().remove(&tid);\n-}\n-\n-pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n-    THREAD_TABLE.lock().get(&tid).cloned()\n-}\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use ostd::{cpu::CpuSet, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    task::{Priority, Task},\n+};\n \n use super::worker_pool::WorkerPool;\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -17,7 +20,7 @@ use crate::{\n /// added to the `WorkerPool`.\n pub(super) struct Worker {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n     bound_cpu: u32,\n     inner: SpinLock<WorkerInner>,\n }\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -51,14 +54,14 @@ impl Worker {\n             if worker_pool.upgrade().unwrap().is_high_priority() {\n                 priority = Priority::high();\n             }\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n                 bound_cpu,\n                 inner: SpinLock::new(WorkerInner {\n                     worker_status: WorkerStatus::Running,\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -68,7 +71,8 @@ impl Worker {\n     }\n \n     pub(super) fn run(&self) {\n-        self.bound_thread.run();\n+        let thread = Thread::borrow_from_task(&self.bound_task);\n+        thread.run();\n     }\n \n     /// The thread function bound to normal workers.\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -97,8 +101,8 @@ impl Worker {\n         self.exit();\n     }\n \n-    pub(super) fn bound_thread(&self) -> &Arc<Thread> {\n-        &self.bound_thread\n+    pub(super) fn bound_task(&self) -> &Arc<Task> {\n+        &self.bound_task\n     }\n \n     pub(super) fn is_idle(&self) -> bool {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -7,12 +7,16 @@ use core::{\n     time::Duration,\n };\n \n-use ostd::{cpu::CpuSet, sync::WaitQueue, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    sync::WaitQueue,\n+    task::{Priority, Task},\n+};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -60,7 +64,7 @@ pub trait WorkerScheduler: Sync + Send {\n /// are found processing in the pool.\n pub struct Monitor {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n }\n \n impl LocalWorkerPool {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -77,7 +81,7 @@ impl LocalWorkerPool {\n     fn add_worker(&self) {\n         let worker = Worker::new(self.parent.clone(), self.cpu_id);\n         self.workers.disable_irq().lock().push_back(worker.clone());\n-        worker.bound_thread().run();\n+        Thread::borrow_from_task(worker.bound_task()).run();\n     }\n \n     fn remove_worker(&self) {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -236,20 +240,20 @@ impl Monitor {\n                 WorkPriority::High => Priority::high(),\n                 WorkPriority::Normal => Priority::normal(),\n             };\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n             }\n         })\n     }\n \n     pub fn run(&self) {\n-        self.bound_thread.run();\n+        Thread::borrow_from_task(&self.bound_task).run()\n     }\n \n     fn run_monitor_loop(self: &Arc<Self>) {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -166,7 +166,7 @@ impl TaskOptions {\n     }\n \n     /// Builds a new task without running it immediately.\n-    pub fn build(self) -> Result<Arc<Task>> {\n+    pub fn build(self) -> Result<Task> {\n         /// all task will entering this function\n         /// this function is mean to executing the task_fn in Task\n         extern \"C\" fn kernel_task_entry() {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -201,12 +201,12 @@ impl TaskOptions {\n         // have any arguments, so we only need to align the stack pointer to 16 bytes.\n         ctx.set_stack_pointer(crate::mm::paddr_to_vaddr(new_task.kstack.end_paddr() - 16));\n \n-        Ok(Arc::new(new_task))\n+        Ok(new_task)\n     }\n \n     /// Builds a new task and run it immediately.\n     pub fn spawn(self) -> Result<Arc<Task>> {\n-        let task = self.build()?;\n+        let task = Arc::new(self.build()?);\n         task.run();\n         Ok(task)\n     }\n",
        "test_patch": "diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -146,15 +143,8 @@ fn init_thread() {\n     // driver::pci::virtio::block::block_device_test();\n     let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n         println!(\"[kernel] Hello world from kernel!\");\n-        let current = current_thread!();\n-        let tid = current.tid();\n-        debug!(\"current tid = {}\", tid);\n     }));\n     thread.join();\n-    info!(\n-        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n-        thread.tid()\n-    );\n \n     print_banner();\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -710,7 +718,7 @@ mod test {\n     fn new_process(parent: Option<Arc<Process>>) -> Arc<Process> {\n         crate::util::random::init();\n         crate::fs::rootfs::init_root_mount();\n-        let pid = allocate_tid();\n+        let pid = allocate_posix_tid();\n         let parent = if let Some(parent) = parent {\n             Arc::downgrade(&parent)\n         } else {\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -102,11 +102,13 @@ fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n     // Kernel tasks are managed by the Framework,\n     // while scheduling algorithms for them can be\n     // determined by the users of the Framework.\n-    TaskOptions::new(user_task)\n-        .user_space(Some(user_space))\n-        .data(0)\n-        .build()\n-        .unwrap()\n+    Arc::new(\n+        TaskOptions::new(user_task)\n+            .user_space(Some(user_space))\n+            .data(0)\n+            .build()\n+            .unwrap(),\n+    )\n }\n \n fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -237,11 +237,13 @@ mod test {\n         let task = || {\n             assert_eq!(1, 1);\n         };\n-        let task_option = crate::task::TaskOptions::new(task)\n-            .data(())\n-            .build()\n-            .unwrap();\n-        task_option.run();\n+        let task = Arc::new(\n+            crate::task::TaskOptions::new(task)\n+                .data(())\n+                .build()\n+                .unwrap(),\n+        );\n+        task.run();\n     }\n \n     #[ktest]\n",
        "problem_statement": "Reachable unwrap panic in `read_clock()`\n### Describe the bug\r\nThere is a reachable unwrap panic in `read_clock()` at kernel/src/syscall/clock_gettime.rs:141 when make a `clock_gettime` syscall with specific argument.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/aa77747f94c4b1cb1237ba52414642827a6efc25/kernel/src/syscall/clock_gettime.rs#L141\r\n\r\n\r\n### To Reproduce\r\n1. Compile a program which calls `clock_gettime`:\r\n```C\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <sys/syscall.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\nint main() {\r\n  clock_gettime(-10, 0x1);\r\n  perror(\"clock_gettime\");\r\n\r\n  return 0;\r\n}\r\n```\r\n2. Run the compiled program in Asterinas.\r\n\r\n### Expected behavior\r\nAsterinas reports panic and is terminated.\r\n\r\n### Environment\r\n- Official docker asterinas/asterinas:0.8.0\r\n- 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\r\n- Asterinas version: main aa77747f\r\n\r\n### Logs\r\n\r\n```\r\n~ # /root/clock_gettime.c \r\npanicked at /root/asterinas/kernel/src/syscall/clock_gettime.rs:141:61:\r\ncalled `Option::unwrap()` on a `None` value\r\nPrinting stack trace:\r\n   1: fn 0xffffffff8880e1c0 - pc 0xffffffff8880e1d8 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297c0;\r\n\r\n   2: fn 0xffffffff8880dfa0 - pc 0xffffffff8880e118 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297d0;\r\n\r\n   3: fn 0xffffffff88049000 - pc 0xffffffff8804900a / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629950;\r\n\r\n   4: fn 0xffffffff889b0fb0 - pc 0xffffffff889b1032 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629960;\r\n\r\n   5: fn 0xffffffff889b1150 - pc 0xffffffff889b1190 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6299f0;\r\n\r\n   6: fn 0xffffffff8899a710 - pc 0xffffffff8899a725 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a60;\r\n\r\n   7: fn 0xffffffff884f2290 - pc 0xffffffff884f289f / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a70;\r\n\r\n   8: fn 0xffffffff884f1d20 - pc 0xffffffff884f1d81 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629d30;\r\n\r\n   9: fn 0xffffffff88161a50 - pc 0xffffffff8818d4ab / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629f30;\r\n\r\n  10: fn 0xffffffff88152f60 - pc 0xffffffff88152fee / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6403d0;\r\n\r\n  11: fn 0xffffffff88110380 - pc 0xffffffff88110eff / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640570;\r\n\r\n  12: fn 0xffffffff8845cb70 - pc 0xffffffff8845cb7e / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640f90;\r\n\r\n  13: fn 0xffffffff887cdc50 - pc 0xffffffff887cdc66 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fb0;\r\n\r\n  14: fn 0xffffffff887b0280 - pc 0xffffffff887b02e9 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fd0;\r\n\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f641000;\r\n\r\n[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\r\n(  1) /root/asterinas/ostd/src/panicking.rs:106\r\n(  2) /root/asterinas/ostd/src/panicking.rs:59\r\n(  3) 89yvfinwjerz0clyodmhm6lzz:?\r\n(  4) ??:?\r\n(  5) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs:220\r\n(  6) ??:?\r\n(  7) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:961\r\n(  8) /root/asterinas/kernel/src/syscall/clock_gettime.rs:29\r\n(  9) /root/asterinas/kernel/src/syscall/mod.rs:164\r\n( 10) /root/asterinas/kernel/src/syscall/mod.rs:328\r\n( 11) /root/asterinas/kernel/src/thread/task.rs:69\r\n( 12) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n( 13) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2077\r\n( 14) /root/asterinas/ostd/src/task/task/mod.rs:341\r\nmake: *** [Makefile:167: run] Error 1\r\n```\n",
        "hints_text": "",
        "created_at": "2024-09-12T06:03:09Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1279,
        "instance_id": "asterinas__asterinas-1279",
        "issue_numbers": [
            "1274"
        ],
        "base_commit": "963874471284ed014b76d268d933b6d13073c2cc",
        "patch": "diff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -50,7 +50,9 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n         // Cannot be reduced to `then_some`, or the possible dropping of the temporary\n         // guard will cause an unexpected unlock.\n-        self.acquire_lock().then_some(MutexGuard { mutex: self })\n+        // SAFETY: The lock is successfully acquired when creating the guard.\n+        self.acquire_lock()\n+            .then(|| unsafe { MutexGuard::new(self) })\n     }\n \n     /// Tries acquire the mutex through an [`Arc`].\ndiff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -100,6 +102,16 @@ pub struct MutexGuard_<T: ?Sized, R: Deref<Target = Mutex<T>>> {\n /// A guard that provides exclusive access to the data protected by a [`Mutex`].\n pub type MutexGuard<'a, T> = MutexGuard_<T, &'a Mutex<T>>;\n \n+impl<'a, T: ?Sized> MutexGuard<'a, T> {\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the given reference of [`Mutex`] lock has been successfully acquired\n+    /// in the current context. When the created [`MutexGuard`] is dropped, it will unlock the [`Mutex`].\n+    unsafe fn new(mutex: &'a Mutex<T>) -> MutexGuard<'a, T> {\n+        MutexGuard { mutex }\n+    }\n+}\n+\n /// An guard that provides exclusive access to the data protected by a `Arc<Mutex>`.\n pub type ArcMutexGuard<T> = MutexGuard_<T, Arc<Mutex<T>>>;\n \n",
        "test_patch": "diff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -138,3 +150,27 @@ impl<'a, T: ?Sized> MutexGuard<'a, T> {\n         guard.mutex\n     }\n }\n+\n+#[cfg(ktest)]\n+mod test {\n+    use super::*;\n+    use crate::prelude::*;\n+\n+    // A regression test for a bug fixed in [#1279](https://github.com/asterinas/asterinas/pull/1279).\n+    #[ktest]\n+    fn test_mutex_try_lock_does_not_unlock() {\n+        let lock = Mutex::new(0);\n+        assert!(!lock.lock.load(Ordering::Relaxed));\n+\n+        // A successful lock\n+        let guard1 = lock.lock();\n+        assert!(lock.lock.load(Ordering::Relaxed));\n+\n+        // A failed `try_lock` won't drop the lock\n+        assert!(lock.try_lock().is_none());\n+        assert!(lock.lock.load(Ordering::Relaxed));\n+\n+        // Ensure the lock is held until here\n+        drop(guard1);\n+    }\n+}\n",
        "problem_statement": "Potential mutex lock bug leading to multiple threads entering critical section\n### Describe the bug\r\n\r\nHi there!\r\n\r\nI'm working on a testcase for issue #1261 to reproduce the bug, and I noticed a weird behavior. It seems that `mutex.lock()` does not block when another thread has already acquired the lock in `ktest`. This causes multiple threads to enter the critical section simultaneously.\r\n\r\n### To Reproduce\r\n\r\n1. `git apply ./patch.diff`\r\n2. `make ktest`\r\n\r\nHere is the `path.diff` file:\r\n\r\n**Note**: I'm not sure if I inited the test environment and used `timer::Jiffies` and `Thread::yield_now()` correctly. I observed that without using `yield_now()`, thread scheduling does not occur. In other words, if `Thread::yield_now()` is commented out, this test case will pass.\r\n\r\n```diff\r\ndiff --git a/kernel/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\r\nindex 944fe070..52f3e971 100644\r\n--- a/kernel/src/process/sync/condvar.rs\r\n+++ b/kernel/src/process/sync/condvar.rs\r\n@@ -363,4 +363,51 @@ mod test {\r\n             assert!(!*started);\r\n         }\r\n     }\r\n+\r\n+    use ostd::arch::timer::Jiffies;\r\n+\r\n+    fn wait_jiffies(value: u64) {\r\n+        let mut previous = Jiffies::elapsed().as_u64();\r\n+        let ddl = previous + value;\r\n+        loop {\r\n+            let current = Jiffies::elapsed().as_u64();\r\n+            if current >= ddl {\r\n+                break;\r\n+            }\r\n+            if current - previous >= 10 {\r\n+                previous = current;\r\n+                Thread::yield_now();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    #[ktest]\r\n+    fn test_mutex_cs() {\r\n+        let pair = Arc::new((Mutex::new(0), Condvar::new()));\r\n+        let pair2 = Arc::clone(&pair);\r\n+\r\n+        Thread::spawn_kernel_thread(ThreadOptions::new(move || {\r\n+            wait_jiffies(1000);\r\n+            let (lock, _) = &*pair;\r\n+            let mut val = lock.lock();\r\n+            *val = 1;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 1);\r\n+            *val = 2;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 2);\r\n+        }));\r\n+\r\n+        {\r\n+            let (lock2, _) = &*pair2;\r\n+            let mut val = lock2.lock();\r\n+            *val = 10;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 10);\r\n+            *val = 20;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 20);\r\n+        }\r\n+\r\n+    }\r\n }\r\n```\r\n\r\n### Expected behavior\r\n\r\nOnly one thread should enter the critical section at a time.\r\n\r\n### Screenshots\r\n\r\n![28cecd84ca55772867240a21d99ec32](https://github.com/user-attachments/assets/2c93be85-fd48-4656-bbd1-fae9c2fd2b31)\r\n\r\n### Environment\r\n\r\nOfficial Docker environment, version 0.8.1\r\n\r\n\n",
        "hints_text": "The bug introduced in this commit: https://github.com/asterinas/asterinas/commit/d15b4d9115cf33490245c06a93928995765f0d3f#r146080074\r\n\r\nA potential fix: #497",
        "created_at": "2024-09-02T06:56:20Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 334,
        "instance_id": "asterinas__asterinas-334",
        "issue_numbers": [
            "214"
        ],
        "base_commit": "25c4f0f2bcaa0bc8c650b0f4ee7b0d78e2a836b2",
        "patch": "diff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -3,7 +3,7 @@ MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n-TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve \n+TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve pty\n \n .PHONY: all\n \ndiff --git /dev/null b/regression/apps/pty/open_pty.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/pty/open_pty.c\n@@ -0,0 +1,51 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <termios.h>\n+#include <pty.h>\n+\n+int main() {\n+    int master, slave;\n+    char name[256];\n+    struct termios term;\n+\n+    if (openpty(&master, &slave, name, NULL, NULL) == -1) {\n+        perror(\"openpty\");\n+        exit(EXIT_FAILURE);\n+    }\n+\n+    printf(\"slave name: %s\\n\", name);\n+\n+    // Set pty slave terminal attributes\n+    tcgetattr(slave, &term);\n+    term.c_lflag &= ~(ICANON | ECHO);\n+    term.c_cc[VMIN] = 1;\n+    term.c_cc[VTIME] = 0;\n+    tcsetattr(slave, TCSANOW, &term);\n+\n+    // Print to pty slave\n+    dprintf(slave, \"Hello world!\\n\");\n+\n+    // Read from pty slave\n+    char buf[256];\n+    ssize_t n = read(master, buf, sizeof(buf));\n+    if (n > 0) {\n+        printf(\"read %ld bytes from slave: %.*s\", n, (int)n, buf);\n+    }\n+\n+    // Write to pty master\n+    dprintf(master, \"hello world from master\\n\");\n+\n+    // Read from pty master\n+    char nbuf[256];\n+    ssize_t nn = read(slave, nbuf, sizeof(nbuf));\n+    if (nn > 0) {\n+        printf(\"read %ld bytes from master: %.*s\", nn, (int)nn, nbuf);\n+    }\n+\n+    close(master);\n+    close(slave);\n+\n+    return 0;\n+}\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -7,6 +7,8 @@ mod zero;\n \n use crate::fs::device::{add_node, Device, DeviceId, DeviceType};\n use crate::prelude::*;\n+pub use pty::new_pty_pair;\n+pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \ndiff --git a/services/libs/jinux-std/src/device/pty.rs /dev/null\n--- a/services/libs/jinux-std/src/device/pty.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-use crate::fs::{\n-    devpts::DevPts,\n-    fs_resolver::{FsPath, FsResolver},\n-    utils::{InodeMode, InodeType},\n-};\n-use crate::prelude::*;\n-\n-pub fn init() -> Result<()> {\n-    let fs = FsResolver::new();\n-\n-    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n-    // Create the \"pts\" directory and mount devpts on it.\n-    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n-    devpts.mount(DevPts::new())?;\n-\n-    // Create the \"ptmx\" symlink.\n-    let ptmx = dev.create(\n-        \"ptmx\",\n-        InodeType::SymLink,\n-        InodeMode::from_bits_truncate(0o777),\n-    )?;\n-    ptmx.write_link(\"pts/ptmx\")?;\n-    Ok(())\n-}\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -0,0 +1,38 @@\n+use crate::fs::devpts::DevPts;\n+use crate::fs::fs_resolver::{FsPath, FsResolver};\n+use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\n+use crate::prelude::*;\n+\n+mod pty;\n+\n+pub use pty::{PtyMaster, PtySlave};\n+use spin::Once;\n+\n+static DEV_PTS: Once<Arc<Dentry>> = Once::new();\n+\n+pub fn init() -> Result<()> {\n+    let fs = FsResolver::new();\n+\n+    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n+    // Create the \"pts\" directory and mount devpts on it.\n+    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n+    devpts.mount(DevPts::new())?;\n+\n+    DEV_PTS.call_once(|| devpts);\n+\n+    // Create the \"ptmx\" symlink.\n+    let ptmx = dev.create(\n+        \"ptmx\",\n+        InodeType::SymLink,\n+        InodeMode::from_bits_truncate(0o777),\n+    )?;\n+    ptmx.write_link(\"pts/ptmx\")?;\n+    Ok(())\n+}\n+\n+pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n+    debug!(\"pty index = {}\", index);\n+    let master = Arc::new(PtyMaster::new(ptmx, index));\n+    let slave = Arc::new(PtySlave::new(master.clone()));\n+    Ok((master, slave))\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/pty.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -0,0 +1,312 @@\n+use alloc::format;\n+use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n+\n+use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::fs_resolver::FsPath;\n+use crate::fs::utils::{AccessMode, Inode, InodeMode, IoEvents, IoctlCmd, Pollee, Poller};\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+const PTS_DIR: &str = \"/dev/pts\";\n+const BUFFER_CAPACITY: usize = 4096;\n+\n+/// Pesudo terminal master.\n+/// Internally, it has two buffers.\n+/// One is inside ldisc, which is written by master and read by slave,\n+/// the other is a ring buffer, which is written by slave and read by master.\n+pub struct PtyMaster {\n+    ptmx: Arc<dyn Inode>,\n+    index: u32,\n+    output: LineDiscipline,\n+    input: SpinLock<HeapRb<u8>>,\n+    /// The state of input buffer\n+    pollee: Pollee,\n+}\n+\n+impl PtyMaster {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n+        Self {\n+            ptmx,\n+            index,\n+            output: LineDiscipline::new(),\n+            input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            pollee: Pollee::new(IoEvents::OUT),\n+        }\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.index\n+    }\n+\n+    pub fn ptmx(&self) -> &Arc<dyn Inode> {\n+        &self.ptmx\n+    }\n+\n+    pub(super) fn slave_push_byte(&self, byte: u8) {\n+        let mut input = self.input.lock_irq_disabled();\n+        input.push_overwrite(byte);\n+        self.update_state(&input);\n+    }\n+\n+    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.output.read(buf)\n+    }\n+\n+    pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.output.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.pollee.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+\n+    pub(super) fn slave_buf_len(&self) -> usize {\n+        self.output.buffer_len()\n+    }\n+\n+    fn update_state(&self, buf: &HeapRb<u8>) {\n+        if buf.is_empty() {\n+            self.pollee.del_events(IoEvents::IN)\n+        } else {\n+            self.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+}\n+\n+impl FileLike for PtyMaster {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        // TODO: deal with nonblocking read\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let poller = Poller::new();\n+        loop {\n+            let mut input = self.input.lock_irq_disabled();\n+\n+            if input.is_empty() {\n+                let events = self.pollee.poll(IoEvents::IN, Some(&poller));\n+\n+                if events.contains(IoEvents::ERR) {\n+                    return_errno_with_message!(Errno::EACCES, \"unexpected err\");\n+                }\n+\n+                if events.is_empty() {\n+                    drop(input);\n+                    poller.wait();\n+                }\n+                continue;\n+            }\n+\n+            let read_len = input.len().min(buf.len());\n+            input.pop_slice(&mut buf[..read_len]);\n+            self.update_state(&input);\n+            return Ok(read_len);\n+        }\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let mut input = self.input.lock();\n+\n+        for character in buf {\n+            self.output.push_char(*character, |content| {\n+                for byte in content.as_bytes() {\n+                    input.push_overwrite(*byte);\n+                }\n+            });\n+        }\n+\n+        self.update_state(&input);\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                let termios = self.output.termios();\n+                write_val_to_user(arg, &termios)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TCSETS => {\n+                let termios = read_val_from_user(arg)?;\n+                self.output.set_termios(termios);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPTLCK => {\n+                // TODO: lock/unlock pty\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTN => {\n+                let idx = self.index();\n+                write_val_to_user(arg, &idx)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTPEER => {\n+                let current = current!();\n+\n+                // TODO: deal with open options\n+                let slave = {\n+                    let slave_name = {\n+                        let devpts_path = super::DEV_PTS.get().unwrap().abs_path();\n+                        format!(\"{}/{}\", devpts_path, self.index())\n+                    };\n+\n+                    let fs_path = FsPath::try_from(slave_name.as_str())?;\n+\n+                    let inode_handle = {\n+                        let fs = current.fs().read();\n+                        let flags = AccessMode::O_RDWR as u32;\n+                        let mode = (InodeMode::S_IRUSR | InodeMode::S_IWUSR).bits();\n+                        fs.open(&fs_path, flags, mode)?\n+                    };\n+                    Arc::new(inode_handle)\n+                };\n+\n+                let fd = {\n+                    let mut file_table = current.file_table().lock();\n+                    file_table.insert(slave)\n+                };\n+                Ok(fd)\n+            }\n+            IoctlCmd::TIOCGWINSZ => {\n+                let winsize = self.output.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.output.set_window_size(winsize);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO: reimplement when adding session.\n+                let foreground = {\n+                    let current = current!();\n+                    let process_group = current.process_group().lock();\n+                    process_group.clone()\n+                };\n+                self.output.set_fg(foreground);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPGRP => {\n+                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO: reimplement when adding session.\n+                self.output.set_fg(Weak::new());\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let len = self.input.lock().len() as i32;\n+                write_val_to_user(arg, &len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.pollee.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.output.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+}\n+\n+pub struct PtySlave(Arc<PtyMaster>);\n+\n+impl PtySlave {\n+    pub fn new(master: Arc<PtyMaster>) -> Self {\n+        PtySlave(master)\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.0.index()\n+    }\n+}\n+\n+impl Device for PtySlave {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> crate::fs::device::DeviceId {\n+        DeviceId::new(88, self.index() as u32)\n+    }\n+\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.slave_read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        for ch in buf {\n+            // do we need to add '\\r' here?\n+            if *ch == b'\\n' {\n+                self.0.slave_push_byte(b'\\r');\n+                self.0.slave_push_byte(b'\\n');\n+            } else {\n+                self.0.slave_push_byte(*ch);\n+            }\n+        }\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS\n+            | IoctlCmd::TCSETS\n+            | IoctlCmd::TIOCGPGRP\n+            | IoctlCmd::TIOCGPTN\n+            | IoctlCmd::TIOCGWINSZ\n+            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let buffer_len = self.0.slave_buf_len() as i32;\n+                write_val_to_user(arg, &buffer_len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.0.slave_poll(mask, poller)\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -25,6 +25,8 @@ pub struct LineDiscipline {\n     foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n+    /// Windows size,\n+    winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -72,12 +74,13 @@ impl LineDiscipline {\n             read_buffer: SpinLock::new(StaticRb::default()),\n             foreground: SpinLock::new(Weak::new()),\n             termios: SpinLock::new(KernelTermios::default()),\n+            winsize: SpinLock::new(WinSize::default()),\n             pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char(&self, mut item: u8, echo_callback: fn(&str)) {\n+    pub fn push_char<F: FnMut(&str)>(&self, mut item: u8, echo_callback: F) {\n         let termios = self.termios.lock_irq_disabled();\n         if termios.contains_icrnl() && item == b'\\r' {\n             item = b'\\n'\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -162,7 +165,7 @@ impl LineDiscipline {\n     }\n \n     // TODO: respect output flags\n-    fn output_char(&self, item: u8, termios: &KernelTermios, echo_callback: fn(&str)) {\n+    fn output_char<F: FnMut(&str)>(&self, item: u8, termios: &KernelTermios, mut echo_callback: F) {\n         match item {\n             b'\\n' => echo_callback(\"\\n\"),\n             b'\\r' => echo_callback(\"\\r\\n\"),\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -350,6 +353,18 @@ impl LineDiscipline {\n         self.current_line.lock().drain();\n         let _: Vec<_> = self.read_buffer.lock().pop_iter().collect();\n     }\n+\n+    pub fn buffer_len(&self) -> usize {\n+        self.read_buffer.lock().len()\n+    }\n+\n+    pub fn window_size(&self) -> WinSize {\n+        self.winsize.lock().clone()\n+    }\n+\n+    pub fn set_window_size(&self, winsize: WinSize) {\n+        *self.winsize.lock() = winsize;\n+    }\n }\n \n fn meet_new_line(item: u8, termios: &KernelTermios) -> bool {\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -6,7 +6,7 @@ use super::*;\n use crate::fs::utils::{IoEvents, IoctlCmd, Poller};\n use crate::prelude::*;\n use crate::process::process_group::ProcessGroup;\n-use crate::process::{process_table, Pgid};\n+use crate::process::process_table;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod driver;\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -130,7 +130,13 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGWINSZ => {\n-                // TODO:get window size\n+                let winsize = self.ldisc.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n             _ => todo!(),\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -14,22 +14,28 @@ bitflags! {\n     #[repr(C)]\n     pub struct C_IFLAGS: u32 {\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits-common.h\n-        const IGNBRK\t= 0x001;\t\t\t/* Ignore break condition */\n-        const BRKINT\t= 0x002;\t\t\t/* Signal interrupt on break */\n-        const IGNPAR\t= 0x004;\t\t\t/* Ignore characters with parity errors */\n-        const PARMRK\t= 0x008;\t\t\t/* Mark parity and framing errors */\n-        const INPCK\t    = 0x010;\t\t\t/* Enable input parity check */\n-        const ISTRIP\t= 0x020;\t\t\t/* Strip 8th bit off characters */\n-        const INLCR\t    = 0x040;\t\t\t/* Map NL to CR on input */\n-        const IGNCR\t    = 0x080;\t\t\t/* Ignore CR */\n-        const ICRNL\t    = 0x100;\t\t\t/* Map CR to NL on input */\n-        const IXANY\t    = 0x800;\t\t\t/* Any character will restart after stop */\n+        const IGNBRK  = 0x001;\t\t\t/* Ignore break condition */\n+        const BRKINT  = 0x002;\t\t\t/* Signal interrupt on break */\n+        const IGNPAR  = 0x004;\t\t\t/* Ignore characters with parity errors */\n+        const PARMRK  = 0x008;\t\t\t/* Mark parity and framing errors */\n+        const INPCK   = 0x010;\t\t\t/* Enable input parity check */\n+        const ISTRIP  = 0x020;\t\t\t/* Strip 8th bit off characters */\n+        const INLCR   = 0x040;\t\t\t/* Map NL to CR on input */\n+        const IGNCR   = 0x080;\t\t\t/* Ignore CR */\n+        const ICRNL   = 0x100;\t\t\t/* Map CR to NL on input */\n+        const IXANY   = 0x800;\t\t\t/* Any character will restart after stop */\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits.h\n-        const IUCLC\t    = 0x0200;\n-        const IXON\t    = 0x0400;\n-        const IXOFF\t    = 0x1000;\n-        const IMAXBEL\t= 0x2000;\n-        const IUTF8\t    = 0x4000;\n+        const IUCLC   = 0x0200;\n+        const IXON    = 0x0400;\n+        const IXOFF   = 0x1000;\n+        const IMAXBEL = 0x2000;\n+        const IUTF8   = 0x4000;\n+    }\n+}\n+\n+impl Default for C_IFLAGS {\n+    fn default() -> Self {\n+        C_IFLAGS::ICRNL | C_IFLAGS::IXON\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -37,18 +43,68 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_OFLAGS: u32 {\n-        const OPOST\t= 0x01;\t\t\t/* Perform output processing */\n-        const OCRNL\t= 0x08;\n-        const ONOCR\t= 0x10;\n-        const ONLRET= 0x20;\n-        const OFILL\t= 0x40;\n-        const OFDEL\t= 0x80;\n+        const OPOST  = 1 << 0;\t\t\t/* Perform output processing */\n+        const OLCUC  = 1 << 1;\n+        const ONLCR  = 1 << 2;\n+        const OCRNL  = 1 << 3;\n+        const ONOCR  = 1 << 4;\n+        const ONLRET = 1 << 5;\n+        const OFILL  = 1 << 6;\n+        const OFDEL  = 1 << 7;\n     }\n }\n \n-#[repr(u32)]\n+impl Default for C_OFLAGS {\n+    fn default() -> Self {\n+        C_OFLAGS::OPOST | C_OFLAGS::ONLCR\n+    }\n+}\n+\n+#[repr(C)]\n #[derive(Debug, Clone, Copy, Pod)]\n-pub enum C_CFLAGS {\n+pub struct C_CFLAGS(u32);\n+\n+impl Default for C_CFLAGS {\n+    fn default() -> Self {\n+        let cbaud = C_CFLAGS_BAUD::B38400 as u32;\n+        let csize = C_CFLAGS_CSIZE::CS8 as u32;\n+        let c_cflags = cbaud | csize | CREAD;\n+        Self(c_cflags)\n+    }\n+}\n+\n+impl C_CFLAGS {\n+    pub fn cbaud(&self) -> Result<C_CFLAGS_BAUD> {\n+        let cbaud = self.0 & CBAUD_MASK;\n+        Ok(C_CFLAGS_BAUD::try_from(cbaud)?)\n+    }\n+\n+    pub fn csize(&self) -> Result<C_CFLAGS_CSIZE> {\n+        let csize = self.0 & CSIZE_MASK;\n+        Ok(C_CFLAGS_CSIZE::try_from(csize)?)\n+    }\n+\n+    pub fn cread(&self) -> bool {\n+        self.0 & CREAD != 0\n+    }\n+}\n+\n+const CREAD: u32 = 0x00000080;\n+const CBAUD_MASK: u32 = 0x0000100f;\n+const CSIZE_MASK: u32 = 0x00000030;\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_CSIZE {\n+    CS5 = 0x00000000,\n+    CS6 = 0x00000010,\n+    CS7 = 0x00000020,\n+    CS8 = 0x00000030,\n+}\n+\n+#[repr(u32)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_BAUD {\n     B0 = 0x00000000, /* hang up */\n     B50 = 0x00000001,\n     B75 = 0x00000002,\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -71,28 +127,41 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_LFLAGS: u32 {\n-        const ISIG\t=   0x00001;\n-        const ICANON=   0x00002;\n-        const XCASE\t=   0x00004;\n-        const ECHO\t=   0x00008;\n-        const ECHOE\t=   0x00010;\n-        const ECHOK\t=   0x00020;\n-        const ECHONL=\t0x00040;\n-        const NOFLSH=\t0x00080;\n-        const TOSTOP=\t0x00100;\n-        const ECHOCTL=\t0x00200;\n-        const ECHOPRT=\t0x00400;\n-        const ECHOKE=   0x00800;\n-        const FLUSHO=\t0x01000;\n-        const PENDIN=\t0x04000;\n-        const IEXTEN=\t0x08000;\n-        const EXTPROC=\t0x10000;\n+        const ISIG    = 0x00001;\n+        const ICANON  = 0x00002;\n+        const XCASE   = 0x00004;\n+        const ECHO    = 0x00008;\n+        const ECHOE   = 0x00010;\n+        const ECHOK   = 0x00020;\n+        const ECHONL  = 0x00040;\n+        const NOFLSH  = 0x00080;\n+        const TOSTOP  = 0x00100;\n+        const ECHOCTL = 0x00200;\n+        const ECHOPRT = 0x00400;\n+        const ECHOKE  = 0x00800;\n+        const FLUSHO  = 0x01000;\n+        const PENDIN  = 0x04000;\n+        const IEXTEN  = 0x08000;\n+        const EXTPROC = 0x10000;\n+    }\n+}\n+\n+impl Default for C_LFLAGS {\n+    fn default() -> Self {\n+        C_LFLAGS::ICANON\n+            | C_LFLAGS::ECHO\n+            | C_LFLAGS::ISIG\n+            | C_LFLAGS::ECHOE\n+            | C_LFLAGS::ECHOK\n+            | C_LFLAGS::ECHOCTL\n+            | C_LFLAGS::ECHOKE\n+            | C_LFLAGS::IEXTEN\n     }\n }\n \n /* c_cc characters index*/\n #[repr(u32)]\n-#[derive(Debug, Clone, Copy, Pod)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum CC_C_CHAR {\n     VINTR = 0,\n     VQUIT = 1,\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -114,61 +183,28 @@ pub enum CC_C_CHAR {\n }\n \n impl CC_C_CHAR {\n-    // The special char is the same as ubuntu\n-    pub fn char(&self) -> u8 {\n+    // The special char is from gvisor\n+    pub fn default_char(&self) -> u8 {\n         match self {\n-            CC_C_CHAR::VINTR => 3,\n-            CC_C_CHAR::VQUIT => 28,\n-            CC_C_CHAR::VERASE => 127,\n-            CC_C_CHAR::VKILL => 21,\n-            CC_C_CHAR::VEOF => 4,\n-            CC_C_CHAR::VTIME => 0,\n+            CC_C_CHAR::VINTR => control_character('C'),\n+            CC_C_CHAR::VQUIT => control_character('\\\\'),\n+            CC_C_CHAR::VERASE => '\\x7f' as u8,\n+            CC_C_CHAR::VKILL => control_character('U'),\n+            CC_C_CHAR::VEOF => control_character('D'),\n+            CC_C_CHAR::VTIME => '\\0' as u8,\n             CC_C_CHAR::VMIN => 1,\n-            CC_C_CHAR::VSWTC => 0,\n-            CC_C_CHAR::VSTART => 17,\n-            CC_C_CHAR::VSTOP => 19,\n-            CC_C_CHAR::VSUSP => 26,\n-            CC_C_CHAR::VEOL => 255,\n-            CC_C_CHAR::VREPRINT => 18,\n-            CC_C_CHAR::VDISCARD => 15,\n-            CC_C_CHAR::VWERASE => 23,\n-            CC_C_CHAR::VLNEXT => 22,\n-            CC_C_CHAR::VEOL2 => 255,\n+            CC_C_CHAR::VSWTC => '\\0' as u8,\n+            CC_C_CHAR::VSTART => control_character('Q'),\n+            CC_C_CHAR::VSTOP => control_character('S'),\n+            CC_C_CHAR::VSUSP => control_character('Z'),\n+            CC_C_CHAR::VEOL => '\\0' as u8,\n+            CC_C_CHAR::VREPRINT => control_character('R'),\n+            CC_C_CHAR::VDISCARD => control_character('O'),\n+            CC_C_CHAR::VWERASE => control_character('W'),\n+            CC_C_CHAR::VLNEXT => control_character('V'),\n+            CC_C_CHAR::VEOL2 => '\\0' as u8,\n         }\n     }\n-\n-    pub fn as_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    pub fn from_char(item: u8) -> Result<Self> {\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VQUIT.char() {\n-            return Ok(Self::VQUIT);\n-        }\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VERASE.char() {\n-            return Ok(Self::VERASE);\n-        }\n-        if item == Self::VEOF.char() {\n-            return Ok(Self::VEOF);\n-        }\n-        if item == Self::VSTART.char() {\n-            return Ok(Self::VSTART);\n-        }\n-        if item == Self::VSTOP.char() {\n-            return Ok(Self::VSTOP);\n-        }\n-        if item == Self::VSUSP.char() {\n-            return Ok(Self::VSUSP);\n-        }\n-\n-        return_errno_with_message!(Errno::EINVAL, \"Not a valid cc_char\");\n-    }\n }\n \n #[derive(Debug, Clone, Copy, Pod)]\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -185,50 +221,39 @@ pub struct KernelTermios {\n impl KernelTermios {\n     pub fn default() -> Self {\n         let mut termios = Self {\n-            c_iflags: C_IFLAGS::ICRNL,\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::ICANON | C_LFLAGS::ECHO,\n+            c_iflags: C_IFLAGS::default(),\n+            c_oflags: C_OFLAGS::default(),\n+            c_cflags: C_CFLAGS::default(),\n+            c_lflags: C_LFLAGS::default(),\n             c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n+            c_cc: [CcT::default(); KERNEL_NCCS],\n         };\n-        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.default_char();\n         termios\n     }\n \n-    fn new() -> Self {\n-        KernelTermios {\n-            c_iflags: C_IFLAGS::empty(),\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::empty(),\n-            c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n-        }\n-    }\n-\n     pub fn get_special_char(&self, cc_c_char: CC_C_CHAR) -> &CcT {\n-        &self.c_cc[cc_c_char.as_usize()]\n+        &self.c_cc[cc_c_char as usize]\n     }\n \n     pub fn get_special_char_mut(&mut self, cc_c_char: CC_C_CHAR) -> &mut CcT {\n-        &mut self.c_cc[cc_c_char.as_usize()]\n+        &mut self.c_cc[cc_c_char as usize]\n     }\n \n     /// Canonical mode means we will handle input by lines, not by single character\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -265,3 +290,17 @@ impl KernelTermios {\n         self.c_lflags.contains(C_LFLAGS::IEXTEN)\n     }\n }\n+\n+const fn control_character(c: char) -> u8 {\n+    debug_assert!(c as u8 >= 'A' as u8);\n+    c as u8 - 'A' as u8 + 1u8\n+}\n+\n+#[derive(Debug, Clone, Copy, Default, Pod)]\n+#[repr(C)]\n+pub struct WinSize {\n+    ws_row: u16,\n+    ws_col: u16,\n+    ws_xpixel: u16,\n+    ws_ypixel: u16,\n+}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -1,7 +1,9 @@\n-use crate::prelude::*;\n+use crate::{fs::file_handle::FileLike, prelude::*};\n \n use super::*;\n \n+use crate::device::PtyMaster;\n+\n /// Pty master inode for the master device.\n pub struct PtyMasterInode(Arc<PtyMaster>);\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -14,8 +16,11 @@ impl PtyMasterInode {\n impl Drop for PtyMasterInode {\n     fn drop(&mut self) {\n         // Remove the slave from fs.\n-        let index = self.0.slave_index();\n-        let _ = self.0.ptmx().devpts().remove_slave(index);\n+        let fs = self.0.ptmx().fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.0.index();\n+        devpts.remove_slave(index);\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -77,52 +82,6 @@ impl Inode for PtyMasterInode {\n     }\n \n     fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().devpts()\n-    }\n-}\n-\n-// TODO: implement real pty master.\n-pub struct PtyMaster {\n-    slave_index: u32,\n-    ptmx: Arc<Ptmx>,\n-}\n-\n-impl PtyMaster {\n-    pub fn new(slave_index: u32, ptmx: Arc<Ptmx>) -> Arc<Self> {\n-        Arc::new(Self { slave_index, ptmx })\n-    }\n-\n-    pub fn slave_index(&self) -> u32 {\n-        self.slave_index\n-    }\n-\n-    fn ptmx(&self) -> &Ptmx {\n-        &self.ptmx\n-    }\n-}\n-\n-impl Device for PtyMaster {\n-    fn type_(&self) -> DeviceType {\n-        self.ptmx.device_type()\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        self.ptmx.device_id()\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n+        self.0.ptmx().fs()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,9 +9,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::{PtyMaster, PtyMasterInode};\n+use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n-use self::slave::{PtySlave, PtySlaveInode};\n+use self::slave::PtySlaveInode;\n \n mod master;\n mod ptmx;\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -60,8 +60,7 @@ impl DevPts {\n             .alloc()\n             .ok_or_else(|| Error::with_message(Errno::EIO, \"cannot alloc index\"))?;\n \n-        let master = PtyMaster::new(index as u32, self.root.ptmx.clone());\n-        let slave = PtySlave::new(master.clone());\n+        let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n         let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -2,6 +2,8 @@ use crate::prelude::*;\n \n use super::*;\n \n+use crate::device::PtySlave;\n+\n /// Same major number with Linux, the minor number is the index of slave.\n const SLAVE_MAJOR_NUM: u32 = 3;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -88,44 +90,3 @@ impl Inode for PtySlaveInode {\n         self.fs.upgrade().unwrap()\n     }\n }\n-\n-// TODO: implement real pty slave.\n-pub struct PtySlave {\n-    master: Arc<PtyMaster>,\n-}\n-\n-impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self { master })\n-    }\n-\n-    pub fn index(&self) -> u32 {\n-        self.master.slave_index()\n-    }\n-}\n-\n-impl Device for PtySlave {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        DeviceId::new(SLAVE_MAJOR_NUM, self.index())\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n--- a/services/libs/jinux-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n@@ -3,18 +3,30 @@ use crate::prelude::*;\n #[repr(u32)]\n #[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum IoctlCmd {\n-    // Get terminal attributes\n+    /// Get terminal attributes\n     TCGETS = 0x5401,\n     TCSETS = 0x5402,\n-    // Drain the output buffer and set attributes\n+    /// Drain the output buffer and set attributes\n     TCSETSW = 0x5403,\n-    // Drain the output buffer, and discard pending input, and set attributes\n+    /// Drain the output buffer, and discard pending input, and set attributes\n     TCSETSF = 0x5404,\n-    // Get the process group ID of the foreground process group on this terminal\n+    /// Make the given terminal the controlling terminal of the calling process.\n+    TIOCSCTTY = 0x540e,\n+    /// Get the process group ID of the foreground process group on this terminal\n     TIOCGPGRP = 0x540f,\n-    // Set the foreground process group ID of this terminal.\n+    /// Set the foreground process group ID of this terminal.\n     TIOCSPGRP = 0x5410,\n-    // Set window size\n+    /// Get the number of bytes in the input buffer.\n+    FIONREAD = 0x541B,\n+    /// Set window size\n     TIOCGWINSZ = 0x5413,\n     TIOCSWINSZ = 0x5414,\n+    /// the calling process gives up this controlling terminal\n+    TIOCNOTTY = 0x5422,\n+    /// Get Pty Number\n+    TIOCGPTN = 0x80045430,\n+    /// Lock/unlock Pty\n+    TIOCSPTLCK = 0x40045431,\n+    /// Safely open the slave\n+    TIOCGPTPEER = 0x40045441,\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -146,6 +146,7 @@ impl Vnode {\n         if let Some(page_cache) = &inner.page_cache {\n             page_cache.evict_range(0..file_len);\n         }\n+\n         inner.inode.read_at(0, &mut buf[..file_len])\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -196,11 +197,13 @@ impl Vnode {\n     }\n \n     pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.inner.read().inode.poll(mask, poller)\n+        let inode = self.inner.read().inode.clone();\n+        inode.poll(mask, poller)\n     }\n \n     pub fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.inner.read().inode.ioctl(cmd, arg)\n+        let inode = self.inner.read().inode.clone();\n+        inode.ioctl(cmd, arg)\n     }\n \n     pub fn fs(&self) -> Arc<dyn FileSystem> {\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -150,12 +150,27 @@ impl VmMapping {\n     }\n     pub fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         let vmo_read_offset = self.vmo_offset() + offset;\n+\n+        // TODO: the current logic is vulnerable to TOCTTOU attack, since the permission may change after check.\n+        let page_idx_range = get_page_idx_range(&(vmo_read_offset..vmo_read_offset + buf.len()));\n+        let read_perm = VmPerm::R;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &read_perm)?;\n+        }\n+\n         self.vmo.read_bytes(vmo_read_offset, buf)?;\n         Ok(())\n     }\n \n     pub fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         let vmo_write_offset = self.vmo_offset() + offset;\n+\n+        let page_idx_range = get_page_idx_range(&(vmo_write_offset..vmo_write_offset + buf.len()));\n+        let write_perm = VmPerm::W;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &write_perm)?;\n+        }\n+\n         self.vmo.write_bytes(vmo_write_offset, buf)?;\n         Ok(())\n     }\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -198,7 +213,9 @@ impl VmMapping {\n         } else {\n             self.vmo.check_rights(Rights::READ)?;\n         }\n-        self.check_perm(&page_idx, write)?;\n+\n+        let required_perm = if write { VmPerm::W } else { VmPerm::R };\n+        self.check_perm(&page_idx, &required_perm)?;\n \n         let frame = self.vmo.get_committed_frame(page_idx, write)?;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -300,8 +317,8 @@ impl VmMapping {\n         self.inner.lock().trim_right(vm_space, vaddr)\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n-        self.inner.lock().check_perm(page_idx, write)\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n+        self.inner.lock().check_perm(page_idx, perm)\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -457,16 +474,14 @@ impl VmMappingInner {\n         self.map_to_addr..self.map_to_addr + self.map_size\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n         let page_perm = self\n             .page_perms\n             .get(&page_idx)\n             .ok_or(Error::with_message(Errno::EINVAL, \"invalid page idx\"))?;\n-        if !page_perm.contains(VmPerm::R) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should at least contain read\");\n-        }\n-        if write && !page_perm.contains(VmPerm::W) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should contain write for write access\");\n+\n+        if !page_perm.contains(*perm) {\n+            return_errno_with_message!(Errno::EACCES, \"perm check fails\");\n         }\n \n         Ok(())\n",
        "test_patch": "diff --git /dev/null b/regression/apps/pty/Makefile\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/pty/Makefile\n@@ -0,0 +1,3 @@\n+include ../test_common.mk\n+\n+EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/scripts/run_tests.sh b/regression/apps/scripts/run_tests.sh\n--- a/regression/apps/scripts/run_tests.sh\n+++ b/regression/apps/scripts/run_tests.sh\n@@ -6,7 +6,7 @@ SCRIPT_DIR=/regression\n cd ${SCRIPT_DIR}/..\n \n echo \"Running tests......\"\n-tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello\"\n+tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello pty/open_pty\"\n for testcase in ${tests}\n do \n     echo \"Running test ${testcase}......\"\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -1,4 +1,4 @@\n-TESTS ?= open_test read_test statfs_test chmod_test\n+TESTS ?= open_test read_test statfs_test chmod_test pty_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\ndiff --git /dev/null b/regression/syscall_test/blocklists/pty_test\nnew file mode 100644\n--- /dev/null\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -0,0 +1,42 @@\n+PtyTrunc.Truncate\n+PtyTest.MasterTermiosUnchangable\n+PtyTest.TermiosICRNL\n+PtyTest.TermiosONLCR\n+PtyTest.TermiosINLCR\n+PtyTest.TermiosOCRNL\n+PtyTest.SwitchCanonToNonCanonNewline\n+PtyTest.TermiosICANONNewline\n+PtyTest.TermiosICANONEOF\n+PtyTest.CanonDiscard\n+PtyTest.CanonMultiline\n+PtyTest.SimpleEcho\n+PtyTest.TermiosIGNCR\n+PtyTest.TermiosONOCR\n+PtyTest.VEOLTermination\n+PtyTest.CanonBigWrite\n+PtyTest.SwitchCanonToNoncanon\n+PtyTest.SwitchNoncanonToCanonNewlineBig\n+PtyTest.SwitchNoncanonToCanonNoNewline\n+PtyTest.SwitchNoncanonToCanonNoNewlineBig\n+PtyTest.NoncanonBigWrite\n+PtyTest.SwitchNoncanonToCanonMultiline\n+PtyTest.SwitchTwiceMultiline\n+JobControlTest.SetTTYMaster\n+JobControlTest.SetTTY\n+JobControlTest.SetTTYNonLeader\n+JobControlTest.SetTTYBadArg\n+JobControlTest.SetTTYDifferentSession\n+JobControlTest.ReleaseTTY\n+JobControlTest.ReleaseUnsetTTY\n+JobControlTest.ReleaseWrongTTY\n+JobControlTest.ReleaseTTYNonLeader\n+JobControlTest.ReleaseTTYDifferentSession\n+JobControlTest.ReleaseTTYSignals\n+JobControlTest.GetForegroundProcessGroup\n+JobControlTest.GetForegroundProcessGroupNonControlling\n+JobControlTest.SetForegroundProcessGroup\n+JobControlTest.SetForegroundProcessGroupWrongTTY\n+JobControlTest.SetForegroundProcessGroupNegPgid\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n+JobControlTest.SetForegroundProcessGroupDifferentSession\n+JobControlTest.OrphanRegression\n\\ No newline at end of file\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -3,13 +3,13 @@ use crate::process::process_group::ProcessGroup;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n use crate::{\n     prelude::*,\n-    process::{process_table, signal::signals::kernel::KernelSignal, Pgid},\n+    process::{signal::signals::kernel::KernelSignal, Pgid},\n };\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n-use super::termio::{KernelTermios, CC_C_CHAR};\n+use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n // This implementation refers the implementation of linux\n // https://elixir.bootlin.com/linux/latest/source/include/linux/tty_ldisc.h\n",
        "problem_statement": "Implement pseudo terminals\nMaybe we need #209 for pty, since each pty will be a device under devfs.\n",
        "hints_text": "",
        "created_at": "2023-08-01T06:37:18Z",
        "version": "0.1"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 327,
        "instance_id": "asterinas__asterinas-327",
        "issue_numbers": [
            "340"
        ],
        "base_commit": "dbfb2e1a62a9981a67cc01ff7310981744ec2ac5",
        "patch": "diff --git /dev/null b/tools/docker/.gitignore\nnew file mode 100644\n--- /dev/null\n+++ b/tools/docker/.gitignore\n@@ -0,0 +1,1 @@\n+bom/\n",
        "test_patch": "diff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -2,9 +2,13 @@ TESTS ?= open_test read_test statfs_test chmod_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n-BUILD_DIR := $(CUR_DIR)/../build\n-SRC_DIR := $(BUILD_DIR)/gvisor_src\n-BIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+BUILD_DIR ?= $(CUR_DIR)/../build\n+ifdef JINUX_PREBUILT_SYSCALL_TEST\n+\tBIN_DIR := $(JINUX_PREBUILT_SYSCALL_TEST)\n+else\n+\tBIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+\tSRC_DIR := $(BUILD_DIR)/gvisor_src\n+endif\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n TARGET_DIR := $(INITRAMFS)/opt/syscall_test\n RUN_BASH := $(CUR_DIR)/run_syscall_test.sh\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -14,20 +18,25 @@ BLOCK_LIST := $(CUR_DIR)/blocklists\n \n all: $(TESTS)\n \n-$(SRC_DIR):\n+$(TESTS): $(BIN_DIR) $(TARGET_DIR)\n+\t@cp -f $</$@ $(TARGET_DIR)/tests\n+\n+ifndef JINUX_PREBUILT_SYSCALL_TEST\n+$(BIN_DIR): $(SRC_DIR)\n \t@if ! type bazel > /dev/null; then \\\n \t\techo \"bazel is not installed, please run $(CUR_DIR)/install_bazel.sh with sudo permission to install it.\"; \\\n-\t\texit 1 ; \\\n+\t\texit 1; \\\n \tfi\n-\t@rm -rf $@ && mkdir -p $@\n-\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n-\n-$(BIN_DIR): $(SRC_DIR)\n \t@rm -rf $@ && mkdir -p $@\n \t@cd $(SRC_DIR) && bazel build --test_tag_filters=native //test/syscalls/...\n \t@cp $(SRC_DIR)/bazel-bin/test/syscalls/linux/*_test $@\n \n-$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n+$(SRC_DIR):\n+\t@rm -rf $@ && mkdir -p $@\n+\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n+endif\n+\n+$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST)\n \t@rm -rf $@ && mkdir -p $@\n \t@# Prepare tests dir for test binaries\n \t@mkdir $@/tests\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -36,8 +45,5 @@ $(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n \t@# Copy bash script\n \t@cp -f $(RUN_BASH) $@\n \n-$(TESTS): $(TARGET_DIR)\n-\t@cp -f $(BIN_DIR)/$@ $(TARGET_DIR)/tests\n-\n clean:\n-\t@rm -rf $(BIN_DIR) $(TARGET_DIR)\n+\t@rm -rf $(TARGET_DIR)\n\\ No newline at end of file\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,27 +1,47 @@\n-FROM ubuntu:22.04\n+FROM ubuntu:22.04 as ubuntu-22.04-with-bazel\n \n SHELL [\"/bin/bash\", \"-c\"]\n \n ARG DEBIAN_FRONTEND=noninteractive\n+\n+# Install all Bazel dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     build-essential \\\n     ca-certificates \\\n+    curl \\\n+    git-core \\\n+    gnupg \\\n+    python-is-python3 \\\n+    python3-pip\n+\n+# Install bazel, which is required by the system call test suite from Gvisor project\n+COPY bom/syscall_test/install_bazel.sh /tmp/\n+WORKDIR /tmp\n+RUN ./install_bazel.sh && rm -f /tmp/install_bazel.sh\n+\n+FROM ubuntu-22.04-with-bazel as syscall_test\n+\n+# Build the syscall test binaries\n+COPY bom/syscall_test /root/syscall_test\n+WORKDIR /root/syscall_test\n+RUN export BUILD_DIR=build && \\\n+    make ${BUILD_DIR}/syscall_test_bins\n+\n+FROM ubuntu-22.04-with-bazel\n+\n+# Install all Jinux dependent packages\n+RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\n-    curl \\\n     file \\\n     g++ \\\n     gdb \\\n-    git-core \\\n-    gnupg \\\n     grub-common \\\n     grub-pc \\\n     libssl-dev \\\n     net-tools \\\n     openssh-server \\\n     pkg-config \\\n-    python-is-python3 \\\n-    python3-pip \\\n     qemu-system-x86 \\\n     strace \\\n     sudo \\\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -31,17 +51,14 @@ RUN apt update && apt-get install -y --no-install-recommends \\\n     xorriso \\\n     zip\n \n-# Install bazel, , which is required by the system call test suite from Gvisor project\n-RUN curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor > bazel.gpg \\ \n-    && mv bazel.gpg /etc/apt/trusted.gpg.d/ \\\n-    && echo 'deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8' | tee /etc/apt/sources.list.d/bazel.list \\\n-    && apt update \\ \n-    && apt install bazel=5.4.0 -y\n-\n # Clean apt cache\n RUN apt clean \\\n     && rm -rf /var/lib/apt/lists/*\n \n+# Prepare the system call test suite\n+COPY --from=syscall_test /root/syscall_test/build/syscall_test_bins /root/syscall_test_bins\n+ENV JINUX_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n+\n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n ARG JINUX_RUST_VERSION\ndiff --git a/tools/docker/build_image.sh b/tools/docker/build_image.sh\n--- a/tools/docker/build_image.sh\n+++ b/tools/docker/build_image.sh\n@@ -7,10 +7,19 @@ CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n VERSION=$( grep -m1 -o '[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+' ${CARGO_TOML_PATH} | sed 's/[^0-9\\.]//g'  )\n IMAGE_NAME=jinuxdev/jinux:${VERSION}\n DOCKER_FILE=${SCRIPT_DIR}/Dockerfile.ubuntu22.04\n+BOM_DIR=${SCRIPT_DIR}/bom\n+TOP_DIR=${SCRIPT_DIR}/../../\n ARCH=linux/amd64\n RUST_TOOLCHAIN_PATH=${SCRIPT_DIR}/../../rust-toolchain.toml\n JINUX_RUST_VERSION=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' ${RUST_TOOLCHAIN_PATH} )\n \n+# Prpare the BOM (bill of materials) directory to copy files or dirs into the docker image.\n+# This is because the `docker build` can not access the parent directory of the context.\n+if [ ! -d ${BOM_DIR} ]; then\n+    mkdir -p ${BOM_DIR}\n+    cp -rf ${TOP_DIR}/regression/syscall_test ${BOM_DIR}/\n+fi\n+\n # Build docker\n cd ${SCRIPT_DIR}\n docker buildx build -f ${DOCKER_FILE} \\\n",
        "problem_statement": "Precompile syscall tests in the dev docker image to accelerate CI\nCurrently the syscall tests are compiled every-time when CI triggers, which is at a cost of around 12 minutes on Github runners.\n",
        "hints_text": "",
        "created_at": "2023-07-27T07:11:21Z",
        "version": "0.1"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1447,
        "instance_id": "asterinas__asterinas-1447",
        "issue_numbers": [
            "1291"
        ],
        "base_commit": "2af9916de92f8ca1e694bb6ac5e33111bbcf51fd",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1,6 +1,6 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n-version = 3\n+version = 4\n \n [[package]]\n name = \"acpi\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -875,9 +875,9 @@ dependencies = [\n  \"log\",\n  \"uart_16550\",\n  \"uefi\",\n- \"uefi-services\",\n- \"x86_64\",\n- \"xmas-elf 0.8.0\",\n+ \"uefi-raw\",\n+ \"x86_64 0.15.1\",\n+ \"xmas-elf 0.9.1\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -953,7 +953,7 @@ dependencies = [\n  \"log\",\n  \"multiboot2-common\",\n  \"ptr_meta\",\n- \"uefi-raw 0.8.0\",\n+ \"uefi-raw\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1119,7 +1119,7 @@ dependencies = [\n  \"unwinding\",\n  \"volatile\",\n  \"x86\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xarray\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1238,6 +1238,12 @@ dependencies = [\n  \"syn 1.0.109\",\n ]\n \n+[[package]]\n+name = \"qemu-exit\"\n+version = \"3.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8bb0fd6580eeed0103c054e3fba2c2618ff476943762f28a645b63b8692b21c9\"\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.37\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1470,7 +1476,7 @@ dependencies = [\n  \"iced-x86\",\n  \"lazy_static\",\n  \"raw-cpuid\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1572,50 +1578,41 @@ dependencies = [\n \n [[package]]\n name = \"ucs2\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bad643914094137d475641b6bab89462505316ec2ce70907ad20102d28a79ab8\"\n+checksum = \"df79298e11f316400c57ec268f3c2c29ac3c4d4777687955cd3d4f3a35ce7eba\"\n dependencies = [\n  \"bit_field\",\n ]\n \n [[package]]\n name = \"uefi\"\n-version = \"0.26.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"07ead9f748a4646479b850add36b527113a80e80a7e0f44d7b0334291850dcc5\"\n+checksum = \"91f17ea8502a6bd414acb2bf5194f90ca4c48e33a2d18cb57eab3294d2050d99\"\n dependencies = [\n  \"bitflags 2.6.0\",\n+ \"cfg-if\",\n  \"log\",\n  \"ptr_meta\",\n+ \"qemu-exit\",\n  \"ucs2\",\n  \"uefi-macros\",\n- \"uefi-raw 0.5.0\",\n+ \"uefi-raw\",\n  \"uguid\",\n ]\n \n [[package]]\n name = \"uefi-macros\"\n-version = \"0.13.0\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"26a7b1c2c808c3db854a54d5215e3f7e7aaf5dcfbce095598cba6af29895695d\"\n+checksum = \"c19ee3a01d435eda42cb9931269b349d28a1762f91ddf01c68d276f74b957cc3\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 2.0.77\",\n ]\n \n-[[package]]\n-name = \"uefi-raw\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"864ac69eadd877bfb34e7814be1928122ed0057d9f975169a56ee496aa7bdfd7\"\n-dependencies = [\n- \"bitflags 2.6.0\",\n- \"ptr_meta\",\n- \"uguid\",\n-]\n-\n [[package]]\n name = \"uefi-raw\"\n version = \"0.8.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1627,17 +1624,6 @@ dependencies = [\n  \"uguid\",\n ]\n \n-[[package]]\n-name = \"uefi-services\"\n-version = \"0.23.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a79fcb420624743c895bad0f9480fbc2f64e7c8d8611fb1ada6bdd799942feb4\"\n-dependencies = [\n- \"cfg-if\",\n- \"log\",\n- \"uefi\",\n-]\n-\n [[package]]\n name = \"uguid\"\n version = \"2.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1751,6 +1737,18 @@ dependencies = [\n  \"volatile\",\n ]\n \n+[[package]]\n+name = \"x86_64\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4bc79523af8abf92fb1a970c3e086c5a343f6bcc1a0eb890f575cbb3b45743df\"\n+dependencies = [\n+ \"bit_field\",\n+ \"bitflags 2.6.0\",\n+ \"rustversion\",\n+ \"volatile\",\n+]\n+\n [[package]]\n name = \"xarray\"\n version = \"0.1.0\"\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -89,7 +89,7 @@ endif\n ifeq ($(BOOT_PROTOCOL), linux-efi-handover64)\n CARGO_OSDK_ARGS += --grub-mkrescue=/usr/bin/grub-mkrescue\n CARGO_OSDK_ARGS += --grub-boot-protocol=\"linux\"\n-CARGO_OSDK_ARGS += --encoding gzip\n+CARGO_OSDK_ARGS += --encoding raw # FIXME: GZIP self-decompression triggers CPU faults\n else ifeq ($(BOOT_PROTOCOL), linux-legacy32)\n CARGO_OSDK_ARGS += --linux-x86-legacy-boot\n CARGO_OSDK_ARGS += --grub-boot-protocol=\"linux\"\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -9,15 +9,8 @@ repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n-[dependencies.linux-bzimage-builder]\n-# The path for local development\n-path = \"../ostd/libs/linux-bzimage/builder\"\n-# The version specified here is used for publishing on crates.io.\n-# Please update this version when publishing the cargo-osdk crate\n-# if there have been any changes to the dependent crate.\n-version = \"0.2.0\"\n-\n [dependencies]\n+linux-bzimage-builder = { version = \"0.2.0\", path = \"../ostd/libs/linux-bzimage/builder\" }\n clap = { version = \"4.4.17\", features = [\"cargo\", \"derive\"] }\n chrono = \"0.4.38\"\n env_logger = \"0.11.0\"\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -167,7 +167,37 @@ fn install_setup_with_arch(\n     let target_dir = std::fs::canonicalize(target_dir).unwrap();\n \n     let mut cmd = Command::new(\"cargo\");\n-    cmd.env(\"RUSTFLAGS\", \"-Ccode-model=kernel -Crelocation-model=pie -Ctarget-feature=+crt-static -Zplt=yes -Zrelax-elf-relocations=yes -Crelro-level=full\");\n+    let mut rustflags = vec![\n+        \"-Cdebuginfo=2\",\n+        \"-Ccode-model=kernel\",\n+        \"-Crelocation-model=pie\",\n+        \"-Zplt=yes\",\n+        \"-Zrelax-elf-relocations=yes\",\n+        \"-Crelro-level=full\",\n+    ];\n+    let target_feature_args = match arch {\n+        SetupInstallArch::X86_64 => {\n+            concat!(\n+                \"-Ctarget-feature=\",\n+                \"+crt-static\",\n+                \",-adx\",\n+                \",-aes\",\n+                \",-avx\",\n+                \",-avx2\",\n+                \",-fxsr\",\n+                \",-sse\",\n+                \",-sse2\",\n+                \",-sse3\",\n+                \",-sse4.1\",\n+                \",-sse4.2\",\n+                \",-ssse3\",\n+                \",-xsave\",\n+            )\n+        }\n+        SetupInstallArch::Other(_) => \"-Ctarget-feature=+crt-static\",\n+    };\n+    rustflags.push(target_feature_args);\n+    cmd.env(\"RUSTFLAGS\", rustflags.join(\" \"));\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -175,10 +205,9 @@ fn install_setup_with_arch(\n         let crate_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n         let setup_dir = crate_dir.join(\"../ostd/libs/linux-bzimage/setup\");\n         cmd.arg(\"--path\").arg(setup_dir);\n+    } else {\n+        cmd.arg(\"--version\").arg(env!(\"CARGO_PKG_VERSION\"));\n     }\n-    // Remember to upgrade this version if new version of linux-bzimage-setup is released.\n-    const LINUX_BZIMAGE_SETUP_VERSION: &str = \"0.1.0\";\n-    cmd.arg(\"--version\").arg(LINUX_BZIMAGE_SETUP_VERSION);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -28,7 +28,7 @@ inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-ma\n int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\", version = \"0.1.0\" }\n intrusive-collections = { version = \"0.9.6\", features = [\"nightly\"] }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n-linux-boot-params = { path = \"libs/linux-bzimage/boot-params\", version = \"0.1.0\" }\n+linux-boot-params = { version = \"0.1.0\", path = \"libs/linux-bzimage/boot-params\" }\n log = \"0.4\"\n num = { version = \"0.4\", default-features = false }\n num-derive = { version = \"0.4\", default-features = false }\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -8,7 +8,7 @@\n //! The reference to the Linux PE header definition:\n //! <https://github.com/torvalds/linux/blob/master/include/linux/pe.h>\n \n-use std::{mem::size_of, ops::Range};\n+use std::{mem::size_of, vec};\n \n use bytemuck::{Pod, Zeroable};\n use serde::Serialize;\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -202,80 +202,6 @@ struct PeSectionHdr {\n     flags: u32,\n }\n \n-struct ImageSectionAddrInfo {\n-    pub text: Range<SetupVA>,\n-    pub data: Range<SetupVA>,\n-    pub bss: Range<SetupVA>,\n-    /// All the readonly but loaded sections.\n-    pub rodata: Range<SetupVA>,\n-}\n-\n-impl ImageSectionAddrInfo {\n-    fn from(elf: &xmas_elf::ElfFile) -> Self {\n-        let mut text_start = None;\n-        let mut text_end = None;\n-        let mut data_start = None;\n-        let mut data_end = None;\n-        let mut bss_start = None;\n-        let mut bss_end = None;\n-        let mut rodata_start = None;\n-        let mut rodata_end = None;\n-        for program in elf.program_iter() {\n-            if program.get_type().unwrap() == xmas_elf::program::Type::Load {\n-                let offset = SetupVA::from(program.virtual_addr() as usize);\n-                let length = program.mem_size() as usize;\n-                if program.flags().is_execute() {\n-                    text_start = Some(offset);\n-                    text_end = Some(offset + length);\n-                } else if program.flags().is_write() {\n-                    data_start = Some(offset);\n-                    data_end = Some(offset + program.file_size() as usize);\n-                    bss_start = Some(offset + program.file_size() as usize);\n-                    bss_end = Some(offset + length);\n-                } else if program.flags().is_read() {\n-                    rodata_start = Some(offset);\n-                    rodata_end = Some(offset + length);\n-                }\n-            }\n-        }\n-\n-        Self {\n-            text: text_start.unwrap()..text_end.unwrap(),\n-            data: data_start.unwrap()..data_end.unwrap(),\n-            bss: bss_start.unwrap()..bss_end.unwrap(),\n-            rodata: rodata_start.unwrap()..rodata_end.unwrap(),\n-        }\n-    }\n-\n-    fn text_virt_size(&self) -> usize {\n-        self.text.end - self.text.start\n-    }\n-\n-    fn text_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.text.end) - SetupFileOffset::from(self.text.start)\n-    }\n-\n-    fn data_virt_size(&self) -> usize {\n-        self.data.end - self.data.start\n-    }\n-\n-    fn data_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.data.end) - SetupFileOffset::from(self.data.start)\n-    }\n-\n-    fn bss_virt_size(&self) -> usize {\n-        self.bss.end - self.bss.start\n-    }\n-\n-    fn rodata_virt_size(&self) -> usize {\n-        self.rodata.end - self.rodata.start\n-    }\n-\n-    fn rodata_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.rodata.end) - SetupFileOffset::from(self.rodata.start)\n-    }\n-}\n-\n pub struct ImagePeCoffHeaderBuf {\n     pub header_at_zero: Vec<u8>,\n     pub relocs: (SetupFileOffset, Vec<u8>),\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -350,17 +276,53 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n         },\n     };\n \n-    let addr_info = ImageSectionAddrInfo::from(&elf);\n-\n     // PE section headers\n-    let sec_hdrs = [\n-        // .reloc\n-        PeSectionHdr {\n+    let mut sec_hdrs = get_pe_sec_headers_from(&elf);\n+\n+    sec_hdrs.push(PeSectionHdr::new_reloc(\n+        relocs.len() as u32,\n+        usize::from(SetupVA::from(reloc_offset)) as u32,\n+        relocs.len() as u32,\n+        usize::from(reloc_offset) as u32,\n+    ));\n+\n+    // Write the MS-DOS header\n+    bin.extend_from_slice(&MZ_MAGIC.to_le_bytes());\n+    // Write the MS-DOS stub at 0x3c\n+    bin.extend_from_slice(&[0x0; 0x3c - 0x2]);\n+    // Write the PE header offset, the header is right after the offset field\n+    bin.extend_from_slice(&(0x3cu32 + size_of::<u32>() as u32).to_le_bytes());\n+\n+    // Write the PE header\n+    pe_hdr.sections = sec_hdrs.len() as u16;\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_hdr));\n+    // Write the PE32+ optional header\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr));\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr_data_dirs));\n+    // Write the PE section headers\n+    for sec_hdr in sec_hdrs {\n+        bin.extend_from_slice(bytemuck::bytes_of(&sec_hdr));\n+    }\n+\n+    ImagePeCoffHeaderBuf {\n+        header_at_zero: bin,\n+        relocs: (reloc_offset, relocs),\n+    }\n+}\n+\n+impl PeSectionHdr {\n+    fn new_reloc(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'r', b'e', b'l', b'o', b'c', 0, 0],\n-            virtual_size: relocs.len() as u32,\n-            virtual_address: usize::from(SetupVA::from(reloc_offset)) as u32,\n-            raw_data_size: relocs.len() as u32,\n-            data_addr: usize::from(reloc_offset) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -370,14 +332,21 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_DISCARDABLE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_1Bytes as u32,\n-        },\n-        // .text\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_text(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b't', b'e', b'x', b't', 0, 0, 0],\n-            virtual_size: addr_info.text_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.text.start) as u32,\n-            raw_data_size: addr_info.text_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.text.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -387,14 +356,21 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_EXECUTE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .data\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_data(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'd', b'a', b't', b'a', 0, 0, 0],\n-            virtual_size: addr_info.data_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.data.start) as u32,\n-            raw_data_size: addr_info.data_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.data.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -404,59 +380,69 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_WRITE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .bss\n-        PeSectionHdr {\n-            name: [b'.', b'b', b's', b's', 0, 0, 0, 0],\n-            virtual_size: addr_info.bss_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.bss.start) as u32,\n-            raw_data_size: 0,\n-            data_addr: 0,\n-            relocs: 0,\n-            line_numbers: 0,\n-            num_relocs: 0,\n-            num_lin_numbers: 0,\n-            flags: (PeSectionHdrFlags::CNT_UNINITIALIZED_DATA\n-                | PeSectionHdrFlags::MEM_READ\n-                | PeSectionHdrFlags::MEM_WRITE)\n-                .bits\n-                | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .rodata\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_rodata(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'r', b'o', b'd', b'a', b't', b'a', 0],\n-            virtual_size: addr_info.rodata_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.rodata.start) as u32,\n-            raw_data_size: addr_info.rodata_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.rodata.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\n             num_lin_numbers: 0,\n             flags: (PeSectionHdrFlags::CNT_INITIALIZED_DATA | PeSectionHdrFlags::MEM_READ).bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-    ];\n-    // Write the MS-DOS header\n-    bin.extend_from_slice(&MZ_MAGIC.to_le_bytes());\n-    // Write the MS-DOS stub at 0x3c\n-    bin.extend_from_slice(&[0x0; 0x3c - 0x2]);\n-    // Write the PE header offset, the header is right after the offset field\n-    bin.extend_from_slice(&(0x3cu32 + size_of::<u32>() as u32).to_le_bytes());\n-\n-    // Write the PE header\n-    pe_hdr.sections = sec_hdrs.len() as u16;\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_hdr));\n-    // Write the PE32+ optional header\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr));\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr_data_dirs));\n-    // Write the PE section headers\n-    for sec_hdr in sec_hdrs {\n-        bin.extend_from_slice(bytemuck::bytes_of(&sec_hdr));\n+        }\n     }\n+}\n \n-    ImagePeCoffHeaderBuf {\n-        header_at_zero: bin,\n-        relocs: (reloc_offset, relocs),\n+fn get_pe_sec_headers_from(elf: &xmas_elf::ElfFile) -> Vec<PeSectionHdr> {\n+    let mut result = vec![];\n+\n+    for program in elf.program_iter() {\n+        if program.get_type().unwrap() == xmas_elf::program::Type::Load {\n+            let offset = SetupVA::from(program.virtual_addr() as usize);\n+            let length = program.mem_size() as usize;\n+\n+            if program.flags().is_execute() {\n+                result.push(PeSectionHdr::new_text(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            } else if program.flags().is_write() {\n+                // We don't care about `.bss` sections since the binary is\n+                // expanded to raw.\n+                if program.file_size() == 0 {\n+                    continue;\n+                }\n+\n+                result.push(PeSectionHdr::new_data(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            } else if program.flags().is_read() {\n+                result.push(PeSectionHdr::new_rodata(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            }\n+        }\n     }\n+\n+    result\n }\ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -16,16 +16,16 @@ path = \"src/main.rs\"\n cfg-if = \"1.0.0\"\n core2 = { version = \"0.4.0\", default-features = false, features = [\"nightly\"] }\n libflate = { version = \"2.1.0\", default-features = false }\n-linux-boot-params = { path = \"../boot-params\", version = \"0.1.0\" }\n+linux-boot-params = { version = \"0.1.0\", path = \"../boot-params\" }\n uart_16550 = \"0.3.0\"\n-xmas-elf = \"0.8.0\"\n+xmas-elf = \"0.9.1\"\n \n [target.x86_64-unknown-none.dependencies]\n bitflags = \"2.4.1\"\n log = \"0.4.20\"\n-uefi = \"0.26.0\"\n-uefi-services = \"0.23.0\"\n-x86_64 = \"0.14.11\"\n+uefi = { version = \"0.32.0\", features = [\"global_allocator\", \"panic_handler\", \"logger\", \"qemu\"]}\n+uefi-raw = \"0.8.0\"\n+x86_64 = \"0.15.1\"\n \n [features]\n default = []\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -2,19 +2,17 @@\n \n use linux_boot_params::BootParams;\n use uefi::{\n-    data_types::Handle,\n+    boot::{exit_boot_services, open_protocol_exclusive},\n+    mem::memory_map::{MemoryMap, MemoryMapOwned},\n+    prelude::*,\n     proto::loaded_image::LoadedImage,\n-    table::{\n-        boot::MemoryMap,\n-        cfg::{ACPI2_GUID, ACPI_GUID},\n-        Boot, Runtime, SystemTable,\n-    },\n };\n+use uefi_raw::table::system::SystemTable;\n \n use super::{\n     decoder::decode_payload,\n     paging::{Ia32eFlags, PageNumber, PageTableCreator},\n-    relocation::apply_rela_dyn_relocations,\n+    relocation::apply_rela_relocations,\n };\n \n // Suppress warnings since using todo!.\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -22,77 +20,92 @@ use super::{\n #[allow(unused_variables)]\n #[allow(clippy::diverging_sub_expression)]\n #[export_name = \"efi_stub_entry\"]\n-extern \"sysv64\" fn efi_stub_entry(handle: Handle, mut system_table: SystemTable<Boot>) -> ! {\n-    unsafe {\n-        system_table.boot_services().set_image_handle(handle);\n-    }\n-    uefi_services::init(&mut system_table).unwrap();\n+extern \"sysv64\" fn efi_stub_entry(handle: Handle, system_table: *const SystemTable) -> ! {\n+    // SAFETY: handle and system_table are valid pointers. It is only called once.\n+    unsafe { system_init(handle, system_table) };\n+\n+    uefi::helpers::init().unwrap();\n \n     let boot_params = todo!(\"Use EFI boot services to fill boot params\");\n \n-    efi_phase_boot(handle, system_table, boot_params);\n+    efi_phase_boot(boot_params);\n }\n \n #[export_name = \"efi_handover_entry\"]\n extern \"sysv64\" fn efi_handover_entry(\n     handle: Handle,\n-    mut system_table: SystemTable<Boot>,\n+    system_table: *const SystemTable,\n     boot_params_ptr: *mut BootParams,\n ) -> ! {\n-    unsafe {\n-        system_table.boot_services().set_image_handle(handle);\n-    }\n-    uefi_services::init(&mut system_table).unwrap();\n+    // SAFETY: handle and system_table are valid pointers. It is only called once.\n+    unsafe { system_init(handle, system_table) };\n+\n+    uefi::helpers::init().unwrap();\n \n     // SAFETY: boot_params is a valid pointer.\n     let boot_params = unsafe { &mut *boot_params_ptr };\n \n-    efi_phase_boot(handle, system_table, boot_params)\n+    efi_phase_boot(boot_params)\n }\n \n-fn efi_phase_boot(\n-    handle: Handle,\n-    system_table: SystemTable<Boot>,\n-    boot_params: &mut BootParams,\n-) -> ! {\n-    // SAFETY: this init function is only called once.\n-    unsafe { crate::console::init() };\n+/// Initialize the system.\n+///\n+/// # Safety\n+///\n+/// This function should be called only once with valid parameters before all\n+/// operations.\n+unsafe fn system_init(handle: Handle, system_table: *const SystemTable) {\n+    // SAFETY: This is the right time to initialize the console and it is only\n+    // called once here before all console operations.\n+    unsafe {\n+        crate::console::init();\n+    }\n \n-    // SAFETY: this is the right time to apply relocations.\n-    unsafe { apply_rela_dyn_relocations() };\n+    // SAFETY: This is the right time to apply relocations.\n+    unsafe { apply_rela_relocations() };\n \n-    uefi_services::println!(\"[EFI stub] Relocations applied.\");\n+    // SAFETY: The handle and system_table are valid pointers. They are passed\n+    // from the UEFI firmware. They are only called once.\n+    unsafe {\n+        boot::set_image_handle(handle);\n+        uefi::table::set_system_table(system_table);\n+    }\n+}\n+\n+fn efi_phase_boot(boot_params: &mut BootParams) -> ! {\n+    uefi::println!(\"[EFI stub] Relocations applied.\");\n+    uefi::println!(\n+        \"[EFI stub] Stub loaded at {:#x?}\",\n+        crate::x86::get_image_loaded_offset()\n+    );\n \n     // Fill the boot params with the RSDP address if it is not provided.\n     if boot_params.acpi_rsdp_addr == 0 {\n-        boot_params.acpi_rsdp_addr = get_rsdp_addr(&system_table);\n+        boot_params.acpi_rsdp_addr = get_rsdp_addr();\n     }\n \n     // Load the kernel payload to memory.\n     let payload = crate::get_payload(boot_params);\n     let kernel = decode_payload(payload);\n \n-    uefi_services::println!(\"[EFI stub] Loading payload.\");\n+    uefi::println!(\"[EFI stub] Loading payload.\");\n     crate::loader::load_elf(&kernel);\n \n-    uefi_services::println!(\"[EFI stub] Exiting EFI boot services.\");\n+    uefi::println!(\"[EFI stub] Exiting EFI boot services.\");\n     let memory_type = {\n-        let boot_services = system_table.boot_services();\n-        let Ok(loaded_image) = boot_services.open_protocol_exclusive::<LoadedImage>(handle) else {\n+        let Ok(loaded_image) = open_protocol_exclusive::<LoadedImage>(boot::image_handle()) else {\n             panic!(\"Failed to open LoadedImage protocol\");\n         };\n         loaded_image.data_type()\n     };\n-    let (system_table, memory_map) = system_table.exit_boot_services(memory_type);\n+    // SAFETY: All allocations in the boot services phase are not used after\n+    // this point.\n+    let memory_map = unsafe { exit_boot_services(memory_type) };\n \n-    efi_phase_runtime(system_table, memory_map, boot_params);\n+    efi_phase_runtime(memory_map, boot_params);\n }\n \n-fn efi_phase_runtime(\n-    _system_table: SystemTable<Runtime>,\n-    memory_map: MemoryMap<'static>,\n-    boot_params: &mut BootParams,\n-) -> ! {\n+fn efi_phase_runtime(memory_map: MemoryMapOwned, boot_params: &mut BootParams) -> ! {\n     unsafe {\n         crate::console::print_str(\"[EFI stub] Entered runtime services.\\n\");\n     }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -218,16 +231,18 @@ fn efi_phase_runtime(\n     }\n }\n \n-fn get_rsdp_addr(boot_table: &SystemTable<Boot>) -> u64 {\n-    let config_table = boot_table.config_table();\n-    for entry in config_table {\n-        // Prefer ACPI2 over ACPI.\n-        if entry.guid == ACPI2_GUID {\n-            return entry.address as usize as u64;\n-        }\n-        if entry.guid == ACPI_GUID {\n-            return entry.address as usize as u64;\n+fn get_rsdp_addr() -> u64 {\n+    use uefi::table::cfg::{ACPI2_GUID, ACPI_GUID};\n+    uefi::system::with_config_table(|table| {\n+        for entry in table {\n+            // Prefer ACPI2 over ACPI.\n+            if entry.guid == ACPI2_GUID {\n+                return entry.address as usize as u64;\n+            }\n+            if entry.guid == ACPI_GUID {\n+                return entry.address as usize as u64;\n+            }\n         }\n-    }\n-    panic!(\"ACPI RSDP not found\");\n+        panic!(\"ACPI RSDP not found\");\n+    })\n }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n@@ -40,15 +40,11 @@ SECTIONS\n     .eh_frame_hdr           : {\n         *(.eh_frame_hdr .eh_frame_hdr.*)\n     }\n-\n-    .rela.dyn               : {\n-        PROVIDE(__rela_dyn_start = .);\n-        *(.rela.dyn .rela.dyn.*)\n-        PROVIDE(__rela_dyn_end = .);\n-    }\n-\n-    .rela.plt               : {\n-        *(.rela.plt .rela.plt.*)\n+    \n+    .rela                   : {\n+        PROVIDE(__rela_start = .);\n+        *(.rela .rela.*)\n+        PROVIDE(__rela_end = .);\n     }\n \n     .comment                : { *(.comment) }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -18,6 +18,7 @@ const TABLE_ENTRY_COUNT: usize = 512;\n \n bitflags::bitflags! {\n     #[derive(Clone, Copy)]\n+    #[repr(C)]\n     pub struct Ia32eFlags: u64 {\n         const PRESENT =         1 << 0;\n         const WRITABLE =        1 << 1;\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -32,9 +33,11 @@ bitflags::bitflags! {\n     }\n }\n \n+#[repr(C)]\n pub struct Ia32eEntry(u64);\n \n /// The table in the IA32E paging specification that occupies a physical page frame.\n+#[repr(C)]\n pub struct Ia32eTable([Ia32eEntry; TABLE_ENTRY_COUNT]);\n \n /// A page number. It could be either a physical page number or a virtual page number.\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -2,62 +2,68 @@\n \n use crate::x86::get_image_loaded_offset;\n \n-struct Elf64Rela {\n-    r_offset: u64,\n-    r_info: u64,\n-    r_addend: i64,\n-}\n+/// Apply the relocations in the `.rela.*` sections.\n+///\n+/// The function will enable dyn Trait objects to work since they rely on\n+/// vtable pointers. Vtable won't work without relocations.\n+///\n+/// We currently support R_X86_64_RELATIVE relocations only. And this type of\n+/// relocation seems to be the only existing type if we compile Rust code to\n+/// PIE ELF binaries.\n+///\n+/// # Safety\n+///\n+/// This function will modify the memory pointed by the relocations. And the\n+/// Rust memory safety mechanisms are not aware of these kind of modification.\n+/// Failure to do relocations will cause `dyn Trait` objects to break.\n+pub unsafe fn apply_rela_relocations() {\n+    use core::arch::asm;\n+    let image_loaded_offset = get_image_loaded_offset();\n+\n+    let mut start: usize;\n+    let end: usize;\n \n-fn get_rela_array() -> &'static [Elf64Rela] {\n-    extern \"C\" {\n-        fn __rela_dyn_start();\n-        fn __rela_dyn_end();\n+    unsafe {\n+        asm!(\n+            \"lea {}, [rip + __rela_start]\",\n+            out(reg) start,\n+        );\n+        asm!(\n+            \"lea {}, [rip + __rela_end]\",\n+            out(reg) end,\n+        );\n     }\n-    let start = __rela_dyn_start as *const Elf64Rela;\n-    let end = __rela_dyn_end as *const Elf64Rela;\n-    let len = unsafe { end.offset_from(start) } as usize;\n+\n     #[cfg(feature = \"debug_print\")]\n     unsafe {\n         use crate::console::{print_hex, print_str};\n-        print_str(\"[EFI stub debug] .rela.dyn section size = \");\n-        print_hex(len as u64);\n-        print_str(\"; __rela_dyn_start = \");\n+        print_str(\"[EFI stub debug] loaded offset = \");\n+        print_hex(image_loaded_offset as u64);\n+        print_str(\"\\n\");\n+        print_str(\"[EFI stub debug] .rela section start = \");\n         print_hex(start as u64);\n-        print_str(\", __rela_dyn_end = \");\n+        print_str(\", end = \");\n         print_hex(end as u64);\n         print_str(\"\\n\");\n     }\n-    // SAFETY: the linker will ensure that the symbols are valid.\n-    unsafe { core::slice::from_raw_parts(start, len) }\n-}\n \n-const R_X86_64_RELATIVE: u32 = 8;\n+    #[cfg(feature = \"debug_print\")]\n+    let mut count = 0;\n \n-/// Apply the relocations in the `.rela.dyn` section.\n-///\n-/// The function will enable dyn Trait objects to work since they rely on vtable pointers. Vtable\n-/// won't work without relocations.\n-///\n-/// We currently support R_X86_64_RELATIVE relocations only. And this type of relocation seems to\n-/// be the only existing type if we compile Rust code to PIC ELF binaries.\n-///\n-/// # Safety\n-/// This function will modify the memory pointed by the relocations. And the Rust memory safety\n-/// mechanisms are not aware of these kind of modification. Failure to do relocations will cause\n-/// dyn Trait objects to break.\n-pub unsafe fn apply_rela_dyn_relocations() {\n-    let image_loaded_offset = get_image_loaded_offset();\n-    let relas = get_rela_array();\n-    for rela in relas {\n+    while start < end {\n+        let rela = (start as *const Elf64Rela).read_volatile();\n         let r_type = (rela.r_info & 0xffffffff) as u32;\n         let _r_sym = (rela.r_info >> 32) as usize;\n-        let r_addend = rela.r_addend;\n-        let r_offset = rela.r_offset as usize;\n-        let target = (image_loaded_offset + r_offset as isize) as usize;\n+        let r_addend = rela.r_addend as isize;\n+        let r_offset = rela.r_offset as isize;\n+        let target = image_loaded_offset.wrapping_add(r_offset) as usize;\n         #[cfg(feature = \"debug_print\")]\n         unsafe {\n             use crate::console::{print_hex, print_str};\n-            print_str(\"[EFI stub debug] Applying relocation at offset \");\n+            count += 1;\n+            print_str(\"[EFI stub debug] Applying relocation #\");\n+            print_hex(count as u64);\n+            print_str(\" at offset \");\n             print_hex(r_offset as u64);\n             print_str(\", type = \");\n             print_hex(r_type as u64);\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -67,12 +73,23 @@ pub unsafe fn apply_rela_dyn_relocations() {\n         }\n         match r_type {\n             R_X86_64_RELATIVE => {\n-                let value = (image_loaded_offset as i64 + r_addend) as usize;\n-                *(target as *mut usize) = value;\n+                let value = image_loaded_offset.wrapping_add(r_addend) as usize;\n+                (target as *mut usize).write(value);\n             }\n             _ => {\n                 panic!(\"Unknown relocation type: {}\", r_type);\n             }\n         }\n+        start = start.wrapping_add(core::mem::size_of::<Elf64Rela>());\n     }\n }\n+\n+const R_X86_64_RELATIVE: u32 = 8;\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Elf64Rela {\n+    r_offset: u64,\n+    r_info: u64,\n+    r_addend: i64,\n+}\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/mod.rs b/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n@@ -16,10 +16,23 @@ const START_OF_SETUP32_VA: usize = 0x100000;\n /// The setup is a position-independent executable. We can get the loaded base\n /// address from the symbol.\n #[inline]\n-#[allow(clippy::fn_to_numeric_cast)]\n pub fn get_image_loaded_offset() -> isize {\n-    extern \"C\" {\n-        fn start_of_setup32();\n+    let address_of_start: usize;\n+    #[cfg(target_arch = \"x86_64\")]\n+    unsafe {\n+        core::arch::asm!(\n+            \"lea {}, [rip + start_of_setup32]\",\n+            out(reg) address_of_start,\n+            options(pure, nomem, nostack)\n+        );\n     }\n-    start_of_setup32 as isize - START_OF_SETUP32_VA as isize\n+    #[cfg(target_arch = \"x86\")]\n+    unsafe {\n+        core::arch::asm!(\n+            \"lea {}, [start_of_setup32]\",\n+            out(reg) address_of_start,\n+            options(pure, nomem, nostack)\n+        );\n+    }\n+    address_of_start as isize - START_OF_SETUP32_VA as isize\n }\ndiff --git a/tools/github_workflows/publish_osdk_and_ostd.sh b/tools/github_workflows/publish_osdk_and_ostd.sh\n--- a/tools/github_workflows/publish_osdk_and_ostd.sh\n+++ b/tools/github_workflows/publish_osdk_and_ostd.sh\n@@ -60,6 +60,8 @@ do_publish_for() {\n }\n \n do_publish_for osdk\n+do_publish_for ostd/libs/linux-bzimage/build\n+do_publish_for ostd/libs/linux-bzimage/boot-params\n \n # All supported targets of OSTD, this array should keep consistent with\n # `package.metadata.docs.rs.targets` in `ostd/Cargo.toml`.\n",
        "test_patch": "diff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -106,6 +106,9 @@ DOCS_DIR=${ASTER_SRC_DIR}/docs\n OSTD_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/Cargo.toml\n OSTD_TEST_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/libs/ostd-test/Cargo.toml\n OSTD_MACROS_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/libs/ostd-macros/Cargo.toml\n+LINUX_BOOT_PARAMS_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n+LINUX_BZIMAGE_BUILDER_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/libs/linux-bzimage/builder/Cargo.toml\n+LINUX_BZIMAGE_SETUP_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/libs/linux-bzimage/setup/Cargo.toml\n OSDK_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/Cargo.toml\n OSDK_TEST_RUNNER_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/test-kernel/Cargo.toml\n VERSION_PATH=${ASTER_SRC_DIR}/VERSION\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -125,11 +128,17 @@ new_version=$(bump_version ${current_version})\n update_package_version ${OSTD_TEST_CARGO_TOML_PATH}\n update_package_version ${OSTD_MACROS_CARGO_TOML_PATH}\n update_package_version ${OSTD_CARGO_TOML_PATH}\n+update_package_version ${LINUX_BOOT_PARAMS_CARGO_TOML_PATH}\n+update_package_version ${LINUX_BZIMAGE_BUILDER_CARGO_TOML_PATH}\n+update_package_version ${LINUX_BZIMAGE_SETUP_CARGO_TOML_PATH}\n update_dep_version ${OSTD_CARGO_TOML_PATH} ostd-test\n+update_dep_version ${OSTD_CARGO_TOML_PATH} linux-boot-params\n update_dep_version ${OSTD_CARGO_TOML_PATH} ostd-macros\n+update_dep_version ${LINUX_BZIMAGE_SETUP_CARGO_TOML_PATH} linux-boot-params\n update_package_version ${OSDK_CARGO_TOML_PATH}\n update_package_version ${OSDK_TEST_RUNNER_CARGO_TOML_PATH}\n update_dep_version ${OSDK_TEST_RUNNER_CARGO_TOML_PATH} ostd\n+update_dep_version ${OSDK_CARGO_TOML_PATH} linux-bzimage-builder\n \n # Automatically bump Cargo.lock files\n cargo update -p aster-nix --precise $new_version # For Cargo.lock\ndiff --git a/tools/github_workflows/publish_osdk_and_ostd.sh b/tools/github_workflows/publish_osdk_and_ostd.sh\n--- a/tools/github_workflows/publish_osdk_and_ostd.sh\n+++ b/tools/github_workflows/publish_osdk_and_ostd.sh\n@@ -67,6 +69,7 @@ TARGETS=\"x86_64-unknown-none\"\n for TARGET in $TARGETS; do\n     do_publish_for ostd/libs/ostd-macros $TARGET\n     do_publish_for ostd/libs/ostd-test $TARGET\n+    do_publish_for ostd/libs/linux-bzimage/setup $TARGET\n     do_publish_for ostd $TARGET\n     do_publish_for osdk/test-kernel $TARGET\n \n",
        "problem_statement": "Invalid opcode after relocation for Linux EFI-handover boot\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nSometimes the Linux EFI-handover boot will fail due to invalid opcode failure during early booting.\r\n\r\n### To Reproduce\r\n\r\nWith KVM on,\r\n\r\n```bash\r\n make run AUTO_TEST=syscall BOOT_PROTOCOL=linux-efi-handover64\r\n```\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\n### Logs\r\n\r\n```\r\n...\r\n      Adding bitflags v1.3.2 (latest: v2.6.0)\r\n      Adding raw-cpuid v10.7.0 (latest: v11.1.0)\r\n      Adding syn v1.0.109 (latest: v2.0.77)\r\n      Adding uefi v0.26.0 (latest: v0.31.0)\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\n[EFI stub] Relocations applied.\r\n!!!! X64 Exception Type - 06(#UD - Invalid Opcode)  CPU Apic ID - 00000000 !!!!\r\nRIP  - 000000007CBC90F0, CS  - 0000000000000038, RFLAGS - 0000000000210217\r\nRAX  - 000000007FF12BB9, RCX - 000000007CBC19A8, RDX - 0000000000000001\r\nRBX  - 000000007CBC23B8, RSP - 000000007CBC2398, RBP - 0000000000000001\r\nRSI  - 000000007CBBBB77, RDI - 000000007CBC2408\r\nR8   - 00000000000000AF, R9  - 0000000000000014, R10 - 000000007E43F78D\r\nR11  - 0000000000000008, R12 - 000000007E43F78D, R13 - 0000000000000008\r\nR14  - 0000000000000002, R15 - 000000007E977518\r\nDS   - 0000000000000030, ES  - 0000000000000030, FS  - 0000000000000030\r\nGS   - 0000000000000030, SS  - 0000000000000030\r\nCR0  - 0000000080010033, CR2 - 0000000000000000, CR3 - 000000007FC01000\r\nCR4  - 0000000000000668, CR8 - 0000000000000000\r\nDR0  - 0000000000000000, DR1 - 0000000000000000, DR2 - 0000000000000000\r\nDR3  - 0000000000000000, DR6 - 00000000FFFF0FF0, DR7 - 0000000000000400\r\nGDTR - 000000007F9DE000 0000000000000047, LDTR - 0000000000000000\r\nIDTR - 000000007F470018 0000000000000FFF,   TR - 0000000000000000\r\nFXSAVE_STATE - 000000007CBC1FF0\r\n```\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\n",
        "hints_text": "",
        "created_at": "2024-10-14T14:03:58Z",
        "version": "0.9"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1372,
        "instance_id": "asterinas__asterinas-1372",
        "issue_numbers": [
            "1399",
            "919"
        ],
        "base_commit": "96efd620072a0cbdccc95b58901894111f17bb3a",
        "patch": "diff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -13,13 +13,13 @@\n //!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n-//! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n+//! | |         For the kernel code, 1 GiB. Mapped frames are tracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n //! +-+ <- 0xffff_ff00_0000_0000\n //! | |         For frame metadata, 1 TiB.\n-//! | |         Mapped frames are untracked.\n+//! | |         Mapped frames are tracked with handles.\n //! +-+ <- 0xffff_fe00_0000_0000\n //! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -104,6 +104,13 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// Returns whether the given address should be mapped as tracked.\n+///\n+/// About what is tracked mapping, see [`crate::mm::page::meta::MapTrackingStatus`].\n+pub(crate) fn should_map_as_tracked(addr: Vaddr) -> bool {\n+    !LINEAR_MAPPING_VADDR_RANGE.contains(&addr)\n+}\n+\n /// The kernel page table instance.\n ///\n /// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\ndiff --git a/ostd/src/mm/page/meta.rs b/ostd/src/mm/page/meta.rs\n--- a/ostd/src/mm/page/meta.rs\n+++ b/ostd/src/mm/page/meta.rs\n@@ -180,29 +180,50 @@ impl Sealed for FrameMeta {}\n /// Make sure the the generic parameters don't effect the memory layout.\n #[derive(Debug)]\n #[repr(C)]\n-pub struct PageTablePageMeta<\n+pub(in crate::mm) struct PageTablePageMeta<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n+    /// The number of valid PTEs. It is mutable if the lock is held.\n+    pub nr_children: UnsafeCell<u16>,\n+    /// The level of the page table page. A page table page cannot be\n+    /// referenced by page tables of different levels.\n     pub level: PagingLevel,\n+    /// Whether the pages mapped by the node is tracked.\n+    pub is_tracked: MapTrackingStatus,\n     /// The lock for the page table page.\n     pub lock: AtomicU8,\n-    /// The number of valid PTEs. It is mutable if the lock is held.\n-    pub nr_children: UnsafeCell<u16>,\n     _phantom: core::marker::PhantomData<(E, C)>,\n }\n \n+/// Describe if the physical address recorded in this page table refers to a\n+/// page tracked by metadata.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+#[repr(u8)]\n+pub(in crate::mm) enum MapTrackingStatus {\n+    /// The page table node cannot contain references to any pages. It can only\n+    /// contain references to child page table nodes.\n+    NotApplicable,\n+    /// The mapped pages are not tracked by metadata. If any child page table\n+    /// nodes exist, they should also be tracked.\n+    Untracked,\n+    /// The mapped pages are tracked by metadata. If any child page table nodes\n+    /// exist, they should also be tracked.\n+    Tracked,\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTablePageMeta<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub fn new_locked(level: PagingLevel) -> Self {\n+    pub fn new_locked(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n         Self {\n+            nr_children: UnsafeCell::new(0),\n             level,\n+            is_tracked,\n             lock: AtomicU8::new(1),\n-            nr_children: UnsafeCell::new(0),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -119,25 +119,6 @@ impl<M: PageMeta> Page<M> {\n         }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The physical address must represent a valid page.\n-    ///\n-    /// And the caller must ensure the metadata slot pointed through the corresponding\n-    /// virtual address is initialized by holding a reference count of the page firstly.\n-    /// Otherwise the function may add a reference count to an unused page.\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        // SAFETY: The virtual address points to an initialized metadata slot.\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address.\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -248,20 +229,6 @@ impl DynPage {\n         Self { ptr }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This is the same as [`Page::inc_ref_count`].\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address of the start of the page\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -363,3 +330,22 @@ impl Drop for DynPage {\n         }\n     }\n }\n+\n+/// Increases the reference count of the page by one.\n+///\n+/// # Safety\n+///\n+/// The caller should ensure the following conditions:\n+///  1. The physical address must represent a valid page;\n+///  2. The caller must have already held a reference to the page.\n+pub(in crate::mm) unsafe fn inc_page_ref_count(paddr: Paddr) {\n+    debug_assert!(paddr % PAGE_SIZE == 0);\n+    debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n+\n+    let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n+    // SAFETY: The virtual address points to an initialized metadata slot.\n+    let slot = unsafe { &*(vaddr as *const MetaSlot) };\n+    let old = slot.ref_count.fetch_add(1, Ordering::Relaxed);\n+\n+    debug_assert!(old > 0);\n+}\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -65,17 +65,21 @@\n //! table cursor should add additional entry point checks to prevent these defined\n //! behaviors if they are not wanted.\n \n-use core::{any::TypeId, marker::PhantomData, mem::ManuallyDrop, ops::Range};\n+use core::{any::TypeId, marker::PhantomData, ops::Range};\n \n use align_ext::AlignExt;\n \n use super::{\n-    page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n+    page_size, pte_index, Child, Entry, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n use crate::{\n     mm::{\n-        page::{meta::PageTablePageMeta, DynPage, Page},\n+        kspace::should_map_as_tracked,\n+        page::{\n+            meta::{MapTrackingStatus, PageTablePageMeta},\n+            DynPage, Page,\n+        },\n         Paddr, PageProperty, Vaddr,\n     },\n     task::{disable_preempt, DisabledPreemptGuard},\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -134,6 +138,7 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n+    #[allow(dead_code)]\n     preempt_guard: DisabledPreemptGuard,\n     _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -190,12 +195,15 @@ where\n                 break;\n             }\n \n-            let cur_pte = cursor.read_cur_pte();\n-            if !cur_pte.is_present() || cur_pte.is_last(cursor.level) {\n+            let entry = cursor.cur_entry();\n+            if !entry.is_node() {\n                 break;\n             }\n+            let Child::PageTable(child_pt) = entry.to_owned() else {\n+                unreachable!(\"Already checked\");\n+            };\n \n-            cursor.level_down();\n+            cursor.push_level(child_pt.lock());\n \n             // Release the guard of the previous (upper) level.\n             cursor.guards[cursor.level as usize] = None;\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -215,9 +223,9 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            match self.cur_child() {\n-                Child::PageTable(_) => {\n-                    self.level_down();\n+            match self.cur_entry().to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.push_level(pt.lock());\n                     continue;\n                 }\n                 Child::None => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -229,7 +237,8 @@ where\n                 Child::Page(page, prop) => {\n                     return Ok(PageTableItem::Mapped { va, page, prop });\n                 }\n-                Child::Untracked(pa, prop) => {\n+                Child::Untracked(pa, plevel, prop) => {\n+                    debug_assert_eq!(plevel, level);\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -249,7 +258,7 @@ where\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\n-            self.level_up();\n+            self.pop_level();\n         }\n         self.va = next_va;\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -283,7 +292,7 @@ where\n             }\n \n             debug_assert!(self.level < self.guard_level);\n-            self.level_up();\n+            self.pop_level();\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -291,70 +300,37 @@ where\n         self.va\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.preempt_guard\n-    }\n-\n-    /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n-    /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n-    /// cursor is dropped.\n+    /// Goes up a level.\n+    ///\n+    /// We release the current page if it has no mappings since the cursor\n+    /// only moves forward. And if needed we will do the final cleanup using\n+    /// this method after re-walk when the cursor is dropped.\n     ///\n-    /// This method requires locks acquired before calling it. The discarded level will be unlocked.\n-    fn level_up(&mut self) {\n+    /// This method requires locks acquired before calling it. The discarded\n+    /// level will be unlocked.\n+    fn pop_level(&mut self) {\n         self.guards[(self.level - 1) as usize] = None;\n         self.level += 1;\n \n         // TODO: Drop page tables if page tables become empty.\n     }\n \n-    /// Goes down a level assuming a child page table exists.\n-    fn level_down(&mut self) {\n-        debug_assert!(self.level > 1);\n-\n-        let Child::PageTable(nxt_lvl_ptn) = self.cur_child() else {\n-            panic!(\"Trying to level down when it is not mapped to a page table\");\n-        };\n-\n-        let nxt_lvl_ptn_locked = nxt_lvl_ptn.lock();\n-\n+    /// Goes down a level to a child page table.\n+    fn push_level(&mut self, child_pt: PageTableNode<E, C>) {\n         self.level -= 1;\n-        debug_assert_eq!(self.level, nxt_lvl_ptn_locked.level());\n-\n-        self.guards[(self.level - 1) as usize] = Some(nxt_lvl_ptn_locked);\n+        debug_assert_eq!(self.level, child_pt.level());\n+        self.guards[(self.level - 1) as usize] = Some(child_pt);\n     }\n \n-    fn cur_node(&self) -> &PageTableNode<E, C> {\n-        self.guards[(self.level - 1) as usize].as_ref().unwrap()\n+    fn should_map_as_tracked(&self) -> bool {\n+        (TypeId::of::<M>() == TypeId::of::<KernelMode>()\n+            || TypeId::of::<M>() == TypeId::of::<UserMode>())\n+            && should_map_as_tracked(self.va)\n     }\n \n-    fn cur_idx(&self) -> usize {\n-        pte_index::<C>(self.va, self.level)\n-    }\n-\n-    fn cur_child(&self) -> Child<E, C> {\n-        self.cur_node()\n-            .child(self.cur_idx(), self.in_tracked_range())\n-    }\n-\n-    fn read_cur_pte(&self) -> E {\n-        self.cur_node().read_pte(self.cur_idx())\n-    }\n-\n-    /// Tells if the current virtual range must contain untracked mappings.\n-    ///\n-    /// _Tracked mappings_ means that the mapped physical addresses (in PTEs) points to pages\n-    /// tracked by the metadata system. _Tracked mappings_ must be created with page handles.\n-    /// While _untracked mappings_ solely maps to plain physical addresses.\n-    ///\n-    /// In the kernel mode, this is aligned with the definition in [`crate::mm::kspace`].\n-    /// Only linear mappings in the kernel should be considered as untracked mappings.\n-    ///\n-    /// All mappings in the user mode are tracked. And all mappings in the IOMMU\n-    /// page table are untracked.\n-    fn in_tracked_range(&self) -> bool {\n-        TypeId::of::<M>() == TypeId::of::<UserMode>()\n-            || TypeId::of::<M>() == TypeId::of::<KernelMode>()\n-                && !crate::mm::kspace::LINEAR_MAPPING_VADDR_RANGE.contains(&self.va)\n+    fn cur_entry(&mut self) -> Entry<'_, E, C> {\n+        let node = self.guards[(self.level - 1) as usize].as_mut().unwrap();\n+        node.entry(pte_index::<C>(self.va, self.level))\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -445,30 +421,38 @@ where\n     pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n-        debug_assert!(self.0.in_tracked_range());\n \n         // Go down if not applicable.\n         while self.0.level > C::HIGHEST_TRANSLATION_LEVEL\n             || self.0.va % page_size::<C>(self.0.level) != 0\n             || self.0.va + page_size::<C>(self.0.level) > end\n         {\n-            let pte = self.0.read_cur_pte();\n-            if pte.is_present() && !pte.is_last(self.0.level) {\n-                self.0.level_down();\n-            } else if !pte.is_present() {\n-                self.level_down_create();\n-            } else {\n-                panic!(\"Mapping a smaller page in an already mapped huge page\");\n+            debug_assert!(self.0.should_map_as_tracked());\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n+            match cur_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.0.push_level(pt.lock());\n+                }\n+                Child::None => {\n+                    let pt =\n+                        PageTableNode::<E, C>::alloc(cur_level - 1, MapTrackingStatus::Tracked);\n+                    let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                    self.0.push_level(pt);\n+                }\n+                Child::Page(_, _) => {\n+                    panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Mapping a tracked page in an untracked range\");\n+                }\n             }\n             continue;\n         }\n         debug_assert_eq!(self.0.level, page.level());\n \n         // Map the current page.\n-        let idx = self.0.cur_idx();\n-        let old = self\n-            .cur_node_mut()\n-            .replace_child(idx, Child::Page(page, prop), true);\n+        let old = self.0.cur_entry().replace(Child::Page(page, prop));\n         self.0.move_forward();\n \n         match old {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -477,7 +461,7 @@ where\n             Child::PageTable(_) => {\n                 todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n             }\n-            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+            Child::Untracked(_, _, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -525,25 +509,40 @@ where\n                 || self.0.va + page_size::<C>(self.0.level) > end\n                 || pa % page_size::<C>(self.0.level) != 0\n             {\n-                let pte = self.0.read_cur_pte();\n-                if pte.is_present() && !pte.is_last(self.0.level) {\n-                    self.0.level_down();\n-                } else if !pte.is_present() {\n-                    self.level_down_create();\n-                } else {\n-                    self.level_down_split();\n+                let cur_level = self.0.level;\n+                let cur_entry = self.0.cur_entry();\n+                match cur_entry.to_owned() {\n+                    Child::PageTable(pt) => {\n+                        self.0.push_level(pt.lock());\n+                    }\n+                    Child::None => {\n+                        let pt = PageTableNode::<E, C>::alloc(\n+                            cur_level - 1,\n+                            MapTrackingStatus::Untracked,\n+                        );\n+                        let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                        self.0.push_level(pt);\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Map the current page.\n-            debug_assert!(!self.0.in_tracked_range());\n-            let idx = self.0.cur_idx();\n+            debug_assert!(!self.0.should_map_as_tracked());\n+            let level = self.0.level;\n             let _ = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::Untracked(pa, prop), false);\n+                .0\n+                .cur_entry()\n+                .replace(Child::Untracked(pa, level, prop));\n \n-            let level = self.0.level;\n+            // Move forward.\n             pa += page_size::<C>(level);\n             self.0.move_forward();\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -580,11 +579,12 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            let is_tracked = self.0.in_tracked_range();\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n \n             // Skip if it is already absent.\n-            if !cur_pte.is_present() {\n+            if cur_entry.is_none() {\n                 if self.0.va + page_size::<C>(self.0.level) > end {\n                     self.0.va = end;\n                     break;\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -593,64 +593,61 @@ where\n                 continue;\n             }\n \n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if !is_tracked {\n-                    // Level down if we are removing part of a huge untracked page.\n-                    self.level_down_split();\n-                    continue;\n-                }\n-\n-                if cur_pte.is_last(self.0.level) {\n-                    panic!(\"removing part of a huge page\");\n-                }\n-\n-                // Level down if the current PTE points to a page table and we cannot\n-                // unmap this page table node entirely.\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n-                    self.0.move_forward();\n+            // Go down if not applicable.\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let child = cur_entry.to_owned();\n+                match child {\n+                    Child::PageTable(pt) => {\n+                        let pt = pt.lock();\n+                        // If there's no mapped PTEs in the next level, we can\n+                        // skip to save time.\n+                        if pt.nr_children() != 0 {\n+                            self.0.push_level(pt);\n+                        } else {\n+                            if self.0.va + page_size::<C>(self.0.level) > end {\n+                                self.0.va = end;\n+                                break;\n+                            }\n+                            self.0.move_forward();\n+                        }\n+                    }\n+                    Child::None => {\n+                        unreachable!(\"Already checked\");\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Removing part of a huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Unmap the current page and return it.\n-            let idx = self.0.cur_idx();\n-            let ret = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::None, is_tracked);\n-            let ret_page_va = self.0.va;\n-            let ret_page_size = page_size::<C>(self.0.level);\n+            let old = cur_entry.replace(Child::None);\n \n             self.0.move_forward();\n \n-            return match ret {\n+            return match old {\n                 Child::Page(page, prop) => PageTableItem::Mapped {\n-                    va: ret_page_va,\n+                    va: self.0.va,\n                     page,\n                     prop,\n                 },\n-                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n-                    va: ret_page_va,\n-                    pa,\n-                    len: ret_page_size,\n-                    prop,\n-                },\n-                Child::PageTable(node) => {\n-                    let node = ManuallyDrop::new(node);\n-                    let page = Page::<PageTablePageMeta<E, C>>::from_raw(node.paddr());\n-                    PageTableItem::PageTableNode { page: page.into() }\n+                Child::Untracked(pa, level, prop) => {\n+                    debug_assert_eq!(level, self.0.level);\n+                    PageTableItem::MappedUntracked {\n+                        va: self.0.va,\n+                        pa,\n+                        len: page_size::<C>(level),\n+                        prop,\n+                    }\n                 }\n+                Child::PageTable(node) => PageTableItem::PageTableNode {\n+                    page: Page::<PageTablePageMeta<E, C>>::from(node).into(),\n+                },\n                 Child::None => unreachable!(),\n             };\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -692,51 +689,46 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let mut cur_entry = self.0.cur_entry();\n+\n+            // Skip if it is already absent.\n+            if cur_entry.is_none() {\n                 self.0.move_forward();\n                 continue;\n             }\n \n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(self.0.level) {\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n+            // Go down if it's not a last entry.\n+            if cur_entry.is_node() {\n+                let Child::PageTable(pt) = cur_entry.to_owned() else {\n+                    unreachable!(\"Already checked\");\n+                };\n+                let pt = pt.lock();\n+                // If there's no mapped PTEs in the next level, we can\n+                // skip to save time.\n+                if pt.nr_children() != 0 {\n+                    self.0.push_level(pt);\n+                } else {\n                     self.0.move_forward();\n                 }\n-\n                 continue;\n             }\n \n             // Go down if the page size is too big and we are protecting part\n             // of untracked huge pages.\n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if self.0.in_tracked_range() {\n-                    panic!(\"protecting part of a huge page\");\n-                } else {\n-                    self.level_down_split();\n-                    continue;\n-                }\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let split_child = cur_entry\n+                    .split_if_untracked_huge()\n+                    .expect(\"Protecting part of a huge page\");\n+                self.0.push_level(split_child);\n+                continue;\n             }\n \n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+            // Protect the current page.\n+            cur_entry.protect(op);\n \n-            let idx = self.0.cur_idx();\n-            self.cur_node_mut().protect(idx, pte_prop);\n             let protected_va = self.0.va..self.0.va + page_size::<C>(self.0.level);\n-\n             self.0.move_forward();\n \n             return Some(protected_va);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -785,91 +777,46 @@ where\n         assert!(src_end <= src.0.barrier_va.end);\n \n         while self.0.va < this_end && src.0.va < src_end {\n-            let cur_pte = src.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n-                src.0.move_forward();\n-                continue;\n-            }\n-\n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(src.0.level) {\n-                src.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if src.0.guards[(src.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    src.0.level_up();\n+            let src_va = src.0.va;\n+            let mut src_entry = src.0.cur_entry();\n+\n+            match src_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    let pt = pt.lock();\n+                    // If there's no mapped PTEs in the next level, we can\n+                    // skip to save time.\n+                    if pt.nr_children() != 0 {\n+                        src.0.push_level(pt);\n+                    } else {\n+                        src.0.move_forward();\n+                    }\n+                    continue;\n+                }\n+                Child::None => {\n                     src.0.move_forward();\n+                    continue;\n                 }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Copying untracked mappings\");\n+                }\n+                Child::Page(page, mut prop) => {\n+                    let mapped_page_size = page.size();\n \n-                continue;\n-            }\n-\n-            // Do protection.\n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+                    // Do protection.\n+                    src_entry.protect(op);\n \n-            let idx = src.0.cur_idx();\n-            src.cur_node_mut().protect(idx, pte_prop);\n+                    // Do copy.\n+                    op(&mut prop);\n+                    self.jump(src_va).unwrap();\n+                    let original = self.map(page, prop);\n+                    assert!(original.is_none());\n \n-            // Do copy.\n-            let child = src.cur_node_mut().child(idx, true);\n-            let Child::<E, C>::Page(page, prop) = child else {\n-                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n-            };\n-            self.jump(src.0.va).unwrap();\n-            let mapped_page_size = page.size();\n-            let original = self.map(page, prop);\n-            debug_assert!(original.is_none());\n-\n-            // Only move the source cursor forward since `Self::map` will do it.\n-            // This assertion is to ensure that they move by the same length.\n-            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n-            src.0.move_forward();\n+                    // Only move the source cursor forward since `Self::map` will do it.\n+                    // This assertion is to ensure that they move by the same length.\n+                    debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+                    src.0.move_forward();\n+                }\n+            }\n         }\n     }\n-\n-    /// Goes down a level assuming the current slot is absent.\n-    ///\n-    /// This method will create a new child page table node and go down to it.\n-    fn level_down_create(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n-        let idx = self.0.cur_idx();\n-        let is_tracked = self.0.in_tracked_range();\n-        let old = self.cur_node_mut().replace_child(\n-            idx,\n-            Child::PageTable(new_node.clone_raw()),\n-            is_tracked,\n-        );\n-        debug_assert!(old.is_none());\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n-    }\n-\n-    /// Goes down a level assuming the current slot is an untracked huge page.\n-    ///\n-    /// This method will split the huge page and go down to the next level.\n-    fn level_down_split(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        debug_assert!(!self.0.in_tracked_range());\n-\n-        let idx = self.0.cur_idx();\n-        self.cur_node_mut().split_untracked_huge(idx);\n-\n-        let Child::PageTable(new_node) = self.0.cur_child() else {\n-            unreachable!();\n-        };\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node.lock());\n-    }\n-\n-    fn cur_node_mut(&mut self) -> &mut PageTableNode<E, C> {\n-        self.0.guards[(self.0.level - 1) as usize].as_mut().unwrap()\n-    }\n }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,8 +3,8 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, page_prop::PageProperty, page_size, Paddr, PagingConstsTrait, PagingLevel,\n-    Vaddr,\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size, Paddr,\n+    PagingConstsTrait, PagingLevel, Vaddr,\n };\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -100,16 +100,17 @@ impl PageTable<KernelMode> {\n     /// This should be the only way to create the user page table, that is to\n     /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n-        let root_node = self.root.clone_shallow().lock();\n-        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n+        let mut root_node = self.root.clone_shallow().lock();\n+        let mut new_node =\n+            PageTableNode::alloc(PagingConsts::NR_LEVELS, MapTrackingStatus::NotApplicable);\n \n         // Make a shallow copy of the root node in the kernel space range.\n         // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n         for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n-            let child = root_node.child(i, /* meaningless */ true);\n-            if !child.is_none() {\n-                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            let root_entry = root_node.entry(i);\n+            if !root_entry.is_none() {\n+                let _ = new_node.entry(i).replace(root_entry.to_owned());\n             }\n         }\n \ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -136,13 +137,18 @@ impl PageTable<KernelMode> {\n \n         let mut root_node = self.root.clone_shallow().lock();\n         for i in start..end {\n-            if !root_node.read_pte(i).is_present() {\n-                let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                let _ = root_node.replace_child(\n-                    i,\n-                    Child::PageTable(node.into_raw()),\n-                    i < NR_PTES_PER_NODE * 3 / 4,\n-                );\n+            let root_entry = root_node.entry(i);\n+            if root_entry.is_none() {\n+                let nxt_level = PagingConsts::NR_LEVELS - 1;\n+                let is_tracked = if super::kspace::should_map_as_tracked(\n+                    i * page_size::<PagingConsts>(nxt_level),\n+                ) {\n+                    MapTrackingStatus::Tracked\n+                } else {\n+                    MapTrackingStatus::Untracked\n+                };\n+                let node = PageTableNode::alloc(nxt_level, is_tracked);\n+                let _ = root_entry.replace(Child::PageTable(node.into_raw()));\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -175,7 +181,8 @@ where\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n     pub fn empty() -> Self {\n         PageTable {\n-            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n+            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS, MapTrackingStatus::NotApplicable)\n+                .into_raw(),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git /dev/null b/ostd/src/mm/page_table/node/child.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -0,0 +1,172 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module specifies the type of the children of a page table node.\n+\n+use core::{mem::ManuallyDrop, panic};\n+\n+use super::{PageTableEntryTrait, RawPageTableNode};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    mm::{\n+        page::{inc_page_ref_count, meta::MapTrackingStatus, DynPage},\n+        page_prop::PageProperty,\n+        Paddr, PagingConstsTrait, PagingLevel,\n+    },\n+};\n+\n+/// A child of a page table node.\n+///\n+/// This is a owning handle to a child of a page table node. If the child is\n+/// either a page table node or a page, it holds a reference count to the\n+/// corresponding page.\n+#[derive(Debug)]\n+pub(in crate::mm) enum Child<\n+    E: PageTableEntryTrait = PageTableEntry,\n+    C: PagingConstsTrait = PagingConsts,\n+> where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    PageTable(RawPageTableNode<E, C>),\n+    Page(DynPage, PageProperty),\n+    /// Pages not tracked by handles.\n+    Untracked(Paddr, PagingLevel, PageProperty),\n+    None,\n+}\n+\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns whether the child does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+\n+    /// Returns whether the child is compatible with the given node.\n+    ///\n+    /// In other words, it checks whether the child can be a child of a node\n+    /// with the given level and tracking status.\n+    pub(super) fn is_compatible(\n+        &self,\n+        node_level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> bool {\n+        match self {\n+            Child::PageTable(pt) => node_level == pt.level() + 1,\n+            Child::Page(p, _) => {\n+                node_level == p.level() && is_tracked == MapTrackingStatus::Tracked\n+            }\n+            Child::Untracked(_, level, _) => {\n+                node_level == *level && is_tracked == MapTrackingStatus::Untracked\n+            }\n+            Child::None => true,\n+        }\n+    }\n+\n+    /// Converts a child into a owning PTE.\n+    ///\n+    /// By conversion it loses information about whether the page is tracked\n+    /// or not. Also it loses the level information. However, the returned PTE\n+    /// takes the ownership (reference count) of the child.\n+    ///\n+    /// Usually this is for recording the PTE into a page table node. When the\n+    /// child is needed again by reading the PTE of a page table node, extra\n+    /// information should be provided using the [`Child::from_pte`] method.\n+    pub(super) fn into_pte(self) -> E {\n+        match self {\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                E::new_pt(pt.paddr())\n+            }\n+            Child::Page(page, prop) => {\n+                let level = page.level();\n+                E::new_page(page.into_raw(), level, prop)\n+            }\n+            Child::Untracked(pa, level, prop) => E::new_page(pa, level, prop),\n+            Child::None => E::new_absent(),\n+        }\n+    }\n+\n+    /// Converts a PTE back to a child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`]. And the\n+    /// provided information (level and tracking status) must be the same with\n+    /// the lost information during the conversion. Strictly speaking, the\n+    /// provided arguments must be compatible with the original child (\n+    /// specified by [`Child::is_compatible`]).\n+    ///\n+    /// This method should be only used no more than once for a PTE that has\n+    /// been converted from a child using the [`Child::into_pte`] method.\n+    pub(super) unsafe fn from_pte(\n+        pte: E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+\n+    /// Gains an extra owning reference to the child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`], which is\n+    /// the same requirement as the [`Child::from_pte`] method.\n+    ///\n+    /// This method must not be used with a PTE that has been restored to a\n+    /// child using the [`Child::from_pte`] method.\n+    pub(super) unsafe fn clone_from_pte(\n+        pte: &E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address is valid and the PTE already owns\n+            // the reference to the page.\n+            unsafe { inc_page_ref_count(paddr) };\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address is valid and the PTE already owns\n+                // the reference to the page.\n+                unsafe { inc_page_ref_count(paddr) };\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/mm/page_table/node/entry.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/entry.rs\n@@ -0,0 +1,161 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module provides accessors to the page table entries in a node.\n+\n+use super::{Child, PageTableEntryTrait, PageTableNode};\n+use crate::mm::{\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size,\n+    PagingConstsTrait,\n+};\n+\n+/// A view of an entry in a page table node.\n+///\n+/// It can be borrowed from a node using the [`PageTableNode::entry`] method.\n+///\n+/// This is a static reference to an entry in a node that does not account for\n+/// a dynamic reference count to the child. It can be used to create a owned\n+/// handle, which is a [`Child`].\n+pub(in crate::mm) struct Entry<'a, E: PageTableEntryTrait, C: PagingConstsTrait>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// The page table entry.\n+    ///\n+    /// We store the page table entry here to optimize the number of reads from\n+    /// the node. We cannot hold a `&mut E` reference to the entry because that\n+    /// other CPUs may modify the memory location for accessed/dirty bits. Such\n+    /// accesses will violate the aliasing rules of Rust and cause undefined\n+    /// behaviors.\n+    pte: E,\n+    /// The index of the entry in the node.\n+    idx: usize,\n+    /// The node that contains the entry.\n+    node: &'a mut PageTableNode<E, C>,\n+}\n+\n+impl<'a, E: PageTableEntryTrait, C: PagingConstsTrait> Entry<'a, E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns if the entry does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        !self.pte.is_present()\n+    }\n+\n+    /// Returns if the entry maps to a page table node.\n+    pub(in crate::mm) fn is_node(&self) -> bool {\n+        self.pte.is_present() && !self.pte.is_last(self.node.level())\n+    }\n+\n+    /// Gets a owned handle to the child.\n+    pub(in crate::mm) fn to_owned(&self) -> Child<E, C> {\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information.\n+        unsafe { Child::clone_from_pte(&self.pte, self.node.level(), self.node.is_tracked()) }\n+    }\n+\n+    /// Operates on the mapping properties of the entry.\n+    ///\n+    /// It only modifies the properties if the entry is present.\n+    // FIXME: in x86_64, you can protect a page with neither of the RWX\n+    // permissions. This would make the page not accessible and leaked. Such a\n+    // behavior is memory-safe but wrong. In RISC-V there's no problem.\n+    pub(in crate::mm) fn protect(&mut self, op: &mut impl FnMut(&mut PageProperty)) {\n+        if !self.pte.is_present() {\n+            return;\n+        }\n+\n+        let prop = self.pte.prop();\n+        let mut new_prop = prop;\n+        op(&mut new_prop);\n+\n+        if prop == new_prop {\n+            return;\n+        }\n+\n+        self.pte.set_prop(new_prop);\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. We replace the PTE with a new one, which differs only in\n+        //     `PageProperty`, so it is still compatible with the current\n+        //     page table node.\n+        unsafe { self.node.write_pte(self.idx, self.pte) };\n+    }\n+\n+    /// Replaces the entry with a new child.\n+    ///\n+    /// The old child is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The method panics if the given child is not compatible with the node.\n+    /// The compatibility is specified by the [`Child::is_compatible`].\n+    pub(in crate::mm) fn replace(self, new_child: Child<E, C>) -> Child<E, C> {\n+        assert!(new_child.is_compatible(self.node.level(), self.node.is_tracked()));\n+\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information. The old PTE is overwritten by the new child\n+        // so that it is not used anymore.\n+        let old_child =\n+            unsafe { Child::from_pte(self.pte, self.node.level(), self.node.is_tracked()) };\n+\n+        if old_child.is_none() && !new_child.is_none() {\n+            *self.node.nr_children_mut() += 1;\n+        } else if !old_child.is_none() && new_child.is_none() {\n+            *self.node.nr_children_mut() -= 1;\n+        }\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. The new PTE is compatible with the page table node, as asserted above.\n+        unsafe { self.node.write_pte(self.idx, new_child.into_pte()) };\n+\n+        old_child\n+    }\n+\n+    /// Splits the entry to smaller pages if it maps to a untracked huge page.\n+    ///\n+    /// If the entry does map to a untracked huge page, it is split into smaller\n+    /// pages mapped by a child page table node. The new child page table node\n+    /// is returned.\n+    ///\n+    /// If the entry does not map to a untracked huge page, the method returns\n+    /// `None`.\n+    pub(in crate::mm) fn split_if_untracked_huge(self) -> Option<PageTableNode<E, C>> {\n+        let level = self.node.level();\n+\n+        if !(self.pte.is_last(level)\n+            && level > 1\n+            && self.node.is_tracked() == MapTrackingStatus::Untracked)\n+        {\n+            return None;\n+        }\n+\n+        let pa = self.pte.paddr();\n+        let prop = self.pte.prop();\n+\n+        let mut new_page = PageTableNode::<E, C>::alloc(level - 1, MapTrackingStatus::Untracked);\n+        for i in 0..nr_subpage_per_huge::<C>() {\n+            let small_pa = pa + i * page_size::<C>(level - 1);\n+            let _ = new_page\n+                .entry(i)\n+                .replace(Child::Untracked(small_pa, level - 1, prop));\n+        }\n+\n+        let _ = self.replace(Child::PageTable(new_page.clone_raw()));\n+\n+        Some(new_page)\n+    }\n+\n+    /// Create a new entry at the node.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bounds of the node.\n+    pub(super) unsafe fn new_at(node: &'a mut PageTableNode<E, C>, idx: usize) -> Self {\n+        // SAFETY: The index is within the bound.\n+        let pte = unsafe { node.read_pte(idx) };\n+        Self { pte, idx, node }\n+    }\n+}\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -25,19 +25,22 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n+mod child;\n+mod entry;\n \n-use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n+use core::{marker::PhantomData, mem::ManuallyDrop, sync::atomic::Ordering};\n+\n+pub(in crate::mm) use self::{child::Child, entry::Entry};\n+use super::{nr_subpage_per_huge, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n         paddr_to_vaddr,\n         page::{\n-            self,\n-            meta::{PageMeta, PageTablePageMeta, PageUsage},\n+            self, inc_page_ref_count,\n+            meta::{MapTrackingStatus, PageMeta, PageTablePageMeta, PageUsage},\n             DynPage, Page,\n         },\n-        page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n };\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -55,7 +58,8 @@ pub(super) struct RawPageTableNode<E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) raw: Paddr,\n+    raw: Paddr,\n+    level: PagingLevel,\n     _phantom: PhantomData<(E, C)>,\n }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -67,15 +71,14 @@ where\n         self.raw\n     }\n \n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.level\n+    }\n+\n     /// Converts a raw handle to an accessible handle by pertaining the lock.\n     pub(super) fn lock(self) -> PageTableNode<E, C> {\n-        // Prevent dropping the handle.\n-        let this = ManuallyDrop::new(self);\n-\n-        // SAFETY: The physical address in the raw handle is valid and we are\n-        // transferring the ownership to a new handle. No increment of the reference\n-        // count is needed.\n-        let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n+        let level = self.level;\n+        let page: Page<PageTablePageMeta<E, C>> = self.into();\n \n         // Acquire the lock.\n         while page\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -87,7 +90,9 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> { page, _private: () }\n+        debug_assert_eq!(page.meta().level, level);\n+\n+        PageTableNode::<E, C> { page }\n     }\n \n     /// Creates a copy of the handle.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -96,6 +101,7 @@ where\n \n         Self {\n             raw: self.raw,\n+            level: self.level,\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -112,12 +118,18 @@ where\n     /// The caller must ensure that the page table to be activated has\n     /// proper mappings for the kernel and has the correct const parameters\n     /// matching the current CPU.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Only top-level page tables can be activated using this function.\n     pub(crate) unsafe fn activate(&self) {\n         use crate::{\n             arch::mm::{activate_page_table, current_page_table_paddr},\n             mm::CachePolicy,\n         };\n \n+        assert_eq!(self.level, C::NR_LEVELS);\n+\n         let last_activated_paddr = current_page_table_paddr();\n \n         if last_activated_paddr == self.raw {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -132,6 +144,7 @@ where\n         // Restore and drop the last activated page table.\n         drop(Self {\n             raw: last_activated_paddr,\n+            level: C::NR_LEVELS,\n             _phantom: PhantomData,\n         });\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -152,11 +165,40 @@ where\n         // SAFETY: We have a reference count to the page and can safely increase the reference\n         // count by one more.\n         unsafe {\n-            Page::<PageTablePageMeta<E, C>>::inc_ref_count(self.paddr());\n+            inc_page_ref_count(self.paddr());\n+        }\n+    }\n+\n+    /// Restores the handle from the physical address and level.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the physical address is valid and points to\n+    /// a forgotten page table node. A forgotten page table node can only be\n+    /// restored once. The level must match the level of the page table node.\n+    unsafe fn from_raw_parts(paddr: Paddr, level: PagingLevel) -> Self {\n+        Self {\n+            raw: paddr,\n+            level,\n+            _phantom: PhantomData,\n         }\n     }\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> From<RawPageTableNode<E, C>>\n+    for Page<PageTablePageMeta<E, C>>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    fn from(raw: RawPageTableNode<E, C>) -> Self {\n+        let raw = ManuallyDrop::new(raw);\n+        // SAFETY: The physical address in the raw handle is valid and we are\n+        // transferring the ownership to a new handle. No increment of the reference\n+        // count is needed.\n+        unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(raw.paddr()) }\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for RawPageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -175,64 +217,49 @@ where\n /// of the page table. Dropping the page table node will also drop all handles if the page\n /// table node has no references. You can set the page table node as a child of another\n /// page table node.\n+#[derive(Debug)]\n pub(super) struct PageTableNode<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    _private: (),\n+    page: Page<PageTablePageMeta<E, C>>,\n }\n \n-// FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\n-// this field or implement the `Debug` trait also for `DisabledPreemptGuard`?\n-impl<E, C> fmt::Debug for PageTableNode<E, C>\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n-    E: PageTableEntryTrait,\n-    C: PagingConstsTrait,\n     [(); C::NR_LEVELS as usize]:,\n {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"PageTableEntryTrait\")\n-            .field(\"page\", &self.page)\n-            .finish()\n+    /// Borrows an entry in the node at a given index.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the index is not within the bound of\n+    /// [`nr_subpage_per_huge<C>`].\n+    pub(super) fn entry(&mut self, idx: usize) -> Entry<'_, E, C> {\n+        assert!(idx < nr_subpage_per_huge::<C>());\n+        // SAFETY: The index is within the bound.\n+        unsafe { Entry::new_at(self, idx) }\n     }\n-}\n \n-/// A child of a page table node.\n-#[derive(Debug)]\n-pub(super) enum Child<E: PageTableEntryTrait = PageTableEntry, C: PagingConstsTrait = PagingConsts>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage, PageProperty),\n-    /// Pages not tracked by handles.\n-    Untracked(Paddr, PageProperty),\n-    None,\n-}\n+    /// Gets the level of the page table node.\n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.page.meta().level\n+    }\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    pub(super) fn is_none(&self) -> bool {\n-        matches!(self, Child::None)\n+    /// Gets the tracking status of the page table node.\n+    pub(super) fn is_tracked(&self) -> MapTrackingStatus {\n+        self.page.meta().is_tracked\n     }\n-}\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n     /// Allocates a new empty page table node.\n     ///\n     /// This function returns an owning handle. The newly created handle does not\n     /// set the lock bit for performance as it is exclusive and unlocking is an\n     /// extra unnecessary expensive operation.\n-    pub(super) fn alloc(level: PagingLevel) -> Self {\n-        let meta = PageTablePageMeta::new_locked(level);\n+    pub(super) fn alloc(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n+        let meta = PageTablePageMeta::new_locked(level, is_tracked);\n         let page = page::allocator::alloc_single::<PageTablePageMeta<E, C>>(meta).unwrap();\n \n         // Zero out the page table node.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -242,209 +269,76 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self { page, _private: () }\n-    }\n-\n-    pub fn level(&self) -> PagingLevel {\n-        self.meta().level\n+        Self { page }\n     }\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n         let this = ManuallyDrop::new(self);\n \n-        let raw = this.page.paddr();\n-\n+        // Release the lock.\n         this.page.meta().lock.store(0, Ordering::Release);\n \n-        RawPageTableNode {\n-            raw,\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is not changed.\n+        unsafe { RawPageTableNode::from_raw_parts(this.page.paddr(), this.page.meta().level) }\n     }\n \n     /// Gets a raw handle while still preserving the original handle.\n     pub(super) fn clone_raw(&self) -> RawPageTableNode<E, C> {\n-        core::mem::forget(self.page.clone());\n+        let page = ManuallyDrop::new(self.page.clone());\n \n-        RawPageTableNode {\n-            raw: self.page.paddr(),\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is increased by one.\n+        unsafe { RawPageTableNode::from_raw_parts(page.paddr(), page.meta().level) }\n     }\n \n-    /// Gets an extra reference of the child at the given index.\n-    pub(super) fn child(&self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            if !pte.is_last(self.level()) {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n-                unsafe {\n-                    Page::<PageTablePageMeta<E, C>>::inc_ref_count(paddr);\n-                }\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely\n-                // increase the reference count by one more.\n-                unsafe {\n-                    DynPage::inc_ref_count(paddr);\n-                }\n-                // SAFETY: The physical address of the PTE points to a forgotten\n-                // page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n-            } else {\n-                Child::Untracked(paddr, pte.prop())\n-            }\n-        }\n+    /// Gets the number of valid PTEs in the node.\n+    pub(super) fn nr_children(&self) -> u16 {\n+        // SAFETY: The lock is held so we have an exclusive access.\n+        unsafe { *self.page.meta().nr_children.get() }\n     }\n \n-    /// Replace the child at the given index with a new child.\n+    /// Reads a non-owning PTE at the given index.\n     ///\n-    /// The old child is returned.\n-    pub(super) fn replace_child(\n-        &mut self,\n-        idx: usize,\n-        new_child: Child<E, C>,\n-        in_tracked_range: bool,\n-    ) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let old_pte = self.read_pte(idx);\n-\n-        let new_child_is_none = match new_child {\n-            Child::None => {\n-                if old_pte.is_present() {\n-                    self.write_pte(idx, E::new_absent());\n-                }\n-                true\n-            }\n-            Child::PageTable(pt) => {\n-                let pt = ManuallyDrop::new(pt);\n-                let new_pte = E::new_pt(pt.paddr());\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Page(page, prop) => {\n-                debug_assert!(in_tracked_range);\n-                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Untracked(pa, prop) => {\n-                debug_assert!(!in_tracked_range);\n-                let new_pte = E::new_page(pa, self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-        };\n-\n-        if old_pte.is_present() {\n-            if new_child_is_none {\n-                *self.nr_children_mut() -= 1;\n-            }\n-            let paddr = old_pte.paddr();\n-            if !old_pte.is_last(self.level()) {\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: The physical address of the old PTE points to a\n-                // forgotten page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n-            } else {\n-                Child::Untracked(paddr, old_pte.prop())\n-            }\n-        } else {\n-            if !new_child_is_none {\n-                *self.nr_children_mut() += 1;\n-            }\n-            Child::None\n-        }\n-    }\n-\n-    /// Splits the untracked huge page mapped at `idx` to smaller pages.\n-    pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n-        // These should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert!(self.level() > 1);\n-\n-        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n-            panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n-        };\n-\n-        let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n-        for i in 0..nr_subpage_per_huge::<C>() {\n-            let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n-        }\n-\n-        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n-    }\n-\n-    /// Protects an already mapped child at a given index.\n-    pub(super) fn protect(&mut self, idx: usize, prop: PageProperty) {\n-        let mut pte = self.read_pte(idx);\n-        debug_assert!(pte.is_present()); // This should be ensured by the cursor.\n-\n-        pte.set_prop(prop);\n-\n-        // SAFETY: the index is within the bound and the PTE is valid.\n-        unsafe {\n-            (self.as_ptr() as *mut E).add(idx).write(pte);\n-        }\n-    }\n-\n-    pub(super) fn read_pte(&self, idx: usize) -> E {\n-        // It should be ensured by the cursor.\n+    /// A non-owning PTE means that it does not account for a reference count\n+    /// of the a page if the PTE points to a page. The original PTE still owns\n+    /// the child page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bound.\n+    unsafe fn read_pte(&self, idx: usize) -> E {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { self.as_ptr().add(idx).read() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *const E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).read() }\n     }\n \n     /// Writes a page table entry at a given index.\n     ///\n-    /// This operation will leak the old child if the PTE is present.\n-    fn write_pte(&mut self, idx: usize, pte: E) {\n-        // It should be ensured by the cursor.\n+    /// This operation will leak the old child if the old PTE is present.\n+    ///\n+    /// The child represented by the given PTE will handover the ownership to\n+    /// the node. The PTE will be rendered invalid after this operation.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that:\n+    ///  1. The index must be within the bound;\n+    ///  2. The PTE must represent a child compatible with this page table node\n+    ///     (see [`Child::is_compatible`]).\n+    unsafe fn write_pte(&mut self, idx: usize, pte: E) {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { (self.as_ptr() as *mut E).add(idx).write(pte) };\n-    }\n-\n-    /// The number of valid PTEs.\n-    pub(super) fn nr_children(&self) -> u16 {\n-        // SAFETY: The lock is held so there is no mutable reference to it.\n-        // It would be safe to read.\n-        unsafe { *self.meta().nr_children.get() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *mut E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).write(pte) }\n     }\n \n+    /// Gets the mutable reference to the number of valid PTEs in the node.\n     fn nr_children_mut(&mut self) -> &mut u16 {\n         // SAFETY: The lock is held so we have an exclusive access.\n-        unsafe { &mut *self.meta().nr_children.get() }\n-    }\n-\n-    fn as_ptr(&self) -> *const E {\n-        paddr_to_vaddr(self.start_paddr()) as *const E\n-    }\n-\n-    fn start_paddr(&self) -> Paddr {\n-        self.page.paddr()\n-    }\n-\n-    fn meta(&self) -> &PageTablePageMeta<E, C> {\n-        self.page.meta()\n+        unsafe { &mut *self.page.meta().nr_children.get() }\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -465,8 +359,16 @@ where\n     const USAGE: PageUsage = PageUsage::PageTable;\n \n     fn on_drop(page: &mut Page<Self>) {\n+        // SAFETY: This is the last reference so we have an exclusive access.\n+        let nr_children = unsafe { *page.meta().nr_children.get() };\n+\n+        if nr_children == 0 {\n+            return;\n+        }\n+\n         let paddr = page.paddr();\n         let level = page.meta().level;\n+        let is_tracked = page.meta().is_tracked;\n \n         // Drop the children.\n         for i in 0..nr_subpage_per_huge::<C>() {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -476,19 +378,21 @@ where\n             let pte_ptr = unsafe { (paddr_to_vaddr(paddr) as *const E).add(i) };\n             // SAFETY: The pointer is valid and the PTE is plain-old-data.\n             let pte = unsafe { pte_ptr.read() };\n+\n+            // Here if we use directly `Child::from_pte` we would experience a\n+            // 50% increase in the overhead of the `drop` function. It seems that\n+            // Rust is very conservative about inlining and optimizing dead code\n+            // for `unsafe` code. So we manually inline the function here.\n             if pte.is_present() {\n-                // Just restore the handle and drop the handle.\n+                let paddr = pte.paddr();\n                 if !pte.is_last(level) {\n-                    // This is a page table.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page table node.\n-                    drop(unsafe { Page::<Self>::from_raw(pte.paddr()) });\n-                } else {\n-                    // This is a page. You cannot drop a page table node that maps to\n-                    // untracked pages. This must be verified.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page.\n-                    drop(unsafe { DynPage::from_raw(pte.paddr()) });\n+                    // SAFETY: The PTE points to a page table node. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { Page::<Self>::from_raw(paddr) });\n+                } else if is_tracked == MapTrackingStatus::Tracked {\n+                    // SAFETY: The PTE points to a tracked page. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { DynPage::from_raw(paddr) });\n                 }\n             }\n         }\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -226,6 +226,8 @@ ktest: initramfs $(CARGO_OSDK)\n \t@for dir in $(OSDK_CRATES); do \\\n \t\t[ $$dir = \"ostd/libs/linux-bzimage/setup\" ] && continue; \\\n \t\t(cd $$dir && cargo osdk test) || exit 1; \\\n+\t\ttail --lines 10 qemu.log | grep -q \"^\\\\[ktest runner\\\\] All crates tested.\" \\\n+\t\t\t|| (echo \"Test failed\" && exit 1); \\\n \tdone\n \n .PHONY: docs\n",
        "problem_statement": "Silently failed ktest in OSTD: untracked_map_unmap\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/11101937778/job/30840638910#step:6:634\r\n\r\nThe ktest `test_untracked_map_unmap` failed, but CI doesn't notice it. The failure is reproducible locally.\r\n\r\n### To Reproduce\r\n\r\n```bash\r\ncd ostd && cargo osdk test test_untracked_map_unmap\r\n```\r\n\n[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "\nI've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-24T09:24:48Z",
        "version": "0.9"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1369,
        "instance_id": "asterinas__asterinas-1369",
        "issue_numbers": [
            "919"
        ],
        "base_commit": "ae4ac384713e63232b74915593ebdef680049d31",
        "patch": "diff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -16,7 +16,7 @@ use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::{\n     cpu::CpuExceptionInfo,\n-    mm::{VmSpace, MAX_USERSPACE_VADDR},\n+    mm::{tlb::TlbFlushOp, PageFlags, PageProperty, VmSpace, MAX_USERSPACE_VADDR},\n };\n \n use self::{\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -220,13 +220,6 @@ impl Vmar_ {\n     }\n \n     fn new_root() -> Arc<Self> {\n-        fn handle_page_fault_wrapper(\n-            vm_space: &VmSpace,\n-            trap_info: &CpuExceptionInfo,\n-        ) -> core::result::Result<(), ()> {\n-            handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n-        }\n-\n         let mut free_regions = BTreeMap::new();\n         let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -236,7 +229,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        let vm_space = VmSpace::new();\n+        let mut vm_space = VmSpace::new();\n         vm_space.register_page_fault_handler(handle_page_fault_wrapper);\n         Vmar_::new(vmar_inner, Arc::new(vm_space), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -668,17 +661,19 @@ impl Vmar_ {\n             let vm_space = if let Some(parent) = parent {\n                 parent.vm_space().clone()\n             } else {\n-                Arc::new(self.vm_space().fork_copy_on_write())\n+                let mut new_space = VmSpace::new();\n+                new_space.register_page_fault_handler(handle_page_fault_wrapper);\n+                Arc::new(new_space)\n             };\n             Vmar_::new(vmar_inner, vm_space, self.base, self.size, parent)\n         };\n \n         let inner = self.inner.lock();\n+        let mut new_inner = new_vmar_.inner.lock();\n+\n         // Clone free regions.\n         for (free_region_base, free_region) in &inner.free_regions {\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .free_regions\n                 .insert(*free_region_base, free_region.clone());\n         }\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -686,26 +681,49 @@ impl Vmar_ {\n         // Clone child vmars.\n         for (child_vmar_base, child_vmar_) in &inner.child_vmar_s {\n             let new_child_vmar = child_vmar_.new_fork(Some(&new_vmar_))?;\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .child_vmar_s\n                 .insert(*child_vmar_base, new_child_vmar);\n         }\n \n         // Clone mappings.\n-        for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n-            let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n-            new_vmar_\n-                .inner\n-                .lock()\n-                .vm_mappings\n-                .insert(*vm_mapping_base, new_mapping);\n+        {\n+            let new_vmspace = new_vmar_.vm_space();\n+            let range = self.base..(self.base + self.size);\n+            let mut new_cursor = new_vmspace.cursor_mut(&range).unwrap();\n+            let cur_vmspace = self.vm_space();\n+            let mut cur_cursor = cur_vmspace.cursor_mut(&range).unwrap();\n+            for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n+                // Clone the `VmMapping` to the new VMAR.\n+                let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n+                new_inner.vm_mappings.insert(*vm_mapping_base, new_mapping);\n+\n+                // Protect the mapping and copy to the new page table for COW.\n+                cur_cursor.jump(*vm_mapping_base).unwrap();\n+                new_cursor.jump(*vm_mapping_base).unwrap();\n+                let mut op = |page: &mut PageProperty| {\n+                    page.flags -= PageFlags::W;\n+                };\n+                new_cursor.copy_from(&mut cur_cursor, vm_mapping.map_size(), &mut op);\n+            }\n+            cur_cursor.flusher().issue_tlb_flush(TlbFlushOp::All);\n+            cur_cursor.flusher().dispatch_tlb_flush();\n         }\n+\n+        drop(new_inner);\n+\n         Ok(new_vmar_)\n     }\n }\n \n+/// This is for fallible user space write handling.\n+fn handle_page_fault_wrapper(\n+    vm_space: &VmSpace,\n+    trap_info: &CpuExceptionInfo,\n+) -> core::result::Result<(), ()> {\n+    handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n+}\n+\n impl<R> Vmar<R> {\n     /// The base address, i.e., the offset relative to the root VMAR.\n     ///\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -11,7 +11,8 @@ use core::{\n use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::mm::{\n-    vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags, PageProperty, VmSpace,\n+    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags,\n+    PageProperty, VmSpace,\n };\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -224,7 +225,7 @@ impl VmMapping {\n \n         match cursor.query().unwrap() {\n             VmItem::Mapped {\n-                va: _,\n+                va,\n                 frame,\n                 mut prop,\n             } if is_write => {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -245,7 +246,9 @@ impl VmMapping {\n                 let new_flags = PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n \n                 if self.is_shared || only_reference {\n-                    cursor.protect(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.protect_next(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.flusher().issue_tlb_flush(TlbFlushOp::Address(va));\n+                    cursor.flusher().dispatch_tlb_flush();\n                 } else {\n                     let new_frame = duplicate_frame(&frame)?;\n                     prop.flags |= new_flags;\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -558,7 +561,15 @@ impl VmMappingInner {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n         let mut cursor = vm_space.cursor_mut(&range).unwrap();\n-        cursor.protect(range.len(), |p| p.flags = perms.into());\n+        let op = |p: &mut PageProperty| p.flags = perms.into();\n+        while cursor.virt_addr() < range.end {\n+            if let Some(va) = cursor.protect_next(range.end - cursor.virt_addr(), op) {\n+                cursor.flusher().issue_tlb_flush(TlbFlushOp::Range(va));\n+            } else {\n+                break;\n+            }\n+        }\n+        cursor.flusher().dispatch_tlb_flush();\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -18,6 +18,7 @@ pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n pub mod stat;\n+pub mod tlb;\n pub mod vm_space;\n \n use core::{fmt::Debug, ops::Range};\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -734,26 +734,93 @@ where\n         None\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.0.preempt_guard\n-    }\n-\n-    /// Consumes itself and leak the root guard for the caller if it locked the root level.\n+    /// Copies the mapping from the given cursor to the current cursor.\n     ///\n-    /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\n-    pub(super) fn leak_root_guard(mut self) -> Option<PageTableNode<E, C>> {\n-        if self.0.guard_level != C::NR_LEVELS {\n-            return None;\n-        }\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// It can only copy tracked mappings since we consider the untracked\n+    /// mappings not useful to be copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that\n+    ///  - the range being copied with the operation does not affect kernel's\n+    ///    memory safety.\n+    ///  - both of the cursors are in tracked mappings.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub unsafe fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        assert!(len % page_size::<C>(1) == 0);\n+        let this_end = self.0.va + len;\n+        assert!(this_end <= self.0.barrier_va.end);\n+        let src_end = src.0.va + len;\n+        assert!(src_end <= src.0.barrier_va.end);\n \n-        while self.0.level < C::NR_LEVELS {\n-            self.0.level_up();\n-        }\n+        while self.0.va < this_end && src.0.va < src_end {\n+            let cur_pte = src.0.read_cur_pte();\n+            if !cur_pte.is_present() {\n+                src.0.move_forward();\n+                continue;\n+            }\n+\n+            // Go down if it's not a last node.\n+            if !cur_pte.is_last(src.0.level) {\n+                src.0.level_down();\n+\n+                // We have got down a level. If there's no mapped PTEs in\n+                // the current node, we can go back and skip to save time.\n+                if src.0.guards[(src.0.level - 1) as usize]\n+                    .as_ref()\n+                    .unwrap()\n+                    .nr_children()\n+                    == 0\n+                {\n+                    src.0.level_up();\n+                    src.0.move_forward();\n+                }\n+\n+                continue;\n+            }\n \n-        self.0.guards[(C::NR_LEVELS - 1) as usize].take()\n+            // Do protection.\n+            let mut pte_prop = cur_pte.prop();\n+            op(&mut pte_prop);\n+\n+            let idx = src.0.cur_idx();\n+            src.cur_node_mut().protect(idx, pte_prop);\n \n-        // Ok to drop the cursor here because we ensure not to access the page table if the current\n-        // level is the root level when running the dropping method.\n+            // Do copy.\n+            let child = src.cur_node_mut().child(idx, true);\n+            let Child::<E, C>::Page(page, prop) = child else {\n+                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n+            };\n+            self.jump(src.0.va).unwrap();\n+            let mapped_page_size = page.size();\n+            let original = self.map(page, prop);\n+            debug_assert!(original.is_none());\n+\n+            // Only move the source cursor forward since `Self::map` will do it.\n+            // This assertion is to ensure that they move by the same length.\n+            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+            src.0.move_forward();\n+        }\n     }\n \n     /// Goes down a level assuming the current slot is absent.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -92,53 +92,29 @@ impl PageTable<UserMode> {\n             self.root.activate();\n         }\n     }\n-\n-    /// Create a cloned new page table.\n-    ///\n-    /// This method takes a mutable cursor to the old page table that locks the\n-    /// entire virtual address range. The caller may implement the copy-on-write\n-    /// mechanism by first protecting the old page table and then clone it using\n-    /// this method.\n-    ///\n-    /// TODO: We may consider making the page table itself copy-on-write.\n-    pub fn clone_with(\n-        &self,\n-        cursor: CursorMut<'_, UserMode, PageTableEntry, PagingConsts>,\n-    ) -> Self {\n-        let root_node = cursor.leak_root_guard().unwrap();\n-\n-        const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node = unsafe {\n-            root_node.make_copy(\n-                0..NR_PTES_PER_NODE / 2,\n-                NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE,\n-            )\n-        };\n-\n-        PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n-            _phantom: PhantomData,\n-        }\n-    }\n }\n \n impl PageTable<KernelMode> {\n     /// Create a new user page table.\n     ///\n-    /// This should be the only way to create the first user page table, that is\n-    /// to fork the kernel page table with all the kernel mappings shared.\n-    ///\n-    /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n-    /// other child page tables.\n+    /// This should be the only way to create the user page table, that is to\n+    /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n+        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n \n+        // Make a shallow copy of the root node in the kernel space range.\n+        // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node =\n-            unsafe { root_node.make_copy(0..0, NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE) };\n+        for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n+            let child = root_node.child(i, /* meaningless */ true);\n+            if !child.is_none() {\n+                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            }\n+        }\n \n         PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n+            root: new_node.into_raw(),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -25,9 +25,7 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{\n-    fmt, marker::PhantomData, mem::ManuallyDrop, ops::Range, panic, sync::atomic::Ordering,\n-};\n+use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n \n use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n use crate::{\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -374,74 +372,6 @@ where\n         }\n     }\n \n-    /// Makes a copy of the page table node.\n-    ///\n-    /// This function allows you to control about the way to copy the children.\n-    /// For indexes in `deep`, the children are deep copied and this function will be recursively called.\n-    /// For indexes in `shallow`, the children are shallow copied as new references.\n-    ///\n-    /// You cannot shallow copy a child that is mapped to a page. Deep copying a page child will not\n-    /// copy the mapped page but will copy the handle to the page.\n-    ///\n-    /// You cannot either deep copy or shallow copy a child that is mapped to an untracked page.\n-    ///\n-    /// The ranges must be disjoint.\n-    pub(super) unsafe fn make_copy(&self, deep: Range<usize>, shallow: Range<usize>) -> Self {\n-        debug_assert!(deep.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(shallow.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(deep.end <= shallow.start || deep.start >= shallow.end);\n-\n-        let mut new_pt = Self::alloc(self.level());\n-        let mut copied_child_count = self.nr_children();\n-        for i in deep {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            match self.child(i, true) {\n-                Child::PageTable(pt) => {\n-                    let guard = pt.clone_shallow().lock();\n-                    let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::Page(page, prop) => {\n-                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        for i in shallow {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            debug_assert_eq!(self.level(), C::NR_LEVELS);\n-            match self.child(i, /*meaningless*/ true) {\n-                Child::PageTable(pt) => {\n-                    let old = new_pt.replace_child(\n-                        i,\n-                        Child::PageTable(pt.clone_shallow()),\n-                        /*meaningless*/ true,\n-                    );\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Page(_, _) | Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        new_pt\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\ndiff --git /dev/null b/ostd/src/mm/tlb.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/tlb.rs\n@@ -0,0 +1,222 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! TLB flush operations.\n+\n+use alloc::vec::Vec;\n+use core::ops::Range;\n+\n+use super::{page::DynPage, Vaddr, PAGE_SIZE};\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    task::disable_preempt,\n+};\n+\n+/// A TLB flusher that is aware of which CPUs are needed to be flushed.\n+///\n+/// The flusher needs to stick to the current CPU.\n+pub struct TlbFlusher<G: PinCurrentCpu> {\n+    target_cpus: CpuSet,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead.\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+    _pin_current: G,\n+}\n+\n+impl<G: PinCurrentCpu> TlbFlusher<G> {\n+    /// Creates a new TLB flusher with the specified CPUs to be flushed.\n+    ///\n+    /// The flusher needs to stick to the current CPU. So please provide a\n+    /// guard that implements [`PinCurrentCpu`].\n+    pub fn new(target_cpus: CpuSet, pin_current_guard: G) -> Self {\n+        let current_cpu = pin_current_guard.current_cpu();\n+\n+        let mut need_self_flush = false;\n+        let mut need_remote_flush = false;\n+\n+        for cpu in target_cpus.iter() {\n+            if cpu == current_cpu {\n+                need_self_flush = true;\n+            } else {\n+                need_remote_flush = true;\n+            }\n+        }\n+        Self {\n+            target_cpus,\n+            need_remote_flush,\n+            need_self_flush,\n+            _pin_current: pin_current_guard,\n+        }\n+    }\n+\n+    /// Issues a pending TLB flush request.\n+    ///\n+    /// On SMP systems, the notification is sent to all the relevant CPUs only\n+    /// when [`Self::dispatch_tlb_flush`] is called.\n+    pub fn issue_tlb_flush(&self, op: TlbFlushOp) {\n+        self.issue_tlb_flush_(op, None);\n+    }\n+\n+    /// Dispatches all the pending TLB flush requests.\n+    ///\n+    /// The pending requests are issued by [`Self::issue_tlb_flush`].\n+    pub fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        crate::smp::inter_processor_call(&self.target_cpus, do_remote_flush);\n+    }\n+\n+    /// Issues a TLB flush request that must happen before dropping the page.\n+    ///\n+    /// If we need to remove a mapped page from the page table, we can only\n+    /// recycle the page after all the relevant TLB entries in all CPUs are\n+    /// flushed. Otherwise if the page is recycled for other purposes, the user\n+    /// space program can still access the page through the TLB entries. This\n+    /// method is designed to be used in such cases.\n+    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: DynPage) {\n+        self.issue_tlb_flush_(op, Some(drop_after_flush));\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on other CPUs.\n+    pub fn need_remote_flush(&self) -> bool {\n+        self.need_remote_flush\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on the current CPU.\n+    pub fn need_self_flush(&self) -> bool {\n+        self.need_self_flush\n+    }\n+\n+    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let op = op.optimize_for_large_range();\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                op.perform_on_current();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.target_cpus.iter() {\n+            let mut op_queue = FLUSH_OPS.get_on_cpu(cpu).lock();\n+            if let Some(drop_after_flush) = drop_after_flush.clone() {\n+                PAGE_KEEPER.get_on_cpu(cpu).lock().push(drop_after_flush);\n+            }\n+            op_queue.push(op.clone());\n+        }\n+    }\n+}\n+\n+/// The operation to flush TLB entries.\n+#[derive(Debug, Clone)]\n+pub enum TlbFlushOp {\n+    /// Flush all TLB entries except for the global entries.\n+    All,\n+    /// Flush the TLB entry for the specified virtual address.\n+    Address(Vaddr),\n+    /// Flush the TLB entries for the specified virtual address range.\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushOp {\n+    /// Performs the TLB flush operation on the current CPU.\n+    pub fn perform_on_current(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match self {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n+        }\n+    }\n+\n+    fn optimize_for_large_range(self) -> Self {\n+        match self {\n+            TlbFlushOp::Range(range) => {\n+                if range.len() > FLUSH_ALL_RANGE_THRESHOLD {\n+                    TlbFlushOp::All\n+                } else {\n+                    TlbFlushOp::Range(range)\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+}\n+\n+// The queues of pending requests on each CPU.\n+//\n+// Lock ordering: lock FLUSH_OPS before PAGE_KEEPER.\n+cpu_local! {\n+    static FLUSH_OPS: SpinLock<OpsStack> = SpinLock::new(OpsStack::new());\n+    static PAGE_KEEPER: SpinLock<Vec<DynPage>> = SpinLock::new(Vec::new());\n+}\n+\n+fn do_remote_flush() {\n+    let preempt_guard = disable_preempt();\n+    let current_cpu = preempt_guard.current_cpu();\n+\n+    let mut op_queue = FLUSH_OPS.get_on_cpu(current_cpu).lock();\n+    op_queue.flush_all();\n+    PAGE_KEEPER.get_on_cpu(current_cpu).lock().clear();\n+}\n+\n+/// If a TLB flushing request exceeds this threshold, we flush all.\n+pub(crate) const FLUSH_ALL_RANGE_THRESHOLD: usize = 32 * PAGE_SIZE;\n+\n+/// If the number of pending requests exceeds this threshold, we flush all the\n+/// TLB entries instead of flushing them one by one.\n+const FLUSH_ALL_OPS_THRESHOLD: usize = 32;\n+\n+struct OpsStack {\n+    ops: [Option<TlbFlushOp>; FLUSH_ALL_OPS_THRESHOLD],\n+    need_flush_all: bool,\n+    size: usize,\n+}\n+\n+impl OpsStack {\n+    const fn new() -> Self {\n+        const ARRAY_REPEAT_VALUE: Option<TlbFlushOp> = None;\n+        Self {\n+            ops: [ARRAY_REPEAT_VALUE; FLUSH_ALL_OPS_THRESHOLD],\n+            need_flush_all: false,\n+            size: 0,\n+        }\n+    }\n+\n+    fn push(&mut self, op: TlbFlushOp) {\n+        if self.need_flush_all {\n+            return;\n+        }\n+\n+        if self.size < FLUSH_ALL_OPS_THRESHOLD {\n+            self.ops[self.size] = Some(op);\n+            self.size += 1;\n+        } else {\n+            self.need_flush_all = true;\n+            self.size = 0;\n+        }\n+    }\n+\n+    fn flush_all(&mut self) {\n+        if self.need_flush_all {\n+            crate::arch::mm::tlb_flush_all_excluding_global();\n+            self.need_flush_all = false;\n+        } else {\n+            for i in 0..self.size {\n+                if let Some(op) = &self.ops[i] {\n+                    op.perform_on_current();\n+                }\n+            }\n+        }\n+\n+        self.size = 0;\n+    }\n+}\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,32 +9,25 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use alloc::collections::vec_deque::VecDeque;\n use core::{\n     ops::Range,\n     sync::atomic::{AtomicPtr, Ordering},\n };\n \n-use spin::Once;\n-\n-use super::{\n-    io::Fallible,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page::DynPage,\n-    page_table::{PageTable, UserMode},\n-    PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n-};\n use crate::{\n     arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n     cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n     cpu_local,\n     mm::{\n-        page_table::{self, PageTableItem},\n-        Frame, MAX_USERSPACE_VADDR,\n+        io::Fallible,\n+        kspace::KERNEL_PAGE_TABLE,\n+        page_table::{self, PageTable, PageTableItem, UserMode},\n+        tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\n+        Frame, PageProperty, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::{RwLock, RwLockReadGuard, SpinLock},\n-    task::disable_preempt,\n+    sync::{RwLock, RwLockReadGuard},\n+    task::{disable_preempt, DisabledPreemptGuard},\n     Error,\n };\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -56,7 +49,7 @@ use crate::{\n #[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+    page_fault_handler: Option<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n     /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n     /// Cursors hold read locks and activation require a write lock.\n     activation_lock: RwLock<()>,\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -67,7 +60,7 @@ impl VmSpace {\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n+            page_fault_handler: None,\n             activation_lock: RwLock::new(()),\n         }\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -98,11 +91,7 @@ impl VmSpace {\n         Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n             let activation_lock = self.activation_lock.read();\n \n-            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n-\n             let mut activated_cpus = CpuSet::new_empty();\n-            let mut need_self_flush = false;\n-            let mut need_remote_flush = false;\n \n             for cpu in 0..num_cpus() {\n                 // The activation lock is held; other CPUs cannot activate this `VmSpace`.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -110,20 +99,13 @@ impl VmSpace {\n                     ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n                 if ptr == self as *const VmSpace {\n                     activated_cpus.add(cpu);\n-                    if cpu == cur_cpu {\n-                        need_self_flush = true;\n-                    } else {\n-                        need_remote_flush = true;\n-                    }\n                 }\n             }\n \n             CursorMut {\n                 pt_cursor,\n                 activation_lock,\n-                activated_cpus,\n-                need_remote_flush,\n-                need_self_flush,\n+                flusher: TlbFlusher::new(activated_cpus, disable_preempt()),\n             }\n         })?)\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -156,63 +138,18 @@ impl VmSpace {\n         &self,\n         info: &CpuExceptionInfo,\n     ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n+        if let Some(func) = self.page_fault_handler {\n             return func(self, info);\n         }\n         Err(())\n     }\n \n     /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n     pub fn register_page_fault_handler(\n-        &self,\n+        &mut self,\n         func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n     ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        // Protect the parent VM space as read-only.\n-        let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n-        let mut op = |prop: &mut PageProperty| {\n-            prop.flags -= PageFlags::W;\n-        };\n-\n-        cursor.protect(end, &mut op);\n-\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-\n-        let CursorMut {\n-            pt_cursor,\n-            activation_lock,\n-            ..\n-        } = cursor;\n-\n-        let new_pt = self.pt.clone_with(pt_cursor);\n-\n-        // Release the activation lock after the page table is cloned to\n-        // prevent modification to the parent page table while cloning.\n-        drop(activation_lock);\n-\n-        Self {\n-            pt: new_pt,\n-            page_fault_handler,\n-            activation_lock: RwLock::new(()),\n-        }\n+        self.page_fault_handler = Some(func);\n     }\n \n     /// Creates a reader to read data from the user space of the current task.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -311,12 +248,9 @@ pub struct CursorMut<'a, 'b> {\n     pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n     #[allow(dead_code)]\n     activation_lock: RwLockReadGuard<'b, ()>,\n-    // Better to store them here since loading and counting them from the CPUs\n-    // list brings non-trivial overhead. We have a read lock so the stored set\n-    // is always a superset of actual activated CPUs.\n-    activated_cpus: CpuSet,\n-    need_remote_flush: bool,\n-    need_self_flush: bool,\n+    // We have a read lock so the CPU set in the flusher is always a superset\n+    // of actual activated CPUs.\n+    flusher: TlbFlusher<DisabledPreemptGuard>,\n }\n \n impl CursorMut<'_, '_> {\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -345,6 +279,11 @@ impl CursorMut<'_, '_> {\n         self.pt_cursor.virt_addr()\n     }\n \n+    /// Get the dedicated TLB flusher for this cursor.\n+    pub fn flusher(&self) -> &TlbFlusher<DisabledPreemptGuard> {\n+        &self.flusher\n+    }\n+\n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -353,9 +292,10 @@ impl CursorMut<'_, '_> {\n         // SAFETY: It is safe to map untyped memory into the userspace.\n         let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        if old.is_some() {\n-            self.issue_tlb_flush(TlbFlushOp::Address(start_va), old);\n-            self.dispatch_tlb_flush();\n+        if let Some(old) = old {\n+            self.flusher\n+                .issue_tlb_flush_with(TlbFlushOp::Address(start_va), old);\n+            self.flusher.dispatch_tlb_flush();\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -367,25 +307,31 @@ impl CursorMut<'_, '_> {\n     /// Already-absent mappings encountered by the cursor will be skipped. It\n     /// is valid to unmap a range that is not mapped.\n     ///\n+    /// It must issue and dispatch a TLB flush after the operation. Otherwise,\n+    /// the memory safety will be compromised. Please call this function less\n+    /// to avoid the overhead of TLB flush. Using a large `len` is wiser than\n+    /// splitting the operation into multiple small ones.\n+    ///\n     /// # Panics\n     ///\n     /// This method will panic if `len` is not page-aligned.\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+        let tlb_prefer_flush_all = len > FLUSH_ALL_RANGE_THRESHOLD;\n \n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n             let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !self.need_remote_flush && tlb_prefer_flush_all {\n+                    if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n                         // Only on single-CPU cases we can drop the page immediately before flushing.\n                         drop(page);\n                         continue;\n                     }\n-                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n+                    self.flusher\n+                        .issue_tlb_flush_with(TlbFlushOp::Address(va), page);\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -396,103 +342,79 @@ impl CursorMut<'_, '_> {\n             }\n         }\n \n-        if !self.need_remote_flush && tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n+            self.flusher.issue_tlb_flush(TlbFlushOp::All);\n         }\n \n-        self.dispatch_tlb_flush();\n+        self.flusher.dispatch_tlb_flush();\n     }\n \n-    /// Change the mapping property starting from the current slot.\n+    /// Applies the operation to the next slot of mapping within the range.\n     ///\n-    /// This method will bring the cursor forward by `len` bytes in the virtual\n-    /// address space after the modification.\n+    /// The range to be found in is the current virtual address with the\n+    /// provided length.\n+    ///\n+    /// The function stops and yields the actually protected range if it has\n+    /// actually protected a page, no matter if the following pages are also\n+    /// required to be protected.\n+    ///\n+    /// It also makes the cursor moves forward to the next page after the\n+    /// protected one. If no mapped pages exist in the following range, the\n+    /// cursor will stop at the end of the range and return [`None`].\n     ///\n-    /// The way to change the property is specified by the closure `op`.\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// [`Self::flusher`].\n     ///\n     /// # Panics\n     ///\n-    /// This method will panic if `len` is not page-aligned.\n-    pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n-        assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n-\n+    /// This function will panic if:\n+    ///  - the range to be protected is out of the range where the cursor\n+    ///    is required to operate;\n+    ///  - the specified virtual address range only covers a part of a page.\n+    pub fn protect_next(\n+        &mut self,\n+        len: usize,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) -> Option<Range<Vaddr>> {\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) =\n-            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n-        {\n-            if !tlb_prefer_flush_all {\n-                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n-            }\n-        }\n-\n-        if tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n-        }\n-        self.dispatch_tlb_flush();\n+        unsafe { self.pt_cursor.protect_next(len, &mut op) }\n     }\n \n-    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n-        let request = TlbFlushRequest {\n-            op,\n-            drop_after_flush,\n-        };\n-\n-        // Fast path for single CPU cases.\n-        if !self.need_remote_flush {\n-            if self.need_self_flush {\n-                request.do_flush();\n-            }\n-            return;\n-        }\n-\n-        // Slow path for multi-CPU cases.\n-        for cpu in self.activated_cpus.iter() {\n-            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n-            queue.push_back(request.clone());\n-        }\n-    }\n-\n-    fn dispatch_tlb_flush(&self) {\n-        if !self.need_remote_flush {\n-            return;\n-        }\n-\n-        fn do_remote_flush() {\n-            let preempt_guard = disable_preempt();\n-            let mut requests = TLB_FLUSH_REQUESTS\n-                .get_on_cpu(preempt_guard.current_cpu())\n-                .lock();\n-            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n-                // TODO: in most cases, we need only to flush all the TLB entries\n-                // for an ASID if it is enabled.\n-                crate::arch::mm::tlb_flush_all_excluding_global();\n-                requests.clear();\n-            } else {\n-                while let Some(request) = requests.pop_front() {\n-                    request.do_flush();\n-                    if matches!(request.op, TlbFlushOp::All) {\n-                        requests.clear();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    /// Copies the mapping from the given cursor to the current cursor.\n+    ///\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// the source's [`CursorMut::flusher`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        // SAFETY: Operations on user memory spaces are safe if it doesn't\n+        // involve dropping any pages.\n+        unsafe { self.pt_cursor.copy_from(&mut src.pt_cursor, len, op) }\n     }\n }\n \n-/// The threshold used to determine whether we need to flush all TLB entries\n-/// when handling a bunch of TLB flush requests. If the number of requests\n-/// exceeds this threshold, the overhead incurred by flushing pages\n-/// individually would surpass the overhead of flushing all entries at once.\n-const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n-\n cpu_local! {\n-    /// The queue of pending requests.\n-    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n     /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n     /// is NULL, it means that the activated page table is merely the kernel\n     /// page table.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -502,38 +424,6 @@ cpu_local! {\n     static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n }\n \n-#[derive(Debug, Clone)]\n-struct TlbFlushRequest {\n-    op: TlbFlushOp,\n-    // If we need to remove a mapped page from the page table, we can only\n-    // recycle the page after all the relevant TLB entries in all CPUs are\n-    // flushed. Otherwise if the page is recycled for other purposes, the user\n-    // space program can still access the page through the TLB entries.\n-    #[allow(dead_code)]\n-    drop_after_flush: Option<DynPage>,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TlbFlushOp {\n-    All,\n-    Address(Vaddr),\n-    Range(Range<Vaddr>),\n-}\n-\n-impl TlbFlushRequest {\n-    /// Perform the TLB flush operation on the current CPU.\n-    fn do_flush(&self) {\n-        use crate::arch::mm::{\n-            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        };\n-        match &self.op {\n-            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n-            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n-            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n-        }\n-    }\n-}\n-\n /// The result of a query over the VM space.\n #[derive(Debug)]\n pub enum VmItem {\n",
        "test_patch": "diff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -81,6 +81,10 @@ fn test_untracked_map_unmap() {\n \n #[ktest]\n fn test_user_copy_on_write() {\n+    fn prot_op(prop: &mut PageProperty) {\n+        prop.flags -= PageFlags::W;\n+    }\n+\n     let pt = PageTable::<UserMode>::empty();\n     let from = PAGE_SIZE..PAGE_SIZE * 2;\n     let page = allocator::alloc_single(FrameMeta::default()).unwrap();\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -96,7 +100,14 @@ fn test_user_copy_on_write() {\n     unsafe { pt.cursor_mut(&from).unwrap().map(page.clone().into(), prop) };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let child_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let child_pt = {\n+        let child_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut child_cursor = child_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { child_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        child_pt\n+    };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert!(matches!(\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -106,7 +117,14 @@ fn test_user_copy_on_write() {\n     assert!(pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let sibling_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let sibling_pt = {\n+        let sibling_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut sibling_cursor = sibling_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { sibling_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        sibling_pt\n+    };\n     assert!(sibling_pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     drop(pt);\n",
        "problem_statement": "[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "I've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-23T14:17:42Z",
        "version": "0.8"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1642,
        "instance_id": "asterinas__asterinas-1642",
        "issue_numbers": [
            "1587"
        ],
        "base_commit": "9da6af03943c15456cdfd781021820a7da78ea40",
        "patch": "diff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -253,7 +253,9 @@ impl FutexBucket {\n             }\n \n             let item = item_cursor.remove().unwrap();\n-            item.wake();\n+            if !item.wake() {\n+                continue;\n+            }\n             count += 1;\n         }\n \ndiff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -323,8 +325,9 @@ impl FutexItem {\n         (futex_item, waiter)\n     }\n \n-    pub fn wake(&self) {\n-        self.waker.wake_up();\n+    #[must_use]\n+    pub fn wake(&self) -> bool {\n+        self.waker.wake_up()\n     }\n \n     pub fn match_up(&self, another: &Self) -> bool {\n",
        "test_patch": "diff --git /dev/null b/test/apps/pthread/pthread_signal_test.c\nnew file mode 100644\n--- /dev/null\n+++ b/test/apps/pthread/pthread_signal_test.c\n@@ -0,0 +1,109 @@\n+// SPDX-License-Identifier: MPL-2.0\n+// A regression test for the futex lost wakeup bug fixed in https://github.com/asterinas/asterinas/pull/1642\n+\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <signal.h>\n+#include <stdatomic.h>\n+\n+pthread_mutex_t mutex;\n+atomic_int sync_flag = ATOMIC_VAR_INIT(0); // Atomic flag for synchronization\n+\n+// Signal handler for SIGUSR1\n+void signal_handler(int signum)\n+{\n+\tatomic_store(&sync_flag, 2);\n+}\n+\n+// Thread function that tries to lock the mutex and waits if it is locked\n+void *thread_function(void *arg)\n+{\n+\tprintf(\"Thread: Trying to lock mutex...\\n\");\n+\n+\t// Set the atomic flag to signal the main thread\n+\tatomic_store(&sync_flag, 1);\n+\n+\t// Try to lock the mutex\n+\tpthread_mutex_lock(&mutex);\n+\tprintf(\"Thread: Got the mutex!\\n\");\n+\n+\tprintf(\"Thread: Exiting.\\n\");\n+\tpthread_mutex_unlock(&mutex);\n+\n+\t// Set the atomic flag to signal the main thread\n+\tatomic_store(&sync_flag, 3);\n+\treturn NULL;\n+}\n+\n+int main()\n+{\n+\tpthread_t thread;\n+\n+\t// Initialize mutex\n+\tif (pthread_mutex_init(&mutex, NULL) != 0) {\n+\t\tperror(\"Mutex initialization failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Set up signal handler for SIGUSR1\n+\tstruct sigaction sa;\n+\tsa.sa_handler = signal_handler;\n+\tsa.sa_flags = 0;\n+\tsigemptyset(&sa.sa_mask);\n+\tif (sigaction(SIGUSR1, &sa, NULL) == -1) {\n+\t\tperror(\"sigaction failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Main thread locks the mutex\n+\tpthread_mutex_lock(&mutex);\n+\tprintf(\"Main thread: Mutex locked.\\n\");\n+\n+\t// Create the second thread\n+\tif (pthread_create(&thread, NULL, thread_function, NULL) != 0) {\n+\t\tperror(\"Thread creation failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Detach the thread to allow it to run independently\n+\tif (pthread_detach(thread) != 0) {\n+\t\tperror(\"Thread detachment failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Wait for the second thread to prepare\n+\twhile (atomic_load(&sync_flag) != 1) {\n+\t}\n+\tsleep(1);\n+\n+\t// Send signal to the second thread\n+\tpthread_kill(thread, SIGUSR1);\n+\tprintf(\"Main thread: Signal sent to the thread.\\n\");\n+\n+\t// Wait for the second thread to process signal\n+\twhile (atomic_load(&sync_flag) != 2) {\n+\t}\n+\tsleep(1);\n+\n+\t// Unlock the mutex\n+\tpthread_mutex_unlock(&mutex);\n+\tprintf(\"Main thread: Mutex unlocked.\\n\");\n+\n+\t// Wait for the second thread to exit\n+\tint count = 3;\n+\twhile (atomic_load(&sync_flag) != 3 && count--) {\n+\t\tsleep(1);\n+\t}\n+\tif (atomic_load(&sync_flag) != 3) {\n+\t\tprintf(\"ERROR: Thread does not exit after timeout.\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Destroy mutex\n+\tpthread_mutex_destroy(&mutex);\n+\n+\tprintf(\"All tests passed.\\n\");\n+\treturn 0;\n+}\n",
        "problem_statement": "`futex_wait_bitset()` should remove `futex_item` when `pause_timeout()` fails\n### Describe the bug\r\n\r\n1. When signaled or timeout, the `futex_item` is not removed from the `futex_bucket`, which can lead to lost-wakeup.\r\n2. `waiter.pause_timeout()` returns `Ok(())` upon waking up from a signal, which can lead to incorrect handling of the wake-up event.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/11382524d1d23cc6d41adf977a72138baa39e38d/kernel/src/process/posix_thread/futex.rs#L76\n",
        "hints_text": "The [wakeup test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L671-L673) must take precedence over the [pending signals test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L678-L683).\r\n\r\nThis is the real cause of the failed CI due to 6421fd0b36aafb3fcd9a8f12d5bc6e89f3f86546, cc https://github.com/asterinas/asterinas/pull/1577.\r\n\r\nI also wonder if we can remove the `pause_timeout` API and let the futex use the normal `pause_until` API, but I am not sure since I have not read the futex implementation.\r\n\r\n> can lead to lost-wakeup.\r\n\r\nThis should only result in spurious wake?",
        "created_at": "2024-11-26T12:04:42Z",
        "version": "0.9"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1598,
        "instance_id": "asterinas__asterinas-1598",
        "issue_numbers": [
            "1578"
        ],
        "base_commit": "b70c4784edff72acc084d27bbb704b7f29c6b36e",
        "patch": "diff --git a/kernel/src/arch/x86/cpu.rs b/kernel/src/arch/x86/cpu.rs\n--- a/kernel/src/arch/x86/cpu.rs\n+++ b/kernel/src/arch/x86/cpu.rs\n@@ -22,6 +22,10 @@ impl LinuxAbi for UserContext {\n         self.rax()\n     }\n \n+    fn set_syscall_num(&mut self, num: usize) {\n+        self.set_rax(num);\n+    }\n+\n     fn set_syscall_ret(&mut self, ret: usize) {\n         self.set_rax(ret);\n     }\ndiff --git a/kernel/src/cpu.rs b/kernel/src/cpu.rs\n--- a/kernel/src/cpu.rs\n+++ b/kernel/src/cpu.rs\n@@ -7,6 +7,9 @@ pub trait LinuxAbi {\n     /// Get return value of syscall\n     fn syscall_ret(&self) -> usize;\n \n+    /// Set number of syscall\n+    fn set_syscall_num(&mut self, num: usize);\n+\n     /// Set return value of syscall\n     fn set_syscall_ret(&mut self, ret: usize);\n \ndiff --git a/kernel/src/error.rs b/kernel/src/error.rs\n--- a/kernel/src/error.rs\n+++ b/kernel/src/error.rs\n@@ -150,6 +150,8 @@ pub enum Errno {\n     ERFKILL = 132, /* Operation not possible due to RF-kill */\n \n     EHWPOISON = 133, /* Memory page has hardware error */\n+\n+    ERESTARTSYS = 512, /* Restart of an interrupted system call. For kernel internal use only. */\n }\n \n /// error used in this crate\ndiff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -74,6 +74,15 @@ pub fn futex_wait_bitset(\n     drop(futex_bucket);\n \n     waiter.pause_timeout(timeout)\n+\n+    // TODO: Ensure the futex item is dequeued and dropped.\n+    //\n+    // The enqueued futex item remain undequeued\n+    // if the futex wait operation is interrupted by a signal or times out.\n+    // In such cases, the `Box<FutexItem>` would persist in memory,\n+    // leaving our implementation vulnerable to exploitation by user programs\n+    // that could repeatedly issue futex wait operations\n+    // to exhaust kernel memory.\n }\n \n /// Does futex wake\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -10,6 +10,7 @@ use ostd::sync::Waker;\n use super::{\n     kill::SignalSenderIds,\n     signal::{\n+        sig_action::SigAction,\n         sig_mask::{AtomicSigMask, SigMask, SigSet},\n         sig_num::SigNum,\n         sig_queues::SigQueues,\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -220,8 +221,11 @@ impl PosixThread {\n     /// Enqueues a thread-directed signal. This method should only be used for enqueue kernel\n     /// signal and fault signal.\n     pub fn enqueue_signal(&self, signal: Box<dyn Signal>) {\n+        let signal_number = signal.num();\n         self.sig_queues.enqueue(signal);\n-        if let Some(waker) = &*self.signalled_waker.lock() {\n+        if self.process().sig_dispositions().lock().get(signal_number) != SigAction::Ign\n+            && let Some(waker) = &*self.signalled_waker.lock()\n+        {\n             waker.wake_up();\n         }\n     }\ndiff --git a/kernel/src/process/signal/mod.rs b/kernel/src/process/signal/mod.rs\n--- a/kernel/src/process/signal/mod.rs\n+++ b/kernel/src/process/signal/mod.rs\n@@ -28,6 +28,7 @@ pub use sig_stack::{SigStack, SigStackFlags};\n \n use super::posix_thread::PosixThread;\n use crate::{\n+    cpu::LinuxAbi,\n     current_userspace,\n     prelude::*,\n     process::{do_exit_group, TermStatus},\ndiff --git a/kernel/src/process/signal/mod.rs b/kernel/src/process/signal/mod.rs\n--- a/kernel/src/process/signal/mod.rs\n+++ b/kernel/src/process/signal/mod.rs\n@@ -41,7 +42,11 @@ pub trait SignalContext {\n // TODO: This interface of this method is error prone.\n // The method takes an argument for the current thread to optimize its efficiency.\n /// Handle pending signal for current process.\n-pub fn handle_pending_signal(user_ctx: &mut UserContext, ctx: &Context) -> Result<()> {\n+pub fn handle_pending_signal(\n+    user_ctx: &mut UserContext,\n+    ctx: &Context,\n+    syscall_number: Option<usize>,\n+) -> Result<()> {\n     // We first deal with signal in current thread, then signal in current process.\n     let posix_thread = ctx.posix_thread;\n     let signal = {\ndiff --git a/kernel/src/process/signal/mod.rs b/kernel/src/process/signal/mod.rs\n--- a/kernel/src/process/signal/mod.rs\n+++ b/kernel/src/process/signal/mod.rs\n@@ -69,6 +74,17 @@ pub fn handle_pending_signal(user_ctx: &mut UserContext, ctx: &Context) -> Resul\n             restorer_addr,\n             mask,\n         } => {\n+            if let Some(syscall_number) = syscall_number\n+                && user_ctx.syscall_ret() == -(Errno::ERESTARTSYS as i32) as usize\n+            {\n+                if flags.contains(SigActionFlags::SA_RESTART) {\n+                    user_ctx.set_syscall_num(syscall_number);\n+                    user_ctx.set_instruction_pointer(user_ctx.instruction_pointer() - 2);\n+                } else {\n+                    user_ctx.set_syscall_ret(-(Errno::EINTR as i32) as usize);\n+                }\n+            }\n+\n             if flags.contains(SigActionFlags::SA_RESETHAND) {\n                 // In Linux, SA_RESETHAND corresponds to SA_ONESHOT,\n                 // which means the user handler will be executed only once and then reset to the default.\ndiff --git a/kernel/src/process/signal/sig_action.rs b/kernel/src/process/signal/sig_action.rs\n--- a/kernel/src/process/signal/sig_action.rs\n+++ b/kernel/src/process/signal/sig_action.rs\n@@ -90,9 +90,6 @@ impl TryFrom<u32> for SigActionFlags {\n     fn try_from(bits: u32) -> Result<Self> {\n         let flags = SigActionFlags::from_bits(bits)\n             .ok_or_else(|| Error::with_message(Errno::EINVAL, \"invalid sig action flag\"))?;\n-        if flags.contains(SigActionFlags::SA_RESTART) {\n-            warn!(\"SA_RESTART is not supported\");\n-        }\n         Ok(flags)\n     }\n }\ndiff --git a/kernel/src/syscall/accept.rs b/kernel/src/syscall/accept.rs\n--- a/kernel/src/syscall/accept.rs\n+++ b/kernel/src/syscall/accept.rs\n@@ -49,7 +49,11 @@ fn do_accept(\n ) -> Result<FileDesc> {\n     let (connected_socket, socket_addr) = {\n         let socket = get_socket_from_fd(sockfd)?;\n-        socket.accept()?\n+        socket.accept().map_err(|err| match err.error() {\n+            // FIXME: `accept` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?\n     };\n \n     if flags.contains(Flags::SOCK_NONBLOCK) {\ndiff --git a/kernel/src/syscall/connect.rs b/kernel/src/syscall/connect.rs\n--- a/kernel/src/syscall/connect.rs\n+++ b/kernel/src/syscall/connect.rs\n@@ -17,6 +17,12 @@ pub fn sys_connect(\n     debug!(\"fd = {sockfd}, socket_addr = {socket_addr:?}\");\n \n     let socket = get_socket_from_fd(sockfd)?;\n-    socket.connect(socket_addr)?;\n+    socket\n+        .connect(socket_addr)\n+        .map_err(|err| match err.error() {\n+            // FIXME: `connect` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?;\n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/kernel/src/syscall/fcntl.rs b/kernel/src/syscall/fcntl.rs\n--- a/kernel/src/syscall/fcntl.rs\n+++ b/kernel/src/syscall/fcntl.rs\n@@ -26,7 +26,10 @@ pub fn sys_fcntl(fd: FileDesc, cmd: i32, arg: u64, ctx: &Context) -> Result<Sysc\n         FcntlCmd::F_SETFL => handle_setfl(fd, arg, ctx),\n         FcntlCmd::F_GETLK => handle_getlk(fd, arg, ctx),\n         FcntlCmd::F_SETLK => handle_setlk(fd, arg, true, ctx),\n-        FcntlCmd::F_SETLKW => handle_setlk(fd, arg, false, ctx),\n+        FcntlCmd::F_SETLKW => handle_setlk(fd, arg, false, ctx).map_err(|err| match err.error() {\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        }),\n         FcntlCmd::F_GETOWN => handle_getown(fd, ctx),\n         FcntlCmd::F_SETOWN => handle_setown(fd, arg, ctx),\n     }\ndiff --git a/kernel/src/syscall/flock.rs b/kernel/src/syscall/flock.rs\n--- a/kernel/src/syscall/flock.rs\n+++ b/kernel/src/syscall/flock.rs\n@@ -30,7 +30,12 @@ pub fn sys_flock(fd: FileDesc, ops: i32, ctx: &Context) -> Result<SyscallReturn>\n             let type_ = FlockType::from(ops);\n             FlockItem::new(&file, type_)\n         };\n-        inode_file.set_flock(flock, is_nonblocking)?;\n+        inode_file\n+            .set_flock(flock, is_nonblocking)\n+            .map_err(|err| match err.error() {\n+                Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+                _ => err,\n+            })?;\n     }\n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/kernel/src/syscall/futex.rs b/kernel/src/syscall/futex.rs\n--- a/kernel/src/syscall/futex.rs\n+++ b/kernel/src/syscall/futex.rs\n@@ -136,13 +136,10 @@ pub fn sys_futex(\n             return_errno_with_message!(Errno::EINVAL, \"unsupported futex op\");\n         }\n     }\n-    .map_err(|e| {\n-        // From Linux manual, Futex returns `ETIMEDOUT` instead of `ETIME`\n-        if e.error() == Errno::ETIME {\n-            Error::with_message(Errno::ETIMEDOUT, \"futex wait timeout\")\n-        } else {\n-            e\n-        }\n+    .map_err(|err| match err.error() {\n+        Errno::ETIME => Error::new(Errno::ETIMEDOUT),\n+        Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+        _ => err,\n     })?;\n \n     debug!(\"futex returns, tid= {} \", ctx.posix_thread.tid());\ndiff --git a/kernel/src/syscall/ioctl.rs b/kernel/src/syscall/ioctl.rs\n--- a/kernel/src/syscall/ioctl.rs\n+++ b/kernel/src/syscall/ioctl.rs\n@@ -56,6 +56,7 @@ pub fn sys_ioctl(fd: FileDesc, cmd: u32, arg: Vaddr, ctx: &Context) -> Result<Sy\n             entry.set_flags(entry.flags() & (!FdFlags::CLOEXEC));\n             0\n         }\n+        // FIXME: ioctl operations involving blocking I/O should be able to restart if interrupted\n         _ => file.ioctl(ioctl_cmd, arg)?,\n     };\n     Ok(SyscallReturn::Return(res as _))\ndiff --git a/kernel/src/syscall/open.rs b/kernel/src/syscall/open.rs\n--- a/kernel/src/syscall/open.rs\n+++ b/kernel/src/syscall/open.rs\n@@ -33,7 +33,11 @@ pub fn sys_openat(\n             .fs()\n             .resolver()\n             .read()\n-            .open(&fs_path, flags, mask_mode)?;\n+            .open(&fs_path, flags, mask_mode)\n+            .map_err(|err| match err.error() {\n+                Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+                _ => err,\n+            })?;\n         Arc::new(inode_handle)\n     };\n     let mut file_table = current.file_table().lock();\ndiff --git a/kernel/src/syscall/read.rs b/kernel/src/syscall/read.rs\n--- a/kernel/src/syscall/read.rs\n+++ b/kernel/src/syscall/read.rs\n@@ -22,16 +22,22 @@ pub fn sys_read(\n     // According to <https://man7.org/linux/man-pages/man2/read.2.html>, if\n     // the user specified an empty buffer, we should detect errors by checking\n     // the file descriptor. If no errors detected, return 0 successfully.\n-    let read_len = if buf_len != 0 {\n-        let mut writer = ctx\n-            .process\n-            .root_vmar()\n-            .vm_space()\n-            .writer(user_buf_addr, buf_len)?;\n-        file.read(&mut writer)?\n-    } else {\n-        file.read_bytes(&mut [])?\n-    };\n+    let read_len = {\n+        if buf_len != 0 {\n+            let mut writer = ctx\n+                .process\n+                .root_vmar()\n+                .vm_space()\n+                .writer(user_buf_addr, buf_len)?;\n+            file.read(&mut writer)\n+        } else {\n+            file.read_bytes(&mut [])\n+        }\n+    }\n+    .map_err(|err| match err.error() {\n+        Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+        _ => err,\n+    })?;\n \n     Ok(SyscallReturn::Return(read_len as _))\n }\ndiff --git a/kernel/src/syscall/recvfrom.rs b/kernel/src/syscall/recvfrom.rs\n--- a/kernel/src/syscall/recvfrom.rs\n+++ b/kernel/src/syscall/recvfrom.rs\n@@ -27,7 +27,14 @@ pub fn sys_recvfrom(\n         vm_space.writer(buf, len)?\n     };\n \n-    let (recv_size, message_header) = socket.recvmsg(&mut writers, flags)?;\n+    let (recv_size, message_header) =\n+        socket\n+            .recvmsg(&mut writers, flags)\n+            .map_err(|err| match err.error() {\n+                // FIXME: `recvfrom` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+                Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+                _ => err,\n+            })?;\n \n     if let Some(socket_addr) = message_header.addr()\n         && src_addr != 0\ndiff --git a/kernel/src/syscall/recvmsg.rs b/kernel/src/syscall/recvmsg.rs\n--- a/kernel/src/syscall/recvmsg.rs\n+++ b/kernel/src/syscall/recvmsg.rs\n@@ -25,7 +25,13 @@ pub fn sys_recvmsg(\n     let (total_bytes, message_header) = {\n         let socket = get_socket_from_fd(sockfd)?;\n         let mut io_vec_writer = c_user_msghdr.copy_writer_array_from_user(ctx)?;\n-        socket.recvmsg(&mut io_vec_writer, flags)?\n+        socket\n+            .recvmsg(&mut io_vec_writer, flags)\n+            .map_err(|err| match err.error() {\n+                // FIXME: `recvmsg` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+                Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+                _ => err,\n+            })?\n     };\n \n     if let Some(addr) = message_header.addr() {\ndiff --git a/kernel/src/syscall/sendmsg.rs b/kernel/src/syscall/sendmsg.rs\n--- a/kernel/src/syscall/sendmsg.rs\n+++ b/kernel/src/syscall/sendmsg.rs\n@@ -39,7 +39,13 @@ pub fn sys_sendmsg(\n         (io_vec_reader, MessageHeader::new(addr, control_message))\n     };\n \n-    let total_bytes = socket.sendmsg(&mut io_vec_reader, message_header, flags)?;\n+    let total_bytes = socket\n+        .sendmsg(&mut io_vec_reader, message_header, flags)\n+        .map_err(|err| match err.error() {\n+            // FIXME: `sendmsg` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?;\n \n     Ok(SyscallReturn::Return(total_bytes as _))\n }\ndiff --git a/kernel/src/syscall/sendto.rs b/kernel/src/syscall/sendto.rs\n--- a/kernel/src/syscall/sendto.rs\n+++ b/kernel/src/syscall/sendto.rs\n@@ -34,7 +34,13 @@ pub fn sys_sendto(\n         let vm_space = ctx.process.root_vmar().vm_space();\n         vm_space.reader(buf, len)?\n     };\n-    let send_size = socket.sendmsg(&mut reader, message_header, flags)?;\n+    let send_size = socket\n+        .sendmsg(&mut reader, message_header, flags)\n+        .map_err(|err| match err.error() {\n+            // FIXME: `sendto` should not be restarted if a timeout has been set on the socket using `setsockopt`.\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?;\n \n     Ok(SyscallReturn::Return(send_size as _))\n }\ndiff --git a/kernel/src/syscall/wait4.rs b/kernel/src/syscall/wait4.rs\n--- a/kernel/src/syscall/wait4.rs\n+++ b/kernel/src/syscall/wait4.rs\n@@ -22,7 +22,11 @@ pub fn sys_wait4(\n     debug!(\"wait4 current pid = {}\", ctx.process.pid());\n     let process_filter = ProcessFilter::from_id(wait_pid as _);\n \n-    let waited_process = wait_child_exit(process_filter, wait_options, ctx)?;\n+    let waited_process =\n+        wait_child_exit(process_filter, wait_options, ctx).map_err(|err| match err.error() {\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?;\n     let Some(process) = waited_process else {\n         return Ok(SyscallReturn::Return(0 as _));\n     };\ndiff --git a/kernel/src/syscall/waitid.rs b/kernel/src/syscall/waitid.rs\n--- a/kernel/src/syscall/waitid.rs\n+++ b/kernel/src/syscall/waitid.rs\n@@ -18,7 +18,11 @@ pub fn sys_waitid(\n     let process_filter = ProcessFilter::from_which_and_id(which, upid)?;\n     let wait_options = WaitOptions::from_bits(options as u32)\n         .ok_or(Error::with_message(Errno::EINVAL, \"invalid options\"))?;\n-    let waited_process = wait_child_exit(process_filter, wait_options, ctx)?;\n+    let waited_process =\n+        wait_child_exit(process_filter, wait_options, ctx).map_err(|err| match err.error() {\n+            Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+            _ => err,\n+        })?;\n     let pid = waited_process.map_or(0, |process| process.pid());\n     Ok(SyscallReturn::Return(pid as _))\n }\ndiff --git a/kernel/src/syscall/write.rs b/kernel/src/syscall/write.rs\n--- a/kernel/src/syscall/write.rs\n+++ b/kernel/src/syscall/write.rs\n@@ -22,16 +22,22 @@ pub fn sys_write(\n     // According to <https://man7.org/linux/man-pages/man2/write.2.html>, if\n     // the user specified an empty buffer, we should detect errors by checking\n     // the file descriptor. If no errors detected, return 0 successfully.\n-    let write_len = if user_buf_len != 0 {\n-        let mut reader = ctx\n-            .process\n-            .root_vmar()\n-            .vm_space()\n-            .reader(user_buf_ptr, user_buf_len)?;\n-        file.write(&mut reader)?\n-    } else {\n-        file.write_bytes(&[])?\n-    };\n+    let write_len = {\n+        if user_buf_len != 0 {\n+            let mut reader = ctx\n+                .process\n+                .root_vmar()\n+                .vm_space()\n+                .reader(user_buf_ptr, user_buf_len)?;\n+            file.write(&mut reader)\n+        } else {\n+            file.write_bytes(&[])\n+        }\n+    }\n+    .map_err(|err| match err.error() {\n+        Errno::EINTR => Error::new(Errno::ERESTARTSYS),\n+        _ => err,\n+    })?;\n \n     Ok(SyscallReturn::Return(write_len as _))\n }\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -64,22 +64,26 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Arc<Thread>)\n         loop {\n             let return_reason = user_mode.execute(has_kernel_event_fn);\n             let user_ctx = user_mode.context_mut();\n+            let mut syscall_number = None;\n             // handle user event:\n             match return_reason {\n                 ReturnReason::UserException => handle_exception(&ctx, user_ctx),\n-                ReturnReason::UserSyscall => handle_syscall(&ctx, user_ctx),\n+                ReturnReason::UserSyscall => {\n+                    syscall_number = Some(user_ctx.syscall_num());\n+                    handle_syscall(&ctx, user_ctx);\n+                }\n                 ReturnReason::KernelEvent => {}\n             };\n \n             if current_thread.is_exited() {\n                 break;\n             }\n-            handle_pending_signal(user_ctx, &ctx).unwrap();\n+            handle_pending_signal(user_ctx, &ctx, syscall_number).unwrap();\n             // If current is suspended, wait for a signal to wake up self\n             while current_thread.is_stopped() {\n                 Thread::yield_now();\n                 debug!(\"{} is suspended.\", current_posix_thread.tid());\n-                handle_pending_signal(user_ctx, &ctx).unwrap();\n+                handle_pending_signal(user_ctx, &ctx, None).unwrap();\n             }\n             if current_thread.is_exited() {\n                 debug!(\"exit due to signal\");\ndiff --git a/ostd/src/arch/x86/trap/syscall.S b/ostd/src/arch/x86/trap/syscall.S\n--- a/ostd/src/arch/x86/trap/syscall.S\n+++ b/ostd/src/arch/x86/trap/syscall.S\n@@ -18,7 +18,7 @@\n .code64\n \n .text\n-    # extern \"sysv64\" fn syscall_return(&mut GeneralRegs)\n+    # extern \"sysv64\" fn syscall_return(&mut UserContext)\n .global syscall_return\n syscall_return:\n     # disable interrupt\ndiff --git a/ostd/src/arch/x86/trap/syscall.S b/ostd/src/arch/x86/trap/syscall.S\n--- a/ostd/src/arch/x86/trap/syscall.S\n+++ b/ostd/src/arch/x86/trap/syscall.S\n@@ -34,7 +34,7 @@ syscall_return:\n \n     push rdi                # keep rsp 16 bytes align\n     mov gs:4, rsp           # store kernel rsp -> TSS.sp0\n-    mov rsp, rdi            # set rsp -> GeneralRegs\n+    mov rsp, rdi            # set rsp -> UserContext\n \n     # restore user gsbase\n     swapgs\ndiff --git a/ostd/src/arch/x86/trap/syscall.S b/ostd/src/arch/x86/trap/syscall.S\n--- a/ostd/src/arch/x86/trap/syscall.S\n+++ b/ostd/src/arch/x86/trap/syscall.S\n@@ -99,8 +99,8 @@ syscall_entry:\n     swapgs                  # swap in kernel gs\n     mov gs:12, rsp          # store user rsp -> scratch at TSS.sp1\n     mov rsp, gs:4           # load kernel rsp <- TSS.sp0\n-    pop rsp                 # load rsp -> GeneralRegs\n-    add rsp, 21*8           # rsp -> error code of GeneralRegs\n+    pop rsp                 # load rsp <- UserContext\n+    add rsp, 21*8           # rsp -> error code of UserContext\n \n     push 0x100              # push trap_num\n     sub rsp, 16             # skip fsbase, gsbase\ndiff --git a/ostd/src/arch/x86/trap/trap.S b/ostd/src/arch/x86/trap/trap.S\n--- a/ostd/src/arch/x86/trap/trap.S\n+++ b/ostd/src/arch/x86/trap/trap.S\n@@ -66,7 +66,7 @@ trap_common:\n __from_user:\n     /*\n     kernel stack:\n-    - ptr to GeneralRegs\n+    - ptr to UserContext\n     - ss\n     - rsp\n     - rflags\ndiff --git a/ostd/src/arch/x86/trap/trap.S b/ostd/src/arch/x86/trap/trap.S\n--- a/ostd/src/arch/x86/trap/trap.S\n+++ b/ostd/src/arch/x86/trap/trap.S\n@@ -80,8 +80,8 @@ __from_user:\n     mov rax, [rsp + 6*8]    # rax = user rsp\n     mov gs:12, rax          # store user rsp -> scratch at TSS.sp1\n \n-    mov rsp, [rsp + 8*8]    # load rsp -> GeneralRegs\n-    add rsp, 22*8           # rsp -> top of GeneralRegs\n+    mov rsp, [rsp + 8*8]    # load rsp <- UserContext\n+    add rsp, 22*8           # rsp -> top of UserContext\n     mov rax, gs:4           # rax = kernel stack\n \n     # push trap_num, error_code\n",
        "test_patch": "diff --git a/test/syscall_test/blocklists/alarm_test /dev/null\n--- a/test/syscall_test/blocklists/alarm_test\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-AlarmTest.UserModeSpinning\n-AlarmTest.Restart_NoRandomSave\n\\ No newline at end of file\n",
        "problem_statement": "Restart signal-interrupted system calls\n### Feature Description\r\n\r\nWhat happens if a POSIX signal is delivered to a thread while it is doing some blocking operation in a system call?\r\n\r\nThe expected behavior  is one of the two below:\r\n1. Return `EINTR`, or\r\n2. Retry the system call.\r\n\r\nThe first behavior is trivial to implement. This issue proposes to add the second one.\r\n\r\n### Problem or Need\r\n\r\nAllow me to quote the man page of [signal(7)](https://man7.org/linux/man-pages/man7/signal.7.html).\r\n\r\n> If a signal handler is invoked while a system call or library function call is blocked, then either:\r\n>\r\n> * the call is automatically restarted after the signal handler returns; or\r\n> * the call fails with the error EINTR.\r\n>\r\n> Which of these two behaviors occurs depends on the interface and whether or not the signal handler was established using the SA_RESTART flag (see [sigaction(2)](https://man7.org/linux/man-pages/man2/sigaction.2.html)).  The details vary across UNIX systems; below, the details for Linux.\r\n>\r\n>  If a blocked call to one of the following interfaces is interrupted by a signal handler, then the call is automatically restarted after the signal handler returns if the SA_RESTART flag was used; otherwise the call fails with the error EINTR:\r\n\r\nSystem calls that will be restarted automatically if the `SA_RESTART` flag is set for the signal handlers include\r\n* `read`, `write`, `ioctl`\r\n* `open`\r\n* `wait`, `waitpid`\r\n* file locks via `fnctl`\r\n* `futex`\r\n\r\nIn particular, we have encountered a CI failure (#1577 ) due to the wrong behavior of signal-interrupted futex system call returning `EINTR`, instead of retrying the system call automatically.\r\n\r\n### Suggested Implementation\r\n\r\nWe need to introduce a general retry mechanism for signal-interrupted system calls. In the case of futex, Linux's futex retry logic can be found [here](https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L706).\r\n\n",
        "hints_text": "> In particular, we have encountered a CI failure (#1577 ) due to the wrong behavior of signal-interrupted futex system call returning `EINTR`, instead of retrying the system call automatically.\r\n\r\nEven if the `futex` system call is restarted, it will still return `EAGAIN` in the case of the failed CI in #1577. See the `futex_wait_restart` function for details.\r\n\r\nhttps://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L714\nIt is also worth noting that the restarting system call stores the [arguments in the `restart_block`](https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L707-L712), which is another motivating case for adding the thread local. Existing motivating examples include the file table (https://github.com/asterinas/asterinas/issues/1550#issue-2631657498) and lockdep (https://github.com/asterinas/asterinas/issues/1550#issuecomment-2463992806).\n> > In particular, we have encountered a CI failure (#1577 ) due to the wrong behavior of signal-interrupted futex system call returning `EINTR`, instead of retrying the system call automatically.\r\n> \r\n> Even if the `futex` system call is restarted, it will still return `EAGAIN` in the case of the failed CI in #1577. See the `futex_wait_restart` function for details.\r\n> \r\n> https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L714\r\n\r\nIn the Linux source code that you referred to, the `futex_wait_restart` function calls `futex_wait` again. I can't see why this retry of `futex_wait` is doomed to return `EAGAIN`.\n> In the Linux source code that you reference, the `futex_wait_restart` function calls `futex_wait` again. I can't see why this retry of `futex_wait` is doomed to return `EAGAIN`.\r\n\r\n@tatetian  You have to follow the code as `futex_wait_restart` -> `futex_wait` -> `__futex_wait` -> `futex_wait_setup` -> [this code snippet](https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L639-L642). (Note in Linux `EWOULDBLOCK` and `EAGAIN` are the same error codes.)\r\n\r\nSo if the `uval` read from userspace is modified at the same time the signal is processed, the restarted `futex` system call will also return `EAGAIN`.\r\n\r\nOf course, the system call test does not actually fail in Linux, because the `uval` is modified _before_ the signal is processed, so the `futex` call will simply succeed _(it will not be restarted)_.\r\n - Following the same principle, we should _avoid returning `EINTR`_ in this case. So whether we have the \"syscall restart\" mechanism or not will _not_ affect whether the CI fails (it shouldn't even be reachable if we follow the Linux implementation).\nI think the actual cause of the failed CI is that signals marked as `SIG_IGN` are noticed by the user program, which causes interruptions during syscalls. This behavior is inconsistent with how Linux handles ignored signals.\r\n\r\n![TLPI_SIG_IGN](https://github.com/user-attachments/assets/82f2a221-d460-41f6-a9be-06e809c32621)\r\n\r\nAdditionally, we should also ignore `SIGCONT` if the process is not stopped and its default disposition hasn't been changed. `SIGCONT` interrupts a running process is found in https://github.com/asterinas/asterinas/issues/1542#issuecomment-2456930970 (Note: The statement about `SA_RESTART` in that comment is incorrect).\r\n\r\n<details><summary>Click to show source code of a test case</summary>\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <sys/mman.h>\r\n#include <pthread.h>\r\n#include <linux/futex.h>      /* Definition of FUTEX_* constants */\r\n#include <sys/syscall.h>      /* Definition of SYS_* constants */\r\n#include <unistd.h>\r\n#include <unistd.h>\r\n#include <stdlib.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include <sys/wait.h>\r\n\r\n// Futex value stored at a global location\r\nint *futex_value;\r\n\r\n// Futex wrapper function (for Linux systems)\r\nint futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3) {\r\n    return syscall(SYS_futex, uaddr, futex_op, val, timeout, uaddr2, val3);\r\n}\r\n\r\n// Function for parent to wait on futex\r\nvoid parent() {\r\n    printf(\"Parent waiting on futex...\\n\");\r\n\r\n    // Wait for futex_value to be modified (i.e., futex_value == 1)\r\n    while (1) {\r\n        int ret = futex(futex_value, FUTEX_WAIT, 0, NULL, NULL, 0);\r\n        if (ret == -1) {\r\n            // Print the error code and corresponding message if futex_wait fails\r\n            if (errno == EINTR) {\r\n                printf(\"futex_wait interrupted by signal (errno %d, %s)\\n\", errno, strerror(errno));\r\n            } else {\r\n                printf(\"futex_wait failed (errno %d, %s)\\n\", errno, strerror(errno));\r\n                exit(1);\r\n            }\r\n        } else {\r\n            printf(\"futex_wait successful, parent awakened!\\n\");\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// Function for child to modify futex_value and signal the parent\r\nvoid child() {\r\n    sleep(5);\r\n\r\n    printf(\"Child changing futex value...\\n\");\r\n\r\n    // Change the futex value to 1\r\n    *futex_value = 1;\r\n\r\n    // Sleep for 5 seconds\r\n    sleep(5);\r\n\r\n    // Send SIGCHLD signal to parent (just for demonstration)\r\n    printf(\"Child sending SIGCHLD to parent...\\n\");\r\n    kill(getppid(), SIGCHLD);\r\n\r\n    // Sleep for 5 seconds\r\n    sleep(5);\r\n\r\n    // Wake the parent by futex_wake\r\n    printf(\"Child waking parent...\\n\");\r\n    int res = futex(futex_value, FUTEX_WAKE, 1, NULL, NULL, 0);\r\n    printf(\"Wakeup num: %d\\n\", res);\r\n}\r\n\r\nint main() {\r\n    pid_t pid;\r\n\r\n    // Initialize futex_value\r\n    futex_value = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\r\n    if (futex_value == MAP_FAILED) {\r\n        perror(\"mmap failed\");\r\n        return 1;\r\n    }\r\n    *futex_value = 0;\r\n\r\n    // Create the child\r\n    pid = fork();\r\n    if (pid == 0)\r\n    {\r\n        child(NULL);\r\n    }\r\n    else {\r\n        parent(NULL);\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n</details>\r\n\r\n![testcase](https://github.com/user-attachments/assets/7f95291d-6f27-4161-be4a-9a6faa7cbc70)\n~~The failed CI is also related to https://github.com/asterinas/asterinas/issues/1587 because it causes `futex` wake to return `1` as if it wakes up one waiting process. As a result, the assert in this line does not fail: https://github.com/google/gvisor/blob/7c2bcddc13c1729e345cfd9a75b910822e4ddcd1/test/syscalls/linux/futex.cc#L520~~\n> I think the actual cause of the failed CI is that signals marked as `SIG_IGN` are noticed by the user program, which causes interruptions during syscalls. This behavior is inconsistent with how Linux handles ignored signals.\r\n\r\nI agree that this is one of the multiple causes of CI failure. This may even be a known issue, as I remember seeing a related FIXME in our codebase (but can't remember where I saw it).\r\n\r\nHowever, I do not think this is the \"root\" cause[^1], because I believe that _even if we register a handler for `SIGCHLD` (so it is no longer `SIG_IGN`), the original CI should not fail_.\r\n\r\nThe reason is pretty clear, as I stated in [my revert PR](https://github.com/asterinas/asterinas/pull/1577#issue-2645632257):\r\n>> Here is the Linux kernel implementation of the `futex` syscall:\r\n>> https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L671-L685\r\n>> Note that `EINTR`/`ERESTARTSYS` is not returned (on line 685) when the futex is awakened (on line 673).\r\n\r\nThe check on line 673 takes precedence over the check on line 685, but in our futex implementation we do not even have a check similar to the one on line 673.\r\n\r\n[^1]: On the other hand, there are multiple reasons for the original CI failure. So arguing about which one is the \"root\" cause doesn't make much sense (and may be subjective). We'd better fix them all.\n> I believe that even if we register a handler for SIGCHLD (so it is no longer SIG_IGN), the original CI should not fail.\r\n\r\n~~I think the CI **will** fail. Since I don't know how to run the gvisor test, I write a test case that establishes an empty `SIGCHLD` handler, and compares it with no sighandler case (using `sed` command to comment out the handler setup):~~\r\n\r\n<details><summary>test source code</summary>\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <sys/mman.h>\r\n#include <pthread.h>\r\n#include <linux/futex.h>      /* Definition of FUTEX_* constants */\r\n#include <sys/syscall.h>      /* Definition of SYS_* constants */\r\n#include <unistd.h>\r\n#include <unistd.h>\r\n#include <stdlib.h>\r\n#include <signal.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include <sys/wait.h>\r\n\r\n// Futex value stored at a global location\r\nint *futex_value;\r\n\r\n// Futex wrapper function (for Linux systems)\r\nint futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3) {\r\n    return syscall(SYS_futex, uaddr, futex_op, val, timeout, uaddr2, val3);\r\n}\r\n\r\nvoid sighandler(int sig)\r\n{\r\n}\r\n\r\n// Function for parent to wait on futex\r\nvoid parent() {\r\n    printf(\"Parent waiting on futex...\\n\");\r\n\r\n    // Wait for futex_value to be modified (i.e., futex_value == 1)\r\n    while (1) {\r\n        int ret = futex(futex_value, FUTEX_WAIT, 0, NULL, NULL, 0);\r\n        if (ret == -1) {\r\n            // Print the error code and corresponding message if futex_wait fails\r\n            if (errno == EINTR) {\r\n                printf(\"futex_wait interrupted by signal (errno %d, %s)\\n\", errno, strerror(errno));\r\n            } else {\r\n                printf(\"futex_wait failed (errno %d, %s)\\n\", errno, strerror(errno));\r\n                exit(1);\r\n            }\r\n        } else {\r\n            printf(\"futex_wait successful, parent awakened!\\n\");\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// Function for child to modify futex_value and signal the parent\r\nvoid child() {\r\n    sleep(5);\r\n\r\n    printf(\"Child changing futex value...\\n\");\r\n\r\n    // Change the futex value to 1\r\n    *futex_value = 1;\r\n\r\n    // Sleep for 5 seconds\r\n    sleep(5);\r\n\r\n    // Send SIGCHLD signal to parent (just for demonstration)\r\n    printf(\"Child sending SIGCHLD to parent...\\n\");\r\n    kill(getppid(), SIGCHLD);\r\n\r\n    // Sleep for 5 seconds\r\n    sleep(5);\r\n\r\n    // Wake the parent by futex_wake\r\n    printf(\"Child waking parent...\\n\");\r\n    int res = futex(futex_value, FUTEX_WAKE, 1, NULL, NULL, 0);\r\n    printf(\"Wakeup num: %d\\n\", res);\r\n}\r\n\r\nint main() {\r\n    // Establish SIGCHLD handler, which does nothing\r\n    signal(SIGCHLD, sighandler);\r\n    printf(\"Established empty sighandler for SIGCHLD\\n\");\r\n    pid_t pid;\r\n\r\n    // Initialize futex_value\r\n    futex_value = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\r\n    if (futex_value == MAP_FAILED) {\r\n        perror(\"mmap failed\");\r\n        return 1;\r\n    }\r\n    *futex_value = 0;\r\n\r\n    // Create the child\r\n    pid = fork();\r\n    if (pid == 0) \r\n    {\r\n        child(NULL);\r\n    }\r\n    else {\r\n        parent(NULL);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n</details>\r\n\r\n![signal_test](https://github.com/user-attachments/assets/24589402-e799-4a4e-9fb4-8c99f0c505f7)\r\n\n> On the other hand, there are multiple reasons for the original CI failure. So arguing about which one is the \"root\" cause doesn't make much sense (and may be subjective). We'd better fix them all.\r\n\r\nI agree that there are multiple causes of the CI failure.\n> I think the CI **will** fail.\r\n\r\n> ```c\r\n>     // Send SIGCHLD signal to parent (just for demonstration)\r\n>     printf(\"Child sending SIGCHLD to parent...\\n\");\r\n>     kill(getppid(), SIGCHLD);\r\n> \r\n>     // Sleep for 5 seconds\r\n>     sleep(5);\r\n> \r\n>     // Wake the parent by futex_wake\r\n>     printf(\"Child waking parent...\\n\");\r\n>     int res = futex(futex_value, FUTEX_WAKE, 1, NULL, NULL, 0);\r\n>     printf(\"Wakeup num: %d\\n\", res);\r\n> ```\r\n\r\nThis is different with the gvisor test. The gvisor test guarantees that the `SIGCHLD` will occur _after_ the `FUTEX_WAKE` call, but you send the `SIGCHLD` _before_ triggering the `FUTEX_WAKE`. I think this is just not the case with the gvisor test.\r\n\n> The gvisor test guarantees that the SIGCHLD will occur after the FUTEX_WAKE call, but you send the SIGCHLD before triggering the FUTEX_WAKE\r\n\r\nAh, that's true. I misunderstood the cleanup behavior. The CI should not fail when wakeup event and signal arrive nealy simultaneously because Linux handles it sophisticatedly (https://github.com/torvalds/linux/blob/da4373fbcf006deda90e5e6a87c499e0ff747572/kernel/futex/waitwake.c#L671-L685). But if pause_timeout returns EINTR in Asterinas, it results in different behavior comparing with Linux. Thanks for pointing it out!",
        "created_at": "2024-11-13T04:36:49Z",
        "version": "0.10"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1559,
        "instance_id": "asterinas__asterinas-1559",
        "issue_numbers": [
            "1554"
        ],
        "base_commit": "11382524d1d23cc6d41adf977a72138baa39e38d",
        "patch": "diff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -114,7 +127,7 @@ impl<T> Producer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -123,7 +136,7 @@ impl<T> Producer<T> {\n         let rb = this_end.rb();\n         if self.is_shutdown() {\n             // The POLLOUT event is always set in this case. Don't try to remove it.\n-        } else if rb.is_full() {\n+        } else if rb.free_len() < PIPE_BUF {\n             this_end.pollee.del_events(IoEvents::OUT);\n         }\n         drop(rb);\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -204,7 +217,7 @@ impl<T> Consumer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -218,7 +231,7 @@ impl<T> Consumer<T> {\n \n         let peer_end = self.peer_end();\n         let rb = peer_end.rb();\n-        if !rb.is_full() {\n+        if rb.free_len() >= PIPE_BUF {\n             peer_end.pollee.add_events(IoEvents::OUT);\n         }\n         drop(rb);\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -307,6 +320,10 @@ impl<R: TRights> Fifo<u8, R> {\n     #[require(R > Write)]\n     pub fn write(&self, reader: &mut dyn MultiRead) -> Result<usize> {\n         let mut rb = self.common.producer.rb();\n+        if rb.free_len() < reader.sum_lens() && reader.sum_lens() <= PIPE_BUF {\n+            // No sufficient space for an atomic write\n+            return Ok(0);\n+        }\n         rb.write_fallible(reader)\n     }\n }\n",
        "test_patch": "diff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -247,7 +247,7 @@ mod test {\n         W: Fn(Arc<PipeWriter>) + Sync + Send + 'static,\n         R: Fn(Arc<PipeReader>) + Sync + Send + 'static,\n     {\n-        let channel = Channel::with_capacity(1);\n+        let channel = Channel::with_capacity(2);\n         let (writer, readr) = channel.split();\n \n         let writer = PipeWriter::new(writer, StatusFlags::empty()).unwrap();\ndiff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -313,13 +313,13 @@ mod test {\n     fn test_write_full() {\n         test_blocking(\n             |writer| {\n-                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2, 3])).unwrap(), 2);\n                 assert_eq!(writer.write(&mut reader_from(&[2])).unwrap(), 1);\n             },\n             |reader| {\n-                let mut buf = [0; 2];\n-                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n-                assert_eq!(&buf[..1], &[1]);\n+                let mut buf = [0; 3];\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 2);\n+                assert_eq!(&buf[..2], &[1, 2]);\n                 assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n                 assert_eq!(&buf[..1], &[2]);\n             },\ndiff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -343,7 +343,7 @@ mod test {\n     fn test_write_closed() {\n         test_blocking(\n             |writer| {\n-                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2, 3])).unwrap(), 2);\n                 assert_eq!(\n                     writer.write(&mut reader_from(&[2])).unwrap_err().error(),\n                     Errno::EPIPE\ndiff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -354,6 +354,24 @@ mod test {\n         );\n     }\n \n+    #[ktest]\n+    fn test_write_atomicity() {\n+        test_blocking(\n+            |writer| {\n+                assert_eq!(writer.write(&mut reader_from(&[1])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 2);\n+            },\n+            |reader| {\n+                let mut buf = [0; 3];\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n+                assert_eq!(&buf[..1], &[1]);\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 2);\n+                assert_eq!(&buf[..2], &[1, 2]);\n+            },\n+            Ordering::WriteThenRead,\n+        );\n+    }\n+\n     fn reader_from(buf: &[u8]) -> VmReader {\n         VmReader::from(buf).to_fallible()\n     }\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -22,6 +22,19 @@ pub struct Channel<T> {\n     consumer: Consumer<T>,\n }\n \n+/// Maximum number of bytes guaranteed to be written to a pipe atomically.\n+///\n+/// If the number of bytes to be written is less than the threshold, the write must be atomic.\n+/// A non-blocking atomic write may fail with `EAGAIN`, even if there is room for a partial write.\n+/// In other words, a partial write is not allowed for an atomic write.\n+///\n+/// For more details, see the description of `PIPE_BUF` in\n+/// <https://man7.org/linux/man-pages/man7/pipe.7.html>.\n+#[cfg(not(ktest))]\n+const PIPE_BUF: usize = 4096;\n+#[cfg(ktest)]\n+const PIPE_BUF: usize = 2;\n+\n impl<T> Channel<T> {\n     /// Creates a new channel with the given capacity.\n     ///\n",
        "problem_statement": "PIPE implementation does not guarantee atomic writes for up to PIPE_BUF bytes\n### Describe the bug\r\n\r\nThe current implementation of the PIPE in Asterinas does not ensure that writes of up to PIPE_BUF bytes are atomic. \r\n\r\n### To Reproduce\r\n\r\nApply the following patch and run `test/pipe/pipe_atomicity`\r\n\r\n<details><summary>patch file</summary>\r\n\r\n```diff\r\ndiff --git a/test/apps/pipe/pipe_atomicity.c b/test/apps/pipe/pipe_atomicity.c\r\nnew file mode 100644\r\nindex 00000000..1e473d78\r\n--- /dev/null\r\n+++ b/test/apps/pipe/pipe_atomicity.c\r\n@@ -0,0 +1,36 @@\r\n+// SPDX-License-Identifier: MPL-2.0\r\n+\r\n+#define _GNU_SOURCE\r\n+\r\n+#include \"../network/test.h\"\r\n+#include <signal.h>\r\n+#include <string.h>\r\n+#include <sys/poll.h>\r\n+#include <unistd.h>\r\n+\r\n+static int rfd, wfd;\r\n+\r\n+FN_SETUP(short_read_and_write)\r\n+{\r\n+       int fildes[2];\r\n+\r\n+       CHECK(pipe(fildes));\r\n+       rfd = fildes[0];\r\n+       wfd = fildes[1];\r\n+\r\n+}\r\n+END_SETUP()\r\n+\r\n+FN_TEST(atomicity)\r\n+{\r\n+       char buf[511] = { 0 };\r\n+\r\n+       // for (int i = 0; i < 130; i++)\r\n+       //      TEST_RES(write(wfd, buf, 511), _ret == 511);\r\n+       for (int i = 0; i < 130; i++)\r\n+       {\r\n+               ssize_t res = write(wfd, buf, 511);\r\n+               printf(\"i=%d, res=%ld\\n\", i, res);\r\n+       }\r\n+}\r\n+END_TEST()\r\n```\r\n</details>\r\n\r\n### Expected behavior\r\n\r\nIn the current Asterinas implementation, writing 511 bytes results in partial writes (128 bytes) after 128 iterations, while the Linux implementation blocks after 127 iterations:\r\n\r\n![aster_vs_linux](https://github.com/user-attachments/assets/e8b9377b-fff3-4c23-bb81-8e3fa6f253e1)\r\n\r\n### Environment\r\n\r\nbranch: [7ddfd42](https://github.com/asterinas/asterinas/tree/7ddfd42baa210656127044995d8707fde74fab4d)\r\n\n",
        "hints_text": "This one is easy to fix. Just check if the remaining space in the internal buffer of a pipe is no less than `PIPE_BUF` before actually writing the data.",
        "created_at": "2024-11-05T07:28:33Z",
        "version": "0.9"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1098,
        "instance_id": "asterinas__asterinas-1098",
        "issue_numbers": [
            "819"
        ],
        "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -59,14 +59,7 @@ impl AnyUnboundSocket {\n     }\n }\n \n-pub struct AnyBoundSocket {\n-    iface: Arc<dyn Iface>,\n-    handle: smoltcp::iface::SocketHandle,\n-    port: u16,\n-    socket_family: SocketFamily,\n-    observer: RwLock<Weak<dyn Observer<()>>>,\n-    weak_self: Weak<Self>,\n-}\n+pub struct AnyBoundSocket(Arc<AnyBoundSocketInner>);\n \n impl AnyBoundSocket {\n     pub(super) fn new(\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -75,21 +68,18 @@ impl AnyBoundSocket {\n         port: u16,\n         socket_family: SocketFamily,\n         observer: Weak<dyn Observer<()>>,\n-    ) -> Arc<Self> {\n-        Arc::new_cyclic(|weak_self| Self {\n+    ) -> Self {\n+        Self(Arc::new(AnyBoundSocketInner {\n             iface,\n             handle,\n             port,\n             socket_family,\n             observer: RwLock::new(observer),\n-            weak_self: weak_self.clone(),\n-        })\n+        }))\n     }\n \n-    pub(super) fn on_iface_events(&self) {\n-        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n-            observer.on_events(&())\n-        }\n+    pub(super) fn inner(&self) -> &Arc<AnyBoundSocketInner> {\n+        &self.0\n     }\n \n     /// Set the observer whose `on_events` will be called when certain iface events happen. After\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -99,34 +89,32 @@ impl AnyBoundSocket {\n     /// that the old observer will never be called after the setting. Users should be aware of this\n     /// and proactively handle the race conditions if necessary.\n     pub fn set_observer(&self, handler: Weak<dyn Observer<()>>) {\n-        *self.observer.write() = handler;\n+        *self.0.observer.write() = handler;\n \n-        self.on_iface_events();\n+        self.0.on_iface_events();\n     }\n \n     pub fn local_endpoint(&self) -> Option<IpEndpoint> {\n         let ip_addr = {\n-            let ipv4_addr = self.iface.ipv4_addr()?;\n+            let ipv4_addr = self.0.iface.ipv4_addr()?;\n             IpAddress::Ipv4(ipv4_addr)\n         };\n-        Some(IpEndpoint::new(ip_addr, self.port))\n+        Some(IpEndpoint::new(ip_addr, self.0.port))\n     }\n \n     pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n         &self,\n-        mut f: F,\n+        f: F,\n     ) -> R {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<T>(self.handle);\n-        f(socket)\n+        self.0.raw_with(f)\n     }\n \n     /// Try to connect to a remote endpoint. Tcp socket only.\n     pub fn do_connect(&self, remote_endpoint: IpEndpoint) -> Result<()> {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<RawTcpSocket>(self.handle);\n-        let port = self.port;\n-        let mut iface_inner = self.iface.iface_inner();\n+        let mut sockets = self.0.iface.sockets();\n+        let socket = sockets.get_mut::<RawTcpSocket>(self.0.handle);\n+        let port = self.0.port;\n+        let mut iface_inner = self.0.iface.iface_inner();\n         let cx = iface_inner.context();\n         socket\n             .connect(cx, remote_endpoint, port)\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -135,28 +123,84 @@ impl AnyBoundSocket {\n     }\n \n     pub fn iface(&self) -> &Arc<dyn Iface> {\n-        &self.iface\n+        &self.0.iface\n     }\n+}\n \n-    pub(super) fn weak_ref(&self) -> Weak<Self> {\n-        self.weak_self.clone()\n+impl Drop for AnyBoundSocket {\n+    fn drop(&mut self) {\n+        if self.0.start_closing() {\n+            self.0.iface.common().remove_bound_socket_now(&self.0);\n+        } else {\n+            self.0\n+                .iface\n+                .common()\n+                .remove_bound_socket_when_closed(&self.0);\n+        }\n     }\n+}\n \n-    fn close(&self) {\n+pub(super) struct AnyBoundSocketInner {\n+    iface: Arc<dyn Iface>,\n+    handle: smoltcp::iface::SocketHandle,\n+    port: u16,\n+    socket_family: SocketFamily,\n+    observer: RwLock<Weak<dyn Observer<()>>>,\n+}\n+\n+impl AnyBoundSocketInner {\n+    pub(super) fn on_iface_events(&self) {\n+        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n+            observer.on_events(&())\n+        }\n+    }\n+\n+    pub(super) fn is_closed(&self) -> bool {\n+        match self.socket_family {\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => true,\n+        }\n+    }\n+\n+    /// Starts closing the socket and returns whether the socket is closed.\n+    ///\n+    /// For sockets that can be closed immediately, such as UDP sockets and TCP listening sockets,\n+    /// this method will always return `true`.\n+    ///\n+    /// For other sockets, such as TCP connected sockets, they cannot be closed immediately because\n+    /// we at least need to send the FIN packet and wait for the remote end to send an ACK packet.\n+    /// In this case, this method will return `false` and [`Self::is_closed`] can be used to\n+    /// determine if the closing process is complete.\n+    fn start_closing(&self) -> bool {\n         match self.socket_family {\n-            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| socket.close()),\n-            SocketFamily::Udp => self.raw_with(|socket: &mut RawUdpSocket| socket.close()),\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.close();\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => {\n+                self.raw_with(|socket: &mut RawUdpSocket| socket.close());\n+                true\n+            }\n         }\n     }\n+\n+    pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n+        &self,\n+        mut f: F,\n+    ) -> R {\n+        let mut sockets = self.iface.sockets();\n+        let socket = sockets.get_mut::<T>(self.handle);\n+        f(socket)\n+    }\n }\n \n-impl Drop for AnyBoundSocket {\n+impl Drop for AnyBoundSocketInner {\n     fn drop(&mut self) {\n-        self.close();\n-        self.iface.poll();\n-        self.iface.common().remove_socket(self.handle);\n-        self.iface.common().release_port(self.port);\n-        self.iface.common().remove_bound_socket(self.weak_ref());\n+        let iface_common = self.iface.common();\n+        iface_common.remove_socket(self.handle);\n+        iface_common.release_port(self.port);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,7 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n-use keyable_arc::KeyableWeak;\n+use keyable_arc::KeyableArc;\n use ostd::sync::WaitQueue;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -12,10 +12,10 @@ use smoltcp::{\n };\n \n use super::{\n-    any_socket::{AnyBoundSocket, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n+    any_socket::{AnyBoundSocketInner, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n     time::get_network_timestamp,\n     util::BindPortConfig,\n-    Iface, Ipv4Address,\n+    AnyBoundSocket, Iface, Ipv4Address,\n };\n use crate::prelude::*;\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -25,7 +25,8 @@ pub struct IfaceCommon {\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n     /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n-    bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    bound_sockets: RwLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n+    closing_sockets: SpinLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n     /// The wait queue that background polling thread will sleep on\n     polling_wait_queue: WaitQueue,\n }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -40,14 +41,21 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            closing_sockets: SpinLock::new(BTreeSet::new()),\n             polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \n+    /// Acquires the lock to the interface.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn interface(&self) -> SpinLockGuard<smoltcp::iface::Interface> {\n         self.interface.lock_irq_disabled()\n     }\n \n+    /// Acuqires the lock to the sockets.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn sockets(&self) -> SpinLockGuard<smoltcp::iface::SocketSet<'static>> {\n         self.sockets.lock_irq_disabled()\n     }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -109,7 +117,7 @@ impl IfaceCommon {\n         iface: Arc<dyn Iface>,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let port = if let Some(port) = config.port() {\n             port\n         } else {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -135,7 +143,7 @@ impl IfaceCommon {\n             ),\n         };\n         let bound_socket = AnyBoundSocket::new(iface, handle, port, socket_family, observer);\n-        self.insert_bound_socket(&bound_socket).unwrap();\n+        self.insert_bound_socket(bound_socket.inner());\n \n         Ok(bound_socket)\n     }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -146,37 +154,60 @@ impl IfaceCommon {\n     }\n \n     pub(super) fn poll<D: Device + ?Sized>(&self, device: &mut D) {\n+        let mut sockets = self.sockets.lock_irq_disabled();\n         let mut interface = self.interface.lock_irq_disabled();\n+\n         let timestamp = get_network_timestamp();\n-        let has_events = {\n-            let mut sockets = self.sockets.lock_irq_disabled();\n-            interface.poll(timestamp, device, &mut sockets)\n-            // drop sockets here to avoid deadlock\n-        };\n-        if has_events {\n-            self.bound_sockets.read().iter().for_each(|bound_socket| {\n-                if let Some(bound_socket) = bound_socket.upgrade() {\n-                    bound_socket.on_iface_events();\n+        let (has_events, poll_at) = {\n+            let mut has_events = false;\n+            let mut poll_at;\n+            loop {\n+                has_events |= interface.poll(timestamp, device, &mut sockets);\n+                poll_at = interface.poll_at(timestamp, &sockets);\n+                let Some(instant) = poll_at else {\n+                    break;\n+                };\n+                if instant > timestamp {\n+                    break;\n                 }\n-            });\n-        }\n+            }\n+            (has_events, poll_at)\n+        };\n+\n+        // drop sockets here to avoid deadlock\n+        drop(interface);\n+        drop(sockets);\n \n-        let sockets = self.sockets.lock_irq_disabled();\n-        if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n-            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+        if let Some(instant) = poll_at {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Relaxed);\n             let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms.store(new_instant, Ordering::Relaxed);\n \n-            if new_instant < old_instant {\n+            if old_instant == 0 || new_instant < old_instant {\n                 self.polling_wait_queue.wake_all();\n             }\n         } else {\n             self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n+\n+        if has_events {\n+            // We never try to hold the write lock in the IRQ context, and we disable IRQ when\n+            // holding the write lock. So we don't need to disable IRQ when holding the read lock.\n+            self.bound_sockets.read().iter().for_each(|bound_socket| {\n+                bound_socket.on_iface_events();\n+            });\n+\n+            let closed_sockets = self\n+                .closing_sockets\n+                .lock_irq_disabled()\n+                .extract_if(|closing_socket| closing_socket.is_closed())\n+                .collect::<Vec<_>>();\n+            drop(closed_sockets);\n+        }\n     }\n \n     pub(super) fn next_poll_at_ms(&self) -> Option<u64> {\n-        let millis = self.next_poll_at_ms.load(Ordering::SeqCst);\n+        let millis = self.next_poll_at_ms.load(Ordering::Relaxed);\n         if millis == 0 {\n             None\n         } else {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -184,19 +215,44 @@ impl IfaceCommon {\n         }\n     }\n \n-    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocket>) -> Result<()> {\n-        let weak_ref = KeyableWeak::from(Arc::downgrade(socket));\n-        let mut bound_sockets = self.bound_sockets.write();\n-        if bound_sockets.contains(&weak_ref) {\n-            return_errno_with_message!(Errno::EINVAL, \"the socket is already bound\");\n-        }\n-        bound_sockets.insert(weak_ref);\n-        Ok(())\n+    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let inserted = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .insert(keyable_socket);\n+        assert!(inserted);\n     }\n \n-    pub(super) fn remove_bound_socket(&self, socket: Weak<AnyBoundSocket>) {\n-        let weak_ref = KeyableWeak::from(socket);\n-        self.bound_sockets.write().remove(&weak_ref);\n+    pub(super) fn remove_bound_socket_now(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+    }\n+\n+    pub(super) fn remove_bound_socket_when_closed(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+\n+        let mut closing_sockets = self.closing_sockets.lock_irq_disabled();\n+\n+        // Check `is_closed` after holding the lock to avoid race conditions.\n+        if keyable_socket.is_closed() {\n+            return;\n+        }\n+\n+        let inserted = closing_sockets.insert(keyable_socket);\n+        assert!(inserted);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -45,7 +45,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n         &self,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let common = self.common();\n         common.bind_socket(self.arc_self(), socket, config)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/common.rs b/kernel/aster-nix/src/net/socket/ip/common.rs\n--- a/kernel/aster-nix/src/net/socket/ip/common.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/common.rs\n@@ -46,7 +46,7 @@ pub(super) fn bind_socket(\n     unbound_socket: Box<AnyUnboundSocket>,\n     endpoint: &IpEndpoint,\n     can_reuse: bool,\n-) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n     let iface = match get_iface_to_bind(&endpoint.addr) {\n         Some(iface) => iface,\n         None => {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n--- a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n@@ -13,12 +13,12 @@ use crate::{\n };\n \n pub struct BoundDatagram {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: Option<IpEndpoint>,\n }\n \n impl BoundDatagram {\n-    pub fn new(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new(bound_socket: AnyBoundSocket) -> Self {\n         Self {\n             bound_socket,\n             remote_endpoint: None,\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -15,7 +15,7 @@ use crate::{\n };\n \n pub struct ConnectedStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     /// Indicates whether this connection is \"new\" in a `connect()` system call.\n     ///\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -32,7 +32,7 @@ pub struct ConnectedStream {\n \n impl ConnectedStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n         is_new_connection: bool,\n     ) -> Self {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub struct ConnectingStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     conn_result: RwLock<Option<ConnResult>>,\n }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -26,9 +26,9 @@ pub enum NonConnectedStream {\n \n impl ConnectingStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         if let Err(err) = bound_socket.do_connect(remote_endpoint) {\n             return Err((err, bound_socket));\n         }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -15,7 +15,7 @@ use crate::{\n \n pub enum InitStream {\n     Unbound(Box<AnyUnboundSocket>),\n-    Bound(Arc<AnyBoundSocket>),\n+    Bound(AnyBoundSocket),\n }\n \n impl InitStream {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -23,14 +23,14 @@ impl InitStream {\n         InitStream::Unbound(Box::new(AnyUnboundSocket::new_tcp(observer)))\n     }\n \n-    pub fn new_bound(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new_bound(bound_socket: AnyBoundSocket) -> Self {\n         InitStream::Bound(bound_socket)\n     }\n \n     pub fn bind(\n         self,\n         endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let unbound_socket = match self {\n             InitStream::Unbound(unbound_socket) => unbound_socket,\n             InitStream::Bound(bound_socket) => {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -50,7 +50,7 @@ impl InitStream {\n     fn bind_to_ephemeral_endpoint(\n         self,\n         remote_endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let endpoint = get_ephemeral_endpoint(remote_endpoint);\n         self.bind(&endpoint)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -13,16 +13,16 @@ use crate::{\n pub struct ListenStream {\n     backlog: usize,\n     /// A bound socket held to ensure the TCP port cannot be released\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     /// Backlog sockets listening at the local endpoint\n     backlog_sockets: RwLock<Vec<BacklogSocket>>,\n }\n \n impl ListenStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         backlog: usize,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         let listen_stream = Self {\n             backlog,\n             bound_socket,\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -99,13 +99,13 @@ impl ListenStream {\n }\n \n struct BacklogSocket {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n }\n \n impl BacklogSocket {\n     // FIXME: All of the error codes below seem to have no Linux equivalents, and I see no reason\n     // why the error may occur. Perhaps it is better to call `unwrap()` directly?\n-    fn new(bound_socket: &Arc<AnyBoundSocket>) -> Result<Self> {\n+    fn new(bound_socket: &AnyBoundSocket) -> Result<Self> {\n         let local_endpoint = bound_socket.local_endpoint().ok_or(Error::with_message(\n             Errno::EINVAL,\n             \"the socket is not bound\",\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -143,7 +143,7 @@ impl BacklogSocket {\n             .raw_with(|socket: &mut RawTcpSocket| socket.remote_endpoint())\n     }\n \n-    fn into_bound_socket(self) -> Arc<AnyBoundSocket> {\n+    fn into_bound_socket(self) -> AnyBoundSocket {\n         self.bound_socket\n     }\n }\n",
        "test_patch": "diff --git a/test/apps/network/listen_backlog.c b/test/apps/network/listen_backlog.c\n--- a/test/apps/network/listen_backlog.c\n+++ b/test/apps/network/listen_backlog.c\n@@ -131,7 +131,7 @@ int main(void)\n \n \tfor (backlog = 0; backlog <= MAX_TEST_BACKLOG; ++backlog) {\n \t\t// Avoid \"bind: Address already in use\"\n-\t\taddr.sin_port = htons(8080 + backlog);\n+\t\taddr.sin_port = htons(10000 + backlog);\n \n \t\terr = test_listen_backlog(&addr, backlog);\n \t\tif (err != 0)\ndiff --git a/test/apps/network/send_buf_full.c b/test/apps/network/send_buf_full.c\n--- a/test/apps/network/send_buf_full.c\n+++ b/test/apps/network/send_buf_full.c\n@@ -265,7 +265,7 @@ int main(void)\n \tstruct sockaddr_in addr;\n \n \taddr.sin_family = AF_INET;\n-\taddr.sin_port = htons(8080);\n+\taddr.sin_port = htons(9999);\n \tif (inet_aton(\"127.0.0.1\", &addr.sin_addr) < 0) {\n \t\tfprintf(stderr, \"inet_aton cannot parse 127.0.0.1\\n\");\n \t\treturn -1;\ndiff --git a/test/apps/network/tcp_err.c b/test/apps/network/tcp_err.c\n--- a/test/apps/network/tcp_err.c\n+++ b/test/apps/network/tcp_err.c\n@@ -338,26 +338,23 @@ FN_TEST(sendmsg_and_recvmsg)\n \n \t// Send two message and receive two message\n \n-\t// This test is commented out due to a known issue:\n-\t// See <https://github.com/asterinas/asterinas/issues/819>\n-\n-\t// iov[0].iov_base = message;\n-\t// iov[0].iov_len = strlen(message);\n-\t// msg.msg_iovlen = 1;\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\n-\t// char first_buffer[BUFFER_SIZE] = { 0 };\n-\t// char second_buffer[BUFFER_SIZE] = { 0 };\n-\t// iov[0].iov_base = first_buffer;\n-\t// iov[0].iov_len = BUFFER_SIZE;\n-\t// iov[1].iov_base = second_buffer;\n-\t// iov[1].iov_len = BUFFER_SIZE;\n-\t// msg.msg_iovlen = 2;\n-\n-\t// // Ensure two messages are prepared for receiving\n-\t// sleep(1);\n-\n-\t// TEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n+\tiov[0].iov_base = message;\n+\tiov[0].iov_len = strlen(message);\n+\tmsg.msg_iovlen = 1;\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\n+\tchar first_buffer[BUFFER_SIZE] = { 0 };\n+\tchar second_buffer[BUFFER_SIZE] = { 0 };\n+\tiov[0].iov_base = first_buffer;\n+\tiov[0].iov_len = BUFFER_SIZE;\n+\tiov[1].iov_base = second_buffer;\n+\tiov[1].iov_len = BUFFER_SIZE;\n+\tmsg.msg_iovlen = 2;\n+\n+\t// Ensure two messages are prepared for receiving\n+\tsleep(1);\n+\n+\tTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n }\n END_TEST()\n",
        "problem_statement": "Polling ifaces may not ensure packets be transmitted\nThe problem occurs when I trying to send two messages to the same TCP socket, and trying to receive the two messages at once.\r\n\r\n```C\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\n\r\n// Ensure two messages are ready for receiving\r\nsleep(1);\r\n\r\nTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\r\n```\r\n\r\nThe test program always succeeds when running on Linux.\r\n\r\nHowever, when running on Asterinas, `sk_connected` can only accept the first message.\r\n\r\nThe problem disappears when I running in set log level as TRACE. So it may be some problems with timeout.......\r\n\r\n# Possible solution\r\n\r\nThis problem may be related to the [nagle-enabled feature](https://docs.rs/smoltcp/latest/smoltcp/socket/tcp/struct.Socket.html#method.set_nagle_enabled), which disables small packets to be transmitted. If set `nagle-enabled` as false, the problem will also disappear.\r\n\r\nBut totally disabling this feature may affect performance. This feature is same as the `TCP_NODELAY` option in Linux, but Linux keeps this option on by default.\n",
        "hints_text": "",
        "created_at": "2024-07-26T01:51:02Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1073,
        "instance_id": "asterinas__asterinas-1073",
        "issue_numbers": [
            "1069"
        ],
        "base_commit": "5aa28eae7e14594bbe68827114443b31002bf742",
        "patch": "diff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -58,6 +58,16 @@ SECTIONS\n     # areas for the application processors.\n     .cpu_local              : AT(ADDR(.cpu_local) - KERNEL_VMA) {\n         __cpu_local_start = .;\n+\n+        # These 4 bytes are used to store the CPU ID.\n+        . += 4;\n+\n+        # These 4 bytes are used to store the number of preemption locks held.\n+        # The reason is stated in the Rust documentation of\n+        # [`ostd::task::processor::PreemptInfo`].\n+        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n+        . += 4;\n+\n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git /dev/null b/ostd/src/arch/x86/cpu/local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Architecture dependent CPU-local information utilities.\n+\n+use x86_64::registers::segmentation::{Segment64, FS};\n+\n+/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n+/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n+///\n+/// # Safety\n+///\n+///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n+///    and is not concurrently accessed for other purposes.\n+///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n+///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n+///    such as during processor initialization.\n+pub(crate) unsafe fn set_base(addr: u64) {\n+    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n+}\n+\n+/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n+pub(crate) fn get_base() -> u64 {\n+    FS::read_base().as_u64()\n+}\n+\n+pub mod preempt_lock_count {\n+    //! We need to increment/decrement the per-CPU preemption lock count using\n+    //! a single instruction. This requirement is stated by\n+    //! [`crate::task::processor::PreemptInfo`].\n+\n+    /// The GDT ensures that the FS segment is initialized to zero on boot.\n+    /// This assertion checks that the base address has been set.\n+    macro_rules! debug_assert_initialized {\n+        () => {\n+            // The compiler may think that [`super::get_base`] has side effects\n+            // so it may not be optimized out. We make sure that it will be\n+            // conditionally compiled only in debug builds.\n+            #[cfg(debug_assertions)]\n+            debug_assert_ne!(super::get_base(), 0);\n+        };\n+    }\n+\n+    /// Increments the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn inc() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly increments the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Decrements the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn dec() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly decrements the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Gets the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn get() -> u32 {\n+        debug_assert_initialized!();\n+\n+        let count: u32;\n+        // SAFETY: The inline assembly reads the lock count in one instruction\n+        // without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n+                out(reg) count,\n+                options(nostack, readonly),\n+            );\n+        }\n+        count\n+    }\n+}\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -2,6 +2,8 @@\n \n //! CPU.\n \n+pub mod local;\n+\n use alloc::vec::Vec;\n use core::{\n     arch::x86_64::{_fxrstor, _fxsave},\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -18,10 +20,7 @@ use log::debug;\n use tdx_guest::tdcall;\n pub use trapframe::GeneralRegs as RawGeneralRegs;\n use trapframe::UserContext as RawUserContext;\n-use x86_64::registers::{\n-    rflags::RFlags,\n-    segmentation::{Segment64, FS},\n-};\n+use x86_64::registers::rflags::RFlags;\n \n #[cfg(feature = \"intel_tdx\")]\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -673,22 +672,3 @@ impl Default for FpRegs {\n struct FxsaveArea {\n     data: [u8; 512], // 512 bytes\n }\n-\n-/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n-/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n-///\n-/// # Safety\n-///\n-///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n-///    and is not concurrently accessed for other purposes.\n-///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n-///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n-///    such as during processor initialization.\n-pub(crate) unsafe fn set_cpu_local_base(addr: u64) {\n-    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n-}\n-\n-/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n-pub(crate) fn get_cpu_local_base() -> u64 {\n-    FS::read_base().as_u64()\n-}\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -21,7 +21,7 @@\n use core::ops::Deref;\n \n use crate::{\n-    cpu::{get_cpu_local_base, set_cpu_local_base},\n+    arch,\n     trap::{disable_local, DisabledLocalIrqGuard},\n };\n \ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -82,6 +82,13 @@ impl<T> !Clone for CpuLocal<T> {}\n // other tasks as they should live on other CPUs to make sending useful.\n impl<T> !Send for CpuLocal<T> {}\n \n+// A check to ensure that the CPU-local object is never accessed before the\n+// initialization for all CPUs.\n+#[cfg(debug_assertions)]\n+use core::sync::atomic::{AtomicBool, Ordering};\n+#[cfg(debug_assertions)]\n+static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n+\n impl<T> CpuLocal<T> {\n     /// Initialize a CPU-local object.\n     ///\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -115,6 +122,11 @@ impl<T> CpuLocal<T> {\n     /// This function calculates the virtual address of the CPU-local object based on the per-\n     /// cpu base address and the offset in the BSP.\n     fn get(&self) -> *const T {\n+        // CPU-local objects should be initialized before being accessed. It should be ensured\n+        // by the implementation of OSTD initialization.\n+        #[cfg(debug_assertions)]\n+        debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n+\n         let offset = {\n             let bsp_va = self as *const _ as usize;\n             let bsp_base = __cpu_local_start as usize;\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -124,7 +136,7 @@ impl<T> CpuLocal<T> {\n             bsp_va - bsp_base as usize\n         };\n \n-        let local_base = get_cpu_local_base() as usize;\n+        let local_base = arch::cpu::local::get_base() as usize;\n         let local_va = local_base + offset;\n \n         // A sanity check about the alignment.\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -170,6 +182,24 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n     }\n }\n \n+/// Sets the base address of the CPU-local storage for the bootstrap processor.\n+///\n+/// It should be called early to let [`crate::task::disable_preempt`] work,\n+/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// panic when calling [`crate::task::disable_preempt`].\n+///\n+/// # Safety\n+///\n+/// It should be called only once and only on the BSP.\n+pub(crate) unsafe fn early_init_bsp_local_base() {\n+    let start_base_va = __cpu_local_start as usize as u64;\n+    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n+    // where accessing the CPU-local objects have defined behaviors.\n+    unsafe {\n+        arch::cpu::local::set_base(start_base_va);\n+    }\n+}\n+\n /// Initializes the CPU local data for the bootstrap processor (BSP).\n ///\n /// # Safety\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -179,9 +209,14 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n /// It must be guaranteed that the BSP will not access local data before\n /// this function being called, otherwise copying non-constant values\n /// will result in pretty bad undefined behavior.\n-pub unsafe fn init_on_bsp() {\n-    let start_base_va = __cpu_local_start as usize as u64;\n-    set_cpu_local_base(start_base_va);\n+pub(crate) unsafe fn init_on_bsp() {\n+    // TODO: allocate the pages for application processors and copy the\n+    // CPU-local objects to the allocated pages.\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        IS_INITIALIZED.store(true, Ordering::Relaxed);\n+    }\n }\n \n // These symbols are provided by the linker script.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -59,6 +59,9 @@ pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n pub fn init() {\n     arch::before_all_init();\n \n+    // SAFETY: This function is called only once and only on the BSP.\n+    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+\n     mm::heap_allocator::init();\n \n     boot::init();\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -340,8 +340,10 @@ impl<'a> VmReader<'a, KernelSpace> {\n     /// it should _not_ overlap with other `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *const u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -516,8 +518,10 @@ impl<'a> VmWriter<'a, KernelSpace> {\n     /// is typed, it should _not_ overlap with other `VmReader`s and `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *mut u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,17 +1,14 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::{\n-    cell::RefCell,\n-    sync::atomic::{AtomicUsize, Ordering::Relaxed},\n-};\n+use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::cpu_local;\n+use crate::{arch, cpu_local};\n \n pub struct Processor {\n     current: Option<Arc<Task>>,\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -154,38 +151,50 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-cpu_local! {\n-    static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-}\n+static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n \n-/// Currently, ``PreemptInfo`` only holds the number of spin\n-/// locks held by the current CPU. When it has a non-zero value,\n-/// the CPU cannot call ``schedule()``.\n-struct PreemptInfo {\n-    num_locks: AtomicUsize,\n-}\n+/// Currently, it only holds the number of preemption locks held by the\n+/// current CPU. When it has a non-zero value, the CPU cannot call\n+/// [`schedule()`].\n+///\n+/// For per-CPU preemption lock count, we cannot afford two non-atomic\n+/// operations to increment and decrement the count. The [`crate::cpu_local`]\n+/// implementation is free to read the base register and then calculate the\n+/// address of the per-CPU variable using an additional instruction. Interrupts\n+/// can happen between the address calculation and modification to that\n+/// address. If the task is preempted to another CPU by this interrupt, the\n+/// count of the original CPU will be mistakenly modified. To avoid this, we\n+/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n+/// can implement this using one instruction. In other less expressive\n+/// architectures, we may need to disable interrupts.\n+///\n+/// Also, the preemption count is reserved in the `.cpu_local` section\n+/// specified in the linker script. The reason is that we need to access the\n+/// preemption count before we can copy the section for application processors.\n+/// So, the preemption count is not copied from bootstrap processor's section\n+/// as the initialization. Instead it is initialized to zero for application\n+/// processors.\n+struct PreemptInfo {}\n \n impl PreemptInfo {\n     const fn new() -> Self {\n-        Self {\n-            num_locks: AtomicUsize::new(0),\n-        }\n+        Self {}\n     }\n \n     fn increase_num_locks(&self) {\n-        self.num_locks.fetch_add(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::inc();\n     }\n \n     fn decrease_num_locks(&self) {\n-        self.num_locks.fetch_sub(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::dec();\n     }\n \n     fn is_preemptive(&self) -> bool {\n-        self.num_locks.load(Relaxed) == 0\n+        arch::cpu::local::preempt_lock_count::get() == 0\n     }\n \n     fn num_locks(&self) -> usize {\n-        self.num_locks.load(Relaxed)\n+        arch::cpu::local::preempt_lock_count::get() as usize\n     }\n }\n \n",
        "test_patch": "diff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -60,36 +60,24 @@ jobs:\n         id: boot_test_mb\n         run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=multiboot RELEASE=1\n \n-      - name: Boot Test (Multiboot2)\n-        id: boot_test_mb2\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=multiboot2 RELEASE=1\n-\n-      - name: Boot Test (MicroVM)\n-        id: boot_test_microvm\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 SCHEME=microvm RELEASE=1\n-\n       - name: Boot Test (Linux Legacy 32-bit Boot Protocol)\n         id: boot_test_linux_legacy32\n         run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=linux-legacy32 RELEASE=1\n \n-      - name: Boot Test (Linux EFI Handover Boot Protocol)\n-        id: boot_test_linux_efi_handover64\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n-\n-      - name: Syscall Test (Linux EFI Handover Boot Protocol)\n+      - name: Syscall Test (Linux EFI Handover Boot Protocol) (Debug Build)\n         id: syscall_test\n-        run: make run AUTO_TEST=syscall ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n+        run: make run AUTO_TEST=syscall ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=0\n \n       - name: Syscall Test at Ext2 (MicroVM)\n         id: syscall_test_at_ext2\n         run: make run AUTO_TEST=syscall SYSCALL_TEST_DIR=/ext2 ENABLE_KVM=1 SCHEME=microvm RELEASE=1\n \n-      - name: Syscall Test at Exfat and without KVM enabled\n+      - name: Syscall Test at Exfat (Multiboot2) (without KVM enabled)\n         id: syscall_test_at_exfat_linux\n         run: |\n           make run AUTO_TEST=syscall \\\n             SYSCALL_TEST_DIR=/exfat EXTRA_BLOCKLISTS_DIRS=blocklists.exfat \\\n-            ENABLE_KVM=0 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n+            ENABLE_KVM=0 BOOT_PROTOCOL=multiboot2 RELEASE=1\n \n       - name: General Test (Linux EFI Handover Boot Protocol)\n         id: test_linux\n",
        "problem_statement": "CPU local memory is used before initialized\nThe use (in `ostd`):\r\n`init` \u2192 `mm::heap_allocator::init` \u2192 `HEAP_ALLOCATOR.init` \u2192 `SpinLock::lock_irq_disabled` \u2192 `trap::irq::disable_local` \u2192 `task::processor::disable_preempt` \u2192 `PREEMPT_COUNT.increase_num_locks`, where `PREEMPT_COUNT` is a cpu-local variable.\r\n\r\nThe initialization:\r\n`init` \u2192 `cpu::cpu_local::init_on_bsp` \u2192 ...\r\n\r\nThe use is before the initialization since `mm::heap_allocator::init` is called prior to `cpu::cpu_local::init_on_bsp`.\r\nhttps://github.com/asterinas/asterinas/blob/94eba6d85eb9e62ddd904c1132d556b808cc3174/ostd/src/lib.rs#L51-L82\r\n\r\n---\r\n\r\nIt does not fault in x86 because `fsbase` is by default `0`, and the OS has write access to the memory near `0x0`, so the error is silent. But in RISC-V, this memory region is not writable, so it faults.\r\n\r\nAnd I guess this is not the only case since `SpinLock` is widely used in `ostd`, it might be other uses of `SpinLock` before CPU local memory is initialized, for example, `mm::kspace::init_boot_page_table` \u2192 `BOOT_PAGE_TABLE.lock`.\n",
        "hints_text": "Modifying `ostd::arch::x86::cpu::get_cpu_local_base` to\r\n``` rust\r\n/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\r\npub(crate) fn get_cpu_local_base() -> u64 {\r\n    let fsbase = FS::read_base().as_u64();\r\n    debug_assert_ne!(fsbase, 0, \"CPU local memory is used before initialized\");\r\n    fsbase\r\n}\r\n```\r\nmay help with discovering cpu local used before initialization bugs.\n> And I guess this is not the only case since SpinLock is widely used in ostd, it might be other uses of SpinLock before CPU local memory is initialized, for example, mm::kspace::init_boot_page_table \u2192 BOOT_PAGE_TABLE.lock.\r\n\r\nIndeed. CPU local variables should not be accessed before initialization of `mod cpu_local`. I will look into it.",
        "created_at": "2024-07-19T13:26:35Z",
        "version": "0.6"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1026,
        "instance_id": "asterinas__asterinas-1026",
        "issue_numbers": [
            "681"
        ],
        "base_commit": "94eba6d85eb9e62ddd904c1132d556b808cc3174",
        "patch": "diff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -5,7 +5,9 @@\n \n use core::ops::Range;\n \n-use ostd::mm::{Frame, FrameVec, PageFlags, VmIo, VmMapOptions, VmSpace};\n+use ostd::mm::{\n+    vm_space::VmQueryResult, CachePolicy, Frame, PageFlags, PageProperty, VmIo, VmSpace,\n+};\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\n use crate::{\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -194,22 +196,41 @@ impl VmMapping {\n         let write_perms = VmPerms::WRITE;\n         self.check_perms(&write_perms)?;\n \n-        let mut page_addr =\n-            self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n-        for page_idx in page_idx_range {\n-            let parent = self.parent.upgrade().unwrap();\n-            let vm_space = parent.vm_space();\n-\n-            // The `VmMapping` has the write permission but the corresponding PTE is present and is read-only.\n-            // This means this PTE is set to read-only due to the COW mechanism. In this situation we need to trigger a\n-            // page fault before writing at the VMO to guarantee the consistency between VMO and the page table.\n-            let need_page_fault = vm_space\n-                .query(page_addr)?\n-                .is_some_and(|prop| !prop.flags.contains(PageFlags::W));\n-            if need_page_fault {\n-                self.handle_page_fault(page_addr, false, true)?;\n+        // We need to make sure the mapping exists.\n+        //\n+        // Also, if the `VmMapping` has the write permission but the corresponding\n+        // PTE is present and is read-only, it would be a copy-on-write page. In\n+        // this situation we need to trigger a page fault before writing at the\n+        // VMO to guarantee the consistency between VMO and the page table.\n+        {\n+            let virt_addr =\n+                self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n+            let virt_range = virt_addr..virt_addr + page_idx_range.len() * PAGE_SIZE;\n+\n+            // FIXME: any sane developer would recommend using `parent.vm_space().cursor(&virt_range)`\n+            // to lock the range and check the mapping status. However, this will cause a deadlock because\n+            // `Self::handle_page_fault` would like to create a cursor again. The following implementation\n+            // indeed introduces a TOCTOU bug.\n+            for page_va in virt_range.step_by(PAGE_SIZE) {\n+                let parent = self.parent.upgrade().unwrap();\n+                let mut cursor = parent\n+                    .vm_space()\n+                    .cursor(&(page_va..page_va + PAGE_SIZE))\n+                    .unwrap();\n+                let map_info = cursor.query().unwrap();\n+                drop(cursor);\n+\n+                match map_info {\n+                    VmQueryResult::Mapped { va, prop, .. } => {\n+                        if !prop.flags.contains(PageFlags::W) {\n+                            self.handle_page_fault(va, false, true)?;\n+                        }\n+                    }\n+                    VmQueryResult::NotMapped { va, .. } => {\n+                        self.handle_page_fault(va, true, true)?;\n+                    }\n+                }\n             }\n-            page_addr += PAGE_SIZE;\n         }\n \n         self.vmo.write_bytes(vmo_write_offset, buf)?;\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -458,7 +479,8 @@ impl VmMappingInner {\n         frame: Frame,\n         is_readonly: bool,\n     ) -> Result<()> {\n-        let map_addr = self.page_map_addr(page_idx);\n+        let map_va = self.page_map_addr(page_idx);\n+        let map_va = map_va..map_va + PAGE_SIZE;\n \n         let vm_perms = {\n             let mut perms = self.perms;\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -468,23 +490,11 @@ impl VmMappingInner {\n             }\n             perms\n         };\n+        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n \n-        let vm_map_options = {\n-            let mut options = VmMapOptions::new();\n-            options.addr(Some(map_addr));\n-            options.flags(vm_perms.into());\n-\n-            // After `fork()`, the entire memory space of the parent and child processes is\n-            // protected as read-only. Therefore, whether the pages need to be COWed (if the memory\n-            // region is private) or not (if the memory region is shared), it is necessary to\n-            // overwrite the page table entry to make the page writable again when the parent or\n-            // child process first tries to write to the memory region.\n-            options.can_overwrite(true);\n-\n-            options\n-        };\n+        let mut cursor = vm_space.cursor_mut(&map_va).unwrap();\n+        cursor.map(frame, map_prop);\n \n-        vm_space.map(FrameVec::from_one_frame(frame), &vm_map_options)?;\n         self.mapped_pages.insert(page_idx);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -492,9 +502,10 @@ impl VmMappingInner {\n     fn unmap_one_page(&mut self, vm_space: &VmSpace, page_idx: usize) -> Result<()> {\n         let map_addr = self.page_map_addr(page_idx);\n         let range = map_addr..(map_addr + PAGE_SIZE);\n-        if vm_space.query(map_addr)?.is_some() {\n-            vm_space.unmap(&range)?;\n-        }\n+\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.unmap(PAGE_SIZE);\n+\n         self.mapped_pages.remove(&page_idx);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -528,17 +539,8 @@ impl VmMappingInner {\n     ) -> Result<()> {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n-        let start_page = (range.start - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let end_page = (range.end - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let flags: PageFlags = perms.into();\n-        for page_idx in start_page..end_page {\n-            let page_addr = self.page_map_addr(page_idx);\n-            if vm_space.query(page_addr)?.is_some() {\n-                // If the page is already mapped, we will modify page table\n-                let page_range = page_addr..(page_addr + PAGE_SIZE);\n-                vm_space.protect(&page_range, |p| p.flags = flags)?;\n-            }\n-        }\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.protect(range.len(), |p| p.flags = perms.into(), true)?;\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/frame/frame_vec.rs /dev/null\n--- a/ostd/src/mm/frame/frame_vec.rs\n+++ /dev/null\n@@ -1,172 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Page frames.\n-\n-use alloc::{vec, vec::Vec};\n-\n-use crate::{\n-    mm::{Frame, VmIo, VmReader, VmWriter, PAGE_SIZE},\n-    Error, Result,\n-};\n-\n-/// A collection of base page frames (regular physical memory pages).\n-///\n-/// For the most parts, `FrameVec` is like `Vec<Frame>`. But the\n-/// implementation may or may not be based on [`Vec`]. Having a dedicated\n-/// type to represent a series of page frames is convenient because,\n-/// more often than not, one needs to operate on a batch of frames rather\n-/// a single frame.\n-#[derive(Debug, Clone)]\n-pub struct FrameVec(pub(crate) Vec<Frame>);\n-\n-impl FrameVec {\n-    /// Retrieves a reference to a [`Frame`] at the specified index.\n-    pub fn get(&self, index: usize) -> Option<&Frame> {\n-        self.0.get(index)\n-    }\n-\n-    /// Creates an empty `FrameVec`.\n-    pub fn empty() -> Self {\n-        Self(Vec::new())\n-    }\n-\n-    /// Creates a new `FrameVec` with the specified capacity.\n-    pub fn new_with_capacity(capacity: usize) -> Self {\n-        Self(Vec::with_capacity(capacity))\n-    }\n-\n-    /// Pushes a new frame to the collection.\n-    pub fn push(&mut self, new_frame: Frame) {\n-        self.0.push(new_frame);\n-    }\n-\n-    /// Pops a frame from the collection.\n-    pub fn pop(&mut self) -> Option<Frame> {\n-        self.0.pop()\n-    }\n-\n-    /// Removes a frame at a position.\n-    pub fn remove(&mut self, at: usize) -> Frame {\n-        self.0.remove(at)\n-    }\n-\n-    /// Appends all the [`Frame`]s from `more` to the end of this collection.\n-    /// and clears the frames in `more`.\n-    pub fn append(&mut self, more: &mut FrameVec) -> Result<()> {\n-        self.0.append(&mut more.0);\n-        Ok(())\n-    }\n-\n-    /// Truncates the `FrameVec` to the specified length.\n-    ///\n-    /// If `new_len >= self.len()`, then this method has no effect.\n-    pub fn truncate(&mut self, new_len: usize) {\n-        if new_len >= self.0.len() {\n-            return;\n-        }\n-        self.0.truncate(new_len)\n-    }\n-\n-    /// Returns an iterator over all frames.\n-    pub fn iter(&self) -> core::slice::Iter<'_, Frame> {\n-        self.0.iter()\n-    }\n-\n-    /// Returns the number of frames.\n-    pub fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    /// Returns whether the frame collection is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    /// Returns the number of bytes.\n-    ///\n-    /// This method is equivalent to `self.len() * BASE_PAGE_SIZE`.\n-    pub fn nbytes(&self) -> usize {\n-        self.0.len() * PAGE_SIZE\n-    }\n-\n-    /// Creates a new `FrameVec` from a single [`Frame`].\n-    pub fn from_one_frame(frame: Frame) -> Self {\n-        Self(vec![frame])\n-    }\n-}\n-\n-impl IntoIterator for FrameVec {\n-    type Item = Frame;\n-\n-    type IntoIter = alloc::vec::IntoIter<Self::Item>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.into_iter()\n-    }\n-}\n-\n-impl VmIo for FrameVec {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unread_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_writer: VmWriter = buf.into();\n-        for frame in self.0.iter().skip(num_unread_pages) {\n-            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n-            if read_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-\n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unwrite_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_reader: VmReader = buf.into();\n-        for frame in self.0.iter().skip(num_unwrite_pages) {\n-            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n-            if write_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// An iterator for frames.\n-pub struct FrameVecIter<'a> {\n-    frames: &'a FrameVec,\n-    current: usize,\n-}\n-\n-impl<'a> FrameVecIter<'a> {\n-    /// Creates a new `FrameVecIter` from the given [`FrameVec`].\n-    pub fn new(frames: &'a FrameVec) -> Self {\n-        Self { frames, current: 0 }\n-    }\n-}\n-\n-impl<'a> Iterator for FrameVecIter<'a> {\n-    type Item = &'a Frame;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.current >= self.frames.0.len() {\n-            return None;\n-        }\n-        Some(self.frames.0.get(self.current).unwrap())\n-    }\n-}\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -8,13 +8,11 @@\n //! frames. Frames, with all the properties of pages, can additionally be safely\n //! read and written by the kernel or the user.\n \n-pub mod frame_vec;\n pub mod options;\n pub mod segment;\n \n use core::mem::ManuallyDrop;\n \n-pub use frame_vec::{FrameVec, FrameVecIter};\n pub use segment::Segment;\n \n use super::page::{\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -155,6 +153,48 @@ impl VmIo for Frame {\n     }\n }\n \n+impl VmIo for alloc::vec::Vec<Frame> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_writer: VmWriter = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n+            if read_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_reader: VmReader = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n+            if write_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl PageMeta for FrameMeta {\n     const USAGE: PageUsage = PageUsage::Frame;\n \ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -2,7 +2,7 @@\n \n //! Options for allocating frames\n \n-use super::{Frame, FrameVec, Segment};\n+use super::{Frame, Segment};\n use crate::{\n     mm::{\n         page::{self, meta::FrameMeta},\ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -55,7 +55,7 @@ impl FrameAllocOptions {\n     }\n \n     /// Allocates a collection of page frames according to the given options.\n-    pub fn alloc(&self) -> Result<FrameVec> {\n+    pub fn alloc(&self) -> Result<Vec<Frame>> {\n         let pages = if self.is_contiguous {\n             page::allocator::alloc(self.nframes * PAGE_SIZE).ok_or(Error::NoMemory)?\n         } else {\ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -63,7 +63,7 @@ impl FrameAllocOptions {\n                 .ok_or(Error::NoMemory)?\n                 .into()\n         };\n-        let frames = FrameVec(pages.into_iter().map(|page| Frame { page }).collect());\n+        let frames: Vec<_> = pages.into_iter().map(|page| Frame { page }).collect();\n         if !self.uninit {\n             for frame in frames.iter() {\n                 frame.writer().fill(0);\ndiff --git a/ostd/src/mm/frame/segment.rs b/ostd/src/mm/frame/segment.rs\n--- a/ostd/src/mm/frame/segment.rs\n+++ b/ostd/src/mm/frame/segment.rs\n@@ -16,15 +16,10 @@ use crate::{\n \n /// A handle to a contiguous range of page frames (physical memory pages).\n ///\n-/// The biggest difference between `Segment` and [`FrameVec`] is that\n-/// the page frames must be contiguous for `Segment`.\n-///\n /// A cloned `Segment` refers to the same page frames as the original.\n /// As the original and cloned instances point to the same physical address,  \n /// they are treated as equal to each other.\n ///\n-/// [`FrameVec`]: crate::mm::FrameVec\n-///\n /// #Example\n ///\n /// ```rust\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -18,7 +18,7 @@ use crate::{\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\n-/// e.g., [`VmSpace`], [`FrameVec`], and [`Frame`].\n+/// e.g., [`Segment`], [`Vec<Frame>`] and [`Frame`].\n ///\n /// # Concurrency\n ///\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -27,8 +27,7 @@ use crate::{\n /// desire predictability or atomicity, the users should add extra mechanism\n /// for such properties.\n ///\n-/// [`VmSpace`]: crate::mm::VmSpace\n-/// [`FrameVec`]: crate::mm::FrameVec\n+/// [`Segment`]: crate::mm::Segment\n /// [`Frame`]: crate::mm::Frame\n pub trait VmIo: Send + Sync {\n     /// Reads a specified number of bytes at a specified offset into a given buffer.\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -17,7 +17,7 @@ mod offset;\n pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n-mod space;\n+pub mod vm_space;\n \n use alloc::vec::Vec;\n use core::{fmt::Debug, ops::Range};\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -26,10 +26,10 @@ use spin::Once;\n \n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n-    frame::{options::FrameAllocOptions, Frame, FrameVec, FrameVecIter, Segment},\n+    frame::{options::FrameAllocOptions, Frame, Segment},\n     io::{KernelSpace, UserSpace, VmIo, VmReader, VmWriter},\n     page_prop::{CachePolicy, PageFlags, PageProperty},\n-    space::{VmMapOptions, VmSpace},\n+    vm_space::VmSpace,\n };\n pub(crate) use self::{\n     kspace::paddr_to_vaddr, page::meta::init as init_page_meta, page_prop::PrivilegedPageFlags,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -76,7 +76,7 @@ use super::{\n use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n \n #[derive(Clone, Debug)]\n-pub(crate) enum PageTableQueryResult {\n+pub enum PageTableQueryResult {\n     NotMapped {\n         va: Vaddr,\n         len: usize,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -105,7 +105,7 @@ pub(crate) enum PageTableQueryResult {\n /// simulate the recursion, and adpot a page table locking protocol to\n /// provide concurrency.\n #[derive(Debug)]\n-pub(crate) struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n+pub struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -140,10 +140,7 @@ where\n     ///\n     /// Note that this function does not ensure exclusive access to the claimed\n     /// virtual address range. The accesses using this cursor may block or fail.\n-    pub(crate) fn new(\n-        pt: &'a PageTable<M, E, C>,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Self, PageTableError> {\n+    pub fn new(pt: &'a PageTable<M, E, C>, va: &Range<Vaddr>) -> Result<Self, PageTableError> {\n         if !M::covers(va) {\n             return Err(PageTableError::InvalidVaddrRange(va.start, va.end));\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -198,9 +195,9 @@ where\n     }\n \n     /// Gets the information of the current slot.\n-    pub(crate) fn query(&mut self) -> Option<PageTableQueryResult> {\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n         if self.va >= self.barrier_va.end {\n-            return None;\n+            return Err(PageTableError::InvalidVaddr(self.va));\n         }\n \n         loop {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -209,7 +206,7 @@ where\n \n             let pte = self.read_cur_pte();\n             if !pte.is_present() {\n-                return Some(PageTableQueryResult::NotMapped {\n+                return Ok(PageTableQueryResult::NotMapped {\n                     va,\n                     len: page_size::<C>(level),\n                 });\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -221,14 +218,14 @@ where\n \n             match self.cur_child() {\n                 Child::Page(page) => {\n-                    return Some(PageTableQueryResult::Mapped {\n+                    return Ok(PageTableQueryResult::Mapped {\n                         va,\n                         page,\n                         prop: pte.prop(),\n                     });\n                 }\n                 Child::Untracked(pa) => {\n-                    return Some(PageTableQueryResult::MappedUntracked {\n+                    return Ok(PageTableQueryResult::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -246,7 +243,7 @@ where\n     ///\n     /// If reached the end of a page table node, it leads itself up to the next page of the parent\n     /// page if possible.\n-    fn move_forward(&mut self) {\n+    pub(in crate::mm) fn move_forward(&mut self) {\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -255,6 +252,41 @@ where\n         self.va = next_va;\n     }\n \n+    /// Jumps to the given virtual address.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the address is out of the range where the cursor is required to operate,\n+    /// or has bad alignment.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        assert!(self.barrier_va.contains(&va));\n+        assert!(va % C::BASE_PAGE_SIZE == 0);\n+\n+        loop {\n+            let cur_node_start = self.va & !(page_size::<C>(self.level + 1) - 1);\n+            let cur_node_end = cur_node_start + page_size::<C>(self.level + 1);\n+            // If the address is within the current node, we can jump directly.\n+            if cur_node_start <= va && va < cur_node_end {\n+                self.va = va;\n+                return;\n+            }\n+\n+            // There is a corner case that the cursor is depleted, sitting at the start of the\n+            // next node but the next node is not locked because the parent is not locked.\n+            if self.va >= self.barrier_va.end && self.level == self.guard_level {\n+                self.va = va;\n+                return;\n+            }\n+\n+            debug_assert!(self.level < self.guard_level);\n+            self.level_up();\n+        }\n+    }\n+\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.va\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -327,10 +359,10 @@ where\n \n     fn next(&mut self) -> Option<Self::Item> {\n         let result = self.query();\n-        if result.is_some() {\n+        if result.is_ok() {\n             self.move_forward();\n         }\n-        result\n+        result.ok()\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -339,7 +371,7 @@ where\n /// Also, it has all the capabilities of a [`Cursor`]. A virtual address range\n /// in a page table can only be accessed by one cursor whether it is mutable or not.\n #[derive(Debug)]\n-pub(crate) struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n+pub struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n     Cursor<'a, M, E, C>,\n )\n where\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -365,43 +397,26 @@ where\n         Cursor::new(pt, va).map(|inner| Self(inner))\n     }\n \n-    /// Gets the information of the current slot and go to the next slot.\n-    ///\n-    /// We choose not to implement `Iterator` or `IterMut` for [`CursorMut`]\n-    /// because the mutable cursor is indeed not an iterator.\n-    pub(crate) fn next(&mut self) -> Option<PageTableQueryResult> {\n-        self.0.next()\n-    }\n-\n     /// Jumps to the given virtual address.\n     ///\n+    /// This is the same as [`Cursor::jump`].\n+    ///\n     /// # Panics\n     ///\n     /// This method panics if the address is out of the range where the cursor is required to operate,\n     /// or has bad alignment.\n-    pub(crate) fn jump(&mut self, va: Vaddr) {\n-        assert!(self.0.barrier_va.contains(&va));\n-        assert!(va % C::BASE_PAGE_SIZE == 0);\n-\n-        loop {\n-            let cur_node_start = self.0.va & !(page_size::<C>(self.0.level + 1) - 1);\n-            let cur_node_end = cur_node_start + page_size::<C>(self.0.level + 1);\n-            // If the address is within the current node, we can jump directly.\n-            if cur_node_start <= va && va < cur_node_end {\n-                self.0.va = va;\n-                return;\n-            }\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va)\n+    }\n \n-            // There is a corner case that the cursor is depleted, sitting at the start of the\n-            // next node but the next node is not locked because the parent is not locked.\n-            if self.0.va >= self.0.barrier_va.end && self.0.level == self.0.guard_level {\n-                self.0.va = va;\n-                return;\n-            }\n+    /// Gets the current virtual address.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n \n-            debug_assert!(self.0.level < self.0.guard_level);\n-            self.0.level_up();\n-        }\n+    /// Gets the information of the current slot.\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n+        self.0.query()\n     }\n \n     /// Maps the range starting from the current address to a [`DynPage`].\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -417,7 +432,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub(crate) unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -472,7 +487,7 @@ where\n     ///  - the range being mapped does not affect kernel's memory safety;\n     ///  - the physical address to be mapped is valid and safe to use;\n     ///  - it is allowed to map untracked pages in this virtual address range.\n-    pub(crate) unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n+    pub unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n         let end = self.0.va + pa.len();\n         let mut pa = pa.start;\n         assert!(end <= self.0.barrier_va.end);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -522,7 +537,7 @@ where\n     /// This function will panic if:\n     ///  - the range to be unmapped is out of the range where the cursor is required to operate;\n     ///  - the range covers only a part of a page.\n-    pub(crate) unsafe fn unmap(&mut self, len: usize) {\n+    pub unsafe fn unmap(&mut self, len: usize) {\n         let end = self.0.va + len;\n         assert!(end <= self.0.barrier_va.end);\n         assert!(end % C::BASE_PAGE_SIZE == 0);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -579,7 +594,7 @@ where\n     ///\n     /// This function will panic if:\n     ///  - the range to be protected is out of the range where the cursor is required to operate.\n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &mut self,\n         len: usize,\n         mut op: impl FnMut(&mut PageProperty),\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,7 +3,7 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, paddr_to_vaddr,\n+    nr_subpage_per_huge,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -23,8 +23,10 @@ pub(in crate::mm) mod boot_pt;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PageTableError {\n-    /// The virtual address range is invalid.\n+    /// The provided virtual address range is invalid.\n     InvalidVaddrRange(Vaddr, Vaddr),\n+    /// The provided virtual address is invalid.\n+    InvalidVaddr(Vaddr),\n     /// Using virtual address not aligned.\n     UnalignedVaddr,\n     /// Protecting a mapping that does not exist.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -76,7 +78,7 @@ const fn pte_index<C: PagingConstsTrait>(va: Vaddr, level: PagingLevel) -> usize\n /// A handle to a page table.\n /// A page table can track the lifetime of the mapped physical pages.\n #[derive(Debug)]\n-pub(crate) struct PageTable<\n+pub struct PageTable<\n     M: PageTableMode,\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -88,7 +90,7 @@ pub(crate) struct PageTable<\n }\n \n impl PageTable<UserMode> {\n-    pub(crate) fn activate(&self) {\n+    pub fn activate(&self) {\n         // SAFETY: The usermode page table is safe to activate since the kernel\n         // mappings are shared.\n         unsafe {\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -100,7 +102,7 @@ impl PageTable<UserMode> {\n     /// new page table.\n     ///\n     /// TODO: We may consider making the page table itself copy-on-write.\n-    pub(crate) fn fork_copy_on_write(&self) -> Self {\n+    pub fn fork_copy_on_write(&self) -> Self {\n         let mut cursor = self.cursor_mut(&UserMode::VADDR_RANGE).unwrap();\n \n         // SAFETY: Protecting the user page table is safe.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -139,7 +141,7 @@ impl PageTable<KernelMode> {\n     ///\n     /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n     /// other child page tables.\n-    pub(crate) fn create_user_page_table(&self) -> PageTable<UserMode> {\n+    pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n \n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -157,7 +159,7 @@ impl PageTable<KernelMode> {\n     /// The virtual address range should be aligned to the root level page size. Considering\n     /// usize overflows, the caller should provide the index range of the root level pages\n     /// instead of the virtual address range.\n-    pub(crate) fn make_shared_tables(&self, root_index: Range<usize>) {\n+    pub fn make_shared_tables(&self, root_index: Range<usize>) {\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n \n         let start = root_index.start;\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -182,7 +184,7 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n-    pub(crate) fn empty() -> Self {\n+    pub fn empty() -> Self {\n         PageTable {\n             root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n             _phantom: PhantomData,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -197,11 +199,11 @@ where\n     ///\n     /// It is dangerous to directly provide the physical address of the root page table to the\n     /// hardware since the page table node may be dropped, resulting in UAF.\n-    pub(crate) unsafe fn root_paddr(&self) -> Paddr {\n+    pub unsafe fn root_paddr(&self) -> Paddr {\n         self.root.paddr()\n     }\n \n-    pub(crate) unsafe fn map(\n+    pub unsafe fn map(\n         &self,\n         vaddr: &Range<Vaddr>,\n         paddr: &Range<Paddr>,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -211,12 +213,12 @@ where\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n+    pub unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n         self.cursor_mut(vaddr)?.unmap(vaddr.len());\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &self,\n         vaddr: &Range<Vaddr>,\n         op: impl FnMut(&mut PageProperty),\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -250,19 +253,17 @@ where\n \n     /// Create a new cursor exclusively accessing the virtual address range for querying.\n     ///\n-    /// If another cursor is already accessing the range, the new cursor will wait until the\n-    /// previous cursor is dropped.\n-    pub(crate) fn cursor(\n-        &'a self,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n+    /// If another cursor is already accessing the range, the new cursor may wait until the\n+    /// previous cursor is dropped. The modification to the mapping by the cursor may also\n+    /// block or be overriden by the mapping of another cursor.\n+    pub fn cursor(&'a self, va: &Range<Vaddr>) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n         Cursor::new(self, va)\n     }\n \n     /// Create a new reference to the same page table.\n     /// The caller must ensure that the kernel page table is not copied.\n     /// This is only useful for IOMMU page tables. Think twice before using it in other cases.\n-    pub(crate) unsafe fn shallow_copy(&self) -> Self {\n+    pub unsafe fn shallow_copy(&self) -> Self {\n         PageTable {\n             root: self.root.clone_shallow(),\n             _phantom: PhantomData,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -336,9 +338,7 @@ pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n /// The interface for defining architecture-specific page table entries.\n ///\n /// Note that a default PTE shoud be a PTE that points to nothing.\n-pub(crate) trait PageTableEntryTrait:\n-    Clone + Copy + Debug + Default + Pod + Sized + Sync\n-{\n+pub trait PageTableEntryTrait: Clone + Copy + Debug + Default + Pod + Sized + Sync {\n     /// Create a set of new invalid page table flags that indicates an absent page.\n     ///\n     /// Note that currently the implementation requires an all zero PTE to be an absent PTE.\ndiff --git a/ostd/src/mm/space.rs /dev/null\n--- a/ostd/src/mm/space.rs\n+++ /dev/null\n@@ -1,408 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use core::ops::Range;\n-\n-use spin::Once;\n-\n-use super::{\n-    io::UserSpace,\n-    is_page_aligned,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page_table::{PageTable, PageTableMode, UserMode},\n-    CachePolicy, FrameVec, PageFlags, PageProperty, PagingConstsTrait, PrivilegedPageFlags,\n-    VmReader, VmWriter, PAGE_SIZE,\n-};\n-use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        PageTableEntry, PagingConsts,\n-    },\n-    cpu::CpuExceptionInfo,\n-    mm::{\n-        page_table::{Cursor, PageTableQueryResult as PtQr},\n-        Frame, MAX_USERSPACE_VADDR,\n-    },\n-    prelude::*,\n-    Error,\n-};\n-\n-/// Virtual memory space.\n-///\n-/// A virtual memory space (`VmSpace`) can be created and assigned to a user space so that\n-/// the virtual memory of the user space can be manipulated safely. For example,\n-/// given an arbitrary user-space pointer, one can read and write the memory\n-/// location referred to by the user-space pointer without the risk of breaking the\n-/// memory safety of the kernel space.\n-///\n-/// A newly-created `VmSpace` is not backed by any physical memory pages.\n-/// To provide memory pages for a `VmSpace`, one can allocate and map\n-/// physical memory ([`Frame`]s) to the `VmSpace`.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-#[allow(clippy::type_complexity)]\n-pub struct VmSpace {\n-    pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-}\n-\n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n-\n-impl VmSpace {\n-    /// Creates a new VM address space.\n-    pub fn new() -> Self {\n-        Self {\n-            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n-        }\n-    }\n-\n-    /// Activates the page table.\n-    pub(crate) fn activate(&self) {\n-        self.pt.activate();\n-    }\n-\n-    pub(crate) fn handle_page_fault(\n-        &self,\n-        info: &CpuExceptionInfo,\n-    ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n-            return func(self, info);\n-        }\n-        Err(())\n-    }\n-\n-    /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n-    pub fn register_page_fault_handler(\n-        &self,\n-        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n-    ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Maps some physical memory pages into the VM space according to the given\n-    /// options, returning the address where the mapping is created.\n-    ///\n-    /// The ownership of the frames will be transferred to the `VmSpace`.\n-    ///\n-    /// For more information, see [`VmMapOptions`].\n-    pub fn map(&self, frames: FrameVec, options: &VmMapOptions) -> Result<Vaddr> {\n-        if options.addr.is_none() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let addr = options.addr.unwrap();\n-\n-        if addr % PAGE_SIZE != 0 {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let size = frames.nbytes();\n-        let end = addr.checked_add(size).ok_or(Error::InvalidArgs)?;\n-\n-        let va_range = addr..end;\n-        if !UserMode::covers(&va_range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let mut cursor = self.pt.cursor_mut(&va_range)?;\n-\n-        // If overwrite is forbidden, we should check if there are existing mappings\n-        if !options.can_overwrite {\n-            while let Some(qr) = cursor.next() {\n-                if matches!(qr, PtQr::Mapped { .. }) {\n-                    return Err(Error::MapAlreadyMappedVaddr);\n-                }\n-            }\n-            cursor.jump(va_range.start);\n-        }\n-\n-        let prop = PageProperty {\n-            flags: options.flags,\n-            cache: CachePolicy::Writeback,\n-            priv_flags: PrivilegedPageFlags::USER,\n-        };\n-\n-        for frame in frames.into_iter() {\n-            // SAFETY: mapping in the user space with `Frame` is safe.\n-            unsafe {\n-                cursor.map(frame.into(), prop);\n-            }\n-        }\n-\n-        drop(cursor);\n-        tlb_flush_addr_range(&va_range);\n-\n-        Ok(addr)\n-    }\n-\n-    /// Queries about a range of virtual memory.\n-    /// You will get an iterator of `VmQueryResult` which contains the information of\n-    /// each parts of the range.\n-    pub fn query_range(&self, range: &Range<Vaddr>) -> Result<VmQueryIter> {\n-        Ok(VmQueryIter {\n-            cursor: self.pt.cursor(range)?,\n-        })\n-    }\n-\n-    /// Queries about the mapping information about a byte in virtual memory.\n-    /// This is more handy than [`query_range`], but less efficient if you want\n-    /// to query in a batch.\n-    ///\n-    /// [`query_range`]: VmSpace::query_range\n-    pub fn query(&self, vaddr: Vaddr) -> Result<Option<PageProperty>> {\n-        if !(0..MAX_USERSPACE_VADDR).contains(&vaddr) {\n-            return Err(Error::AccessDenied);\n-        }\n-        Ok(self.pt.query(vaddr).map(|(_pa, prop)| prop))\n-    }\n-\n-    /// Unmaps the physical memory pages within the VM address range.\n-    ///\n-    /// The range is allowed to contain gaps, where no physical memory pages\n-    /// are mapped.\n-    pub fn unmap(&self, range: &Range<Vaddr>) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: unmapping in the user space is safe.\n-        unsafe {\n-            self.pt.unmap(range)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Clears all mappings\n-    pub fn clear(&self) {\n-        // SAFETY: unmapping user space is safe, and we don't care unmapping\n-        // invalid ranges.\n-        unsafe {\n-            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        }\n-        tlb_flush_all_excluding_global();\n-    }\n-\n-    /// Updates the VM protection permissions within the VM address range.\n-    ///\n-    /// If any of the page in the given range is not mapped, it is skipped.\n-    /// The method panics when virtual address is not aligned to base page\n-    /// size.\n-    ///\n-    /// It is guarenteed that the operation is called once for each valid\n-    /// page found in the range.\n-    ///\n-    /// TODO: It returns error when invalid operations such as protect\n-    /// partial huge page happens, and efforts are not reverted, leaving us\n-    /// in a bad state.\n-    pub fn protect(&self, range: &Range<Vaddr>, op: impl FnMut(&mut PageProperty)) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: protecting in the user space is safe.\n-        unsafe {\n-            self.pt.protect(range, op)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-        let new_space = Self {\n-            pt: self.pt.fork_copy_on_write(),\n-            page_fault_handler,\n-        };\n-        tlb_flush_all_excluding_global();\n-        new_space\n-    }\n-\n-    /// Creates a reader to read data from the user space of the current task.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmReader`.\n-        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n-    }\n-\n-    /// Creates a writer to write data into the user space.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmWriter`.\n-        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n-    }\n-}\n-\n-impl Default for VmSpace {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// Options for mapping physical memory pages into a VM address space.\n-/// See [`VmSpace::map`].\n-#[derive(Clone, Debug)]\n-pub struct VmMapOptions {\n-    /// Starting virtual address\n-    addr: Option<Vaddr>,\n-    /// Map align\n-    align: usize,\n-    /// Page permissions and status\n-    flags: PageFlags,\n-    /// Can overwrite\n-    can_overwrite: bool,\n-}\n-\n-impl VmMapOptions {\n-    /// Creates the default options.\n-    pub fn new() -> Self {\n-        Self {\n-            addr: None,\n-            align: PagingConsts::BASE_PAGE_SIZE,\n-            flags: PageFlags::empty(),\n-            can_overwrite: false,\n-        }\n-    }\n-\n-    /// Sets the alignment of the address of the mapping.\n-    ///\n-    /// The alignment must be a power-of-2 and greater than or equal to the\n-    /// page size.\n-    ///\n-    /// The default value of this option is the page size.\n-    pub fn align(&mut self, align: usize) -> &mut Self {\n-        self.align = align;\n-        self\n-    }\n-\n-    /// Sets the permissions of the mapping, which affects whether\n-    /// the mapping can be read, written, or executed.\n-    ///\n-    /// The default value of this option is read-only.\n-    pub fn flags(&mut self, flags: PageFlags) -> &mut Self {\n-        self.flags = flags;\n-        self\n-    }\n-\n-    /// Sets the address of the new mapping.\n-    ///\n-    /// The default value of this option is `None`.\n-    pub fn addr(&mut self, addr: Option<Vaddr>) -> &mut Self {\n-        if addr.is_none() {\n-            return self;\n-        }\n-        self.addr = Some(addr.unwrap());\n-        self\n-    }\n-\n-    /// Sets whether the mapping can overwrite any existing mappings.\n-    ///\n-    /// If this option is `true`, then the address option must be `Some(_)`.\n-    ///\n-    /// The default value of this option is `false`.\n-    pub fn can_overwrite(&mut self, can_overwrite: bool) -> &mut Self {\n-        self.can_overwrite = can_overwrite;\n-        self\n-    }\n-}\n-\n-impl Default for VmMapOptions {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// The iterator for querying over the VM space without modifying it.\n-pub struct VmQueryIter<'a> {\n-    cursor: Cursor<'a, UserMode, PageTableEntry, PagingConsts>,\n-}\n-\n-pub enum VmQueryResult {\n-    NotMapped {\n-        va: Vaddr,\n-        len: usize,\n-    },\n-    Mapped {\n-        va: Vaddr,\n-        frame: Frame,\n-        prop: PageProperty,\n-    },\n-}\n-\n-impl Iterator for VmQueryIter<'_> {\n-    type Item = VmQueryResult;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.cursor.next().map(|ptqr| match ptqr {\n-            PtQr::NotMapped { va, len } => VmQueryResult::NotMapped { va, len },\n-            PtQr::Mapped { va, page, prop } => VmQueryResult::Mapped {\n-                va,\n-                frame: page.try_into().unwrap(),\n-                prop,\n-            },\n-            // It is not possible to map untyped memory in user space.\n-            PtQr::MappedUntracked { .. } => unreachable!(),\n-        })\n-    }\n-}\ndiff --git /dev/null b/ostd/src/mm/vm_space.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/vm_space.rs\n@@ -0,0 +1,373 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Virtual memory space management.\n+//!\n+//! The [`VmSpace`] struct is provided to manage the virtual memory space of a\n+//! user. Cursors are used to traverse and modify over the virtual memory space\n+//! concurrently. The VM space cursor [`self::Cursor`] is just a wrapper over\n+//! the page table cursor [`super::page_table::Cursor`], providing efficient,\n+//! powerful concurrent accesses to the page table, and suffers from the same\n+//! validity concerns as described in [`super::page_table::cursor`].\n+\n+use core::ops::Range;\n+\n+use spin::Once;\n+\n+use super::{\n+    io::UserSpace,\n+    kspace::KERNEL_PAGE_TABLE,\n+    page_table::{PageTable, UserMode},\n+    PageProperty, VmReader, VmWriter,\n+};\n+use crate::{\n+    arch::mm::{\n+        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        PageTableEntry, PagingConsts,\n+    },\n+    cpu::CpuExceptionInfo,\n+    mm::{\n+        page_table::{self, PageTableQueryResult as PtQr},\n+        Frame, MAX_USERSPACE_VADDR,\n+    },\n+    prelude::*,\n+    Error,\n+};\n+\n+/// Virtual memory space.\n+///\n+/// A virtual memory space (`VmSpace`) can be created and assigned to a user\n+/// space so that the virtual memory of the user space can be manipulated\n+/// safely. For example,  given an arbitrary user-space pointer, one can read\n+/// and write the memory location referred to by the user-space pointer without\n+/// the risk of breaking the memory safety of the kernel space.\n+///\n+/// A newly-created `VmSpace` is not backed by any physical memory pages. To\n+/// provide memory pages for a `VmSpace`, one can allocate and map physical\n+/// memory ([`Frame`]s) to the `VmSpace` using the cursor.\n+///\n+/// A `VmSpace` can also attach a page fault handler, which will be invoked to\n+/// handle page faults generated from user space.\n+#[allow(clippy::type_complexity)]\n+pub struct VmSpace {\n+    pt: PageTable<UserMode>,\n+    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+}\n+\n+// Notes on TLB flushing:\n+//\n+// We currently assume that:\n+// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n+//    immediately after we make changes to the page table entries. So we must invalidate the\n+//    corresponding TLB caches accordingly.\n+// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n+//    support is not yet available. But we need to consider this situation in the future (TODO).\n+impl VmSpace {\n+    /// Creates a new VM address space.\n+    pub fn new() -> Self {\n+        Self {\n+            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n+            page_fault_handler: Once::new(),\n+        }\n+    }\n+\n+    /// Gets an immutable cursor in the virtual address range.\n+    ///\n+    /// The cursor behaves like a lock guard, exclusively owning a sub-tree of\n+    /// the page table, preventing others from creating a cursor in it. So be\n+    /// sure to drop the cursor as soon as possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive.\n+    pub fn cursor(&self, va: &Range<Vaddr>) -> Result<Cursor<'_>> {\n+        Ok(self.pt.cursor(va).map(Cursor)?)\n+    }\n+\n+    /// Gets an mutable cursor in the virtual address range.\n+    ///\n+    /// The same as [`Self::cursor`], the cursor behaves like a lock guard,\n+    /// exclusively owning a sub-tree of the page table, preventing others\n+    /// from creating a cursor in it. So be sure to drop the cursor as soon as\n+    /// possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive. The modification to the mapping by the\n+    /// cursor may also block or be overriden the mapping of another cursor.\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n+        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    }\n+\n+    /// Activates the page table.\n+    pub(crate) fn activate(&self) {\n+        self.pt.activate();\n+    }\n+\n+    pub(crate) fn handle_page_fault(\n+        &self,\n+        info: &CpuExceptionInfo,\n+    ) -> core::result::Result<(), ()> {\n+        if let Some(func) = self.page_fault_handler.get() {\n+            return func(self, info);\n+        }\n+        Err(())\n+    }\n+\n+    /// Registers the page fault handler in this `VmSpace`.\n+    ///\n+    /// The page fault handler of a `VmSpace` can only be initialized once.\n+    /// If it has been initialized before, calling this method will have no effect.\n+    pub fn register_page_fault_handler(\n+        &self,\n+        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n+    ) {\n+        self.page_fault_handler.call_once(|| func);\n+    }\n+\n+    /// Clears all mappings\n+    pub fn clear(&self) {\n+        // SAFETY: unmapping user space is safe, and we don't care unmapping\n+        // invalid ranges.\n+        unsafe {\n+            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n+        }\n+        tlb_flush_all_excluding_global();\n+    }\n+\n+    /// Forks a new VM space with copy-on-write semantics.\n+    ///\n+    /// Both the parent and the newly forked VM space will be marked as\n+    /// read-only. And both the VM space will take handles to the same\n+    /// physical memory pages.\n+    pub fn fork_copy_on_write(&self) -> Self {\n+        let page_fault_handler = {\n+            let new_handler = Once::new();\n+            if let Some(handler) = self.page_fault_handler.get() {\n+                new_handler.call_once(|| *handler);\n+            }\n+            new_handler\n+        };\n+        let new_space = Self {\n+            pt: self.pt.fork_copy_on_write(),\n+            page_fault_handler,\n+        };\n+        tlb_flush_all_excluding_global();\n+        new_space\n+    }\n+\n+    /// Creates a reader to read data from the user space of the current task.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmReader`.\n+        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n+    }\n+\n+    /// Creates a writer to write data into the user space.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmWriter`.\n+        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n+    }\n+}\n+\n+impl Default for VmSpace {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+/// The cursor for querying over the VM space without modifying it.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree. Two read-only cursors can not be\n+/// created from the same virtual address range either.\n+pub struct Cursor<'a>(page_table::Cursor<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl Iterator for Cursor<'_> {\n+    type Item = VmQueryResult;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let result = self.query();\n+        if result.is_ok() {\n+            self.0.move_forward();\n+        }\n+        result.ok()\n+    }\n+}\n+\n+impl Cursor<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+}\n+\n+/// The cursor for modifying the mappings in VM space.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree.\n+pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl CursorMut<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This is the same as [`Cursor::query`].\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    ///\n+    /// This is the same as [`Cursor::jump`].\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+\n+    /// Map a frame into the current slot.\n+    ///\n+    /// This method will bring the cursor to the next slot after the modification.\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + frame.size();\n+\n+        // SAFETY: It is safe to map untyped memory into the userspace.\n+        unsafe {\n+            self.0.map(frame.into(), prop);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Clear the mapping starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn unmap(&mut self, len: usize) {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to un-map memory in the userspace.\n+        unsafe {\n+            self.0.unmap(len);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Change the mapping property starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// The way to change the property is specified by the closure `op`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn protect(\n+        &mut self,\n+        len: usize,\n+        op: impl FnMut(&mut PageProperty),\n+        allow_protect_absent: bool,\n+    ) -> Result<()> {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to protect memory in the userspace.\n+        let result = unsafe { self.0.protect(len, op, allow_protect_absent) };\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+\n+        Ok(result?)\n+    }\n+}\n+\n+/// The result of a query over the VM space.\n+#[derive(Debug)]\n+pub enum VmQueryResult {\n+    /// The current slot is not mapped.\n+    NotMapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The length of the slot.\n+        len: usize,\n+    },\n+    /// The current slot is mapped.\n+    Mapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The mapped frame.\n+        frame: Frame,\n+        /// The property of the slot.\n+        prop: PageProperty,\n+    },\n+}\n+\n+impl TryFrom<PtQr> for VmQueryResult {\n+    type Error = &'static str;\n+\n+    fn try_from(ptqr: PtQr) -> core::result::Result<Self, Self::Error> {\n+        match ptqr {\n+            PtQr::NotMapped { va, len } => Ok(VmQueryResult::NotMapped { va, len }),\n+            PtQr::Mapped { va, page, prop } => Ok(VmQueryResult::Mapped {\n+                va,\n+                frame: page\n+                    .try_into()\n+                    .map_err(|_| \"found typed memory mapped into `VmSpace`\")?,\n+                prop,\n+            }),\n+            PtQr::MappedUntracked { .. } => Err(\"found untracked memory mapped into `VmSpace`\"),\n+        }\n+    }\n+}\n",
        "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -13,7 +13,8 @@ use alloc::vec;\n use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n use ostd::cpu::UserContext;\n use ostd::mm::{\n-    FrameAllocOptions, PageFlags, Vaddr, VmIo, VmMapOptions, VmSpace, VmWriter, PAGE_SIZE,\n+    CachePolicy, FrameAllocOptions, PageFlags, PageProperty, Vaddr, VmIo, VmSpace, VmWriter,\n+    PAGE_SIZE,\n };\n use ostd::prelude::*;\n use ostd::task::{Task, TaskOptions};\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -32,8 +33,8 @@ pub fn main() {\n }\n \n fn create_user_space(program: &[u8]) -> UserSpace {\n+    let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n     let user_pages = {\n-        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n         let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n         // Phyiscal memory pages can be only accessed\n         // via the Frame abstraction.\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -45,11 +46,15 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n \n         // The page table of the user space can be\n         // created and manipulated safely through\n-        // the VmSpace abstraction.\n+        // the `VmSpace` abstraction.\n         let vm_space = VmSpace::new();\n-        let mut options = VmMapOptions::new();\n-        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n-        vm_space.map(user_pages, &options).unwrap();\n+        let mut cursor = vm_space\n+            .cursor_mut(&(MAP_ADDR..MAP_ADDR + nframes * PAGE_SIZE))\n+            .unwrap();\n+        let map_prop = PageProperty::new(PageFlags::RWX, CachePolicy::Writeback);\n+        for frame in user_pages {\n+            cursor.map(frame, map_prop);\n+        }\n         Arc::new(vm_space)\n     };\n     let user_cpu_state = {\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -14,8 +14,8 @@ use crate::{\n \n mod node;\n use node::*;\n-mod cursor;\n-pub(crate) use cursor::{Cursor, CursorMut, PageTableQueryResult};\n+pub mod cursor;\n+pub use cursor::{Cursor, CursorMut, PageTableQueryResult};\n #[cfg(ktest)]\n mod test;\n \ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -232,16 +234,17 @@ where\n     /// Note that this function may fail reflect an accurate result if there are\n     /// cursors concurrently accessing the same virtual address range, just like what\n     /// happens for the hardware MMU walk.\n-    pub(crate) fn query(&self, vaddr: Vaddr) -> Option<(Paddr, PageProperty)> {\n+    #[cfg(ktest)]\n+    pub fn query(&self, vaddr: Vaddr) -> Option<(Paddr, PageProperty)> {\n         // SAFETY: The root node is a valid page table node so the address is valid.\n         unsafe { page_walk::<E, C>(self.root_paddr(), vaddr) }\n     }\n \n     /// Create a new cursor exclusively accessing the virtual address range for mapping.\n     ///\n-    /// If another cursor is already accessing the range, the new cursor will wait until the\n+    /// If another cursor is already accessing the range, the new cursor may wait until the\n     /// previous cursor is dropped.\n-    pub(crate) fn cursor_mut(\n+    pub fn cursor_mut(\n         &'a self,\n         va: &Range<Vaddr>,\n     ) -> Result<CursorMut<'a, M, E, C>, PageTableError> {\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -288,13 +289,14 @@ where\n ///\n /// To mitigate this problem, the page table nodes are by default not\n /// actively recycled, until we find an appropriate solution.\n+#[cfg(ktest)]\n pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n     root_paddr: Paddr,\n     vaddr: Vaddr,\n ) -> Option<(Paddr, PageProperty)> {\n-    // We disable preemt here to mimic the MMU walk, which will not be interrupted\n-    // then must finish within a given time.\n-    let _guard = crate::task::disable_preempt();\n+    use super::paddr_to_vaddr;\n+\n+    let preempt_guard = crate::task::disable_preempt();\n \n     let mut cur_level = C::NR_LEVELS;\n     let mut cur_pte = {\ndiff --git a/tools/format_all.sh b/tools/format_all.sh\n--- a/tools/format_all.sh\n+++ b/tools/format_all.sh\n@@ -29,6 +29,14 @@ else\n     cargo fmt\n fi\n \n+# Format the 100-line kernel demo as well\n+KERNEL_DEMO_FILE=\"$WORKSPACE_ROOT/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\"\n+if [ \"$CHECK_MODE\" = true ]; then\n+    cargo fmt --check -- $KERNEL_DEMO_FILE\n+else\n+    cargo fmt -- $KERNEL_DEMO_FILE\n+fi\n+\n for CRATE in $EXCLUDED_CRATES; do\n     CRATE_DIR=\"$WORKSPACE_ROOT/$CRATE\"\n \n",
        "problem_statement": "The APIs of `VmSpace` are vulnerable to race conditions\n```rust\r\n#[derive(Debug, Clone)]\r\npub struct VmSpace {\r\n    memory_set: Arc<Mutex<MemorySet>>,\r\n}\r\n\r\nimpl VmSpace {\r\n    /// determine whether a vaddr is already mapped\r\n    pub fn is_mapped(&self, vaddr: Vaddr) -> bool {\r\n        let memory_set = self.memory_set.lock();\r\n        memory_set.is_mapped(vaddr)\r\n    }\r\n}\r\n```\r\n\r\n- This API is racy by design *unless an external lock is used properly*.\r\n   - `is_mapped` returns whether the page is mapped or not *when the method is called*, but the result can be changed immediately just after the method returns (because it releases the `VmSpace`'s lock).\r\n - Even `type VmSpace = Arc<Mutex<MemorySet>>` is probably better, at least it makes the lock explicit.\r\n   - Something like `vm_space.lock().is_mapped(vaddr1) && vm_space.lock().is_mapped(vaddr2)` is obviously wrong (or at least not optimized) code.\n",
        "hints_text": "",
        "created_at": "2024-07-04T11:40:07Z",
        "version": "0.6"
    }
]