[
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1279,
        "instance_id": "asterinas__asterinas-1279",
        "issue_numbers": [
            "1274"
        ],
        "base_commit": "963874471284ed014b76d268d933b6d13073c2cc",
        "patch": "diff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -50,7 +50,9 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n         // Cannot be reduced to `then_some`, or the possible dropping of the temporary\n         // guard will cause an unexpected unlock.\n-        self.acquire_lock().then_some(MutexGuard { mutex: self })\n+        // SAFETY: The lock is successfully acquired when creating the guard.\n+        self.acquire_lock()\n+            .then(|| unsafe { MutexGuard::new(self) })\n     }\n \n     /// Tries acquire the mutex through an [`Arc`].\n\ndiff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -100,6 +102,16 @@ pub struct MutexGuard_<T: ?Sized, R: Deref<Target = Mutex<T>>> {\n /// A guard that provides exclusive access to the data protected by a [`Mutex`].\n pub type MutexGuard<'a, T> = MutexGuard_<T, &'a Mutex<T>>;\n \n+impl<'a, T: ?Sized> MutexGuard<'a, T> {\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the given reference of [`Mutex`] lock has been successfully acquired\n+    /// in the current context. When the created [`MutexGuard`] is dropped, it will unlock the [`Mutex`].\n+    unsafe fn new(mutex: &'a Mutex<T>) -> MutexGuard<'a, T> {\n+        MutexGuard { mutex }\n+    }\n+}\n+\n /// An guard that provides exclusive access to the data protected by a `Arc<Mutex>`.\n pub type ArcMutexGuard<T> = MutexGuard_<T, Arc<Mutex<T>>>;\n \n",
        "test_patch": "diff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -138,3 +150,27 @@ impl<'a, T: ?Sized> MutexGuard<'a, T> {\n         guard.mutex\n     }\n }\n+\n+#[cfg(ktest)]\n+mod test {\n+    use super::*;\n+    use crate::prelude::*;\n+\n+    // A regression test for a bug fixed in [#1279](https://github.com/asterinas/asterinas/pull/1279).\n+    #[ktest]\n+    fn test_mutex_try_lock_does_not_unlock() {\n+        let lock = Mutex::new(0);\n+        assert!(!lock.lock.load(Ordering::Relaxed));\n+\n+        // A successful lock\n+        let guard1 = lock.lock();\n+        assert!(lock.lock.load(Ordering::Relaxed));\n+\n+        // A failed `try_lock` won't drop the lock\n+        assert!(lock.try_lock().is_none());\n+        assert!(lock.lock.load(Ordering::Relaxed));\n+\n+        // Ensure the lock is held until here\n+        drop(guard1);\n+    }\n+}\n",
        "problem_statement": "Potential mutex lock bug leading to multiple threads entering critical section\n### Describe the bug\r\n\r\nHi there!\r\n\r\nI'm working on a testcase for issue #1261 to reproduce the bug, and I noticed a weird behavior. It seems that `mutex.lock()` does not block when another thread has already acquired the lock in `ktest`. This causes multiple threads to enter the critical section simultaneously.\r\n\r\n### To Reproduce\r\n\r\n1. `git apply ./patch.diff`\r\n2. `make ktest`\r\n\r\nHere is the `path.diff` file:\r\n\r\n**Note**: I'm not sure if I inited the test environment and used `timer::Jiffies` and `Thread::yield_now()` correctly. I observed that without using `yield_now()`, thread scheduling does not occur. In other words, if `Thread::yield_now()` is commented out, this test case will pass.\r\n\r\n```diff\r\ndiff --git a/kernel/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\r\nindex 944fe070..52f3e971 100644\r\n--- a/kernel/src/process/sync/condvar.rs\r\n+++ b/kernel/src/process/sync/condvar.rs\r\n@@ -363,4 +363,51 @@ mod test {\r\n             assert!(!*started);\r\n         }\r\n     }\r\n+\r\n+    use ostd::arch::timer::Jiffies;\r\n+\r\n+    fn wait_jiffies(value: u64) {\r\n+        let mut previous = Jiffies::elapsed().as_u64();\r\n+        let ddl = previous + value;\r\n+        loop {\r\n+            let current = Jiffies::elapsed().as_u64();\r\n+            if current >= ddl {\r\n+                break;\r\n+            }\r\n+            if current - previous >= 10 {\r\n+                previous = current;\r\n+                Thread::yield_now();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    #[ktest]\r\n+    fn test_mutex_cs() {\r\n+        let pair = Arc::new((Mutex::new(0), Condvar::new()));\r\n+        let pair2 = Arc::clone(&pair);\r\n+\r\n+        Thread::spawn_kernel_thread(ThreadOptions::new(move || {\r\n+            wait_jiffies(1000);\r\n+            let (lock, _) = &*pair;\r\n+            let mut val = lock.lock();\r\n+            *val = 1;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 1);\r\n+            *val = 2;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 2);\r\n+        }));\r\n+\r\n+        {\r\n+            let (lock2, _) = &*pair2;\r\n+            let mut val = lock2.lock();\r\n+            *val = 10;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 10);\r\n+            *val = 20;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 20);\r\n+        }\r\n+\r\n+    }\r\n }\r\n```\r\n\r\n### Expected behavior\r\n\r\nOnly one thread should enter the critical section at a time.\r\n\r\n### Screenshots\r\n\r\n![28cecd84ca55772867240a21d99ec32](https://github.com/user-attachments/assets/2c93be85-fd48-4656-bbd1-fae9c2fd2b31)\r\n\r\n### Environment\r\n\r\nOfficial Docker environment, version 0.8.1\r\n\r\n\n",
        "hints_text": "The bug introduced in this commit: https://github.com/asterinas/asterinas/commit/d15b4d9115cf33490245c06a93928995765f0d3f#r146080074\r\n\r\nA potential fix: #497",
        "created_at": "2024-09-02T06:56:20Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 928,
        "instance_id": "asterinas__asterinas-928",
        "issue_numbers": [
            "906"
        ],
        "base_commit": "e210e68920481c911f62f03ade0a780f96e48e24",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -161,13 +161,6 @@ impl PageTableEntryTrait for PageTableEntry {\n         let flags = PageTableFlags::PRESENT.bits()\n             | PageTableFlags::WRITABLE.bits()\n             | PageTableFlags::USER.bits();\n-        #[cfg(feature = \"intel_tdx\")]\n-        let flags = flags\n-            | parse_flags!(\n-                prop.priv_flags.bits(),\n-                PrivFlags::SHARED,\n-                PageTableFlags::SHARED\n-            );\n         Self(paddr & Self::PHYS_ADDR_MASK | flags)\n     }\n \n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -11,15 +11,12 @@ use tdx_guest::{\n };\n use trapframe::TrapFrame;\n \n-use crate::{\n-    arch::mm::PageTableFlags,\n-    mm::{\n-        kspace::KERNEL_PAGE_TABLE,\n-        paddr_to_vaddr,\n-        page_prop::{CachePolicy, PageProperty, PrivilegedPageFlags as PrivFlags},\n-        page_table::PageTableError,\n-        KERNEL_BASE_VADDR, KERNEL_END_VADDR, PAGE_SIZE,\n-    },\n+use crate::mm::{\n+    kspace::{BOOT_PAGE_TABLE, KERNEL_BASE_VADDR, KERNEL_END_VADDR, KERNEL_PAGE_TABLE},\n+    paddr_to_vaddr,\n+    page_prop::{PageProperty, PrivilegedPageFlags as PrivFlags},\n+    page_table::PageTableError,\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -416,16 +413,28 @@ pub unsafe fn unprotect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Pa\n     if gpa & PAGE_MASK != 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags | PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa(\n         (gpa & (!PAGE_MASK)) as u64 | SHARED_MASK,\n         (page_num * PAGE_SIZE) as u64,\n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -452,16 +461,28 @@ pub unsafe fn protect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Page\n     if gpa & !PAGE_MASK == 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags - PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa((gpa & PAGE_MASK) as u64, (page_num * PAGE_SIZE) as u64)\n         .map_err(PageConvertError::TdVmcallError)?;\n     for i in 0..page_num {\n\ndiff --git a/framework/aster-frame/src/arch/x86/trap.rs b/framework/aster-frame/src/arch/x86/trap.rs\n--- a/framework/aster-frame/src/arch/x86/trap.rs\n+++ b/framework/aster-frame/src/arch/x86/trap.rs\n@@ -11,11 +11,7 @@ use tdx_guest::tdcall;\n use trapframe::TrapFrame;\n \n #[cfg(feature = \"intel_tdx\")]\n-use crate::arch::{\n-    cpu::VIRTUALIZATION_EXCEPTION,\n-    mm::PageTableFlags,\n-    tdx_guest::{handle_virtual_exception, TdxTrapFrame},\n-};\n+use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, PageFaultErrorCode, PAGE_FAULT},\n     cpu_local,\n\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -76,15 +76,15 @@ pub fn init() {\n     boot::init();\n \n     mm::page::allocator::init();\n-    let mut boot_pt = mm::get_boot_pt();\n-    let meta_pages = mm::init_page_meta(&mut boot_pt);\n+    mm::kspace::init_boot_page_table();\n+    mm::kspace::init_kernel_page_table(mm::init_page_meta());\n     mm::misc_init();\n \n     trap::init();\n     arch::after_all_init();\n     bus::init();\n \n-    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\n+    mm::kspace::activate_kernel_page_table();\n \n     invoke_ffi_init_funcs();\n }\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -7,24 +7,27 @@\n //! The kernel memory space is currently managed as follows, if the\n //! address width is 48 bits (with 47 bits kernel space).\n //!\n+//! TODO: the cap of linear mapping (the start of vm alloc) are raised\n+//! to workaround for high IO in TDX. We need actual vm alloc API to have\n+//! a proper fix.\n+//!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n //! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n-//! +-+ <- 0xffff_e100_0000_0000\n-//! | |         For frame metadata, 1 TiB. Mapped frames are untracked.\n-//! +-+ <- 0xffff_e000_0000_0000\n-//! | |\n-//! | |         For vm alloc/io mappings, 32 TiB.\n+//! +-+ <- 0xffff_ff00_0000_0000\n+//! | |         For frame metadata, 1 TiB.\n+//! | |         Mapped frames are untracked.\n+//! +-+ <- 0xffff_fe00_0000_0000\n+//! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\n+//! +-+ <- 0xffff_fd00_0000_0000\n //! | |\n-//! +-+ <- the middle of the higher half (0xffff_c000_0000_0000)\n //! | |\n //! | |\n-//! | |\n-//! | |         For linear mappings, 64 TiB.\n+//! | |         For linear mappings.\n //! | |         Mapped physical addresses are untracked.\n //! | |\n //! | |\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -36,7 +39,7 @@\n //! 39 bits or 57 bits, the memory space just adjust porportionally.\n \n use alloc::vec::Vec;\n-use core::ops::Range;\n+use core::{mem::ManuallyDrop, ops::Range};\n \n use align_ext::AlignExt;\n use log::info;\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -52,7 +55,10 @@ use super::{\n     page_table::{boot_pt::BootPageTable, KernelMode, PageTable},\n     MemoryRegionType, Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    sync::SpinLock,\n+};\n \n /// The shortest supported address width is 39 bits. And the literal\n /// values are written for 48 bits address width. Adjust the values\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -76,12 +82,12 @@ pub fn kernel_loaded_offset() -> usize {\n \n const KERNEL_CODE_BASE_VADDR: usize = 0xffff_ffff_8000_0000 << ADDR_WIDTH_SHIFT;\n \n-const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_e100_0000_0000 << ADDR_WIDTH_SHIFT;\n-const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_e000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_ff00_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_fe00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub(in crate::mm) const FRAME_METADATA_RANGE: Range<Vaddr> =\n     FRAME_METADATA_BASE_VADDR..FRAME_METADATA_CAP_VADDR;\n \n-const VMALLOC_BASE_VADDR: Vaddr = 0xffff_c000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const VMALLOC_BASE_VADDR: Vaddr = 0xffff_fd00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub const VMALLOC_VADDR_RANGE: Range<Vaddr> = VMALLOC_BASE_VADDR..FRAME_METADATA_BASE_VADDR;\n \n /// The base address of the linear mapping of all physical\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -95,9 +101,25 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// The boot page table instance.\n+///\n+/// It is used in the initialization phase before [`KERNEL_PAGE_TABLE`] is activated.\n+/// Since we want dropping the boot page table unsafe, it is wrapped in a [`ManuallyDrop`].\n+pub static BOOT_PAGE_TABLE: SpinLock<Option<ManuallyDrop<BootPageTable>>> = SpinLock::new(None);\n+\n+/// The kernel page table instance.\n+///\n+/// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\n+/// is unlikely to be activated.\n pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingConsts>> =\n     Once::new();\n \n+/// Initializes the boot page table.\n+pub(crate) fn init_boot_page_table() {\n+    let boot_pt = BootPageTable::from_current_pt();\n+    *BOOT_PAGE_TABLE.lock() = Some(ManuallyDrop::new(boot_pt));\n+}\n+\n /// Initializes the kernel page table.\n ///\n /// This function should be called after:\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -106,10 +128,7 @@ pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingC\n ///\n /// This function should be called before:\n ///  - any initializer that modifies the kernel page table.\n-pub fn init_kernel_page_table(\n-    boot_pt: BootPageTable<PageTableEntry, PagingConsts>,\n-    meta_pages: Vec<Range<Paddr>>,\n-) {\n+pub fn init_kernel_page_table(meta_pages: Vec<Range<Paddr>>) {\n     info!(\"Initializing the kernel page table\");\n \n     let regions = crate::boot::memory_regions();\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -201,15 +220,21 @@ pub fn init_kernel_page_table(\n         }\n     }\n \n+    KERNEL_PAGE_TABLE.call_once(|| kpt);\n+}\n+\n+pub fn activate_kernel_page_table() {\n+    let kpt = KERNEL_PAGE_TABLE\n+        .get()\n+        .expect(\"The kernel page table is not initialized yet\");\n     // SAFETY: the kernel page table is initialized properly.\n     unsafe {\n         kpt.first_activate_unchecked();\n         crate::arch::mm::tlb_flush_all_including_global();\n     }\n \n-    KERNEL_PAGE_TABLE.call_once(|| kpt);\n-\n-    // SAFETY: the boot page table is OK to be retired now since\n+    // SAFETY: the boot page table is OK to be dropped now since\n     // the kernel page table is activated.\n-    unsafe { boot_pt.retire() };\n+    let mut boot_pt = BOOT_PAGE_TABLE.lock().take().unwrap();\n+    unsafe { ManuallyDrop::drop(&mut boot_pt) };\n }\n\ndiff --git a/framework/aster-frame/src/mm/mod.rs b/framework/aster-frame/src/mm/mod.rs\n--- a/framework/aster-frame/src/mm/mod.rs\n+++ b/framework/aster-frame/src/mm/mod.rs\n@@ -131,7 +131,3 @@ pub(crate) fn misc_init() {\n     }\n     FRAMEBUFFER_REGIONS.call_once(|| framebuffer_regions);\n }\n-\n-pub(crate) fn get_boot_pt() -> page_table::boot_pt::BootPageTable {\n-    unsafe { page_table::boot_pt::BootPageTable::from_current_pt() }\n-}\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -53,12 +53,9 @@ use super::Page;\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr,\n-        page::allocator::FRAME_ALLOCATOR,\n-        page_size,\n-        page_table::{boot_pt::BootPageTable, PageTableEntryTrait},\n-        CachePolicy, Paddr, PageFlags, PageProperty, PagingConstsTrait, PagingLevel,\n-        PrivilegedPageFlags, PAGE_SIZE,\n+        kspace::BOOT_PAGE_TABLE, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, page_size,\n+        page_table::PageTableEntryTrait, CachePolicy, Paddr, PageFlags, PageProperty,\n+        PagingConstsTrait, PagingLevel, PrivilegedPageFlags, PAGE_SIZE,\n     },\n };\n \n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -191,7 +188,7 @@ impl PageMeta for KernelMeta {\n /// Initializes the metadata of all physical pages.\n ///\n /// The function returns a list of `Page`s containing the metadata.\n-pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n+pub(crate) fn init() -> Vec<Range<Paddr>> {\n     let max_paddr = {\n         let regions = crate::boot::memory_regions();\n         regions.iter().map(|r| r.base() + r.len()).max().unwrap()\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -207,8 +204,11 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n     let num_pages = max_paddr / page_size::<PagingConsts>(1);\n     let num_meta_pages = (num_pages * size_of::<MetaSlot>()).div_ceil(PAGE_SIZE);\n     let meta_pages = alloc_meta_pages(num_meta_pages);\n-\n     // Map the metadata pages.\n+    let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+    let boot_pt = boot_pt_lock\n+        .as_mut()\n+        .expect(\"boot page table not initialized\");\n     for (i, frame_paddr) in meta_pages.iter().enumerate() {\n         let vaddr = mapping::page_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n         let prop = PageProperty {\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -216,9 +216,9 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n             cache: CachePolicy::Writeback,\n             priv_flags: PrivilegedPageFlags::GLOBAL,\n         };\n-        boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop);\n+        // SAFETY: we are doing the metadata mappings for the kernel.\n+        unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n     }\n-\n     // Now the metadata pages are mapped, we can initialize the metadata.\n     meta_pages\n         .into_iter()\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -10,8 +10,8 @@ use super::{pte_index, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty, PagingConstsTrait, Vaddr,\n-        PAGE_SIZE,\n+        nr_subpage_per_huge, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty,\n+        PagingConstsTrait, Vaddr, PAGE_SIZE,\n     },\n };\n \n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -34,10 +34,7 @@ pub struct BootPageTable<\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     /// Creates a new boot page table from the current page table root physical address.\n-    ///\n-    /// The caller must ensure that the current page table may be set up by the firmware,\n-    /// loader or the setup code.\n-    pub unsafe fn from_current_pt() -> Self {\n+    pub fn from_current_pt() -> Self {\n         let root_paddr = crate::arch::mm::current_page_table_paddr();\n         Self {\n             root_pt: root_paddr / C::BASE_PAGE_SIZE,\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -47,8 +44,16 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     }\n \n     /// Maps a base page to a frame.\n+    ///\n+    /// # Panics\n+    ///\n     /// This function will panic if the page is already mapped.\n-    pub fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n         let mut pt = self.root_pt;\n         let mut level = C::NR_LEVELS;\n         // Walk to the last level of the page table.\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -77,6 +82,67 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { pte_ptr.write(E::new_frame(to * C::BASE_PAGE_SIZE, 1, prop)) };\n     }\n \n+    /// Maps a base page to a frame.\n+    ///\n+    /// This function may split a huge page into base pages, causing page allocations\n+    /// if the original mapping is a huge page.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the page is already mapped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn protect_base_page(\n+        &mut self,\n+        virt_addr: Vaddr,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) {\n+        let mut pt = self.root_pt;\n+        let mut level = C::NR_LEVELS;\n+        // Walk to the last level of the page table.\n+        while level > 1 {\n+            let index = pte_index::<C>(virt_addr, level);\n+            let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+            let pte = unsafe { pte_ptr.read() };\n+            pt = if !pte.is_present() {\n+                panic!(\"protecting an unmapped page in the boot page table\");\n+            } else if pte.is_last(level) {\n+                // Split the huge page.\n+                let frame = self.alloc_frame();\n+                let huge_pa = pte.paddr();\n+                for i in 0..nr_subpage_per_huge::<C>() {\n+                    let nxt_ptr =\n+                        unsafe { (paddr_to_vaddr(frame * C::BASE_PAGE_SIZE) as *mut E).add(i) };\n+                    unsafe {\n+                        nxt_ptr.write(E::new_frame(\n+                            huge_pa + i * C::BASE_PAGE_SIZE,\n+                            level - 1,\n+                            pte.prop(),\n+                        ))\n+                    };\n+                }\n+                unsafe { pte_ptr.write(E::new_pt(frame * C::BASE_PAGE_SIZE)) };\n+                frame\n+            } else {\n+                pte.paddr() / C::BASE_PAGE_SIZE\n+            };\n+            level -= 1;\n+        }\n+        // Do protection in the last level page table.\n+        let index = pte_index::<C>(virt_addr, 1);\n+        let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+        let pte = unsafe { pte_ptr.read() };\n+        if !pte.is_present() {\n+            panic!(\"protecting an unmapped page in the boot page table\");\n+        }\n+        let mut prop = pte.prop();\n+        op(&mut prop);\n+        unsafe { pte_ptr.write(E::new_frame(pte.paddr(), 1, prop)) };\n+    }\n+\n     fn alloc_frame(&mut self) -> FrameNumber {\n         let frame = FRAME_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n         self.frames.push(frame);\n",
        "test_patch": "diff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -85,43 +151,19 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { core::ptr::write_bytes(vaddr, 0, PAGE_SIZE) };\n         frame\n     }\n-\n-    /// Retires this boot-stage page table.\n-    ///\n-    /// Do not drop a boot-stage page table. Instead, retire it.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method can only be called when this boot-stage page table is no longer in use,\n-    /// e.g., after the permanent kernel page table has been activated.\n-    pub unsafe fn retire(mut self) {\n-        // Manually free all heap and frame memory allocated.\n-        let frames = core::mem::take(&mut self.frames);\n-        for frame in frames {\n-            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(frame, 1);\n-        }\n-        // We do not want or need to trigger drop.\n-        core::mem::forget(self);\n-        // FIXME: an empty `Vec` is leaked on the heap here since the drop is not called\n-        // and we have no ways to free it.\n-        // The best solution to recycle the boot-phase page table is to initialize all\n-        // page table page metadata of the boot page table by page walk after the metadata\n-        // pages are mapped. Therefore the boot page table can be recycled or dropped by\n-        // the routines in the [`super::node`] module. There's even without a need of\n-        // `first_activate` concept if the boot page table can be managed by page table\n-        // pages.\n-    }\n }\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for BootPageTable<E, C> {\n     fn drop(&mut self) {\n-        panic!(\"the boot page table is dropped rather than retired.\");\n+        for frame in &self.frames {\n+            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(*frame, 1);\n+        }\n     }\n }\n \n #[cfg(ktest)]\n #[ktest]\n-fn test_boot_pt() {\n+fn test_boot_pt_map_protect() {\n     use super::page_walk;\n     use crate::{\n         arch::mm::{PageTableEntry, PagingConsts},\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -140,20 +182,34 @@ fn test_boot_pt() {\n     let from1 = 0x1000;\n     let to1 = 0x2;\n     let prop1 = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n-    boot_pt.map_base_page(from1, to1, prop1);\n+    unsafe { boot_pt.map_base_page(from1, to1, prop1) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n         Some((to1 * PAGE_SIZE + 1, prop1))\n     );\n+    unsafe { boot_pt.protect_base_page(from1, |prop| prop.flags = PageFlags::RX) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n+        Some((\n+            to1 * PAGE_SIZE + 1,\n+            PageProperty::new(PageFlags::RX, CachePolicy::Writeback)\n+        ))\n+    );\n \n     let from2 = 0x2000;\n     let to2 = 0x3;\n     let prop2 = PageProperty::new(PageFlags::RX, CachePolicy::Uncacheable);\n-    boot_pt.map_base_page(from2, to2, prop2);\n+    unsafe { boot_pt.map_base_page(from2, to2, prop2) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n         Some((to2 * PAGE_SIZE + 2, prop2))\n     );\n-\n-    unsafe { boot_pt.retire() }\n+    unsafe { boot_pt.protect_base_page(from2, |prop| prop.flags = PageFlags::RW) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n+        Some((\n+            to2 * PAGE_SIZE + 2,\n+            PageProperty::new(PageFlags::RW, CachePolicy::Uncacheable)\n+        ))\n+    );\n }\n",
        "problem_statement": "[TDX BUG] The TDX SHARED bit can\u2018t be set in the page table during IOAPIC initialization.\nIn `framework/aster-frame/src/arch/x86/tdx_guest.rs`:\r\n```rust\r\n    trap::init();\r\n    arch::after_all_init();\r\n    bus::init();\r\n\r\n    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\r\n```\r\n\r\nThe kernel page table is initialized and activated in the `init_kernel_page_table` function. This step occurs after ioapic is initialized (via `after_all_init` function).\r\n\r\nHowever, we should set the ioapic MMIO space as shared page in TDX env, this process manipulates the page table, but the page table is not yet activated.\r\n\n",
        "hints_text": "",
        "created_at": "2024-06-12T07:29:38Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1159,
        "instance_id": "asterinas__asterinas-1159",
        "issue_numbers": [
            "975"
        ],
        "base_commit": "c2a83427520f8263a8eb2c36edacdba261ad5cae",
        "patch": "diff --git a/.github/workflows/benchmark_asterinas.yml b/.github/workflows/benchmark_asterinas.yml\n--- a/.github/workflows/benchmark_asterinas.yml\n+++ b/.github/workflows/benchmark_asterinas.yml\n@@ -57,7 +57,7 @@ jobs:\n       fail-fast: false\n     timeout-minutes: 60\n     container: \n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\n\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -16,7 +16,7 @@ jobs:\n   osdk-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v4\n \n\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -39,7 +39,7 @@ jobs:\n   ostd-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     strategy:\n       matrix:\n         # All supported targets, this array should keep consistent with\n\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -48,15 +48,18 @@ jobs:\n     steps:\n       - uses: actions/checkout@v4\n \n-      - name: Check Publish OSTD\n+      - name: Check Publish OSTD and the test runner\n         # On pull request, set `--dry-run` to check whether OSDK can publish\n         if: github.event_name == 'pull_request'\n         run: |\n           cd ostd\n           cargo publish --target ${{ matrix.target }} --dry-run\n           cargo doc --target ${{ matrix.target }}\n+          cd osdk/test-kernel\n+          cargo publish --target ${{ matrix.target }} --dry-run\n+          cargo doc --target ${{ matrix.target }}\n       \n-      - name: Publish OSTD\n+      - name: Publish OSTD and the test runner\n         if: github.event_name == 'push'\n         env:\n           REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -66,4 +69,6 @@ jobs:\n         run: |\n           cd ostd\n           cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n-      \n+          cd osdk/test-kernel\n+          cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n+      \n\\ No newline at end of file\n\ndiff --git a/.github/workflows/publish_website.yml b/.github/workflows/publish_website.yml\n--- a/.github/workflows/publish_website.yml\n+++ b/.github/workflows/publish_website.yml\n@@ -16,7 +16,7 @@ jobs:\n   build_and_deploy:\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v2\n         with:\n\ndiff --git a/.github/workflows/push_git_tag.yml b/.github/workflows/push_git_tag.yml\n--- a/.github/workflows/push_git_tag.yml\n+++ b/.github/workflows/push_git_tag.yml\n@@ -17,4 +17,4 @@ jobs:\n         uses: pxpm/github-tag-action@1.0.1\n         with:\n           repo-token: ${{ secrets.GITHUB_TOKEN }}\n-          tag: v0.7.0\n+          tag: v0.8.0\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -153,6 +153,7 @@ dependencies = [\n  \"ascii\",\n  \"aster-block\",\n  \"aster-console\",\n+ \"aster-framebuffer\",\n  \"aster-input\",\n  \"aster-network\",\n  \"aster-rights\",\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -166,6 +167,7 @@ dependencies = [\n  \"bytemuck\",\n  \"bytemuck_derive\",\n  \"cfg-if\",\n+ \"component\",\n  \"controlled\",\n  \"core2\",\n  \"cpio-decoder\",\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -262,19 +264,6 @@ dependencies = [\n  \"typeflags-util\",\n ]\n \n-[[package]]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n-dependencies = [\n- \"aster-framebuffer\",\n- \"aster-nix\",\n- \"aster-time\",\n- \"component\",\n- \"id-alloc\",\n- \"ostd\",\n- \"x86_64 0.14.11\",\n-]\n-\n [[package]]\n name = \"atomic\"\n version = \"0.6.0\"\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1045,9 +1034,18 @@ version = \"1.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d\"\n \n+[[package]]\n+name = \"osdk-test-kernel\"\n+version = \"0.8.0\"\n+dependencies = [\n+ \"ostd\",\n+ \"owo-colors 4.0.0\",\n+ \"unwinding\",\n+]\n+\n [[package]]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n dependencies = [\n  \"acpi\",\n  \"align_ext\",\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1075,7 +1073,7 @@ dependencies = [\n  \"ostd-macros\",\n  \"ostd-pod\",\n  \"ostd-test\",\n- \"owo-colors\",\n+ \"owo-colors 3.5.0\",\n  \"rsdp\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1119,9 +1117,6 @@ dependencies = [\n [[package]]\n name = \"ostd-test\"\n version = \"0.1.0\"\n-dependencies = [\n- \"owo-colors\",\n-]\n \n [[package]]\n name = \"owo-colors\"\n\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1129,6 +1124,12 @@ version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n+[[package]]\n+name = \"owo-colors\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f\"\n+\n [[package]]\n name = \"paste\"\n version = \"1.0.14\"\n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,6 +1,7 @@\n [workspace]\n resolver = \"2\"\n members = [\n+    \"osdk/test-kernel\",\n     \"ostd\",\n     \"ostd/libs/align_ext\",\n     \"ostd/libs/ostd-macros\",\n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -10,7 +11,6 @@ members = [\n     \"ostd/libs/linux-bzimage/setup\",\n     \"ostd/libs/ostd-test\",\n     \"kernel\",\n-    \"kernel/aster-nix\",\n     \"kernel/comps/block\",\n     \"kernel/comps/console\",\n     \"kernel/comps/framebuffer\",\n\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -8,8 +8,7 @@ console = { name = \"aster-console\" }\n time = { name = \"aster-time\" }\n framebuffer = { name = \"aster-framebuffer\" }\n network = { name = \"aster-network\" }\n-main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.nix.run_first_process]\n+[whitelist.nix.main]\n main = true\n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -110,10 +110,10 @@ NON_OSDK_CRATES := \\\n # In contrast, OSDK crates depend on OSTD (or being `ostd` itself)\n # and need to be built or tested with OSDK.\n OSDK_CRATES := \\\n+\tosdk/test-kernel \\\n \tostd \\\n \tostd/libs/linux-bzimage/setup \\\n \tkernel \\\n-\tkernel/aster-nix \\\n \tkernel/comps/block \\\n \tkernel/comps/console \\\n \tkernel/comps/framebuffer \\\n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -130,7 +130,10 @@ all: build\n # To uninstall, do `cargo uninstall cargo-osdk`\n .PHONY: install_osdk\n install_osdk:\n-\t@cargo install cargo-osdk --path osdk\n+\t@# The `OSDK_LOCAL_DEV` environment variable is used for local development\n+\t@# without the need to publish the changes of OSDK's self-hosted\n+\t@# dependencies to `crates.io`.\n+\t@OSDK_LOCAL_DEV=1 cargo install cargo-osdk --path osdk\n \n # This will install OSDK if it is not already installed\n # To update OSDK, we need to run `install_osdk` manually\n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -206,7 +209,7 @@ format:\n \t@make --no-print-directory -C test format\n \n .PHONY: check\n-check: $(CARGO_OSDK)\n+check: initramfs $(CARGO_OSDK)\n \t@./tools/format_all.sh --check   \t# Check Rust format issues\n \t@# Check if STD_CRATES and NOSTD_CRATES combined is the same as all workspace members\n \t@sed -n '/^\\[workspace\\]/,/^\\[.*\\]/{/members = \\[/,/\\]/p}' Cargo.toml | \\\n\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -52,7 +52,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\n\ndiff --git a/README_CN.md b/README_CN.md\n--- a/README_CN.md\n+++ b/README_CN.md\n@@ -49,7 +49,7 @@ git clone https://github.com/asterinas/asterinas\n 2. \u8fd0\u884c\u4e00\u4e2a\u4f5c\u4e3a\u5f00\u53d1\u73af\u5883\u7684Docker\u5bb9\u5668\u3002\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. \u5728\u5bb9\u5668\u5185\uff0c\u8fdb\u5165\u9879\u76ee\u6587\u4ef6\u5939\u6784\u5efa\u5e76\u8fd0\u884c\u661f\u7efd\u3002\n\ndiff --git a/VERSION b/VERSION\n--- a/VERSION\n+++ b/VERSION\n@@ -1,1 +1,1 @@\n-0.7.0\n\\ No newline at end of file\n+0.8.0\n\\ No newline at end of file\n\ndiff --git a/docs/src/kernel/README.md b/docs/src/kernel/README.md\n--- a/docs/src/kernel/README.md\n+++ b/docs/src/kernel/README.md\n@@ -44,7 +44,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\n\ndiff --git a/docs/src/kernel/intel_tdx.md b/docs/src/kernel/intel_tdx.md\n--- a/docs/src/kernel/intel_tdx.md\n+++ b/docs/src/kernel/intel_tdx.md\n@@ -66,7 +66,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0-tdx\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0-tdx\n ```\n \n 3. Inside the container,\n\ndiff --git a/docs/src/osdk/reference/manifest.md b/docs/src/osdk/reference/manifest.md\n--- a/docs/src/osdk/reference/manifest.md\n+++ b/docs/src/osdk/reference/manifest.md\n@@ -15,10 +15,10 @@ one is of the workspace\n (in the same directory as the workspace's `Cargo.toml`)\n and one of the crate\n (in the same directory as the crate's `Cargo.toml`).\n-OSDK will first refer to the crate-level manifest, then\n-query the workspace-level manifest for undefined fields.\n-In other words, missing fields of the crate manifest\n-will inherit values from the workspace manifest.\n+OSDK will firstly try to find the crate-level manifest.\n+If the crate-level manifest is found, OSDK uses it only.\n+If the manifest is not found, OSDK will look into the\n+workspace-level manifest.\n \n ## Configurations\n \n\ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -1,18 +1,82 @@\n [package]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n+name = \"aster-nix\"\n+version = \"0.1.0\"\n edition = \"2021\"\n \n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n [dependencies]\n-id-alloc = { path = \"../ostd/libs/id-alloc\" }\n-ostd = { path = \"../ostd\" }\n-aster-nix = { path = \"aster-nix\" }\n+align_ext = { path = \"../ostd/libs/align_ext\" }\n+aster-input = { path = \"comps/input\" }\n+aster-block = { path = \"comps/block\" }\n+aster-network = { path = \"comps/network\" }\n+aster-console = { path = \"comps/console\" }\n+aster-framebuffer = { path = \"comps/framebuffer\" }\n+aster-time = { path = \"comps/time\" }\n+aster-virtio = { path = \"comps/virtio\" }\n+aster-rights = { path = \"libs/aster-rights\" }\n component = { path = \"libs/comp-sys/component\" }\n+controlled = { path = \"libs/comp-sys/controlled\" }\n+ostd = { path = \"../ostd\" }\n+typeflags = { path = \"libs/typeflags\" }\n+typeflags-util = { path = \"libs/typeflags-util\" }\n+aster-rights-proc = { path = \"libs/aster-rights-proc\" }\n+aster-util = { path = \"libs/aster-util\" }\n+id-alloc = { path = \"../ostd/libs/id-alloc\" }\n+int-to-c-enum = { path = \"libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"libs/cpio-decoder\" }\n+ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n+intrusive-collections = \"0.9.5\"\n+paste = \"1.0\"\n+time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n+smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n+    \"alloc\",\n+    \"log\",\n+    \"medium-ethernet\",\n+    \"medium-ip\",\n+    \"proto-dhcpv4\",\n+    \"proto-ipv4\",\n+    \"proto-igmp\",\n+    \"socket-icmp\",\n+    \"socket-udp\",\n+    \"socket-tcp\",\n+    \"socket-raw\",\n+    \"socket-dhcpv4\",\n+] }\n+tdx-guest = { version = \"0.1.7\", optional = true }\n \n-[dev-dependencies]\n-x86_64 = \"0.14.2\"\n-aster-time = { path = \"comps/time\" }\n-aster-framebuffer = { path = \"comps/framebuffer\" }\n+# parse elf file\n+xmas-elf = \"0.8.0\"\n+# data-structures\n+bitflags = \"1.3\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"libs/keyable-arc\" }\n+# unzip initramfs\n+libflate = { version = \"2\", default-features = false }\n+core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n+lending-iterator = \"0.1.7\"\n+spin = \"0.9.4\"\n+vte = \"0.10\"\n+lru = \"0.12.3\"\n+log = \"0.4\"\n+bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n+hashbrown = \"0.14\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\n+    \"small_rng\",\n+    \"std_rng\",\n+] }\n+static_assertions = \"1.1.0\"\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n+getset = \"0.1.2\"\n+atomic = \"0.6\"\n+bytemuck = \"1.14.3\"\n+bytemuck_derive = \"1.5.0\"\n+takeable = \"0.2.2\"\n+cfg-if = \"1.0\"\n+\n+[dependencies.lazy_static]\n+version = \"1.0\"\n+features = [\"spin_no_std\"]\n \n [features]\n-cvm_guest = [\"ostd/cvm_guest\", \"aster-nix/cvm_guest\"]\n+cvm_guest = [\"dep:tdx-guest\", \"ostd/cvm_guest\"]\n\ndiff --git a/kernel/aster-nix/Cargo.toml /dev/null\n--- a/kernel/aster-nix/Cargo.toml\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-[package]\n-name = \"aster-nix\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-align_ext = { path = \"../../ostd/libs/align_ext\" }\n-aster-input = { path = \"../comps/input\" }\n-aster-block = { path = \"../comps/block\" }\n-aster-network = { path = \"../comps/network\" }\n-aster-console = { path = \"../comps/console\" }\n-aster-time = { path = \"../comps/time\" }\n-aster-virtio = { path = \"../comps/virtio\" }\n-aster-rights = { path = \"../libs/aster-rights\" }\n-controlled = { path = \"../libs/comp-sys/controlled\" }\n-ostd = { path = \"../../ostd\" }\n-typeflags = { path = \"../libs/typeflags\" }\n-typeflags-util = { path = \"../libs/typeflags-util\" }\n-aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n-aster-util = { path = \"../libs/aster-util\" }\n-id-alloc = { path = \"../../ostd/libs/id-alloc\" }\n-int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../libs/cpio-decoder\" }\n-ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n-intrusive-collections = \"0.9.5\"\n-paste = \"1.0\"\n-time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n-smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n-    \"alloc\",\n-    \"log\",\n-    \"medium-ethernet\",\n-    \"medium-ip\",\n-    \"proto-dhcpv4\",\n-    \"proto-ipv4\",\n-    \"proto-igmp\",\n-    \"socket-icmp\",\n-    \"socket-udp\",\n-    \"socket-tcp\",\n-    \"socket-raw\",\n-    \"socket-dhcpv4\",\n-] }\n-tdx-guest = { version = \"0.1.7\", optional = true }\n-\n-# parse elf file\n-xmas-elf = \"0.8.0\"\n-# goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n-# data-structures\n-bitflags = \"1.3\"\n-ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../libs/keyable-arc\" }\n-# unzip initramfs\n-libflate = { version = \"2\", default-features = false }\n-core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n-lending-iterator = \"0.1.7\"\n-spin = \"0.9.4\"\n-vte = \"0.10\"\n-lru = \"0.12.3\"\n-log = \"0.4\"\n-bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-hashbrown = \"0.14\"\n-rand = { version = \"0.8.5\", default-features = false, features = [\n-    \"small_rng\",\n-    \"std_rng\",\n-] }\n-static_assertions = \"1.1.0\"\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-getset = \"0.1.2\"\n-atomic = \"0.6\"\n-bytemuck = \"1.14.3\"\n-bytemuck_derive = \"1.5.0\"\n-takeable = \"0.2.2\"\n-cfg-if = \"1.0\"\n-\n-[dependencies.lazy_static]\n-version = \"1.0\"\n-features = [\"spin_no_std\"]\n-\n-[features]\n-cvm_guest = [\"dep:tdx-guest\"]\n\ndiff --git a/kernel/aster-nix/src/lib.rs /dev/null\n--- a/kernel/aster-nix/src/lib.rs\n+++ /dev/null\n@@ -1,154 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The std library of Asterinas.\n-#![no_std]\n-#![deny(unsafe_code)]\n-#![allow(incomplete_features)]\n-#![feature(btree_cursors)]\n-#![feature(btree_extract_if)]\n-#![feature(const_option)]\n-#![feature(extend_one)]\n-#![feature(fn_traits)]\n-#![feature(format_args_nl)]\n-#![feature(int_roundings)]\n-#![feature(iter_repeat_n)]\n-#![feature(let_chains)]\n-#![feature(linked_list_remove)]\n-#![feature(negative_impls)]\n-#![feature(register_tool)]\n-// FIXME: This feature is used to support vm capbility now as a work around.\n-// Since this is an incomplete feature, use this feature is unsafe.\n-// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n-#![feature(specialization)]\n-#![feature(step_trait)]\n-#![feature(trait_alias)]\n-#![feature(trait_upcasting)]\n-#![feature(linked_list_retain)]\n-#![register_tool(component_access_control)]\n-\n-use ostd::{\n-    arch::qemu::{exit_qemu, QemuExitCode},\n-    boot,\n-};\n-use process::Process;\n-\n-use crate::{\n-    prelude::*,\n-    thread::{\n-        kernel_thread::{KernelThreadExt, ThreadOptions},\n-        Thread,\n-    },\n-};\n-\n-extern crate alloc;\n-extern crate lru;\n-#[macro_use]\n-extern crate controlled;\n-#[macro_use]\n-extern crate getset;\n-\n-pub mod arch;\n-pub mod console;\n-pub mod context;\n-pub mod cpu;\n-pub mod device;\n-pub mod driver;\n-pub mod error;\n-pub mod events;\n-pub mod fs;\n-pub mod ipc;\n-pub mod net;\n-pub mod prelude;\n-mod process;\n-mod sched;\n-pub mod softirq_id;\n-pub mod syscall;\n-mod taskless;\n-pub mod thread;\n-pub mod time;\n-mod util;\n-pub(crate) mod vdso;\n-pub mod vm;\n-\n-pub fn init() {\n-    util::random::init();\n-    driver::init();\n-    time::init();\n-    net::init();\n-    sched::init();\n-    fs::rootfs::init(boot::initramfs()).unwrap();\n-    device::init().unwrap();\n-    vdso::init();\n-    taskless::init();\n-    process::init();\n-}\n-\n-fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n-    // Work queue should be initialized before interrupt is enabled,\n-    // in case any irq handler uses work queue as bottom half\n-    thread::work_queue::init();\n-    net::lazy_init();\n-    fs::lazy_init();\n-    ipc::init();\n-    // driver::pci::virtio::block::block_device_test();\n-    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n-        println!(\"[kernel] Hello world from kernel!\");\n-        let current = current_thread!();\n-        let tid = current.tid();\n-        debug!(\"current tid = {}\", tid);\n-    }));\n-    thread.join();\n-    info!(\n-        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n-        thread.tid()\n-    );\n-\n-    print_banner();\n-\n-    let karg = boot::kernel_cmdline();\n-\n-    let initproc = Process::spawn_user_process(\n-        karg.get_initproc_path().unwrap(),\n-        karg.get_initproc_argv().to_vec(),\n-        karg.get_initproc_envp().to_vec(),\n-    )\n-    .expect(\"Run init process failed.\");\n-    // Wait till initproc become zombie.\n-    while !initproc.is_zombie() {\n-        // We don't have preemptive scheduler now.\n-        // The long running init thread should yield its own execution to allow other tasks to go on.\n-        Thread::yield_now();\n-    }\n-\n-    // TODO: exit via qemu isa debug device should not be the only way.\n-    let exit_code = if initproc.exit_code().unwrap() == 0 {\n-        QemuExitCode::Success\n-    } else {\n-        QemuExitCode::Failed\n-    };\n-    exit_qemu(exit_code);\n-}\n-\n-/// first process never return\n-#[controlled]\n-pub fn run_first_process() -> ! {\n-    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n-    unreachable!()\n-}\n-\n-fn print_banner() {\n-    println!(\"\\x1B[36m\");\n-    println!(\n-        r\"\n-   _   ___ _____ ___ ___ ___ _  _   _   ___\n-  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n- / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n-/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n-\"\n-    );\n-    println!(\"\\x1B[0m\");\n-}\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/utils.rs b/kernel/src/fs/exfat/utils.rs\n--- a/kernel/aster-nix/src/fs/exfat/utils.rs\n+++ b/kernel/src/fs/exfat/utils.rs\n@@ -60,7 +60,6 @@ impl DosTimestamp {\n         #[cfg(not(ktest))]\n         {\n             use crate::time::clocks::RealTimeClock;\n-\n             DosTimestamp::from_duration(RealTimeClock::get().read_time())\n         }\n \n\ndiff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -1,16 +1,161 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+//! Aster-nix is the Asterinas kernel, a safe, efficient unix-like\n+//! operating system kernel built on top of OSTD and OSDK.\n+\n #![no_std]\n #![no_main]\n #![deny(unsafe_code)]\n-extern crate ostd;\n+#![allow(incomplete_features)]\n+#![feature(btree_cursors)]\n+#![feature(btree_extract_if)]\n+#![feature(const_option)]\n+#![feature(extend_one)]\n+#![feature(fn_traits)]\n+#![feature(format_args_nl)]\n+#![feature(int_roundings)]\n+#![feature(iter_repeat_n)]\n+#![feature(let_chains)]\n+#![feature(linkage)]\n+#![feature(linked_list_remove)]\n+#![feature(negative_impls)]\n+#![feature(register_tool)]\n+// FIXME: This feature is used to support vm capbility now as a work around.\n+// Since this is an incomplete feature, use this feature is unsafe.\n+// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n+#![feature(specialization)]\n+#![feature(step_trait)]\n+#![feature(trait_alias)]\n+#![feature(trait_upcasting)]\n+#![feature(linked_list_retain)]\n+#![register_tool(component_access_control)]\n+\n+use ostd::{\n+    arch::qemu::{exit_qemu, QemuExitCode},\n+    boot,\n+};\n+use process::Process;\n+\n+use crate::{\n+    prelude::*,\n+    thread::{\n+        kernel_thread::{KernelThreadExt, ThreadOptions},\n+        Thread,\n+    },\n+};\n+\n+extern crate alloc;\n+extern crate lru;\n+#[macro_use]\n+extern crate controlled;\n+#[macro_use]\n+extern crate getset;\n \n-use ostd::prelude::*;\n+pub mod arch;\n+pub mod console;\n+pub mod context;\n+pub mod cpu;\n+pub mod device;\n+pub mod driver;\n+pub mod error;\n+pub mod events;\n+pub mod fs;\n+pub mod ipc;\n+pub mod net;\n+pub mod prelude;\n+mod process;\n+mod sched;\n+pub mod softirq_id;\n+pub mod syscall;\n+mod taskless;\n+pub mod thread;\n+pub mod time;\n+mod util;\n+pub(crate) mod vdso;\n+pub mod vm;\n \n #[ostd::main]\n+#[controlled]\n pub fn main() {\n-    println!(\"[kernel] finish init ostd\");\n+    ostd::early_println!(\"[kernel] OSTD initialized. Preparing components.\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    aster_nix::init();\n-    aster_nix::run_first_process();\n+    init();\n+    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n+    unreachable!()\n+}\n+\n+pub fn init() {\n+    util::random::init();\n+    driver::init();\n+    time::init();\n+    net::init();\n+    sched::init();\n+    fs::rootfs::init(boot::initramfs()).unwrap();\n+    device::init().unwrap();\n+    vdso::init();\n+    taskless::init();\n+    process::init();\n+}\n+\n+fn init_thread() {\n+    println!(\n+        \"[kernel] Spawn init thread, tid = {}\",\n+        current_thread!().tid()\n+    );\n+    // Work queue should be initialized before interrupt is enabled,\n+    // in case any irq handler uses work queue as bottom half\n+    thread::work_queue::init();\n+    net::lazy_init();\n+    fs::lazy_init();\n+    ipc::init();\n+    // driver::pci::virtio::block::block_device_test();\n+    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n+        println!(\"[kernel] Hello world from kernel!\");\n+        let current = current_thread!();\n+        let tid = current.tid();\n+        debug!(\"current tid = {}\", tid);\n+    }));\n+    thread.join();\n+    info!(\n+        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n+        thread.tid()\n+    );\n+\n+    print_banner();\n+\n+    let karg = boot::kernel_cmdline();\n+\n+    let initproc = Process::spawn_user_process(\n+        karg.get_initproc_path().unwrap(),\n+        karg.get_initproc_argv().to_vec(),\n+        karg.get_initproc_envp().to_vec(),\n+    )\n+    .expect(\"Run init process failed.\");\n+    // Wait till initproc become zombie.\n+    while !initproc.is_zombie() {\n+        // We don't have preemptive scheduler now.\n+        // The long running init thread should yield its own execution to allow other tasks to go on.\n+        Thread::yield_now();\n+    }\n+\n+    // TODO: exit via qemu isa debug device should not be the only way.\n+    let exit_code = if initproc.exit_code().unwrap() == 0 {\n+        QemuExitCode::Success\n+    } else {\n+        QemuExitCode::Failed\n+    };\n+    exit_qemu(exit_code);\n+}\n+\n+fn print_banner() {\n+    println!(\"\\x1B[36m\");\n+    println!(\n+        r\"\n+   _   ___ _____ ___ ___ ___ _  _   _   ___\n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n+\"\n+    );\n+    println!(\"\\x1B[0m\");\n }\n\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\n\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"cargo-osdk\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Accelerate OS development with Asterinas OSDK\"\n license = \"MPL-2.0\"\n\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n //! The base crate is the OSDK generated crate that is ultimately built by cargo.\n-//! It will depend on the kernel crate.\n-//!\n+//! It will depend on the to-be-built kernel crate or the to-be-tested crate.\n \n use std::{\n     fs,\n\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -12,10 +11,16 @@ use std::{\n \n use crate::util::get_cargo_metadata;\n \n+/// Create a new base crate that will be built by cargo.\n+///\n+/// The dependencies of the base crate will be the target crate. If\n+/// `link_unit_test_runner` is set to true, the base crate will also depend on\n+/// the `ostd-test-runner` crate.\n pub fn new_base_crate(\n     base_crate_path: impl AsRef<Path>,\n     dep_crate_name: &str,\n     dep_crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n ) {\n     let workspace_root = {\n         let meta = get_cargo_metadata(None::<&str>, None::<&[&str]>).unwrap();\n\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -82,7 +87,7 @@ pub fn new_base_crate(\n     fs::write(\"src/main.rs\", main_rs).unwrap();\n \n     // Add dependencies to the Cargo.toml\n-    add_manifest_dependency(dep_crate_name, dep_crate_path);\n+    add_manifest_dependency(dep_crate_name, dep_crate_path, link_unit_test_runner);\n \n     // Copy the manifest configurations from the target crate to the base crate\n     copy_profile_configurations(workspace_root);\n\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -94,7 +99,11 @@ pub fn new_base_crate(\n     std::env::set_current_dir(original_dir).unwrap();\n }\n \n-fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n+fn add_manifest_dependency(\n+    crate_name: &str,\n+    crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n+) {\n     let mainfest_path = \"Cargo.toml\";\n \n     let mut manifest: toml::Table = {\n\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -112,13 +121,26 @@ fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let dep = toml::Table::from_str(&format!(\n+    let target_dep = toml::Table::from_str(&format!(\n         \"{} = {{ path = \\\"{}\\\", default-features = false }}\",\n         crate_name,\n         crate_path.as_ref().display()\n     ))\n     .unwrap();\n-    dependencies.as_table_mut().unwrap().extend(dep);\n+    dependencies.as_table_mut().unwrap().extend(target_dep);\n+\n+    if link_unit_test_runner {\n+        let dep_str = match option_env!(\"OSDK_LOCAL_DEV\") {\n+            Some(\"1\") => \"osdk-test-kernel = { path = \\\"../../../osdk/test-kernel\\\" }\",\n+            _ => concat!(\n+                \"osdk-test-kernel = { version = \\\"\",\n+                env!(\"CARGO_PKG_VERSION\"),\n+                \"\\\" }\"\n+            ),\n+        };\n+        let test_runner_dep = toml::Table::from_str(dep_str).unwrap();\n+        dependencies.as_table_mut().unwrap().extend(test_runner_dep);\n+    }\n \n     let content = toml::to_string(&manifest).unwrap();\n     fs::write(mainfest_path, content).unwrap();\n\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -49,9 +49,9 @@ pub fn main() {\n         OsdkSubcommand::Test(test_args) => {\n             execute_test_command(&load_config(&test_args.common_args), test_args);\n         }\n-        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args),\n-        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args),\n-        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args),\n+        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args, true),\n+        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args, true),\n+        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args, false),\n     }\n }\n \n\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -171,7 +171,7 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    if std::env::var(\"AUTO_TEST\").is_ok() || std::env::var(\"OSDK_INTEGRATION_TEST\").is_ok() {\n+    if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n         cmd.arg(\"--path\")\n             .arg(\"../../../ostd/libs/linux-bzimage/setup\");\n     }\n\ndiff --git a/osdk/src/commands/build/mod.rs b/osdk/src/commands/build/mod.rs\n--- a/osdk/src/commands/build/mod.rs\n+++ b/osdk/src/commands/build/mod.rs\n@@ -72,6 +72,7 @@ pub fn create_base_and_cached_build(\n         &base_crate_path,\n         &get_current_crate_info().name,\n         get_current_crate_info().path,\n+        false,\n     );\n     let original_dir = std::env::current_dir().unwrap();\n     std::env::set_current_dir(&base_crate_path).unwrap();\n\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -16,8 +16,10 @@ pub use self::{\n \n use crate::arch::get_default_arch;\n \n-/// Execute the forwarded cargo command with args containing the subcommand and its arguments.\n-pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n+/// Execute the forwarded cargo command with arguments.\n+///\n+/// The `cfg_ktest` parameter controls whether `cfg(ktest)` is enabled.\n+pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>, cfg_ktest: bool) -> ! {\n     let mut cargo = util::cargo();\n     cargo.arg(subcommand).args(util::COMMON_CARGO_ARGS);\n     if !args.contains(&\"--target\".to_owned()) {\n\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -27,6 +29,11 @@ pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n \n     let env_rustflags = std::env::var(\"RUSTFLAGS\").unwrap_or_default();\n     let rustflags = env_rustflags + \" --check-cfg cfg(ktest)\";\n+    let rustflags = if cfg_ktest {\n+        rustflags + \" --cfg ktest\"\n+    } else {\n+        rustflags\n+    };\n \n     cargo.env(\"RUSTFLAGS\", rustflags);\n \n\ndiff --git a/osdk/src/commands/new/kernel.template b/osdk/src/commands/new/kernel.template\n--- a/osdk/src/commands/new/kernel.template\n+++ b/osdk/src/commands/new/kernel.template\n@@ -1,4 +1,6 @@\n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\n\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -50,60 +50,33 @@ impl TomlManifest {\n                     .unwrap(),\n             )\n         };\n-        // All the custom schemes should inherit settings from the default scheme, this is a helper.\n-        fn finalize(current_manifest: Option<TomlManifest>) -> TomlManifest {\n-            let Some(mut current_manifest) = current_manifest else {\n-                error_msg!(\n-                    \"Cannot find `OSDK.toml` in the current directory or the workspace root\"\n-                );\n-                process::exit(Errno::GetMetadata as _);\n-            };\n-            for scheme in current_manifest.map.values_mut() {\n-                scheme.inherit(&current_manifest.default_scheme);\n-            }\n-            current_manifest\n-        }\n \n         // Search for OSDK.toml in the current directory first.\n-        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize().ok();\n-        let mut current_manifest = match &current_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n-        };\n-        // Then search in the workspace root.\n-        let workspace_manifest_path = workspace_root.join(\"OSDK.toml\").canonicalize().ok();\n-        // The case that the current directory is also the workspace root.\n-        if let Some(current) = &current_manifest_path {\n-            if let Some(workspace) = &workspace_manifest_path {\n-                if current == workspace {\n-                    return finalize(current_manifest);\n+        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize();\n+        let current_manifest = match &current_manifest_path {\n+            Ok(path) => deserialize_toml_manifest(path),\n+            Err(_) => {\n+                // If not found, search in the workspace root.\n+                if let Ok(workspace_manifest_path) = workspace_root.join(\"OSDK.toml\").canonicalize()\n+                {\n+                    deserialize_toml_manifest(workspace_manifest_path)\n+                } else {\n+                    None\n                 }\n             }\n-        }\n-        let workspace_manifest = match workspace_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n         };\n-        // The current manifest should inherit settings from the workspace manifest.\n-        if let Some(workspace_manifest) = workspace_manifest {\n-            if current_manifest.is_none() {\n-                current_manifest = Some(workspace_manifest);\n-            } else {\n-                // Inherit one scheme at a time.\n-                let current_manifest = current_manifest.as_mut().unwrap();\n-                current_manifest\n-                    .default_scheme\n-                    .inherit(&workspace_manifest.default_scheme);\n-                for (scheme_string, scheme) in workspace_manifest.map {\n-                    let current_scheme = current_manifest\n-                        .map\n-                        .entry(scheme_string)\n-                        .or_insert_with(Scheme::empty);\n-                    current_scheme.inherit(&scheme);\n-                }\n-            }\n+\n+        let Some(mut current_manifest) = current_manifest else {\n+            error_msg!(\"Cannot find `OSDK.toml` in the current directory or the workspace root\");\n+            process::exit(Errno::GetMetadata as _);\n+        };\n+\n+        // All the schemes should inherit from the default scheme.\n+        for scheme in current_manifest.map.values_mut() {\n+            scheme.inherit(&current_manifest.default_scheme);\n         }\n-        finalize(current_manifest)\n+\n+        current_manifest\n     }\n \n     /// Get the scheme given the scheme from the command line arguments.\n\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -10,6 +10,7 @@ pub enum Errno {\n     ExecuteCommand = 5,\n     BuildCrate = 6,\n     RunBundle = 7,\n+    BadCrateName = 8,\n }\n \n /// Print error message to console\n\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n license = \"MPL-2.0\"\n\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -7,12 +7,13 @@ use quote::quote;\n use rand::{distributions::Alphanumeric, Rng};\n use syn::{parse_macro_input, Expr, Ident, ItemFn};\n \n-/// This macro is used to mark the kernel entry point.\n+/// A macro attribute to mark the kernel entry point.\n ///\n /// # Example\n ///\n /// ```ignore\n /// #![no_std]\n+/// #![feature(linkage)]\n ///\n /// use ostd::prelude::*;\n ///\n\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -28,8 +29,37 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n \n     quote!(\n         #[no_mangle]\n-        pub fn __ostd_main() -> ! {\n-            ostd::init();\n+        #[linkage = \"weak\"]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n+            #main_fn_name();\n+            ostd::prelude::abort();\n+        }\n+\n+        #main_fn\n+    )\n+    .into()\n+}\n+\n+/// A macro attribute for the unit test kernel entry point.\n+///\n+/// This macro is used for internal OSDK implementation. Do not use it\n+/// directly.\n+///\n+/// It is a strong version of the `main` macro attribute. So if it exists (\n+/// which means the unit test kernel is linked to perform testing), the actual\n+/// kernel entry point will be replaced by this one.\n+#[proc_macro_attribute]\n+pub fn test_main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let main_fn = parse_macro_input!(item as ItemFn);\n+    let main_fn_name = &main_fn.sig.ident;\n+\n+    quote!(\n+        #[no_mangle]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n             #main_fn_name();\n             ostd::prelude::abort();\n         }\n\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -115,8 +115,9 @@ pub fn init() {\n ///\n /// Any kernel that uses the `ostd` crate should define a function marked with\n /// `ostd::main` as the entrypoint.\n-pub fn call_ostd_main() -> ! {\n-    #[cfg(not(ktest))]\n+///\n+/// This function should be only called from the bootloader-specific module.\n+pub(crate) fn call_ostd_main() -> ! {\n     unsafe {\n         // The entry point of kernel code, which should be defined by the package that\n         // uses OSTD.\n\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -125,42 +126,4 @@ pub fn call_ostd_main() -> ! {\n         }\n         __ostd_main();\n     }\n-    #[cfg(ktest)]\n-    unsafe {\n-        use crate::task::TaskOptions;\n-\n-        crate::init();\n-        // The whitelists that will be generated by OSDK runner as static consts.\n-        extern \"Rust\" {\n-            static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n-            static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n-        }\n-\n-        let test_task = move || {\n-            run_ktests(KTEST_TEST_WHITELIST, KTEST_CRATE_WHITELIST);\n-        };\n-        let _ = TaskOptions::new(test_task).data(()).spawn();\n-        unreachable!(\"The spawn method will NOT return in the boot context\")\n-    }\n-}\n-\n-fn run_ktests(test_whitelist: Option<&[&str]>, crate_whitelist: Option<&[&str]>) -> ! {\n-    use alloc::{boxed::Box, string::ToString};\n-    use core::any::Any;\n-\n-    use crate::arch::qemu::{exit_qemu, QemuExitCode};\n-\n-    let fn_catch_unwind = &(unwinding::panic::catch_unwind::<(), fn()>\n-        as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>);\n-\n-    use ostd_test::runner::{run_ktests, KtestResult};\n-    match run_ktests(\n-        &crate::console::early_print,\n-        fn_catch_unwind,\n-        test_whitelist.map(|s| s.iter().map(|s| s.to_string())),\n-        crate_whitelist,\n-    ) {\n-        KtestResult::Ok => exit_qemu(QemuExitCode::Success),\n-        KtestResult::Failed => exit_qemu(QemuExitCode::Failed),\n-    };\n }\n\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -56,10 +56,15 @@ pub(crate) use crate::cpu::local::cpu_local_cell;\n /// This function represents the first phase booting up the system. It makes\n /// all functionalities of OSTD available after the call.\n ///\n-/// TODO: We need to refactor this function to make it more modular and\n-/// make inter-initialization-dependencies more clear and reduce usages of\n-/// boot stage only global variables.\n-pub fn init() {\n+/// # Safety\n+///\n+/// This function should be called only once and only on the BSP.\n+//\n+// TODO: We need to refactor this function to make it more modular and\n+// make inter-initialization-dependencies more clear and reduce usages of\n+// boot stage only global variables.\n+#[doc(hidden)]\n+pub unsafe fn init() {\n     arch::enable_cpu_features();\n     arch::serial::init();\n \n\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -114,6 +119,7 @@ mod test {\n     use crate::prelude::*;\n \n     #[ktest]\n+    #[allow(clippy::eq_op)]\n     fn trivial_assertion() {\n         assert_eq!(0, 0);\n     }\n\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -131,8 +137,14 @@ mod test {\n     }\n }\n \n-/// The module re-exports everything from the ktest crate\n-#[cfg(ktest)]\n+#[doc(hidden)]\n pub mod ktest {\n+    //! The module re-exports everything from the [`ostd_test`] crate, as well\n+    //! as the test entry point macro.\n+    //!\n+    //! It is rather discouraged to use the definitions here directly. The\n+    //! `ktest` attribute is sufficient for all normal use cases.\n+\n+    pub use ostd_macros::test_main as main;\n     pub use ostd_test::*;\n }\n\ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -313,24 +313,24 @@ mod test {\n     fn set_get() {\n         let bits = AtomicBits::new_zeroes(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n         }\n \n         let bits = AtomicBits::new_ones(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n         }\n     }\n \n\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -20,6 +20,13 @@ update_package_version() {\n     sed -i \"0,/${pattern}/s/${pattern}/version = \\\"${new_version}\\\"/1\" $1\n }\n \n+# Update the version of the `ostd` dependency (`ostd = { version = \"\", ...`) in file $1\n+update_ostd_dep_version() {\n+    echo \"Updating file $1\"\n+    pattern=\"^ostd = { version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"\"\n+    sed -i \"0,/${pattern}/s/${pattern}/ostd = { version = \\\"${new_version}\\\"/1\" $1\n+}\n+\n # Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\n\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -98,6 +105,7 @@ ASTER_SRC_DIR=${SCRIPT_DIR}/..\n DOCS_DIR=${ASTER_SRC_DIR}/docs\n OSTD_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/Cargo.toml\n OSDK_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/Cargo.toml\n+OSTD_TEST_RUNNER_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/test-kernel/Cargo.toml\n VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n current_version=$(cat ${VERSION_PATH})\n\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -114,9 +122,11 @@ new_version=$(bump_version ${current_version})\n # Update the package version in Cargo.toml\n update_package_version ${OSTD_CARGO_TOML_PATH}\n update_package_version ${OSDK_CARGO_TOML_PATH}\n+update_package_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n+update_ostd_dep_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p asterinas --precise $new_version\n+cargo update -p aster-nix --precise $new_version\n \n # Update Docker image versions in README files\n update_image_versions ${ASTER_SRC_DIR}/README.md\n\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -142,4 +152,4 @@ update_image_versions $GET_STARTED_PATH\n # `-n` is used to avoid adding a '\\n' in the VERSION file.\n echo -n \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Asterinas & OSDK version to $new_version\"\n+echo \"Bumped Asterinas OSTD & OSDK version to $new_version\"\n",
        "test_patch": "diff --git a/kernel/libs/aster-util/src/coeff.rs b/kernel/libs/aster-util/src/coeff.rs\n--- a/kernel/libs/aster-util/src/coeff.rs\n+++ b/kernel/libs/aster-util/src/coeff.rs\n@@ -134,8 +134,8 @@ mod test {\n     #[ktest]\n     fn calculation() {\n         let coeff = Coeff::new(23456, 56789, 1_000_000_000);\n-        assert!(coeff * 0 as u64 == 0);\n-        assert!(coeff * 100 as u64 == 100 * 23456 / 56789);\n-        assert!(coeff * 1_000_000_000 as u64 == 1_000_000_000 * 23456 / 56789);\n+        assert!(coeff * 0_u64 == 0);\n+        assert!(coeff * 100_u64 == 100 * 23456 / 56789);\n+        assert!(coeff * 1_000_000_000_u64 == 1_000_000_000 * 23456 / 56789);\n     }\n }\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -107,7 +107,7 @@ mod test {\n         }\n     }\n     /// Exfat disk image\n-    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../../test/build/exfat.img\");\n+    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../test/build/exfat.img\");\n \n     /// Read exfat disk image\n     fn new_vm_segment_from_image() -> Segment {\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -484,7 +484,7 @@ mod test {\n         let mut read = vec![0u8; BUF_SIZE];\n         let read_after_rename = a_inode_new.read_bytes_at(0, &mut read);\n         assert!(\n-            read_after_rename.is_ok() && read_after_rename.clone().unwrap() == BUF_SIZE,\n+            read_after_rename.is_ok() && read_after_rename.unwrap() == BUF_SIZE,\n             \"Fail to read after rename: {:?}\",\n             read_after_rename.unwrap_err()\n         );\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -495,8 +495,7 @@ mod test {\n         let new_buf = vec![7u8; NEW_BUF_SIZE];\n         let new_write_after_rename = a_inode_new.write_bytes_at(0, &new_buf);\n         assert!(\n-            new_write_after_rename.is_ok()\n-                && new_write_after_rename.clone().unwrap() == NEW_BUF_SIZE,\n+            new_write_after_rename.is_ok() && new_write_after_rename.unwrap() == NEW_BUF_SIZE,\n             \"Fail to write file after rename: {:?}\",\n             new_write_after_rename.unwrap_err()\n         );\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -984,7 +983,7 @@ mod test {\n         let mut file_names: Vec<String> = (0..file_num).map(|x| x.to_string()).collect();\n         file_names.sort();\n         let mut file_inodes: Vec<Arc<dyn Inode>> = Vec::new();\n-        for (_file_id, file_name) in file_names.iter().enumerate() {\n+        for file_name in file_names.iter() {\n             let inode = create_file(root.clone(), file_name);\n             file_inodes.push(inode);\n         }\n\ndiff --git a/kernel/aster-nix/src/fs/exfat/utils.rs b/kernel/src/fs/exfat/utils.rs\n--- a/kernel/aster-nix/src/fs/exfat/utils.rs\n+++ b/kernel/src/fs/exfat/utils.rs\n@@ -68,9 +67,9 @@ impl DosTimestamp {\n         #[cfg(ktest)]\n         {\n             use crate::time::SystemTime;\n-            return DosTimestamp::from_duration(\n+            DosTimestamp::from_duration(\n                 SystemTime::UNIX_EPOCH.duration_since(&SystemTime::UNIX_EPOCH)?,\n-            );\n+            )\n         }\n     }\n \n\ndiff --git a/kernel/aster-nix/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/aster-nix/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -331,7 +331,7 @@ mod test {\n     #[ktest]\n     fn test_read_closed() {\n         test_blocking(\n-            |writer| drop(writer),\n+            drop,\n             |reader| {\n                 let mut buf = [0; 1];\n                 assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 0);\n\ndiff --git a/kernel/aster-nix/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/aster-nix/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -350,7 +350,7 @@ mod test {\n                     Errno::EPIPE\n                 );\n             },\n-            |reader| drop(reader),\n+            drop,\n             Ordering::WriteThenRead,\n         );\n     }\n\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -291,7 +291,7 @@ mod test {\n             while !*started {\n                 started = cvar.wait(started).unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \n\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -316,7 +316,7 @@ mod test {\n                     .wait_timeout(started, Duration::from_secs(1))\n                     .unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \n\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -338,7 +338,7 @@ mod test {\n             let started = cvar\n                 .wait_while(lock.lock(), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n \n\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -360,7 +360,7 @@ mod test {\n             let (started, _) = cvar\n                 .wait_timeout_while(lock.lock(), Duration::from_secs(1), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n }\n\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/src/taskless.rs\n@@ -216,7 +216,7 @@ mod test {\n         let mut counter = 0;\n \n         // Schedule this taskless for `SCHEDULE_TIMES`.\n-        while taskless.is_scheduled.load(Ordering::Acquire) == false {\n+        while !taskless.is_scheduled.load(Ordering::Acquire) {\n             taskless.schedule();\n             counter += 1;\n             if counter == SCHEDULE_TIMES {\n\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/src/taskless.rs\n@@ -227,7 +227,9 @@ mod test {\n         // Wait for all taskless having finished.\n         while taskless.is_running.load(Ordering::Acquire)\n             || taskless.is_scheduled.load(Ordering::Acquire)\n-        {}\n+        {\n+            core::hint::spin_loop()\n+        }\n \n         assert_eq!(counter, COUNTER.load(Ordering::Relaxed));\n     }\n\ndiff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/src/vm/vmar/options.rs\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/src/vm/vmar/options.rs\n@@ -136,7 +136,7 @@ impl<R> VmarChildOptions<R> {\n #[cfg(ktest)]\n mod test {\n     use aster_rights::Full;\n-    use ostd::{mm::VmIo, prelude::*};\n+    use ostd::prelude::*;\n \n     use super::*;\n     use crate::vm::{\n\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -334,9 +334,10 @@ mod test {\n             .alloc_contiguous()\n             .unwrap();\n         let vm_segment_child = vm_segment_parent.range(0..1);\n-        let _dma_stream_parent =\n+        let dma_stream_parent =\n             DmaStream::map(vm_segment_parent, DmaDirection::Bidirectional, false);\n         let dma_stream_child = DmaStream::map(vm_segment_child, DmaDirection::Bidirectional, false);\n+        assert!(dma_stream_parent.is_ok());\n         assert!(dma_stream_child.is_err());\n     }\n \n\ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -389,9 +389,9 @@ mod test {\n     #[ktest]\n     fn iter() {\n         let bits = AtomicBits::new_zeroes(7);\n-        assert!(bits.iter().all(|bit| bit == false));\n+        assert!(bits.iter().all(|bit| !bit));\n \n         let bits = AtomicBits::new_ones(128);\n-        assert!(bits.iter().all(|bit| bit == true));\n+        assert!(bits.iter().all(|bit| bit));\n     }\n }\n\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -293,7 +293,7 @@ mod test {\n             Task::yield_now();\n \n             cond_cloned.store(true, Ordering::Relaxed);\n-            wake(&*queue_cloned);\n+            wake(&queue_cloned);\n         })\n         .data(())\n         .spawn()\n\ndiff --git a/ostd/src/task/task/mod.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task/mod.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -383,6 +383,7 @@ mod test {\n \n     #[ktest]\n     fn create_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\n\ndiff --git a/ostd/src/task/task/mod.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task/mod.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -395,6 +396,7 @@ mod test {\n \n     #[ktest]\n     fn spawn_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\n",
        "problem_statement": "ktest as a kernel\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nWell, I want to make ktest as a kernel built on top of aster-frame (OSTD), and run as a kernel. Currently the ktest crate is a dependency of aster-frame, which leads to many problems such as:\r\n - a lot of runtime needed when running ktest, which need to be passed as parameters #834 ;\r\n - need to pass cfg to aster-frame when rebuilding the test #974 ;\r\n\r\nBy making ktest a kernel depending on aster-frame, which has it's entrypoint as `#[aster_main]` (`#[ostd::main]`), it works for all the above problems.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\n### Proposal\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\nOriginally the dependency chain of testing a target crate `A` is:\r\n\r\n```text\r\nktest <---------------- ostd <--- A <--- base_crate\r\n                       /         / \r\nktest_proc_macro <----'---------'\r\n```\r\n\r\nThe proposed one is:\r\n\r\n```text\r\n\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nInstead of a conditional compilation to choose the ktest entry point at `aster_frame::boot::call_aster_main`, the ktest entry point should be registered as **STRONG** `#[aster_main]`, while other kernel's `#[aster_main]` should be WEAK. So during linking, if the ktest main exist ktests will be excecuted, other wise kernel main would be executed.\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n",
        "hints_text": "This proposal aims to address to problems.\r\n\r\n> * a lot of runtime needed when running ktest, which need to be passed as parameters https://github.com/asterinas/asterinas/pull/834 ;\r\n> * need to pass cfg to aster-frame when rebuilding the test https://github.com/asterinas/asterinas/issues/974 ;\r\n\r\nI can see why this proposal is able to resolve the first problem. But why can it address the second?\n> The proposed one is:\r\n\r\n```plain\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nUsers don't need to be aware of the existence of the `ktest_proc_macro` and `ktest` crates, correct? The `ktest` crate is solely a dependency of the `base_crate`, and the `ktest_proc_macro` is now re-exported from `ostd`. Therefore, the crate A to be tested can only depend on `ostd`.\nDue to the current implementation of both `#[ostd::ktest]` and `ktest` relying on `KtestItem` and `KtestItemInfo`, we cannot directly move `ktest` above `ostd`.\r\n\r\nThe most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n\r\n```text\r\n\t\t            .-- ktest_run <---(if testing)---.\r\n\t\t            v                                 \\\r\n  ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n               \\\t  v            \r\n                .----->  ktest \r\n```\r\n\r\nAn alternative solution might be to place the parameters that originally needed to be wrapped in `KtestItem` into a `.ktest_array`, and then retrieve these parameters to generate `KtestItem` objects during execution. However, this might not be an elegant solution.\r\n\r\nI haven't been able to think of a better approach\u2639\ufe0f. Could you give me some input @junyang-zh ?\n> The most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n> \r\n> ```\r\n> \t\t            .-- ktest_run <---(if testing)---.\r\n> \t\t            v                                 \\\r\n>   ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n>                \\\t  v            \r\n>                 .----->  ktest \r\n> ```\r\n\r\nYour question makes sense. And the best solution I can think of is just like yours, splitting the crate into two.\r\n\r\nSo it seems that we are just making the ktest runner a kernel. The ktest item definitions are still a dependency of OSTD.",
        "created_at": "2024-08-13T11:21:28Z"
    }
]