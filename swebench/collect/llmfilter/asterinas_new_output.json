[
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1642,
        "instance_id": "asterinas__asterinas-1642",
        "issue_numbers": [
            "1587"
        ],
        "base_commit": "9da6af03943c15456cdfd781021820a7da78ea40",
        "patch": "diff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -253,7 +253,9 @@ impl FutexBucket {\n             }\n \n             let item = item_cursor.remove().unwrap();\n-            item.wake();\n+            if !item.wake() {\n+                continue;\n+            }\n             count += 1;\n         }\n \ndiff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -323,8 +325,9 @@ impl FutexItem {\n         (futex_item, waiter)\n     }\n \n-    pub fn wake(&self) {\n-        self.waker.wake_up();\n+    #[must_use]\n+    pub fn wake(&self) -> bool {\n+        self.waker.wake_up()\n     }\n \n     pub fn match_up(&self, another: &Self) -> bool {\n",
        "test_patch": "",
        "problem_statement": "`futex_wait_bitset()` should remove `futex_item` when `pause_timeout()` fails\n### Describe the bug\r\n\r\n1. When signaled or timeout, the `futex_item` is not removed from the `futex_bucket`, which can lead to lost-wakeup.\r\n2. `waiter.pause_timeout()` returns `Ok(())` upon waking up from a signal, which can lead to incorrect handling of the wake-up event.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/11382524d1d23cc6d41adf977a72138baa39e38d/kernel/src/process/posix_thread/futex.rs#L76\n",
        "hints_text": "The [wakeup test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L671-L673) must take precedence over the [pending signals test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L678-L683).\r\n\r\nThis is the real cause of the failed CI due to 6421fd0b36aafb3fcd9a8f12d5bc6e89f3f86546, cc https://github.com/asterinas/asterinas/pull/1577.\r\n\r\nI also wonder if we can remove the `pause_timeout` API and let the futex use the normal `pause_until` API, but I am not sure since I have not read the futex implementation.\r\n\r\n> can lead to lost-wakeup.\r\n\r\nThis should only result in spurious wake?",
        "created_at": "2024-11-26T12:04:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1279,
        "instance_id": "asterinas__asterinas-1279",
        "issue_numbers": [
            "1274"
        ],
        "base_commit": "963874471284ed014b76d268d933b6d13073c2cc",
        "patch": "diff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -50,7 +50,9 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n         // Cannot be reduced to `then_some`, or the possible dropping of the temporary\n         // guard will cause an unexpected unlock.\n-        self.acquire_lock().then_some(MutexGuard { mutex: self })\n+        // SAFETY: The lock is successfully acquired when creating the guard.\n+        self.acquire_lock()\n+            .then(|| unsafe { MutexGuard::new(self) })\n     }\n \n     /// Tries acquire the mutex through an [`Arc`].\ndiff --git a/ostd/src/sync/mutex.rs b/ostd/src/sync/mutex.rs\n--- a/ostd/src/sync/mutex.rs\n+++ b/ostd/src/sync/mutex.rs\n@@ -100,6 +102,16 @@ pub struct MutexGuard_<T: ?Sized, R: Deref<Target = Mutex<T>>> {\n /// A guard that provides exclusive access to the data protected by a [`Mutex`].\n pub type MutexGuard<'a, T> = MutexGuard_<T, &'a Mutex<T>>;\n \n+impl<'a, T: ?Sized> MutexGuard<'a, T> {\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the given reference of [`Mutex`] lock has been successfully acquired\n+    /// in the current context. When the created [`MutexGuard`] is dropped, it will unlock the [`Mutex`].\n+    unsafe fn new(mutex: &'a Mutex<T>) -> MutexGuard<'a, T> {\n+        MutexGuard { mutex }\n+    }\n+}\n+\n /// An guard that provides exclusive access to the data protected by a `Arc<Mutex>`.\n pub type ArcMutexGuard<T> = MutexGuard_<T, Arc<Mutex<T>>>;\n \n",
        "test_patch": "",
        "problem_statement": "Potential mutex lock bug leading to multiple threads entering critical section\n### Describe the bug\r\n\r\nHi there!\r\n\r\nI'm working on a testcase for issue #1261 to reproduce the bug, and I noticed a weird behavior. It seems that `mutex.lock()` does not block when another thread has already acquired the lock in `ktest`. This causes multiple threads to enter the critical section simultaneously.\r\n\r\n### To Reproduce\r\n\r\n1. `git apply ./patch.diff`\r\n2. `make ktest`\r\n\r\nHere is the `path.diff` file:\r\n\r\n**Note**: I'm not sure if I inited the test environment and used `timer::Jiffies` and `Thread::yield_now()` correctly. I observed that without using `yield_now()`, thread scheduling does not occur. In other words, if `Thread::yield_now()` is commented out, this test case will pass.\r\n\r\n```diff\r\ndiff --git a/kernel/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\r\nindex 944fe070..52f3e971 100644\r\n--- a/kernel/src/process/sync/condvar.rs\r\n+++ b/kernel/src/process/sync/condvar.rs\r\n@@ -363,4 +363,51 @@ mod test {\r\n             assert!(!*started);\r\n         }\r\n     }\r\n+\r\n+    use ostd::arch::timer::Jiffies;\r\n+\r\n+    fn wait_jiffies(value: u64) {\r\n+        let mut previous = Jiffies::elapsed().as_u64();\r\n+        let ddl = previous + value;\r\n+        loop {\r\n+            let current = Jiffies::elapsed().as_u64();\r\n+            if current >= ddl {\r\n+                break;\r\n+            }\r\n+            if current - previous >= 10 {\r\n+                previous = current;\r\n+                Thread::yield_now();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    #[ktest]\r\n+    fn test_mutex_cs() {\r\n+        let pair = Arc::new((Mutex::new(0), Condvar::new()));\r\n+        let pair2 = Arc::clone(&pair);\r\n+\r\n+        Thread::spawn_kernel_thread(ThreadOptions::new(move || {\r\n+            wait_jiffies(1000);\r\n+            let (lock, _) = &*pair;\r\n+            let mut val = lock.lock();\r\n+            *val = 1;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 1);\r\n+            *val = 2;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 2);\r\n+        }));\r\n+\r\n+        {\r\n+            let (lock2, _) = &*pair2;\r\n+            let mut val = lock2.lock();\r\n+            *val = 10;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 10);\r\n+            *val = 20;\r\n+            wait_jiffies(1000);\r\n+            assert!(*val == 20);\r\n+        }\r\n+\r\n+    }\r\n }\r\n```\r\n\r\n### Expected behavior\r\n\r\nOnly one thread should enter the critical section at a time.\r\n\r\n### Screenshots\r\n\r\n![28cecd84ca55772867240a21d99ec32](https://github.com/user-attachments/assets/2c93be85-fd48-4656-bbd1-fae9c2fd2b31)\r\n\r\n### Environment\r\n\r\nOfficial Docker environment, version 0.8.1\r\n\r\n\n",
        "hints_text": "The bug introduced in this commit: https://github.com/asterinas/asterinas/commit/d15b4d9115cf33490245c06a93928995765f0d3f#r146080074\r\n\r\nA potential fix: #497",
        "created_at": "2024-09-02T06:56:20Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1369,
        "instance_id": "asterinas__asterinas-1369",
        "issue_numbers": [
            "919"
        ],
        "base_commit": "ae4ac384713e63232b74915593ebdef680049d31",
        "patch": "diff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -16,7 +16,7 @@ use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::{\n     cpu::CpuExceptionInfo,\n-    mm::{VmSpace, MAX_USERSPACE_VADDR},\n+    mm::{tlb::TlbFlushOp, PageFlags, PageProperty, VmSpace, MAX_USERSPACE_VADDR},\n };\n \n use self::{\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -220,13 +220,6 @@ impl Vmar_ {\n     }\n \n     fn new_root() -> Arc<Self> {\n-        fn handle_page_fault_wrapper(\n-            vm_space: &VmSpace,\n-            trap_info: &CpuExceptionInfo,\n-        ) -> core::result::Result<(), ()> {\n-            handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n-        }\n-\n         let mut free_regions = BTreeMap::new();\n         let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -236,7 +229,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        let vm_space = VmSpace::new();\n+        let mut vm_space = VmSpace::new();\n         vm_space.register_page_fault_handler(handle_page_fault_wrapper);\n         Vmar_::new(vmar_inner, Arc::new(vm_space), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -668,17 +661,19 @@ impl Vmar_ {\n             let vm_space = if let Some(parent) = parent {\n                 parent.vm_space().clone()\n             } else {\n-                Arc::new(self.vm_space().fork_copy_on_write())\n+                let mut new_space = VmSpace::new();\n+                new_space.register_page_fault_handler(handle_page_fault_wrapper);\n+                Arc::new(new_space)\n             };\n             Vmar_::new(vmar_inner, vm_space, self.base, self.size, parent)\n         };\n \n         let inner = self.inner.lock();\n+        let mut new_inner = new_vmar_.inner.lock();\n+\n         // Clone free regions.\n         for (free_region_base, free_region) in &inner.free_regions {\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .free_regions\n                 .insert(*free_region_base, free_region.clone());\n         }\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -686,26 +681,49 @@ impl Vmar_ {\n         // Clone child vmars.\n         for (child_vmar_base, child_vmar_) in &inner.child_vmar_s {\n             let new_child_vmar = child_vmar_.new_fork(Some(&new_vmar_))?;\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .child_vmar_s\n                 .insert(*child_vmar_base, new_child_vmar);\n         }\n \n         // Clone mappings.\n-        for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n-            let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n-            new_vmar_\n-                .inner\n-                .lock()\n-                .vm_mappings\n-                .insert(*vm_mapping_base, new_mapping);\n+        {\n+            let new_vmspace = new_vmar_.vm_space();\n+            let range = self.base..(self.base + self.size);\n+            let mut new_cursor = new_vmspace.cursor_mut(&range).unwrap();\n+            let cur_vmspace = self.vm_space();\n+            let mut cur_cursor = cur_vmspace.cursor_mut(&range).unwrap();\n+            for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n+                // Clone the `VmMapping` to the new VMAR.\n+                let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n+                new_inner.vm_mappings.insert(*vm_mapping_base, new_mapping);\n+\n+                // Protect the mapping and copy to the new page table for COW.\n+                cur_cursor.jump(*vm_mapping_base).unwrap();\n+                new_cursor.jump(*vm_mapping_base).unwrap();\n+                let mut op = |page: &mut PageProperty| {\n+                    page.flags -= PageFlags::W;\n+                };\n+                new_cursor.copy_from(&mut cur_cursor, vm_mapping.map_size(), &mut op);\n+            }\n+            cur_cursor.flusher().issue_tlb_flush(TlbFlushOp::All);\n+            cur_cursor.flusher().dispatch_tlb_flush();\n         }\n+\n+        drop(new_inner);\n+\n         Ok(new_vmar_)\n     }\n }\n \n+/// This is for fallible user space write handling.\n+fn handle_page_fault_wrapper(\n+    vm_space: &VmSpace,\n+    trap_info: &CpuExceptionInfo,\n+) -> core::result::Result<(), ()> {\n+    handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n+}\n+\n impl<R> Vmar<R> {\n     /// The base address, i.e., the offset relative to the root VMAR.\n     ///\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -11,7 +11,8 @@ use core::{\n use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::mm::{\n-    vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags, PageProperty, VmSpace,\n+    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags,\n+    PageProperty, VmSpace,\n };\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -224,7 +225,7 @@ impl VmMapping {\n \n         match cursor.query().unwrap() {\n             VmItem::Mapped {\n-                va: _,\n+                va,\n                 frame,\n                 mut prop,\n             } if is_write => {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -245,7 +246,9 @@ impl VmMapping {\n                 let new_flags = PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n \n                 if self.is_shared || only_reference {\n-                    cursor.protect(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.protect_next(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.flusher().issue_tlb_flush(TlbFlushOp::Address(va));\n+                    cursor.flusher().dispatch_tlb_flush();\n                 } else {\n                     let new_frame = duplicate_frame(&frame)?;\n                     prop.flags |= new_flags;\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -558,7 +561,15 @@ impl VmMappingInner {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n         let mut cursor = vm_space.cursor_mut(&range).unwrap();\n-        cursor.protect(range.len(), |p| p.flags = perms.into());\n+        let op = |p: &mut PageProperty| p.flags = perms.into();\n+        while cursor.virt_addr() < range.end {\n+            if let Some(va) = cursor.protect_next(range.end - cursor.virt_addr(), op) {\n+                cursor.flusher().issue_tlb_flush(TlbFlushOp::Range(va));\n+            } else {\n+                break;\n+            }\n+        }\n+        cursor.flusher().dispatch_tlb_flush();\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -18,6 +18,7 @@ pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n pub mod stat;\n+pub mod tlb;\n pub mod vm_space;\n \n use core::{fmt::Debug, ops::Range};\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -734,26 +734,93 @@ where\n         None\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.0.preempt_guard\n-    }\n-\n-    /// Consumes itself and leak the root guard for the caller if it locked the root level.\n+    /// Copies the mapping from the given cursor to the current cursor.\n     ///\n-    /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\n-    pub(super) fn leak_root_guard(mut self) -> Option<PageTableNode<E, C>> {\n-        if self.0.guard_level != C::NR_LEVELS {\n-            return None;\n-        }\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// It can only copy tracked mappings since we consider the untracked\n+    /// mappings not useful to be copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that\n+    ///  - the range being copied with the operation does not affect kernel's\n+    ///    memory safety.\n+    ///  - both of the cursors are in tracked mappings.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub unsafe fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        assert!(len % page_size::<C>(1) == 0);\n+        let this_end = self.0.va + len;\n+        assert!(this_end <= self.0.barrier_va.end);\n+        let src_end = src.0.va + len;\n+        assert!(src_end <= src.0.barrier_va.end);\n \n-        while self.0.level < C::NR_LEVELS {\n-            self.0.level_up();\n-        }\n+        while self.0.va < this_end && src.0.va < src_end {\n+            let cur_pte = src.0.read_cur_pte();\n+            if !cur_pte.is_present() {\n+                src.0.move_forward();\n+                continue;\n+            }\n+\n+            // Go down if it's not a last node.\n+            if !cur_pte.is_last(src.0.level) {\n+                src.0.level_down();\n+\n+                // We have got down a level. If there's no mapped PTEs in\n+                // the current node, we can go back and skip to save time.\n+                if src.0.guards[(src.0.level - 1) as usize]\n+                    .as_ref()\n+                    .unwrap()\n+                    .nr_children()\n+                    == 0\n+                {\n+                    src.0.level_up();\n+                    src.0.move_forward();\n+                }\n+\n+                continue;\n+            }\n \n-        self.0.guards[(C::NR_LEVELS - 1) as usize].take()\n+            // Do protection.\n+            let mut pte_prop = cur_pte.prop();\n+            op(&mut pte_prop);\n+\n+            let idx = src.0.cur_idx();\n+            src.cur_node_mut().protect(idx, pte_prop);\n \n-        // Ok to drop the cursor here because we ensure not to access the page table if the current\n-        // level is the root level when running the dropping method.\n+            // Do copy.\n+            let child = src.cur_node_mut().child(idx, true);\n+            let Child::<E, C>::Page(page, prop) = child else {\n+                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n+            };\n+            self.jump(src.0.va).unwrap();\n+            let mapped_page_size = page.size();\n+            let original = self.map(page, prop);\n+            debug_assert!(original.is_none());\n+\n+            // Only move the source cursor forward since `Self::map` will do it.\n+            // This assertion is to ensure that they move by the same length.\n+            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+            src.0.move_forward();\n+        }\n     }\n \n     /// Goes down a level assuming the current slot is absent.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -92,53 +92,29 @@ impl PageTable<UserMode> {\n             self.root.activate();\n         }\n     }\n-\n-    /// Create a cloned new page table.\n-    ///\n-    /// This method takes a mutable cursor to the old page table that locks the\n-    /// entire virtual address range. The caller may implement the copy-on-write\n-    /// mechanism by first protecting the old page table and then clone it using\n-    /// this method.\n-    ///\n-    /// TODO: We may consider making the page table itself copy-on-write.\n-    pub fn clone_with(\n-        &self,\n-        cursor: CursorMut<'_, UserMode, PageTableEntry, PagingConsts>,\n-    ) -> Self {\n-        let root_node = cursor.leak_root_guard().unwrap();\n-\n-        const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node = unsafe {\n-            root_node.make_copy(\n-                0..NR_PTES_PER_NODE / 2,\n-                NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE,\n-            )\n-        };\n-\n-        PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n-            _phantom: PhantomData,\n-        }\n-    }\n }\n \n impl PageTable<KernelMode> {\n     /// Create a new user page table.\n     ///\n-    /// This should be the only way to create the first user page table, that is\n-    /// to fork the kernel page table with all the kernel mappings shared.\n-    ///\n-    /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n-    /// other child page tables.\n+    /// This should be the only way to create the user page table, that is to\n+    /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n+        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n \n+        // Make a shallow copy of the root node in the kernel space range.\n+        // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node =\n-            unsafe { root_node.make_copy(0..0, NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE) };\n+        for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n+            let child = root_node.child(i, /* meaningless */ true);\n+            if !child.is_none() {\n+                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            }\n+        }\n \n         PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n+            root: new_node.into_raw(),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -25,9 +25,7 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{\n-    fmt, marker::PhantomData, mem::ManuallyDrop, ops::Range, panic, sync::atomic::Ordering,\n-};\n+use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n \n use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n use crate::{\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -374,74 +372,6 @@ where\n         }\n     }\n \n-    /// Makes a copy of the page table node.\n-    ///\n-    /// This function allows you to control about the way to copy the children.\n-    /// For indexes in `deep`, the children are deep copied and this function will be recursively called.\n-    /// For indexes in `shallow`, the children are shallow copied as new references.\n-    ///\n-    /// You cannot shallow copy a child that is mapped to a page. Deep copying a page child will not\n-    /// copy the mapped page but will copy the handle to the page.\n-    ///\n-    /// You cannot either deep copy or shallow copy a child that is mapped to an untracked page.\n-    ///\n-    /// The ranges must be disjoint.\n-    pub(super) unsafe fn make_copy(&self, deep: Range<usize>, shallow: Range<usize>) -> Self {\n-        debug_assert!(deep.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(shallow.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(deep.end <= shallow.start || deep.start >= shallow.end);\n-\n-        let mut new_pt = Self::alloc(self.level());\n-        let mut copied_child_count = self.nr_children();\n-        for i in deep {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            match self.child(i, true) {\n-                Child::PageTable(pt) => {\n-                    let guard = pt.clone_shallow().lock();\n-                    let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::Page(page, prop) => {\n-                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        for i in shallow {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            debug_assert_eq!(self.level(), C::NR_LEVELS);\n-            match self.child(i, /*meaningless*/ true) {\n-                Child::PageTable(pt) => {\n-                    let old = new_pt.replace_child(\n-                        i,\n-                        Child::PageTable(pt.clone_shallow()),\n-                        /*meaningless*/ true,\n-                    );\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Page(_, _) | Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        new_pt\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\ndiff --git /dev/null b/ostd/src/mm/tlb.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/tlb.rs\n@@ -0,0 +1,222 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! TLB flush operations.\n+\n+use alloc::vec::Vec;\n+use core::ops::Range;\n+\n+use super::{page::DynPage, Vaddr, PAGE_SIZE};\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    task::disable_preempt,\n+};\n+\n+/// A TLB flusher that is aware of which CPUs are needed to be flushed.\n+///\n+/// The flusher needs to stick to the current CPU.\n+pub struct TlbFlusher<G: PinCurrentCpu> {\n+    target_cpus: CpuSet,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead.\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+    _pin_current: G,\n+}\n+\n+impl<G: PinCurrentCpu> TlbFlusher<G> {\n+    /// Creates a new TLB flusher with the specified CPUs to be flushed.\n+    ///\n+    /// The flusher needs to stick to the current CPU. So please provide a\n+    /// guard that implements [`PinCurrentCpu`].\n+    pub fn new(target_cpus: CpuSet, pin_current_guard: G) -> Self {\n+        let current_cpu = pin_current_guard.current_cpu();\n+\n+        let mut need_self_flush = false;\n+        let mut need_remote_flush = false;\n+\n+        for cpu in target_cpus.iter() {\n+            if cpu == current_cpu {\n+                need_self_flush = true;\n+            } else {\n+                need_remote_flush = true;\n+            }\n+        }\n+        Self {\n+            target_cpus,\n+            need_remote_flush,\n+            need_self_flush,\n+            _pin_current: pin_current_guard,\n+        }\n+    }\n+\n+    /// Issues a pending TLB flush request.\n+    ///\n+    /// On SMP systems, the notification is sent to all the relevant CPUs only\n+    /// when [`Self::dispatch_tlb_flush`] is called.\n+    pub fn issue_tlb_flush(&self, op: TlbFlushOp) {\n+        self.issue_tlb_flush_(op, None);\n+    }\n+\n+    /// Dispatches all the pending TLB flush requests.\n+    ///\n+    /// The pending requests are issued by [`Self::issue_tlb_flush`].\n+    pub fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        crate::smp::inter_processor_call(&self.target_cpus, do_remote_flush);\n+    }\n+\n+    /// Issues a TLB flush request that must happen before dropping the page.\n+    ///\n+    /// If we need to remove a mapped page from the page table, we can only\n+    /// recycle the page after all the relevant TLB entries in all CPUs are\n+    /// flushed. Otherwise if the page is recycled for other purposes, the user\n+    /// space program can still access the page through the TLB entries. This\n+    /// method is designed to be used in such cases.\n+    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: DynPage) {\n+        self.issue_tlb_flush_(op, Some(drop_after_flush));\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on other CPUs.\n+    pub fn need_remote_flush(&self) -> bool {\n+        self.need_remote_flush\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on the current CPU.\n+    pub fn need_self_flush(&self) -> bool {\n+        self.need_self_flush\n+    }\n+\n+    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let op = op.optimize_for_large_range();\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                op.perform_on_current();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.target_cpus.iter() {\n+            let mut op_queue = FLUSH_OPS.get_on_cpu(cpu).lock();\n+            if let Some(drop_after_flush) = drop_after_flush.clone() {\n+                PAGE_KEEPER.get_on_cpu(cpu).lock().push(drop_after_flush);\n+            }\n+            op_queue.push(op.clone());\n+        }\n+    }\n+}\n+\n+/// The operation to flush TLB entries.\n+#[derive(Debug, Clone)]\n+pub enum TlbFlushOp {\n+    /// Flush all TLB entries except for the global entries.\n+    All,\n+    /// Flush the TLB entry for the specified virtual address.\n+    Address(Vaddr),\n+    /// Flush the TLB entries for the specified virtual address range.\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushOp {\n+    /// Performs the TLB flush operation on the current CPU.\n+    pub fn perform_on_current(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match self {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n+        }\n+    }\n+\n+    fn optimize_for_large_range(self) -> Self {\n+        match self {\n+            TlbFlushOp::Range(range) => {\n+                if range.len() > FLUSH_ALL_RANGE_THRESHOLD {\n+                    TlbFlushOp::All\n+                } else {\n+                    TlbFlushOp::Range(range)\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+}\n+\n+// The queues of pending requests on each CPU.\n+//\n+// Lock ordering: lock FLUSH_OPS before PAGE_KEEPER.\n+cpu_local! {\n+    static FLUSH_OPS: SpinLock<OpsStack> = SpinLock::new(OpsStack::new());\n+    static PAGE_KEEPER: SpinLock<Vec<DynPage>> = SpinLock::new(Vec::new());\n+}\n+\n+fn do_remote_flush() {\n+    let preempt_guard = disable_preempt();\n+    let current_cpu = preempt_guard.current_cpu();\n+\n+    let mut op_queue = FLUSH_OPS.get_on_cpu(current_cpu).lock();\n+    op_queue.flush_all();\n+    PAGE_KEEPER.get_on_cpu(current_cpu).lock().clear();\n+}\n+\n+/// If a TLB flushing request exceeds this threshold, we flush all.\n+pub(crate) const FLUSH_ALL_RANGE_THRESHOLD: usize = 32 * PAGE_SIZE;\n+\n+/// If the number of pending requests exceeds this threshold, we flush all the\n+/// TLB entries instead of flushing them one by one.\n+const FLUSH_ALL_OPS_THRESHOLD: usize = 32;\n+\n+struct OpsStack {\n+    ops: [Option<TlbFlushOp>; FLUSH_ALL_OPS_THRESHOLD],\n+    need_flush_all: bool,\n+    size: usize,\n+}\n+\n+impl OpsStack {\n+    const fn new() -> Self {\n+        const ARRAY_REPEAT_VALUE: Option<TlbFlushOp> = None;\n+        Self {\n+            ops: [ARRAY_REPEAT_VALUE; FLUSH_ALL_OPS_THRESHOLD],\n+            need_flush_all: false,\n+            size: 0,\n+        }\n+    }\n+\n+    fn push(&mut self, op: TlbFlushOp) {\n+        if self.need_flush_all {\n+            return;\n+        }\n+\n+        if self.size < FLUSH_ALL_OPS_THRESHOLD {\n+            self.ops[self.size] = Some(op);\n+            self.size += 1;\n+        } else {\n+            self.need_flush_all = true;\n+            self.size = 0;\n+        }\n+    }\n+\n+    fn flush_all(&mut self) {\n+        if self.need_flush_all {\n+            crate::arch::mm::tlb_flush_all_excluding_global();\n+            self.need_flush_all = false;\n+        } else {\n+            for i in 0..self.size {\n+                if let Some(op) = &self.ops[i] {\n+                    op.perform_on_current();\n+                }\n+            }\n+        }\n+\n+        self.size = 0;\n+    }\n+}\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,32 +9,25 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use alloc::collections::vec_deque::VecDeque;\n use core::{\n     ops::Range,\n     sync::atomic::{AtomicPtr, Ordering},\n };\n \n-use spin::Once;\n-\n-use super::{\n-    io::Fallible,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page::DynPage,\n-    page_table::{PageTable, UserMode},\n-    PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n-};\n use crate::{\n     arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n     cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n     cpu_local,\n     mm::{\n-        page_table::{self, PageTableItem},\n-        Frame, MAX_USERSPACE_VADDR,\n+        io::Fallible,\n+        kspace::KERNEL_PAGE_TABLE,\n+        page_table::{self, PageTable, PageTableItem, UserMode},\n+        tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\n+        Frame, PageProperty, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::{RwLock, RwLockReadGuard, SpinLock},\n-    task::disable_preempt,\n+    sync::{RwLock, RwLockReadGuard},\n+    task::{disable_preempt, DisabledPreemptGuard},\n     Error,\n };\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -56,7 +49,7 @@ use crate::{\n #[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+    page_fault_handler: Option<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n     /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n     /// Cursors hold read locks and activation require a write lock.\n     activation_lock: RwLock<()>,\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -67,7 +60,7 @@ impl VmSpace {\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n+            page_fault_handler: None,\n             activation_lock: RwLock::new(()),\n         }\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -98,11 +91,7 @@ impl VmSpace {\n         Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n             let activation_lock = self.activation_lock.read();\n \n-            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n-\n             let mut activated_cpus = CpuSet::new_empty();\n-            let mut need_self_flush = false;\n-            let mut need_remote_flush = false;\n \n             for cpu in 0..num_cpus() {\n                 // The activation lock is held; other CPUs cannot activate this `VmSpace`.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -110,20 +99,13 @@ impl VmSpace {\n                     ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n                 if ptr == self as *const VmSpace {\n                     activated_cpus.add(cpu);\n-                    if cpu == cur_cpu {\n-                        need_self_flush = true;\n-                    } else {\n-                        need_remote_flush = true;\n-                    }\n                 }\n             }\n \n             CursorMut {\n                 pt_cursor,\n                 activation_lock,\n-                activated_cpus,\n-                need_remote_flush,\n-                need_self_flush,\n+                flusher: TlbFlusher::new(activated_cpus, disable_preempt()),\n             }\n         })?)\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -156,63 +138,18 @@ impl VmSpace {\n         &self,\n         info: &CpuExceptionInfo,\n     ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n+        if let Some(func) = self.page_fault_handler {\n             return func(self, info);\n         }\n         Err(())\n     }\n \n     /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n     pub fn register_page_fault_handler(\n-        &self,\n+        &mut self,\n         func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n     ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        // Protect the parent VM space as read-only.\n-        let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n-        let mut op = |prop: &mut PageProperty| {\n-            prop.flags -= PageFlags::W;\n-        };\n-\n-        cursor.protect(end, &mut op);\n-\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-\n-        let CursorMut {\n-            pt_cursor,\n-            activation_lock,\n-            ..\n-        } = cursor;\n-\n-        let new_pt = self.pt.clone_with(pt_cursor);\n-\n-        // Release the activation lock after the page table is cloned to\n-        // prevent modification to the parent page table while cloning.\n-        drop(activation_lock);\n-\n-        Self {\n-            pt: new_pt,\n-            page_fault_handler,\n-            activation_lock: RwLock::new(()),\n-        }\n+        self.page_fault_handler = Some(func);\n     }\n \n     /// Creates a reader to read data from the user space of the current task.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -311,12 +248,9 @@ pub struct CursorMut<'a, 'b> {\n     pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n     #[allow(dead_code)]\n     activation_lock: RwLockReadGuard<'b, ()>,\n-    // Better to store them here since loading and counting them from the CPUs\n-    // list brings non-trivial overhead. We have a read lock so the stored set\n-    // is always a superset of actual activated CPUs.\n-    activated_cpus: CpuSet,\n-    need_remote_flush: bool,\n-    need_self_flush: bool,\n+    // We have a read lock so the CPU set in the flusher is always a superset\n+    // of actual activated CPUs.\n+    flusher: TlbFlusher<DisabledPreemptGuard>,\n }\n \n impl CursorMut<'_, '_> {\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -345,6 +279,11 @@ impl CursorMut<'_, '_> {\n         self.pt_cursor.virt_addr()\n     }\n \n+    /// Get the dedicated TLB flusher for this cursor.\n+    pub fn flusher(&self) -> &TlbFlusher<DisabledPreemptGuard> {\n+        &self.flusher\n+    }\n+\n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -353,9 +292,10 @@ impl CursorMut<'_, '_> {\n         // SAFETY: It is safe to map untyped memory into the userspace.\n         let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        if old.is_some() {\n-            self.issue_tlb_flush(TlbFlushOp::Address(start_va), old);\n-            self.dispatch_tlb_flush();\n+        if let Some(old) = old {\n+            self.flusher\n+                .issue_tlb_flush_with(TlbFlushOp::Address(start_va), old);\n+            self.flusher.dispatch_tlb_flush();\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -367,25 +307,31 @@ impl CursorMut<'_, '_> {\n     /// Already-absent mappings encountered by the cursor will be skipped. It\n     /// is valid to unmap a range that is not mapped.\n     ///\n+    /// It must issue and dispatch a TLB flush after the operation. Otherwise,\n+    /// the memory safety will be compromised. Please call this function less\n+    /// to avoid the overhead of TLB flush. Using a large `len` is wiser than\n+    /// splitting the operation into multiple small ones.\n+    ///\n     /// # Panics\n     ///\n     /// This method will panic if `len` is not page-aligned.\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+        let tlb_prefer_flush_all = len > FLUSH_ALL_RANGE_THRESHOLD;\n \n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n             let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !self.need_remote_flush && tlb_prefer_flush_all {\n+                    if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n                         // Only on single-CPU cases we can drop the page immediately before flushing.\n                         drop(page);\n                         continue;\n                     }\n-                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n+                    self.flusher\n+                        .issue_tlb_flush_with(TlbFlushOp::Address(va), page);\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -396,103 +342,79 @@ impl CursorMut<'_, '_> {\n             }\n         }\n \n-        if !self.need_remote_flush && tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n+            self.flusher.issue_tlb_flush(TlbFlushOp::All);\n         }\n \n-        self.dispatch_tlb_flush();\n+        self.flusher.dispatch_tlb_flush();\n     }\n \n-    /// Change the mapping property starting from the current slot.\n+    /// Applies the operation to the next slot of mapping within the range.\n     ///\n-    /// This method will bring the cursor forward by `len` bytes in the virtual\n-    /// address space after the modification.\n+    /// The range to be found in is the current virtual address with the\n+    /// provided length.\n+    ///\n+    /// The function stops and yields the actually protected range if it has\n+    /// actually protected a page, no matter if the following pages are also\n+    /// required to be protected.\n+    ///\n+    /// It also makes the cursor moves forward to the next page after the\n+    /// protected one. If no mapped pages exist in the following range, the\n+    /// cursor will stop at the end of the range and return [`None`].\n     ///\n-    /// The way to change the property is specified by the closure `op`.\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// [`Self::flusher`].\n     ///\n     /// # Panics\n     ///\n-    /// This method will panic if `len` is not page-aligned.\n-    pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n-        assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n-\n+    /// This function will panic if:\n+    ///  - the range to be protected is out of the range where the cursor\n+    ///    is required to operate;\n+    ///  - the specified virtual address range only covers a part of a page.\n+    pub fn protect_next(\n+        &mut self,\n+        len: usize,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) -> Option<Range<Vaddr>> {\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) =\n-            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n-        {\n-            if !tlb_prefer_flush_all {\n-                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n-            }\n-        }\n-\n-        if tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n-        }\n-        self.dispatch_tlb_flush();\n+        unsafe { self.pt_cursor.protect_next(len, &mut op) }\n     }\n \n-    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n-        let request = TlbFlushRequest {\n-            op,\n-            drop_after_flush,\n-        };\n-\n-        // Fast path for single CPU cases.\n-        if !self.need_remote_flush {\n-            if self.need_self_flush {\n-                request.do_flush();\n-            }\n-            return;\n-        }\n-\n-        // Slow path for multi-CPU cases.\n-        for cpu in self.activated_cpus.iter() {\n-            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n-            queue.push_back(request.clone());\n-        }\n-    }\n-\n-    fn dispatch_tlb_flush(&self) {\n-        if !self.need_remote_flush {\n-            return;\n-        }\n-\n-        fn do_remote_flush() {\n-            let preempt_guard = disable_preempt();\n-            let mut requests = TLB_FLUSH_REQUESTS\n-                .get_on_cpu(preempt_guard.current_cpu())\n-                .lock();\n-            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n-                // TODO: in most cases, we need only to flush all the TLB entries\n-                // for an ASID if it is enabled.\n-                crate::arch::mm::tlb_flush_all_excluding_global();\n-                requests.clear();\n-            } else {\n-                while let Some(request) = requests.pop_front() {\n-                    request.do_flush();\n-                    if matches!(request.op, TlbFlushOp::All) {\n-                        requests.clear();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    /// Copies the mapping from the given cursor to the current cursor.\n+    ///\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// the source's [`CursorMut::flusher`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        // SAFETY: Operations on user memory spaces are safe if it doesn't\n+        // involve dropping any pages.\n+        unsafe { self.pt_cursor.copy_from(&mut src.pt_cursor, len, op) }\n     }\n }\n \n-/// The threshold used to determine whether we need to flush all TLB entries\n-/// when handling a bunch of TLB flush requests. If the number of requests\n-/// exceeds this threshold, the overhead incurred by flushing pages\n-/// individually would surpass the overhead of flushing all entries at once.\n-const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n-\n cpu_local! {\n-    /// The queue of pending requests.\n-    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n     /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n     /// is NULL, it means that the activated page table is merely the kernel\n     /// page table.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -502,38 +424,6 @@ cpu_local! {\n     static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n }\n \n-#[derive(Debug, Clone)]\n-struct TlbFlushRequest {\n-    op: TlbFlushOp,\n-    // If we need to remove a mapped page from the page table, we can only\n-    // recycle the page after all the relevant TLB entries in all CPUs are\n-    // flushed. Otherwise if the page is recycled for other purposes, the user\n-    // space program can still access the page through the TLB entries.\n-    #[allow(dead_code)]\n-    drop_after_flush: Option<DynPage>,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TlbFlushOp {\n-    All,\n-    Address(Vaddr),\n-    Range(Range<Vaddr>),\n-}\n-\n-impl TlbFlushRequest {\n-    /// Perform the TLB flush operation on the current CPU.\n-    fn do_flush(&self) {\n-        use crate::arch::mm::{\n-            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        };\n-        match &self.op {\n-            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n-            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n-            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n-        }\n-    }\n-}\n-\n /// The result of a query over the VM space.\n #[derive(Debug)]\n pub enum VmItem {\n",
        "test_patch": "",
        "problem_statement": "[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "I've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-23T14:17:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1559,
        "instance_id": "asterinas__asterinas-1559",
        "issue_numbers": [
            "1554"
        ],
        "base_commit": "11382524d1d23cc6d41adf977a72138baa39e38d",
        "patch": "diff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -114,7 +127,7 @@ impl<T> Producer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -123,7 +136,7 @@ impl<T> Producer<T> {\n         let rb = this_end.rb();\n         if self.is_shutdown() {\n             // The POLLOUT event is always set in this case. Don't try to remove it.\n-        } else if rb.is_full() {\n+        } else if rb.free_len() < PIPE_BUF {\n             this_end.pollee.del_events(IoEvents::OUT);\n         }\n         drop(rb);\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -204,7 +217,7 @@ impl<T> Consumer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -218,7 +231,7 @@ impl<T> Consumer<T> {\n \n         let peer_end = self.peer_end();\n         let rb = peer_end.rb();\n-        if !rb.is_full() {\n+        if rb.free_len() >= PIPE_BUF {\n             peer_end.pollee.add_events(IoEvents::OUT);\n         }\n         drop(rb);\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -307,6 +320,10 @@ impl<R: TRights> Fifo<u8, R> {\n     #[require(R > Write)]\n     pub fn write(&self, reader: &mut dyn MultiRead) -> Result<usize> {\n         let mut rb = self.common.producer.rb();\n+        if rb.free_len() < reader.sum_lens() && reader.sum_lens() <= PIPE_BUF {\n+            // No sufficient space for an atomic write\n+            return Ok(0);\n+        }\n         rb.write_fallible(reader)\n     }\n }\n",
        "test_patch": "",
        "problem_statement": "PIPE implementation does not guarantee atomic writes for up to PIPE_BUF bytes\n### Describe the bug\r\n\r\nThe current implementation of the PIPE in Asterinas does not ensure that writes of up to PIPE_BUF bytes are atomic. \r\n\r\n### To Reproduce\r\n\r\nApply the following patch and run `test/pipe/pipe_atomicity`\r\n\r\n<details><summary>patch file</summary>\r\n\r\n```diff\r\ndiff --git a/test/apps/pipe/pipe_atomicity.c b/test/apps/pipe/pipe_atomicity.c\r\nnew file mode 100644\r\nindex 00000000..1e473d78\r\n--- /dev/null\r\n+++ b/test/apps/pipe/pipe_atomicity.c\r\n@@ -0,0 +1,36 @@\r\n+// SPDX-License-Identifier: MPL-2.0\r\n+\r\n+#define _GNU_SOURCE\r\n+\r\n+#include \"../network/test.h\"\r\n+#include <signal.h>\r\n+#include <string.h>\r\n+#include <sys/poll.h>\r\n+#include <unistd.h>\r\n+\r\n+static int rfd, wfd;\r\n+\r\n+FN_SETUP(short_read_and_write)\r\n+{\r\n+       int fildes[2];\r\n+\r\n+       CHECK(pipe(fildes));\r\n+       rfd = fildes[0];\r\n+       wfd = fildes[1];\r\n+\r\n+}\r\n+END_SETUP()\r\n+\r\n+FN_TEST(atomicity)\r\n+{\r\n+       char buf[511] = { 0 };\r\n+\r\n+       // for (int i = 0; i < 130; i++)\r\n+       //      TEST_RES(write(wfd, buf, 511), _ret == 511);\r\n+       for (int i = 0; i < 130; i++)\r\n+       {\r\n+               ssize_t res = write(wfd, buf, 511);\r\n+               printf(\"i=%d, res=%ld\\n\", i, res);\r\n+       }\r\n+}\r\n+END_TEST()\r\n```\r\n</details>\r\n\r\n### Expected behavior\r\n\r\nIn the current Asterinas implementation, writing 511 bytes results in partial writes (128 bytes) after 128 iterations, while the Linux implementation blocks after 127 iterations:\r\n\r\n![aster_vs_linux](https://github.com/user-attachments/assets/e8b9377b-fff3-4c23-bb81-8e3fa6f253e1)\r\n\r\n### Environment\r\n\r\nbranch: [7ddfd42](https://github.com/asterinas/asterinas/tree/7ddfd42baa210656127044995d8707fde74fab4d)\r\n\n",
        "hints_text": "This one is easy to fix. Just check if the remaining space in the internal buffer of a pipe is no less than `PIPE_BUF` before actually writing the data.",
        "created_at": "2024-11-05T07:28:33Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1215,
        "instance_id": "asterinas__asterinas-1215",
        "issue_numbers": [
            "1197"
        ],
        "base_commit": "562e64437584279783f244edba10b512beddc81d",
        "patch": "diff --git a/kernel/aster-nix/src/syscall/waitid.rs b/kernel/aster-nix/src/syscall/waitid.rs\n--- a/kernel/aster-nix/src/syscall/waitid.rs\n+++ b/kernel/aster-nix/src/syscall/waitid.rs\n@@ -15,8 +15,9 @@ pub fn sys_waitid(\n     _ctx: &Context,\n ) -> Result<SyscallReturn> {\n     // FIXME: what does infoq and rusage use for?\n-    let process_filter = ProcessFilter::from_which_and_id(which, upid);\n-    let wait_options = WaitOptions::from_bits(options as u32).expect(\"Unknown wait options\");\n+    let process_filter = ProcessFilter::from_which_and_id(which, upid)?;\n+    let wait_options = WaitOptions::from_bits(options as u32)\n+        .ok_or(Error::with_message(Errno::EINVAL, \"invalid options\"))?;\n     let waited_process = wait_child_exit(process_filter, wait_options)?;\n     let pid = waited_process.map_or(0, |process| process.pid());\n     Ok(SyscallReturn::Return(pid as _))\n",
        "test_patch": "",
        "problem_statement": "Reachable unwrap panic in `ProcessFilter::from_which_and_id()`\n### Describe the bug\r\nThere is a reachable unwrap panic in `ProcessFilter::from_which_and_id()` at kernel/aster-nix/src/process/process_filter.rs:24 when make a `waitid` syscall.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/ce2af1eb057077753a7a757edc1833e677a83918/kernel/aster-nix/src/process/process_filter.rs#L17-L26\r\n\r\n\r\n### To Reproduce\r\n1. Compile a program which calls `waitid`:\r\n```C\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\nint main() {\r\n  waitid(0x31142aad0bc93209, 15, 0x1, -10);\r\n\r\n  return 0;\r\n}\r\n\r\n```\r\n2. Run the compiled program in Asterinas.\r\n\r\n### Expected behavior\r\nAsterinas reports panic and is terminated.\r\n\r\n### Environment\r\n- Official docker asterinas/asterinas:0.6.2\r\n- 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\r\n- Asterinas version: main ce2af1eb\r\n\r\n### Logs\r\n```\r\n~ # /root/waitpid.c\r\npanicked at /root/asterinas/kernel/aster-nix/src/process/process_filter.rs:24:18:\r\nUnknown id type\r\nPrinting stack trace:\r\n   1: fn 0xffffffff8876b840 - pc 0xffffffff8876b858 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a370;\r\n\r\n   2: fn 0xffffffff8876b620 - pc 0xffffffff8876b798 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a380;\r\n\r\n   3: fn 0xffffffff88049000 - pc 0xffffffff8804900a / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a500;\r\n\r\n   4: fn 0xffffffff8897ee20 - pc 0xffffffff8897eea2 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a510;\r\n\r\n   5: fn 0xffffffff88163050 - pc 0xffffffff881630b0 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a5a0;\r\n\r\n   6: fn 0xffffffff8822cc20 - pc 0xffffffff8822cc8d / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a610;\r\n\r\n   7: fn 0xffffffff88292390 - pc 0xffffffff882bebda / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80000122a730;\r\n\r\n   8: fn 0xffffffff88291f70 - pc 0xffffffff88291ffe / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff8000012403d0;\r\n\r\n   9: fn 0xffffffff8836de80 - pc 0xffffffff8836e9ff / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240570;\r\n\r\n  10: fn 0xffffffff885a49f0 - pc 0xffffffff885a49fe / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240f90;\r\n\r\n  11: fn 0xffffffff88781b90 - pc 0xffffffff88781ba6 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240fb0;\r\n\r\n  12: fn 0xffffffff887b9740 - pc 0xffffffff887b97a9 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001240fd0;\r\n\r\n  13: fn                0x0 - pc                0x0 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff889fd930; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff800001241000;\r\n\r\n[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\r\n(  1) /root/asterinas/ostd/src/panicking.rs:107\r\n(  2) /root/asterinas/ostd/src/panicking.rs:59\r\n(  3) 2aghao2n2kcoquuybdyjuveav:?\r\n(  4) ??:?\r\n(  5) /root/asterinas/kernel/aster-nix/src/process/process_filter.rs:21\r\n(  6) /root/asterinas/kernel/aster-nix/src/syscall/waitid.rs:18\r\n(  7) /root/asterinas/kernel/aster-nix/src/syscall/mod.rs:195\r\n(  8) /root/asterinas/kernel/aster-nix/src/syscall/mod.rs:325\r\n(  9) /root/asterinas/kernel/aster-nix/src/thread/task.rs:69\r\n( 10) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n( 11) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2077\r\n( 12) /root/asterinas/ostd/src/task/task/mod.rs:310\r\nmake: *** [Makefile:153: run] Error 1\r\n```\n",
        "hints_text": "",
        "created_at": "2024-08-21T12:44:17Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1138,
        "instance_id": "asterinas__asterinas-1138",
        "issue_numbers": [
            "1135"
        ],
        "base_commit": "6414111cc57b42db2bae1a0c8b01b85c3830a3b3",
        "patch": "diff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -163,18 +163,14 @@ fn get_manifest_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str\n fn get_src_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str) -> &'a str {\n     let metadata = get_package_metadata(cargo_metadata, crate_name);\n     let targets = metadata.get(\"targets\").unwrap().as_array().unwrap();\n-\n-    for target in targets {\n-        let name = target.get(\"name\").unwrap().as_str().unwrap();\n-        if name != crate_name {\n-            continue;\n-        }\n-\n-        let src_path = target.get(\"src_path\").unwrap();\n-        return src_path.as_str().unwrap();\n-    }\n-\n-    panic!(\"the crate name does not match with any target\");\n+    assert!(\n+        targets.len() == 1,\n+        \"there must be one and only one target generated\"\n+    );\n+\n+    let target = &targets[0];\n+    let src_path = target.get(\"src_path\").unwrap();\n+    return src_path.as_str().unwrap();\n }\n \n fn get_workspace_root(cargo_metadata: &serde_json::Value) -> &str {\n",
        "test_patch": "",
        "problem_statement": "OSDK should support creating crate with `-` in its name\nAs discovered by #1133, `cargo osdk new --kernel my-first-os` will panic due to `my-first-os` contains `-`.\r\n\r\nSince `cargo new my-first-os` is allowed, we should fix the problem to keep osdk consistent with cargo.\r\n\r\n\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2024-08-08T01:38:09Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1362,
        "instance_id": "asterinas__asterinas-1362",
        "issue_numbers": [
            "964"
        ],
        "base_commit": "f7932595125a0bba8230b5f8d3b110c687d6f3b2",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,13 +1,14 @@\n # SPDX-License-Identifier: MPL-2.0\n \n-# Global options.\n+# =========================== Makefile options. ===============================\n+\n+# Global build options.\n ARCH ?= x86_64\n BENCHMARK ?= none\n BOOT_METHOD ?= grub-rescue-iso\n BOOT_PROTOCOL ?= multiboot2\n BUILD_SYSCALL_TEST ?= 0\n ENABLE_KVM ?= 1\n-GDB_TCP_PORT ?= 1234\n INTEL_TDX ?= 0\n MEM ?= 8G\n RELEASE ?= 0\ndiff --git a/docs/src/osdk/reference/commands/debug.md b/docs/src/osdk/reference/commands/debug.md\n--- a/docs/src/osdk/reference/commands/debug.md\n+++ b/docs/src/osdk/reference/commands/debug.md\n@@ -2,29 +2,39 @@\n \n ## Overview\n \n-`cargo osdk debug` is used to debug a remote target via GDB.\n-The usage is as follows:\n+`cargo osdk debug` is used to debug a remote target via GDB. You need to start\n+a running server to debug with. This is accomplished by the `run` subcommand\n+with `--gdb-server`. Then you can use the following command to attach to the\n+server and do debugging.\n \n ```bash\n cargo osdk debug [OPTIONS]\n ```\n \n+Note that when KVM is enabled, hardware-assisted break points (`hbreak`) are\n+needed instead of the normal break points (`break`/`b`) in GDB.\n+\n ## Options\n \n `--remote <REMOTE>`:\n-Specify the address of the remote target [default: .aster-gdb-socket].\n+Specify the address of the remote target [default: .osdk-gdb-socket].\n The address can be either a path for the UNIX domain socket\n or a TCP port on an IP address.\n \n ## Examples\n \n-- To debug a remote target via a\n-[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html),\n-    - connect to an unix socket, e.g., `./debug`;\n-    ```bash\n-    cargo osdk debug --remote ./debug\n-    ```\n-    - connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`.\n-    ```bash\n-    cargo osdk debug --remote localhost:1234\n-    ```\n+To debug a remote target started with\n+[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html) or the `run`\n+subcommand, use the following commands.\n+\n+Connect to an unix socket, e.g., `./debug`:\n+\n+```bash\n+cargo osdk debug --remote ./debug\n+```\n+\n+Connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`:\n+\n+```bash\n+cargo osdk debug --remote localhost:1234\n+```\ndiff --git /dev/null b/docs/src/osdk/reference/commands/profile.md\nnew file mode 100644\n--- /dev/null\n+++ b/docs/src/osdk/reference/commands/profile.md\n@@ -0,0 +1,75 @@\n+# cargo osdk profile\n+\n+## Overview\n+\n+The profile command is used to collect stack traces when running the target\n+kernel in QEMU. It attaches to the GDB server initiated with the run subcommand\n+and collects the stack trace periodically. The collected information can be\n+used to directly generate a flame graph, or be stored for later analysis using\n+[the original flame graph tool](https://github.com/brendangregg/FlameGraph).\n+\n+## Options\n+\n+`--remote <REMOTE>`:\n+\n+Specify the address of the remote target.\n+By default this is `.osdk-gdb-socket`\n+\n+`--samples <SAMPLES>`:\n+\n+The number of samples to collect (default 200).\n+It is recommended to go beyond 100 for performance analysis.\n+\n+`--interval <INTERVAL>`:\n+\n+The interval between samples in seconds (default 0.1).\n+\n+`--parse <PATH>`:\n+\n+Parse a collected JSON profile file into other formats.\n+\n+`--format <FORMAT>`:\n+\n+Possible values:\n+    - `json`:   The parsed stack trace log from GDB in JSON.\n+    - `folded`: The folded stack trace for flame graph.\n+    - `flame-graph`: A SVG flame graph.\n+\n+If the user does not specify the format, it will be inferred from the\n+output file extension. If the output file does not have an extension,\n+the default format is flame graph.\n+\n+`--cpu-mask <CPU_MASK>`:\n+\n+The mask of the CPU to generate traces for in the output profile data\n+(default first 128 cores). This mask is presented as an integer.\n+\n+`--output <PATH>`:\n+\n+The path to the output profile data file.\n+\n+If the user does not specify the output path, it will be generated from\n+the crate name, current time stamp and the format.\n+\n+## Examples\n+\n+To profile a remote QEMU GDB server running some workload for flame graph, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01\n+```\n+\n+If wanted a detailed analysis, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01 --output trace.json\n+```\n+\n+When you get the above detailed analysis, you can also use the JSON file\n+to generate the folded format for flame graph.\n+\n+```bash\n+cargo osdk profile --parse trace.json --output trace.folded\n+```\ndiff --git a/docs/src/osdk/reference/commands/run.md b/docs/src/osdk/reference/commands/run.md\n--- a/docs/src/osdk/reference/commands/run.md\n+++ b/docs/src/osdk/reference/commands/run.md\n@@ -15,34 +15,34 @@ Most options are the same as those of `cargo osdk build`.\n Refer to the [documentation](build.md) of `cargo osdk build`\n for more details.\n \n-Options related with debugging:\n+Additionally, when running the kernel using QEMU, we can setup the QEMU as a\n+debug server using option `--gdb-server`. This option supports an additional\n+comma separated configuration list:\n \n-- `-G, --enable-gdb`: Enable QEMU GDB server for debugging.\n-- `--vsc`: Generate a '.vscode/launch.json' for debugging kernel with Visual Studio Code\n-(only works when QEMU GDB server is enabled, i.e., `--enable-gdb`).\n-Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb).\n-- `--gdb-server-addr <ADDR>`: The network address on which the GDB server listens,\n-it can be either a path for the UNIX domain socket or a TCP port on an IP address.\n-[default: `.aster-gdb-socket`(a local UNIX socket)]\n+ - `addr=ADDR`: the network or unix socket address on which the GDB server listens\n+    (default: `.osdk-gdb-socket`, a local UNIX socket);\n+ - `wait-client`: let the GDB server wait for the GDB client before execution;\n+ - `vscode`: generate a '.vscode/launch.json' for debugging with Visual Studio Code\n+    (Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)).\n \n See [Debug Command](debug.md) to interact with the GDB server in terminal.\n \n ## Examples\n \n-- Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n+Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr .debug\n+cargo osdk run --gdb-server addr=.debug\n ```\n \n-- Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n+Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr :1234\n+cargo osdk run --gdb-server addr=:1234\n ```\n \n-- Launch a debug server via QEMU and use VSCode to interact:\n+Launch a debug server via QEMU and use VSCode to interact with:\n \n ```bash\n-cargo osdk run --enable-gdb --vsc --gdb-server-addr :1234\n+cargo osdk run --gdb-server wait-client,vscode,addr=:1234\n ```\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -15,6 +15,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011\"\n dependencies = [\n  \"cfg-if\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n  \"zerocopy\",\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -35,6 +36,21 @@ version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f\"\n \n+[[package]]\n+name = \"android-tzdata\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0\"\n+\n+[[package]]\n+name = \"android_system_properties\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"anstream\"\n version = \"0.6.12\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -83,6 +99,12 @@ dependencies = [\n  \"windows-sys\",\n ]\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50\"\n+\n [[package]]\n name = \"assert_cmd\"\n version = \"2.0.14\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -98,12 +120,24 @@ dependencies = [\n  \"wait-timeout\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"2.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de\"\n+\n [[package]]\n name = \"block-buffer\"\n version = \"0.10.4\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -124,6 +158,12 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.16.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c\"\n+\n [[package]]\n name = \"bytemuck\"\n version = \"1.17.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -149,9 +189,12 @@ name = \"cargo-osdk\"\n version = \"0.8.3\"\n dependencies = [\n  \"assert_cmd\",\n+ \"chrono\",\n  \"clap\",\n  \"env_logger\",\n  \"indexmap\",\n+ \"indicatif\",\n+ \"inferno\",\n  \"lazy_static\",\n  \"linux-bzimage-builder\",\n  \"log\",\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -166,12 +209,35 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"cc\"\n+version = \"1.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07b1695e2c7e8fc85310cde85aeaab7e3097f593c91d209d3f9df76c928100f0\"\n+dependencies = [\n+ \"shlex\",\n+]\n+\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"chrono\"\n+version = \"0.4.38\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401\"\n+dependencies = [\n+ \"android-tzdata\",\n+ \"iana-time-zone\",\n+ \"js-sys\",\n+ \"num-traits\",\n+ \"wasm-bindgen\",\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"clap\"\n version = \"4.5.1\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -218,6 +284,25 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7\"\n \n+[[package]]\n+name = \"console\"\n+version = \"0.15.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0e1f83fc076bd6dd27517eacdf25fef6c4dfe5f1d7448bafaaf3a26f13b5e4eb\"\n+dependencies = [\n+ \"encode_unicode\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"unicode-width\",\n+ \"windows-sys\",\n+]\n+\n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.8.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\"\n+\n [[package]]\n name = \"core2\"\n version = \"0.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -245,6 +330,21 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.20\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80\"\n+\n [[package]]\n name = \"crypto-common\"\n version = \"0.1.6\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -261,6 +361,20 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7762d17f1241643615821a8455a0b2c3e803784b058693d990b11f2dce25a0ca\"\n \n+[[package]]\n+name = \"dashmap\"\n+version = \"6.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+ \"hashbrown\",\n+ \"lock_api\",\n+ \"once_cell\",\n+ \"parking_lot_core\",\n+]\n+\n [[package]]\n name = \"difflib\"\n version = \"0.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -283,6 +397,12 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10\"\n \n+[[package]]\n+name = \"encode_unicode\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n+\n [[package]]\n name = \"env_filter\"\n version = \"0.1.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -322,6 +442,17 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.14.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -338,12 +469,41 @@ version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc\"\n+\n [[package]]\n name = \"humantime\"\n version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n+[[package]]\n+name = \"iana-time-zone\"\n+version = \"0.1.61\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220\"\n+dependencies = [\n+ \"android_system_properties\",\n+ \"core-foundation-sys\",\n+ \"iana-time-zone-haiku\",\n+ \"js-sys\",\n+ \"wasm-bindgen\",\n+ \"windows-core\",\n+]\n+\n+[[package]]\n+name = \"iana-time-zone-haiku\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"indexmap\"\n version = \"2.2.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -354,12 +514,77 @@ dependencies = [\n  \"hashbrown\",\n ]\n \n+[[package]]\n+name = \"indicatif\"\n+version = \"0.17.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"763a5a8f45087d6bcea4222e7b72c291a054edf80e4ef6efd2a4979878c7bea3\"\n+dependencies = [\n+ \"console\",\n+ \"instant\",\n+ \"number_prefix\",\n+ \"portable-atomic\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"inferno\"\n+version = \"0.11.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"232929e1d75fe899576a3d5c7416ad0d88dbfbb3c3d6aa00873a7408a50ddb88\"\n+dependencies = [\n+ \"ahash\",\n+ \"clap\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-utils\",\n+ \"dashmap\",\n+ \"env_logger\",\n+ \"indexmap\",\n+ \"is-terminal\",\n+ \"itoa\",\n+ \"log\",\n+ \"num-format\",\n+ \"once_cell\",\n+ \"quick-xml\",\n+ \"rgb\",\n+ \"str_stack\",\n+]\n+\n+[[package]]\n+name = \"instant\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"is-terminal\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"1.0.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c\"\n \n+[[package]]\n+name = \"js-sys\"\n+version = \"0.3.70\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a\"\n+dependencies = [\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -368,9 +593,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.153\"\n+version = \"0.2.159\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd\"\n+checksum = \"561d97a539a36e26a9a5fad1ea11a3039a67714694aaa379433e580854bc3dc5\"\n \n [[package]]\n name = \"libflate\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -400,13 +625,23 @@ dependencies = [\n name = \"linux-bzimage-builder\"\n version = \"0.2.0\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"bytemuck\",\n  \"libflate\",\n  \"serde\",\n  \"xmas-elf\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\n+dependencies = [\n+ \"autocfg\",\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.20\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -419,12 +654,56 @@ version = \"2.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n+[[package]]\n+name = \"num-format\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a652d9771a63711fd3c3deb670acfbe5c30a4072e664d7a3bf5a9e1056ac72c3\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"itoa\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.2.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"number_prefix\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.9.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"portable-atomic\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d30538d42559de6b034bc76fd6dd4c38961b1ee5c6c56e3808c50128fdbc22ce\"\n+\n [[package]]\n name = \"predicates\"\n version = \"3.1.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -461,6 +740,15 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"quick-xml\"\n+version = \"0.26.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7f50b1c63b38611e7d4d7f68b82d3ad0cc71a2ad2e7f61fc10f1328d917c93cd\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.35\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -470,6 +758,15 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.5.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"355ae415ccd3a04315d3f8246e86d67689ea74d88d915576e1589a351062a13b\"\n+dependencies = [\n+ \"bitflags 2.6.0\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"1.10.4\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -508,6 +805,15 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"rgb\"\n+version = \"0.8.50\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"57397d16646700483b67d2dd6511d79318f9d057fdbd21a4066aeac8b41d310a\"\n+dependencies = [\n+ \"bytemuck\",\n+]\n+\n [[package]]\n name = \"rle-decode-fast\"\n version = \"1.0.3\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -520,6 +826,12 @@ version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1\"\n \n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.197\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -577,6 +889,18 @@ version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.13.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n+\n+[[package]]\n+name = \"str_stack\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9091b6114800a5f2141aee1d1b9d6ca3592ac062dc5decb3764ec5895a47b4eb\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.11.0\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -647,6 +971,12 @@ version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n \n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af\"\n+\n [[package]]\n name = \"utf8parse\"\n version = \"0.2.1\"\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -668,6 +998,76 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n+\n+[[package]]\n+name = \"wasm-bindgen\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+ \"wasm-bindgen-macro\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-backend\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b\"\n+dependencies = [\n+ \"bumpalo\",\n+ \"log\",\n+ \"once_cell\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf\"\n+dependencies = [\n+ \"quote\",\n+ \"wasm-bindgen-macro-support\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro-support\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-backend\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-shared\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484\"\n+\n+[[package]]\n+name = \"windows-core\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.52.0\"\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -19,8 +19,11 @@ version = \"0.2.0\"\n \n [dependencies]\n clap = { version = \"4.4.17\", features = [\"cargo\", \"derive\"] }\n+chrono = \"0.4.38\"\n env_logger = \"0.11.0\"\n+inferno = \"0.11.21\"\n indexmap = \"2.2.1\"\n+indicatif = \"0.17.8\" # For a commandline progress bar\n lazy_static = \"1.4.0\"\n log = \"0.4.20\"\n quote = \"1.0.35\"\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -37,7 +37,7 @@ pub fn main() {\n         OsdkSubcommand::Run(run_args) => {\n             execute_run_command(\n                 &load_config(&run_args.common_args),\n-                &run_args.gdb_server_args,\n+                run_args.gdb_server.as_deref(),\n             );\n         }\n         OsdkSubcommand::Debug(debug_args) => {\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -160,49 +168,150 @@ pub struct BuildArgs {\n \n #[derive(Debug, Parser)]\n pub struct RunArgs {\n+    #[arg(\n+        long = \"gdb-server\",\n+        help = \"Enable the QEMU GDB server for debugging\\n\\\n+                This option supports an additional comma separated configuration list:\\n\\t \\\n+                    addr=ADDR:   the network or unix socket address on which the GDB server listens, \\\n+                                 `.osdk-gdb-socket` by default;\\n\\t \\\n+                    wait-client: let the GDB server wait for the GDB client before execution;\\n\\t \\\n+                    vscode:      generate a '.vscode/launch.json' for debugging with Visual Studio Code.\",\n+        value_name = \"[addr=ADDR][,wait-client][,vscode]\",\n+        default_missing_value = \"\"\n+    )]\n+    pub gdb_server: Option<String>,\n     #[command(flatten)]\n-    pub gdb_server_args: GdbServerArgs,\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Debug, Parser)]\n+pub struct DebugArgs {\n+    #[arg(\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n+    )]\n+    pub remote: String,\n     #[command(flatten)]\n     pub common_args: CommonArgs,\n }\n \n-#[derive(Debug, Args, Clone, Default)]\n-pub struct GdbServerArgs {\n-    /// Whether to enable QEMU GDB server for debugging\n+#[derive(Debug, Parser)]\n+pub struct ProfileArgs {\n     #[arg(\n-        long = \"enable-gdb\",\n-        short = 'G',\n-        help = \"Enable QEMU GDB server for debugging\",\n-        default_value_t\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n     )]\n-    pub is_gdb_enabled: bool,\n+    pub remote: String,\n+    #[arg(long, help = \"The number of samples to collect\", default_value = \"200\")]\n+    pub samples: usize,\n     #[arg(\n-        long = \"vsc\",\n-        help = \"Generate a '.vscode/launch.json' for debugging with Visual Studio Code \\\n-                (only works when '--enable-gdb' is enabled)\",\n-        default_value_t\n+        long,\n+        help = \"The interval between samples in seconds\",\n+        default_value = \"0.1\"\n     )]\n-    pub vsc_launch_file: bool,\n+    pub interval: f64,\n     #[arg(\n-        long = \"gdb-server-addr\",\n-        help = \"The network address on which the GDB server listens, \\\n-        it can be either a path for the UNIX domain socket or a TCP port on an IP address.\",\n-        value_name = \"ADDR\",\n-        default_value = \".aster-gdb-socket\"\n+        long,\n+        help = \"Parse a collected JSON profile file into other formats\",\n+        value_name = \"PATH\",\n+        conflicts_with = \"samples\",\n+        conflicts_with = \"interval\"\n     )]\n-    pub gdb_server_addr: String,\n+    pub parse: Option<PathBuf>,\n+    #[command(flatten)]\n+    pub out_args: DebugProfileOutArgs,\n+    #[command(flatten)]\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Clone, Copy, Debug, ValueEnum)]\n+pub enum ProfileFormat {\n+    /// The raw stack trace log parsed from GDB in JSON\n+    Json,\n+    /// The folded stack trace for generating a flame graph later using\n+    /// [the original tool](https://github.com/brendangregg/FlameGraph)\n+    Folded,\n+    /// A SVG flame graph\n+    FlameGraph,\n+}\n+\n+impl ProfileFormat {\n+    pub fn file_extension(&self) -> &'static str {\n+        match self {\n+            ProfileFormat::Json => \"json\",\n+            ProfileFormat::Folded => \"folded\",\n+            ProfileFormat::FlameGraph => \"svg\",\n+        }\n+    }\n }\n \n #[derive(Debug, Parser)]\n-pub struct DebugArgs {\n+pub struct DebugProfileOutArgs {\n+    #[arg(long, help = \"The output format for the profile data\")]\n+    format: Option<ProfileFormat>,\n     #[arg(\n         long,\n-        help = \"Specify the address of the remote target\",\n-        default_value = \".aster-gdb-socket\"\n+        help = \"The mask of the CPU to generate traces for in the output profile data\",\n+        default_value_t = u128::MAX\n     )]\n-    pub remote: String,\n-    #[command(flatten)]\n-    pub common_args: CommonArgs,\n+    pub cpu_mask: u128,\n+    #[arg(\n+        long,\n+        help = \"The path to the output profile data file\",\n+        value_name = \"PATH\"\n+    )]\n+    output: Option<PathBuf>,\n+}\n+\n+impl DebugProfileOutArgs {\n+    /// Get the output format for the profile data.\n+    ///\n+    /// If the user does not specify the format, it will be inferred from the\n+    /// output file extension. If the output file does not have an extension,\n+    /// the default format is flame graph.\n+    pub fn format(&self) -> ProfileFormat {\n+        self.format.unwrap_or_else(|| {\n+            if self.output.is_some() {\n+                match self.output.as_ref().unwrap().extension() {\n+                    Some(ext) if ext == \"folded\" => ProfileFormat::Folded,\n+                    Some(ext) if ext == \"json\" => ProfileFormat::Json,\n+                    Some(ext) if ext == \"svg\" => ProfileFormat::FlameGraph,\n+                    _ => ProfileFormat::FlameGraph,\n+                }\n+            } else {\n+                ProfileFormat::FlameGraph\n+            }\n+        })\n+    }\n+\n+    /// Get the output path for the profile data.\n+    ///\n+    /// If the user does not specify the output path, it will be generated from\n+    /// the current time stamp and the format. The caller can provide a hint\n+    /// output path to the file to override the file name.\n+    pub fn output_path(&self, hint: Option<&PathBuf>) -> PathBuf {\n+        self.output.clone().unwrap_or_else(|| {\n+            use chrono::{offset::Local, DateTime};\n+            let file_stem = if let Some(hint) = hint {\n+                format!(\n+                    \"{}\",\n+                    hint.parent()\n+                        .unwrap()\n+                        .join(hint.file_stem().unwrap())\n+                        .display()\n+                )\n+            } else {\n+                let crate_name = crate::util::get_current_crate_info().name;\n+                let time_stamp = std::time::SystemTime::now();\n+                let time_stamp: DateTime<Local> = time_stamp.into();\n+                let time_stamp = time_stamp.format(\"%H%M%S\");\n+                format!(\"{}-profile-{}\", crate_name, time_stamp)\n+            };\n+            PathBuf::from(format!(\"{}.{}\", file_stem, self.format().file_extension()))\n+        })\n+    }\n }\n \n #[derive(Debug, Parser)]\ndiff --git a/osdk/src/commands/debug.rs b/osdk/src/commands/debug.rs\n--- a/osdk/src/commands/debug.rs\n+++ b/osdk/src/commands/debug.rs\n@@ -18,10 +18,9 @@ pub fn execute_debug_command(_profile: &str, args: &DebugArgs) {\n \n     let mut gdb = Command::new(\"gdb\");\n     gdb.args([\n+        format!(\"{}\", file_path.display()).as_str(),\n         \"-ex\",\n         format!(\"target remote {}\", remote).as_str(),\n-        \"-ex\",\n-        format!(\"file {}\", file_path.display()).as_str(),\n     ]);\n     gdb.status().unwrap();\n }\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -1,60 +1,29 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::process::exit;\n+\n+use vsc::VscLaunchConfig;\n+\n use super::{build::create_base_and_cached_build, util::DEFAULT_TARGET_RELPATH};\n use crate::{\n-    cli::GdbServerArgs,\n     config::{scheme::ActionChoice, Config},\n+    error::Errno,\n+    error_msg,\n     util::{get_current_crate_info, get_target_directory},\n };\n \n-pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n-    if gdb_server_args.is_gdb_enabled {\n-        use std::env;\n-        env::set_var(\n-            \"RUSTFLAGS\",\n-            env::var(\"RUSTFLAGS\").unwrap_or_default() + \" -g\",\n-        );\n-    }\n-\n+pub fn execute_run_command(config: &Config, gdb_server_args: Option<&str>) {\n     let cargo_target_directory = get_target_directory();\n     let osdk_output_directory = cargo_target_directory.join(DEFAULT_TARGET_RELPATH);\n     let target_name = get_current_crate_info().name;\n \n     let mut config = config.clone();\n-    if gdb_server_args.is_gdb_enabled {\n-        let qemu_gdb_args = {\n-            let gdb_stub_addr = gdb_server_args.gdb_server_addr.as_str();\n-            match gdb::stub_type_of(gdb_stub_addr) {\n-                gdb::StubAddrType::Unix => {\n-                    format!(\n-                        \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0 -S\",\n-                        gdb_stub_addr\n-                    )\n-                }\n-                gdb::StubAddrType::Tcp => {\n-                    format!(\n-                        \" -gdb tcp:{} -S\",\n-                        gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n-                    )\n-                }\n-            }\n-        };\n-        config.run.qemu.args += &qemu_gdb_args;\n-\n-        // Ensure debug info added when debugging in the release profile.\n-        if config.run.build.profile.contains(\"release\") {\n-            config\n-                .run\n-                .build\n-                .override_configs\n-                .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n-        }\n-    }\n-    let _vsc_launch_file = gdb_server_args.vsc_launch_file.then(|| {\n-        vsc::check_gdb_config(gdb_server_args);\n-        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n-        vsc::VscLaunchConfig::new(profile, &gdb_server_args.gdb_server_addr)\n-    });\n+\n+    let _vsc_launch_file = if let Some(gdb_server_str) = gdb_server_args {\n+        adapt_for_gdb_server(&mut config, gdb_server_str)\n+    } else {\n+        None\n+    };\n \n     let default_bundle_directory = osdk_output_directory.join(target_name);\n     let bundle = create_base_and_cached_build(\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -69,6 +38,82 @@ pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n     bundle.run(&config, ActionChoice::Run);\n }\n \n+fn adapt_for_gdb_server(config: &mut Config, gdb_server_str: &str) -> Option<VscLaunchConfig> {\n+    let gdb_server_args = GdbServerArgs::from_str(gdb_server_str);\n+\n+    // Add GDB server arguments to QEMU.\n+    let qemu_gdb_args = {\n+        let gdb_stub_addr = gdb_server_args.host_addr.as_str();\n+        match gdb::stub_type_of(gdb_stub_addr) {\n+            gdb::StubAddrType::Unix => {\n+                format!(\n+                    \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0\",\n+                    gdb_stub_addr\n+                )\n+            }\n+            gdb::StubAddrType::Tcp => {\n+                format!(\n+                    \" -gdb tcp:{}\",\n+                    gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n+                )\n+            }\n+        }\n+    };\n+    config.run.qemu.args += &qemu_gdb_args;\n+\n+    if gdb_server_args.wait_client {\n+        config.run.qemu.args += \" -S\";\n+    }\n+\n+    // Ensure debug info added when debugging in the release profile.\n+    if config.run.build.profile.contains(\"release\") {\n+        config\n+            .run\n+            .build\n+            .override_configs\n+            .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n+    }\n+\n+    gdb_server_args.vsc_launch_file.then(|| {\n+        vsc::check_gdb_config(&gdb_server_args);\n+        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n+        vsc::VscLaunchConfig::new(profile, &gdb_server_args.host_addr)\n+    })\n+}\n+\n+struct GdbServerArgs {\n+    host_addr: String,\n+    wait_client: bool,\n+    vsc_launch_file: bool,\n+}\n+\n+impl GdbServerArgs {\n+    fn from_str(args: &str) -> Self {\n+        let mut host_addr = \".osdk-gdb-socket\".to_string();\n+        let mut wait_client = false;\n+        let mut vsc_launch_file = false;\n+\n+        for arg in args.split(\",\") {\n+            let kv = arg.split('=').collect::<Vec<_>>();\n+            match kv.as_slice() {\n+                [\"addr\", addr] => host_addr = addr.to_string(),\n+                [\"wait-client\"] => wait_client = true,\n+                [\"vscode\"] => vsc_launch_file = true,\n+                _ => {\n+                    error_msg!(\"Invalid GDB server argument: {}\", arg);\n+                    exit(Errno::Cli as _);\n+                }\n+            }\n+        }\n+\n+        GdbServerArgs {\n+            host_addr,\n+            wait_client,\n+            vsc_launch_file,\n+        }\n+    }\n+}\n+\n mod gdb {\n     #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n     pub enum StubAddrType {\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -111,7 +156,6 @@ mod gdb {\n \n mod vsc {\n     use crate::{\n-        cli::GdbServerArgs,\n         commands::util::bin_file_name,\n         util::{get_cargo_metadata, get_current_crate_info},\n     };\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -121,7 +165,7 @@ mod vsc {\n         path::Path,\n     };\n \n-    use super::gdb;\n+    use super::{gdb, GdbServerArgs};\n \n     const VSC_DIR: &str = \".vscode\";\n \ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -170,6 +214,7 @@ mod vsc {\n             }\n         }\n     }\n+\n     impl Drop for VscLaunchConfig {\n         fn drop(&mut self) {\n             // remove generated files\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -205,22 +250,16 @@ mod vsc {\n         use crate::{error::Errno, error_msg};\n         use std::process::exit;\n \n-        if !args.is_gdb_enabled {\n-            error_msg!(\n-                \"No need for a VSCode launch file without launching GDB server,\\\n-                    pass '-h' for help\"\n-            );\n-            exit(Errno::ParseMetadata as _);\n-        }\n-\n         // check GDB server address\n-        let gdb_stub_addr = args.gdb_server_addr.as_str();\n+        let gdb_stub_addr = args.host_addr.as_str();\n         if gdb_stub_addr.is_empty() {\n             error_msg!(\"GDB server address is required to generate a VSCode launch file\");\n             exit(Errno::ParseMetadata as _);\n         }\n         if gdb::stub_type_of(gdb_stub_addr) != gdb::StubAddrType::Tcp {\n-            error_msg!(\"Non-TCP GDB server address is not supported under '--vsc' currently\");\n+            error_msg!(\n+                \"Non-TCP GDB server address is not supported under '--gdb-server vscode' currently\"\n+            );\n             exit(Errno::ParseMetadata as _);\n         }\n     }\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -3,14 +3,15 @@\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Errno {\n-    CreateCrate = 1,\n-    GetMetadata = 2,\n-    AddRustToolchain = 3,\n-    ParseMetadata = 4,\n-    ExecuteCommand = 5,\n-    BuildCrate = 6,\n-    RunBundle = 7,\n-    BadCrateName = 8,\n+    Cli = 1,\n+    CreateCrate = 2,\n+    GetMetadata = 3,\n+    AddRustToolchain = 4,\n+    ParseMetadata = 5,\n+    ExecuteCommand = 6,\n+    BuildCrate = 7,\n+    RunBundle = 8,\n+    BadCrateName = 9,\n }\n \n /// Print error message to console\n",
        "test_patch": "",
        "problem_statement": "[Perf Guide] Flame graph scripts on Asterinas\n[Flame graph](https://github.com/brendangregg/FlameGraph) is a well known and powerful tool for performance (bottoleneck) analysis. It's based on sampling. If you inspect the call stack 100 times per second, the function that appears more often, would like to consume more time. The flame graph helps you to visualize it.\r\n\r\nHere's my experience about how to capture a flame graph for Asterinas.\r\n\r\nJust like what's proposed in #691, the first step is to launch a GDB server (`make gdb_server RELEASE=1`), attach to it (`make gdb_client`) and quit to leave the kernel running.\r\n\r\nThen, use the following script to sample call stacks using GDB:\r\n\r\n<details><summary>script to sample</summary>\r\n<p>\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\n# Number of samples\r\nnsamples=100\r\n# Sleep time between samples (in seconds)\r\nsleeptime=0.1\r\n\r\n# Hostname or IP address of the machine running QEMU with GDB server\r\nremote_host=\"localhost\"\r\n# Port number where QEMU GDB server is listening\r\nremote_port=\"1234\"\r\n\r\nsleep 0.1\r\n\r\nfor x in $(seq 1 $nsamples)\r\ndo\r\n\tgdb -batch \\\r\n\t\t-ex \"set pagination 0\" \\\r\n\t\t-ex \"file target/osdk/aster-nix/aster-nix-osdk-bin\" \\\r\n\t\t-ex \"target remote $remote_host:$remote_port\" \\\r\n\t\t-ex \"bt -frame-arguments presence -frame-info short-location\" >> gdb_perf.log\r\n\tsleep $sleeptime\r\ndone\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nAfter that, the text log is dumped to `gdb_perf.log`. Use a python script to generate folded stack traces for the flame graph:\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n```python\r\nimport re\r\n\r\ndef process_stack_trace(file_path):\r\n    with open(file_path, 'r') as file:\r\n        lines = file.readlines()\r\n\r\n    captures = []\r\n    current_capture = []\r\n\r\n    for line in lines:\r\n        if not line.startswith('#'):\r\n            continue\r\n        if line.startswith('#0'):\r\n            if current_capture:\r\n                captures.append(current_capture)\r\n                current_capture = []\r\n        processed = line.strip()\r\n        # remove all things between < and >, use bracket matching\r\n        cut_generic = ''\r\n        cnt = 0\r\n        for c in processed:\r\n            if c == '<':\r\n                cnt += 1\r\n            if cnt == 0:\r\n                cut_generic += c\r\n            if c == '>':\r\n                cnt -= 1\r\n        processed = cut_generic\r\n        # remove all things like \"::{impl#70}\"\r\n        processed = re.sub(r'::\\{.*?\\}', '', processed)\r\n        # remove all \"(...)\"\r\n        processed = processed.replace('(...)', '')\r\n        # remove all \"()\"\r\n        processed = processed.replace('()', '')\r\n        # remove all things like \"0xffffffff8819d0fb in\"\r\n        processed = re.sub(r'0x[0-9a-f]+ in', '', processed)\r\n\r\n        # split by spaces, the first is number and the second is function name\r\n        parts = [s for s in processed.split(' ') if s != '']\r\n\r\n        current_capture.append(parts[1])\r\n\r\n    if current_capture:\r\n        captures.append(current_capture)\r\n\r\n    folded = {} # { bt: value }\r\n\r\n    for capture in captures:\r\n        bt_from_butt = []\r\n        for frame in reversed(capture):\r\n            bt_from_butt.append(frame)\r\n        folded_key = ';'.join(bt_from_butt)\r\n        if folded_key in folded:\r\n            folded[folded_key] += 1\r\n        else:\r\n            folded[folded_key] = 1\r\n\r\n    with open('out.folded', 'w') as out_file:\r\n        for key, v in folded.items():\r\n            out_file.write(f\"{key} {v}\\n\")\r\n\r\nif __name__ == \"__main__\":\r\n    process_stack_trace('gdb_perf.log')\r\n\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nThis script generates a file `out.folded`. Then the file is ready to be processed using [Flame graph](https://github.com/brendangregg/FlameGraph). Follow the guide to have an SVG.\r\n\r\nTLDR:\r\n\r\n```shell\r\n./FlameGraph/flamegraph.pl ./asterinas/out.folded > kernel.svg\r\n```\r\n\r\nHere's an example on the unixbench spawn benchmark (on [c75a373](https://github.com/asterinas/asterinas/commit/c75a3732b9a6a7f0dbf11a839affaf2c126ecdc5)):\r\n\r\n![kernel](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d))\r\n\r\nHere's also another example using #895 to optimize it:\r\n\r\n![kernel_vmspacerw](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215))\r\n\r\nYou can clearly see that when the bottleneck `read_val_from_user` is optimized, the performance boosts significantly and the bottleneck becomes the `ProcessBuilder`.\r\n\n",
        "hints_text": "",
        "created_at": "2024-09-21T13:48:03Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1256,
        "instance_id": "asterinas__asterinas-1256",
        "issue_numbers": [
            "1237"
        ],
        "base_commit": "539984bbed414969b0c40cf181a10e9341ed2359",
        "patch": "diff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.8.0\"\n+version = \"0.8.1\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\ndiff --git a/osdk/src/config/eval.rs /dev/null\n--- a/osdk/src/config/eval.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The module implementing the evaluation feature.\n-\n-use std::{io, path::Path, process};\n-\n-/// This function is used to evaluate the string using the host's shell recursively\n-/// in order.\n-pub fn eval(cwd: impl AsRef<Path>, s: &String) -> io::Result<String> {\n-    let mut eval = process::Command::new(\"bash\");\n-    eval.arg(\"-c\");\n-    eval.arg(format!(\"echo \\\"{}\\\"\", s));\n-    eval.current_dir(cwd.as_ref());\n-    let output = eval.output()?;\n-    if !output.stderr.is_empty() {\n-        println!(\n-            \"[Info] {}\",\n-            String::from_utf8_lossy(&output.stderr).trim_end_matches('\\n')\n-        );\n-    }\n-    Ok(String::from_utf8_lossy(&output.stdout)\n-        .trim_end_matches('\\n')\n-        .to_string())\n-}\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -12,7 +12,7 @@ use serde::{de, Deserialize, Deserializer, Serialize};\n \n use super::scheme::Scheme;\n \n-use crate::{config::scheme::QemuScheme, error::Errno, error_msg, util::get_cargo_metadata};\n+use crate::{error::Errno, error_msg, util::get_cargo_metadata};\n \n #[derive(Debug, Clone, Serialize, Deserialize)]\n pub struct OsdkMeta {\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -25,6 +27,8 @@ use crate::{\n     arch::{get_default_arch, Arch},\n     cli::CommonArgs,\n     config::unix_args::apply_kv_array,\n+    error::Errno,\n+    error_msg,\n };\n \n /// The global configuration for the OSDK actions.\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -61,7 +69,11 @@ fn apply_args_before_finalize(action_scheme: &mut ActionScheme, args: &CommonArg\n             }\n         }\n         if let Some(initramfs) = &args.initramfs {\n-            boot.initramfs = Some(initramfs.clone());\n+            let Ok(initramfs) = initramfs.canonicalize() else {\n+                error_msg!(\"The initramfs path provided with argument `--initramfs` does not match any files.\");\n+                process::exit(Errno::GetMetadata as _);\n+            };\n+            boot.initramfs = Some(initramfs);\n         }\n         if let Some(boot_method) = args.boot_method {\n             boot.method = Some(boot_method);\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -73,12 +85,90 @@ fn apply_args_before_finalize(action_scheme: &mut ActionScheme, args: &CommonArg\n     }\n     if let Some(ref mut qemu) = action_scheme.qemu {\n         if let Some(path) = &args.qemu_exe {\n-            qemu.path = Some(path.clone());\n+            let Ok(qemu_path) = path.canonicalize() else {\n+                error_msg!(\n+                    \"The QEMU path provided with argument `--qemu-exe` does not match any files.\"\n+                );\n+                process::exit(Errno::GetMetadata as _);\n+            };\n+            qemu.path = Some(qemu_path);\n         }\n         if let Some(bootdev_options) = &args.bootdev_append_options {\n             qemu.bootdev_append_options = Some(bootdev_options.clone());\n         }\n     }\n+\n+    canonicalize_and_eval(action_scheme, workdir);\n+}\n+\n+fn canonicalize_and_eval(action_scheme: &mut ActionScheme, workdir: &PathBuf) {\n+    let canonicalize = |target: &mut PathBuf| {\n+        let last_cwd = std::env::current_dir().unwrap();\n+        std::env::set_current_dir(workdir).unwrap();\n+\n+        *target = target.canonicalize().unwrap_or_else(|err| {\n+            error_msg!(\n+                \"Cannot canonicalize path `{}`: {}\",\n+                target.to_string_lossy(),\n+                err,\n+            );\n+            std::env::set_current_dir(&last_cwd).unwrap();\n+            process::exit(Errno::GetMetadata as _);\n+        });\n+        std::env::set_current_dir(last_cwd).unwrap();\n+    };\n+\n+    if let Some(ref mut boot) = action_scheme.boot {\n+        if let Some(ref mut initramfs) = boot.initramfs {\n+            canonicalize(initramfs);\n+        }\n+\n+        if let Some(ref mut qemu) = action_scheme.qemu {\n+            if let Some(ref mut qemu_path) = qemu.path {\n+                canonicalize(qemu_path);\n+            }\n+        }\n+\n+        if let Some(ref mut grub) = action_scheme.grub {\n+            if let Some(ref mut grub_mkrescue_path) = grub.grub_mkrescue {\n+                canonicalize(grub_mkrescue_path);\n+            }\n+        }\n+    }\n+\n+    // Do evaluations on the need to be evaluated string field, namely,\n+    // QEMU arguments.\n+\n+    if let Some(ref mut qemu) = action_scheme.qemu {\n+        if let Some(ref mut args) = qemu.args {\n+            *args = match eval(workdir, args) {\n+                Ok(v) => v,\n+                Err(e) => {\n+                    error_msg!(\"Failed to evaluate qemu args: {:#?}\", e);\n+                    process::exit(Errno::ParseMetadata as _);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// This function is used to evaluate the string using the host's shell recursively\n+/// in order.\n+pub fn eval(cwd: impl AsRef<Path>, s: &String) -> io::Result<String> {\n+    let mut eval = process::Command::new(\"bash\");\n+    eval.arg(\"-c\");\n+    eval.arg(format!(\"echo \\\"{}\\\"\", s));\n+    eval.current_dir(cwd.as_ref());\n+    let output = eval.output()?;\n+    if !output.stderr.is_empty() {\n+        println!(\n+            \"[Info] {}\",\n+            String::from_utf8_lossy(&output.stderr).trim_end_matches('\\n')\n+        );\n+    }\n+    Ok(String::from_utf8_lossy(&output.stdout)\n+        .trim_end_matches('\\n')\n+        .to_string())\n }\n \n fn apply_args_after_finalize(action: &mut Action, args: &CommonArgs) {\ndiff --git a/osdk/src/config/mod.rs b/osdk/src/config/mod.rs\n--- a/osdk/src/config/mod.rs\n+++ b/osdk/src/config/mod.rs\n@@ -111,7 +201,7 @@ impl Config {\n         let run = {\n             let mut run = scheme.run.clone().unwrap_or_default();\n             run.inherit(&default_scheme);\n-            apply_args_before_finalize(&mut run, common_args);\n+            apply_args_before_finalize(&mut run, common_args, scheme.work_dir.as_ref().unwrap());\n             let mut run = run.finalize(target_arch);\n             apply_args_after_finalize(&mut run, common_args);\n             check_compatibility(run.grub.boot_protocol, run.build.encoding.clone());\n",
        "test_patch": "",
        "problem_statement": "OSDK should not check the options that have been overridden\n### Describe the bug\r\n\r\nOSDK will (but should not) keep checking the existence of the file, despite that option is overridden .\r\n\r\n### To Reproduce\r\n\r\n1. Create a `OSDK.toml` whose `initramfs` points to a non-exist file.\r\n   ``` toml\r\n   [boot]\r\n   initramfs = \"non/exist/directory/initramfs.cpio.gz\"\r\n   ```\r\n2. Run OSDK with command line `initramfs` option, e.g. `cargo osdk build --initramfs=\"test/build/initramfs.cpio.gz\"`, where `initramfs.cpio.gz` does exist.\r\n3. OSDK will report that `non/exist/directory/initramfs.cpio.gz` does not exist, despite it's overridden by command-line `--initramfs`.\r\n   ```\r\n   $ cargo osdk build --initramfs=\"test/build/initramfs.cpio.gz\"\r\n   [Error]: Cannot canonicalize path `non/exist/directory/initramfs.cpio.gz`: No such file or directory (os error 2)\r\n   ```\r\n\r\n### Expected behavior\r\n\r\nIt should work, and don't need to check `non/exist/directory/initramfs.cpio.gz`.\r\n\r\n### Screenshots\r\n\r\n<img width=\"1192\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c80d5a9c-1cf0-4647-aefc-735c469667d4\">\r\n\r\nwhere `result/initrd.gz` exists while `test/build/initramfs.cpio.gz` does not.\n",
        "hints_text": "",
        "created_at": "2024-08-28T11:24:08Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1154,
        "instance_id": "asterinas__asterinas-1154",
        "issue_numbers": [
            "1130"
        ],
        "base_commit": "38b46f7ac3dd206d116f7db1fa33654569a8e443",
        "patch": "diff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -18,12 +18,14 @@ use ostd::{\n \n use super::Process;\n use crate::{\n-    prelude::*,\n     process::{\n         posix_thread::PosixThreadExt,\n         signal::{constants::SIGALRM, signals::kernel::KernelSignal},\n     },\n-    thread::work_queue::{submit_work_item, work_item::WorkItem},\n+    thread::{\n+        work_queue::{submit_work_item, work_item::WorkItem},\n+        Thread,\n+    },\n     time::{\n         clocks::{ProfClock, RealTimeClock},\n         Timer, TimerManager,\ndiff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -36,40 +38,43 @@ use crate::{\n /// invoke the callbacks of expired timers which are based on the updated\n /// CPU clock.\n fn update_cpu_time() {\n-    let current_thread = current_thread!();\n-    if let Some(posix_thread) = current_thread.as_posix_thread() {\n-        let process = posix_thread.process();\n-        let timer_manager = process.timer_manager();\n-        let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n-        // Based on whether the timer interrupt occurs in kernel mode or user mode,\n-        // the function will add the duration of one timer interrupt interval to the\n-        // corresponding CPU clocks.\n-        if is_kernel_interrupted() {\n-            posix_thread\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-            process\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-        } else {\n-            posix_thread\n-                .prof_clock()\n-                .user_clock()\n-                .add_time(jiffies_interval);\n-            process.prof_clock().user_clock().add_time(jiffies_interval);\n-            timer_manager\n-                .virtual_timer()\n-                .timer_manager()\n-                .process_expired_timers();\n-        }\n+    let Some(current_thread) = Thread::current() else {\n+        return;\n+    };\n+    let Some(posix_thread) = current_thread.as_posix_thread() else {\n+        return;\n+    };\n+    let process = posix_thread.process();\n+    let timer_manager = process.timer_manager();\n+    let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n+    // Based on whether the timer interrupt occurs in kernel mode or user mode,\n+    // the function will add the duration of one timer interrupt interval to the\n+    // corresponding CPU clocks.\n+    if is_kernel_interrupted() {\n+        posix_thread\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+        process\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+    } else {\n+        posix_thread\n+            .prof_clock()\n+            .user_clock()\n+            .add_time(jiffies_interval);\n+        process.prof_clock().user_clock().add_time(jiffies_interval);\n         timer_manager\n-            .prof_timer()\n+            .virtual_timer()\n             .timer_manager()\n             .process_expired_timers();\n-        posix_thread.process_expired_timers();\n     }\n+    timer_manager\n+        .prof_timer()\n+        .timer_manager()\n+        .process_expired_timers();\n+    posix_thread.process_expired_timers();\n }\n \n /// Registers a function to update the CPU clock in processes and\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -119,6 +119,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     }\n \n     trap::init();\n+    crate::arch::irq::enable_local();\n \n     // Mark the AP as started.\n     let ap_boot_info = AP_BOOT_INFO.get().unwrap();\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -86,6 +86,8 @@ pub fn init() {\n \n     mm::kspace::activate_kernel_page_table();\n \n+    arch::irq::enable_local();\n+\n     invoke_ffi_init_funcs();\n }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -71,6 +71,11 @@ pub fn preempt(task: &Arc<Task>) {\n ///\n /// If the current task's status not [`TaskStatus::Runnable`], it will not be\n /// added to the scheduler.\n+///\n+/// # Panics\n+///\n+/// This function will panic if called while holding preemption locks or with\n+/// local IRQ disabled.\n fn switch_to_task(next_task: Arc<Task>) {\n     let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n     if preemt_lock_count != 0 {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -80,6 +85,11 @@ fn switch_to_task(next_task: Arc<Task>) {\n         );\n     }\n \n+    assert!(\n+        crate::arch::irq::is_local_enabled(),\n+        \"Switching task with local IRQ disabled\"\n+    );\n+\n     let irq_guard = crate::trap::disable_local();\n \n     let current_task_ptr = CURRENT_TASK_PTR.load();\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -9,7 +9,6 @@ use trapframe::TrapFrame;\n use crate::{\n     arch::irq::{self, IrqCallbackHandle, IRQ_ALLOCATOR},\n     prelude::*,\n-    task::{disable_preempt, DisablePreemptGuard},\n     Error,\n };\n \ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -135,7 +134,6 @@ pub fn disable_local() -> DisabledLocalIrqGuard {\n #[must_use]\n pub struct DisabledLocalIrqGuard {\n     was_enabled: bool,\n-    preempt_guard: DisablePreemptGuard,\n }\n \n impl !Send for DisabledLocalIrqGuard {}\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -146,11 +144,7 @@ impl DisabledLocalIrqGuard {\n         if was_enabled {\n             irq::disable_local();\n         }\n-        let preempt_guard = disable_preempt();\n-        Self {\n-            was_enabled,\n-            preempt_guard,\n-        }\n+        Self { was_enabled }\n     }\n \n     /// Transfers the saved IRQ status of this guard to a new guard.\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -158,10 +152,7 @@ impl DisabledLocalIrqGuard {\n     pub fn transfer_to(&mut self) -> Self {\n         let was_enabled = self.was_enabled;\n         self.was_enabled = false;\n-        Self {\n-            was_enabled,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { was_enabled }\n     }\n }\n \ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -172,18 +163,3 @@ impl Drop for DisabledLocalIrqGuard {\n         }\n     }\n }\n-\n-/// Enables all IRQs on the current CPU.\n-///\n-/// FIXME: The reason we need to add this API is that currently IRQs\n-/// are enabled when the CPU enters the user space for the first time,\n-/// which is too late. During the OS initialization phase,\n-/// we need to get the block device working and mount the filesystems,\n-/// thus requiring the IRQs should be enabled as early as possible.\n-///\n-/// FIXME: this method may be unsound.\n-pub fn enable_local() {\n-    if !crate::arch::irq::is_local_enabled() {\n-        crate::arch::irq::enable_local();\n-    }\n-}\ndiff --git a/ostd/src/trap/mod.rs b/ostd/src/trap/mod.rs\n--- a/ostd/src/trap/mod.rs\n+++ b/ostd/src/trap/mod.rs\n@@ -11,9 +11,7 @@ pub use softirq::SoftIrqLine;\n pub use trapframe::TrapFrame;\n \n pub(crate) use self::handler::call_irq_callback_functions;\n-pub use self::irq::{\n-    disable_local, enable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine,\n-};\n+pub use self::irq::{disable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine};\n \n pub(crate) fn init() {\n     unsafe {\n",
        "test_patch": "",
        "problem_statement": "We shouldn't disable preemption when disabling IRQ.\nCurrently `ostd::trap::disable_local` disables preemption as well when disabling IRQ. However, such a policy would like to be based on an observation that: \"we shouldn't do `switch_to_task()` when IRQ is disabled\". Indeed we shouldn't do so. But this is not the best way to solve the problem.\r\n\r\nWe shouldn't disable preemption in `ostd::trap::disable_local`, instead, we should check if the IRQ is disabled in `switch_to_task()`. This alternative solution precisely resolves the problem without other overheads.\r\n\r\nIn contrast, if we disable preemption in `ostd::trap::disable_local`, an enormous number of places that preemption won't ever happen will try to disable preemption, introducing non negligible costs since a memory write must happen when disabling preemption. Even worse, in the case of #1125, if the architecture don't implement single instruction writes, the fall back implementation will disable IRQ. But disabling preemption would need a CPU-local write, which in turn needs to disable preemption, causing a dead loop here.\r\n\r\nSo, we need only to check if the IRQ is disabled in `switch_to_task()`. The user should disable both preemption and IRQ if they indeed need both. We should check the entire code base for such needs and add `disable_preempt` delicately.\n",
        "hints_text": "",
        "created_at": "2024-08-12T13:23:15Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1447,
        "instance_id": "asterinas__asterinas-1447",
        "issue_numbers": [
            "1291"
        ],
        "base_commit": "2af9916de92f8ca1e694bb6ac5e33111bbcf51fd",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1,6 +1,6 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n-version = 3\n+version = 4\n \n [[package]]\n name = \"acpi\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -875,9 +875,9 @@ dependencies = [\n  \"log\",\n  \"uart_16550\",\n  \"uefi\",\n- \"uefi-services\",\n- \"x86_64\",\n- \"xmas-elf 0.8.0\",\n+ \"uefi-raw\",\n+ \"x86_64 0.15.1\",\n+ \"xmas-elf 0.9.1\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -953,7 +953,7 @@ dependencies = [\n  \"log\",\n  \"multiboot2-common\",\n  \"ptr_meta\",\n- \"uefi-raw 0.8.0\",\n+ \"uefi-raw\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1119,7 +1119,7 @@ dependencies = [\n  \"unwinding\",\n  \"volatile\",\n  \"x86\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xarray\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1238,6 +1238,12 @@ dependencies = [\n  \"syn 1.0.109\",\n ]\n \n+[[package]]\n+name = \"qemu-exit\"\n+version = \"3.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8bb0fd6580eeed0103c054e3fba2c2618ff476943762f28a645b63b8692b21c9\"\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.37\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1470,7 +1476,7 @@ dependencies = [\n  \"iced-x86\",\n  \"lazy_static\",\n  \"raw-cpuid\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1572,50 +1578,41 @@ dependencies = [\n \n [[package]]\n name = \"ucs2\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bad643914094137d475641b6bab89462505316ec2ce70907ad20102d28a79ab8\"\n+checksum = \"df79298e11f316400c57ec268f3c2c29ac3c4d4777687955cd3d4f3a35ce7eba\"\n dependencies = [\n  \"bit_field\",\n ]\n \n [[package]]\n name = \"uefi\"\n-version = \"0.26.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"07ead9f748a4646479b850add36b527113a80e80a7e0f44d7b0334291850dcc5\"\n+checksum = \"91f17ea8502a6bd414acb2bf5194f90ca4c48e33a2d18cb57eab3294d2050d99\"\n dependencies = [\n  \"bitflags 2.6.0\",\n+ \"cfg-if\",\n  \"log\",\n  \"ptr_meta\",\n+ \"qemu-exit\",\n  \"ucs2\",\n  \"uefi-macros\",\n- \"uefi-raw 0.5.0\",\n+ \"uefi-raw\",\n  \"uguid\",\n ]\n \n [[package]]\n name = \"uefi-macros\"\n-version = \"0.13.0\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"26a7b1c2c808c3db854a54d5215e3f7e7aaf5dcfbce095598cba6af29895695d\"\n+checksum = \"c19ee3a01d435eda42cb9931269b349d28a1762f91ddf01c68d276f74b957cc3\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 2.0.77\",\n ]\n \n-[[package]]\n-name = \"uefi-raw\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"864ac69eadd877bfb34e7814be1928122ed0057d9f975169a56ee496aa7bdfd7\"\n-dependencies = [\n- \"bitflags 2.6.0\",\n- \"ptr_meta\",\n- \"uguid\",\n-]\n-\n [[package]]\n name = \"uefi-raw\"\n version = \"0.8.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1627,17 +1624,6 @@ dependencies = [\n  \"uguid\",\n ]\n \n-[[package]]\n-name = \"uefi-services\"\n-version = \"0.23.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a79fcb420624743c895bad0f9480fbc2f64e7c8d8611fb1ada6bdd799942feb4\"\n-dependencies = [\n- \"cfg-if\",\n- \"log\",\n- \"uefi\",\n-]\n-\n [[package]]\n name = \"uguid\"\n version = \"2.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1751,6 +1737,18 @@ dependencies = [\n  \"volatile\",\n ]\n \n+[[package]]\n+name = \"x86_64\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4bc79523af8abf92fb1a970c3e086c5a343f6bcc1a0eb890f575cbb3b45743df\"\n+dependencies = [\n+ \"bit_field\",\n+ \"bitflags 2.6.0\",\n+ \"rustversion\",\n+ \"volatile\",\n+]\n+\n [[package]]\n name = \"xarray\"\n version = \"0.1.0\"\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -89,7 +89,7 @@ endif\n ifeq ($(BOOT_PROTOCOL), linux-efi-handover64)\n CARGO_OSDK_ARGS += --grub-mkrescue=/usr/bin/grub-mkrescue\n CARGO_OSDK_ARGS += --grub-boot-protocol=\"linux\"\n-CARGO_OSDK_ARGS += --encoding gzip\n+CARGO_OSDK_ARGS += --encoding raw # FIXME: GZIP self-decompression triggers CPU faults\n else ifeq ($(BOOT_PROTOCOL), linux-legacy32)\n CARGO_OSDK_ARGS += --linux-x86-legacy-boot\n CARGO_OSDK_ARGS += --grub-boot-protocol=\"linux\"\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -9,15 +9,8 @@ repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n-[dependencies.linux-bzimage-builder]\n-# The path for local development\n-path = \"../ostd/libs/linux-bzimage/builder\"\n-# The version specified here is used for publishing on crates.io.\n-# Please update this version when publishing the cargo-osdk crate\n-# if there have been any changes to the dependent crate.\n-version = \"0.2.0\"\n-\n [dependencies]\n+linux-bzimage-builder = { version = \"0.2.0\", path = \"../ostd/libs/linux-bzimage/builder\" }\n clap = { version = \"4.4.17\", features = [\"cargo\", \"derive\"] }\n chrono = \"0.4.38\"\n env_logger = \"0.11.0\"\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -167,7 +167,37 @@ fn install_setup_with_arch(\n     let target_dir = std::fs::canonicalize(target_dir).unwrap();\n \n     let mut cmd = Command::new(\"cargo\");\n-    cmd.env(\"RUSTFLAGS\", \"-Ccode-model=kernel -Crelocation-model=pie -Ctarget-feature=+crt-static -Zplt=yes -Zrelax-elf-relocations=yes -Crelro-level=full\");\n+    let mut rustflags = vec![\n+        \"-Cdebuginfo=2\",\n+        \"-Ccode-model=kernel\",\n+        \"-Crelocation-model=pie\",\n+        \"-Zplt=yes\",\n+        \"-Zrelax-elf-relocations=yes\",\n+        \"-Crelro-level=full\",\n+    ];\n+    let target_feature_args = match arch {\n+        SetupInstallArch::X86_64 => {\n+            concat!(\n+                \"-Ctarget-feature=\",\n+                \"+crt-static\",\n+                \",-adx\",\n+                \",-aes\",\n+                \",-avx\",\n+                \",-avx2\",\n+                \",-fxsr\",\n+                \",-sse\",\n+                \",-sse2\",\n+                \",-sse3\",\n+                \",-sse4.1\",\n+                \",-sse4.2\",\n+                \",-ssse3\",\n+                \",-xsave\",\n+            )\n+        }\n+        SetupInstallArch::Other(_) => \"-Ctarget-feature=+crt-static\",\n+    };\n+    rustflags.push(target_feature_args);\n+    cmd.env(\"RUSTFLAGS\", rustflags.join(\" \"));\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -175,10 +205,9 @@ fn install_setup_with_arch(\n         let crate_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n         let setup_dir = crate_dir.join(\"../ostd/libs/linux-bzimage/setup\");\n         cmd.arg(\"--path\").arg(setup_dir);\n+    } else {\n+        cmd.arg(\"--version\").arg(env!(\"CARGO_PKG_VERSION\"));\n     }\n-    // Remember to upgrade this version if new version of linux-bzimage-setup is released.\n-    const LINUX_BZIMAGE_SETUP_VERSION: &str = \"0.1.0\";\n-    cmd.arg(\"--version\").arg(LINUX_BZIMAGE_SETUP_VERSION);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -28,7 +28,7 @@ inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-ma\n int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\", version = \"0.1.0\" }\n intrusive-collections = { version = \"0.9.6\", features = [\"nightly\"] }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n-linux-boot-params = { path = \"libs/linux-bzimage/boot-params\", version = \"0.1.0\" }\n+linux-boot-params = { version = \"0.1.0\", path = \"libs/linux-bzimage/boot-params\" }\n log = \"0.4\"\n num = { version = \"0.4\", default-features = false }\n num-derive = { version = \"0.4\", default-features = false }\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -8,7 +8,7 @@\n //! The reference to the Linux PE header definition:\n //! <https://github.com/torvalds/linux/blob/master/include/linux/pe.h>\n \n-use std::{mem::size_of, ops::Range};\n+use std::{mem::size_of, vec};\n \n use bytemuck::{Pod, Zeroable};\n use serde::Serialize;\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -202,80 +202,6 @@ struct PeSectionHdr {\n     flags: u32,\n }\n \n-struct ImageSectionAddrInfo {\n-    pub text: Range<SetupVA>,\n-    pub data: Range<SetupVA>,\n-    pub bss: Range<SetupVA>,\n-    /// All the readonly but loaded sections.\n-    pub rodata: Range<SetupVA>,\n-}\n-\n-impl ImageSectionAddrInfo {\n-    fn from(elf: &xmas_elf::ElfFile) -> Self {\n-        let mut text_start = None;\n-        let mut text_end = None;\n-        let mut data_start = None;\n-        let mut data_end = None;\n-        let mut bss_start = None;\n-        let mut bss_end = None;\n-        let mut rodata_start = None;\n-        let mut rodata_end = None;\n-        for program in elf.program_iter() {\n-            if program.get_type().unwrap() == xmas_elf::program::Type::Load {\n-                let offset = SetupVA::from(program.virtual_addr() as usize);\n-                let length = program.mem_size() as usize;\n-                if program.flags().is_execute() {\n-                    text_start = Some(offset);\n-                    text_end = Some(offset + length);\n-                } else if program.flags().is_write() {\n-                    data_start = Some(offset);\n-                    data_end = Some(offset + program.file_size() as usize);\n-                    bss_start = Some(offset + program.file_size() as usize);\n-                    bss_end = Some(offset + length);\n-                } else if program.flags().is_read() {\n-                    rodata_start = Some(offset);\n-                    rodata_end = Some(offset + length);\n-                }\n-            }\n-        }\n-\n-        Self {\n-            text: text_start.unwrap()..text_end.unwrap(),\n-            data: data_start.unwrap()..data_end.unwrap(),\n-            bss: bss_start.unwrap()..bss_end.unwrap(),\n-            rodata: rodata_start.unwrap()..rodata_end.unwrap(),\n-        }\n-    }\n-\n-    fn text_virt_size(&self) -> usize {\n-        self.text.end - self.text.start\n-    }\n-\n-    fn text_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.text.end) - SetupFileOffset::from(self.text.start)\n-    }\n-\n-    fn data_virt_size(&self) -> usize {\n-        self.data.end - self.data.start\n-    }\n-\n-    fn data_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.data.end) - SetupFileOffset::from(self.data.start)\n-    }\n-\n-    fn bss_virt_size(&self) -> usize {\n-        self.bss.end - self.bss.start\n-    }\n-\n-    fn rodata_virt_size(&self) -> usize {\n-        self.rodata.end - self.rodata.start\n-    }\n-\n-    fn rodata_file_size(&self) -> usize {\n-        SetupFileOffset::from(self.rodata.end) - SetupFileOffset::from(self.rodata.start)\n-    }\n-}\n-\n pub struct ImagePeCoffHeaderBuf {\n     pub header_at_zero: Vec<u8>,\n     pub relocs: (SetupFileOffset, Vec<u8>),\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -350,17 +276,53 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n         },\n     };\n \n-    let addr_info = ImageSectionAddrInfo::from(&elf);\n-\n     // PE section headers\n-    let sec_hdrs = [\n-        // .reloc\n-        PeSectionHdr {\n+    let mut sec_hdrs = get_pe_sec_headers_from(&elf);\n+\n+    sec_hdrs.push(PeSectionHdr::new_reloc(\n+        relocs.len() as u32,\n+        usize::from(SetupVA::from(reloc_offset)) as u32,\n+        relocs.len() as u32,\n+        usize::from(reloc_offset) as u32,\n+    ));\n+\n+    // Write the MS-DOS header\n+    bin.extend_from_slice(&MZ_MAGIC.to_le_bytes());\n+    // Write the MS-DOS stub at 0x3c\n+    bin.extend_from_slice(&[0x0; 0x3c - 0x2]);\n+    // Write the PE header offset, the header is right after the offset field\n+    bin.extend_from_slice(&(0x3cu32 + size_of::<u32>() as u32).to_le_bytes());\n+\n+    // Write the PE header\n+    pe_hdr.sections = sec_hdrs.len() as u16;\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_hdr));\n+    // Write the PE32+ optional header\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr));\n+    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr_data_dirs));\n+    // Write the PE section headers\n+    for sec_hdr in sec_hdrs {\n+        bin.extend_from_slice(bytemuck::bytes_of(&sec_hdr));\n+    }\n+\n+    ImagePeCoffHeaderBuf {\n+        header_at_zero: bin,\n+        relocs: (reloc_offset, relocs),\n+    }\n+}\n+\n+impl PeSectionHdr {\n+    fn new_reloc(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'r', b'e', b'l', b'o', b'c', 0, 0],\n-            virtual_size: relocs.len() as u32,\n-            virtual_address: usize::from(SetupVA::from(reloc_offset)) as u32,\n-            raw_data_size: relocs.len() as u32,\n-            data_addr: usize::from(reloc_offset) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -370,14 +332,21 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_DISCARDABLE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_1Bytes as u32,\n-        },\n-        // .text\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_text(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b't', b'e', b'x', b't', 0, 0, 0],\n-            virtual_size: addr_info.text_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.text.start) as u32,\n-            raw_data_size: addr_info.text_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.text.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -387,14 +356,21 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_EXECUTE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .data\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_data(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'd', b'a', b't', b'a', 0, 0, 0],\n-            virtual_size: addr_info.data_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.data.start) as u32,\n-            raw_data_size: addr_info.data_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.data.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\ndiff --git a/ostd/libs/linux-bzimage/builder/src/pe_header.rs b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/ostd/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -404,59 +380,69 @@ pub(crate) fn make_pe_coff_header(setup_elf: &[u8], image_size: usize) -> ImageP\n                 | PeSectionHdrFlags::MEM_WRITE)\n                 .bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .bss\n-        PeSectionHdr {\n-            name: [b'.', b'b', b's', b's', 0, 0, 0, 0],\n-            virtual_size: addr_info.bss_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.bss.start) as u32,\n-            raw_data_size: 0,\n-            data_addr: 0,\n-            relocs: 0,\n-            line_numbers: 0,\n-            num_relocs: 0,\n-            num_lin_numbers: 0,\n-            flags: (PeSectionHdrFlags::CNT_UNINITIALIZED_DATA\n-                | PeSectionHdrFlags::MEM_READ\n-                | PeSectionHdrFlags::MEM_WRITE)\n-                .bits\n-                | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-        // .rodata\n-        PeSectionHdr {\n+        }\n+    }\n+\n+    fn new_rodata(\n+        virtual_size: u32,\n+        virtual_address: u32,\n+        raw_data_size: u32,\n+        data_addr: u32,\n+    ) -> Self {\n+        Self {\n             name: [b'.', b'r', b'o', b'd', b'a', b't', b'a', 0],\n-            virtual_size: addr_info.rodata_virt_size() as u32,\n-            virtual_address: usize::from(addr_info.rodata.start) as u32,\n-            raw_data_size: addr_info.rodata_file_size() as u32,\n-            data_addr: usize::from(SetupFileOffset::from(addr_info.rodata.start)) as u32,\n+            virtual_size,\n+            virtual_address,\n+            raw_data_size,\n+            data_addr,\n             relocs: 0,\n             line_numbers: 0,\n             num_relocs: 0,\n             num_lin_numbers: 0,\n             flags: (PeSectionHdrFlags::CNT_INITIALIZED_DATA | PeSectionHdrFlags::MEM_READ).bits\n                 | PeSectionHdrFlagsAlign::_16Bytes as u32,\n-        },\n-    ];\n-    // Write the MS-DOS header\n-    bin.extend_from_slice(&MZ_MAGIC.to_le_bytes());\n-    // Write the MS-DOS stub at 0x3c\n-    bin.extend_from_slice(&[0x0; 0x3c - 0x2]);\n-    // Write the PE header offset, the header is right after the offset field\n-    bin.extend_from_slice(&(0x3cu32 + size_of::<u32>() as u32).to_le_bytes());\n-\n-    // Write the PE header\n-    pe_hdr.sections = sec_hdrs.len() as u16;\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_hdr));\n-    // Write the PE32+ optional header\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr));\n-    bin.extend_from_slice(bytemuck::bytes_of(&pe_opt_hdr_data_dirs));\n-    // Write the PE section headers\n-    for sec_hdr in sec_hdrs {\n-        bin.extend_from_slice(bytemuck::bytes_of(&sec_hdr));\n+        }\n     }\n+}\n \n-    ImagePeCoffHeaderBuf {\n-        header_at_zero: bin,\n-        relocs: (reloc_offset, relocs),\n+fn get_pe_sec_headers_from(elf: &xmas_elf::ElfFile) -> Vec<PeSectionHdr> {\n+    let mut result = vec![];\n+\n+    for program in elf.program_iter() {\n+        if program.get_type().unwrap() == xmas_elf::program::Type::Load {\n+            let offset = SetupVA::from(program.virtual_addr() as usize);\n+            let length = program.mem_size() as usize;\n+\n+            if program.flags().is_execute() {\n+                result.push(PeSectionHdr::new_text(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            } else if program.flags().is_write() {\n+                // We don't care about `.bss` sections since the binary is\n+                // expanded to raw.\n+                if program.file_size() == 0 {\n+                    continue;\n+                }\n+\n+                result.push(PeSectionHdr::new_data(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            } else if program.flags().is_read() {\n+                result.push(PeSectionHdr::new_rodata(\n+                    length as u32,\n+                    usize::from(offset) as u32,\n+                    length as u32,\n+                    usize::from(SetupFileOffset::from(offset)) as u32,\n+                ));\n+            }\n+        }\n     }\n+\n+    result\n }\ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -16,16 +16,16 @@ path = \"src/main.rs\"\n cfg-if = \"1.0.0\"\n core2 = { version = \"0.4.0\", default-features = false, features = [\"nightly\"] }\n libflate = { version = \"2.1.0\", default-features = false }\n-linux-boot-params = { path = \"../boot-params\", version = \"0.1.0\" }\n+linux-boot-params = { version = \"0.1.0\", path = \"../boot-params\" }\n uart_16550 = \"0.3.0\"\n-xmas-elf = \"0.8.0\"\n+xmas-elf = \"0.9.1\"\n \n [target.x86_64-unknown-none.dependencies]\n bitflags = \"2.4.1\"\n log = \"0.4.20\"\n-uefi = \"0.26.0\"\n-uefi-services = \"0.23.0\"\n-x86_64 = \"0.14.11\"\n+uefi = { version = \"0.32.0\", features = [\"global_allocator\", \"panic_handler\", \"logger\", \"qemu\"]}\n+uefi-raw = \"0.8.0\"\n+x86_64 = \"0.15.1\"\n \n [features]\n default = []\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -2,19 +2,17 @@\n \n use linux_boot_params::BootParams;\n use uefi::{\n-    data_types::Handle,\n+    boot::{exit_boot_services, open_protocol_exclusive},\n+    mem::memory_map::{MemoryMap, MemoryMapOwned},\n+    prelude::*,\n     proto::loaded_image::LoadedImage,\n-    table::{\n-        boot::MemoryMap,\n-        cfg::{ACPI2_GUID, ACPI_GUID},\n-        Boot, Runtime, SystemTable,\n-    },\n };\n+use uefi_raw::table::system::SystemTable;\n \n use super::{\n     decoder::decode_payload,\n     paging::{Ia32eFlags, PageNumber, PageTableCreator},\n-    relocation::apply_rela_dyn_relocations,\n+    relocation::apply_rela_relocations,\n };\n \n // Suppress warnings since using todo!.\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -22,77 +20,92 @@ use super::{\n #[allow(unused_variables)]\n #[allow(clippy::diverging_sub_expression)]\n #[export_name = \"efi_stub_entry\"]\n-extern \"sysv64\" fn efi_stub_entry(handle: Handle, mut system_table: SystemTable<Boot>) -> ! {\n-    unsafe {\n-        system_table.boot_services().set_image_handle(handle);\n-    }\n-    uefi_services::init(&mut system_table).unwrap();\n+extern \"sysv64\" fn efi_stub_entry(handle: Handle, system_table: *const SystemTable) -> ! {\n+    // SAFETY: handle and system_table are valid pointers. It is only called once.\n+    unsafe { system_init(handle, system_table) };\n+\n+    uefi::helpers::init().unwrap();\n \n     let boot_params = todo!(\"Use EFI boot services to fill boot params\");\n \n-    efi_phase_boot(handle, system_table, boot_params);\n+    efi_phase_boot(boot_params);\n }\n \n #[export_name = \"efi_handover_entry\"]\n extern \"sysv64\" fn efi_handover_entry(\n     handle: Handle,\n-    mut system_table: SystemTable<Boot>,\n+    system_table: *const SystemTable,\n     boot_params_ptr: *mut BootParams,\n ) -> ! {\n-    unsafe {\n-        system_table.boot_services().set_image_handle(handle);\n-    }\n-    uefi_services::init(&mut system_table).unwrap();\n+    // SAFETY: handle and system_table are valid pointers. It is only called once.\n+    unsafe { system_init(handle, system_table) };\n+\n+    uefi::helpers::init().unwrap();\n \n     // SAFETY: boot_params is a valid pointer.\n     let boot_params = unsafe { &mut *boot_params_ptr };\n \n-    efi_phase_boot(handle, system_table, boot_params)\n+    efi_phase_boot(boot_params)\n }\n \n-fn efi_phase_boot(\n-    handle: Handle,\n-    system_table: SystemTable<Boot>,\n-    boot_params: &mut BootParams,\n-) -> ! {\n-    // SAFETY: this init function is only called once.\n-    unsafe { crate::console::init() };\n+/// Initialize the system.\n+///\n+/// # Safety\n+///\n+/// This function should be called only once with valid parameters before all\n+/// operations.\n+unsafe fn system_init(handle: Handle, system_table: *const SystemTable) {\n+    // SAFETY: This is the right time to initialize the console and it is only\n+    // called once here before all console operations.\n+    unsafe {\n+        crate::console::init();\n+    }\n \n-    // SAFETY: this is the right time to apply relocations.\n-    unsafe { apply_rela_dyn_relocations() };\n+    // SAFETY: This is the right time to apply relocations.\n+    unsafe { apply_rela_relocations() };\n \n-    uefi_services::println!(\"[EFI stub] Relocations applied.\");\n+    // SAFETY: The handle and system_table are valid pointers. They are passed\n+    // from the UEFI firmware. They are only called once.\n+    unsafe {\n+        boot::set_image_handle(handle);\n+        uefi::table::set_system_table(system_table);\n+    }\n+}\n+\n+fn efi_phase_boot(boot_params: &mut BootParams) -> ! {\n+    uefi::println!(\"[EFI stub] Relocations applied.\");\n+    uefi::println!(\n+        \"[EFI stub] Stub loaded at {:#x?}\",\n+        crate::x86::get_image_loaded_offset()\n+    );\n \n     // Fill the boot params with the RSDP address if it is not provided.\n     if boot_params.acpi_rsdp_addr == 0 {\n-        boot_params.acpi_rsdp_addr = get_rsdp_addr(&system_table);\n+        boot_params.acpi_rsdp_addr = get_rsdp_addr();\n     }\n \n     // Load the kernel payload to memory.\n     let payload = crate::get_payload(boot_params);\n     let kernel = decode_payload(payload);\n \n-    uefi_services::println!(\"[EFI stub] Loading payload.\");\n+    uefi::println!(\"[EFI stub] Loading payload.\");\n     crate::loader::load_elf(&kernel);\n \n-    uefi_services::println!(\"[EFI stub] Exiting EFI boot services.\");\n+    uefi::println!(\"[EFI stub] Exiting EFI boot services.\");\n     let memory_type = {\n-        let boot_services = system_table.boot_services();\n-        let Ok(loaded_image) = boot_services.open_protocol_exclusive::<LoadedImage>(handle) else {\n+        let Ok(loaded_image) = open_protocol_exclusive::<LoadedImage>(boot::image_handle()) else {\n             panic!(\"Failed to open LoadedImage protocol\");\n         };\n         loaded_image.data_type()\n     };\n-    let (system_table, memory_map) = system_table.exit_boot_services(memory_type);\n+    // SAFETY: All allocations in the boot services phase are not used after\n+    // this point.\n+    let memory_map = unsafe { exit_boot_services(memory_type) };\n \n-    efi_phase_runtime(system_table, memory_map, boot_params);\n+    efi_phase_runtime(memory_map, boot_params);\n }\n \n-fn efi_phase_runtime(\n-    _system_table: SystemTable<Runtime>,\n-    memory_map: MemoryMap<'static>,\n-    boot_params: &mut BootParams,\n-) -> ! {\n+fn efi_phase_runtime(memory_map: MemoryMapOwned, boot_params: &mut BootParams) -> ! {\n     unsafe {\n         crate::console::print_str(\"[EFI stub] Entered runtime services.\\n\");\n     }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -218,16 +231,18 @@ fn efi_phase_runtime(\n     }\n }\n \n-fn get_rsdp_addr(boot_table: &SystemTable<Boot>) -> u64 {\n-    let config_table = boot_table.config_table();\n-    for entry in config_table {\n-        // Prefer ACPI2 over ACPI.\n-        if entry.guid == ACPI2_GUID {\n-            return entry.address as usize as u64;\n-        }\n-        if entry.guid == ACPI_GUID {\n-            return entry.address as usize as u64;\n+fn get_rsdp_addr() -> u64 {\n+    use uefi::table::cfg::{ACPI2_GUID, ACPI_GUID};\n+    uefi::system::with_config_table(|table| {\n+        for entry in table {\n+            // Prefer ACPI2 over ACPI.\n+            if entry.guid == ACPI2_GUID {\n+                return entry.address as usize as u64;\n+            }\n+            if entry.guid == ACPI_GUID {\n+                return entry.address as usize as u64;\n+            }\n         }\n-    }\n-    panic!(\"ACPI RSDP not found\");\n+        panic!(\"ACPI RSDP not found\");\n+    })\n }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/linker.ld\n@@ -40,15 +40,11 @@ SECTIONS\n     .eh_frame_hdr           : {\n         *(.eh_frame_hdr .eh_frame_hdr.*)\n     }\n-\n-    .rela.dyn               : {\n-        PROVIDE(__rela_dyn_start = .);\n-        *(.rela.dyn .rela.dyn.*)\n-        PROVIDE(__rela_dyn_end = .);\n-    }\n-\n-    .rela.plt               : {\n-        *(.rela.plt .rela.plt.*)\n+    \n+    .rela                   : {\n+        PROVIDE(__rela_start = .);\n+        *(.rela .rela.*)\n+        PROVIDE(__rela_end = .);\n     }\n \n     .comment                : { *(.comment) }\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -18,6 +18,7 @@ const TABLE_ENTRY_COUNT: usize = 512;\n \n bitflags::bitflags! {\n     #[derive(Clone, Copy)]\n+    #[repr(C)]\n     pub struct Ia32eFlags: u64 {\n         const PRESENT =         1 << 0;\n         const WRITABLE =        1 << 1;\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -32,9 +33,11 @@ bitflags::bitflags! {\n     }\n }\n \n+#[repr(C)]\n pub struct Ia32eEntry(u64);\n \n /// The table in the IA32E paging specification that occupies a physical page frame.\n+#[repr(C)]\n pub struct Ia32eTable([Ia32eEntry; TABLE_ENTRY_COUNT]);\n \n /// A page number. It could be either a physical page number or a virtual page number.\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -2,62 +2,68 @@\n \n use crate::x86::get_image_loaded_offset;\n \n-struct Elf64Rela {\n-    r_offset: u64,\n-    r_info: u64,\n-    r_addend: i64,\n-}\n+/// Apply the relocations in the `.rela.*` sections.\n+///\n+/// The function will enable dyn Trait objects to work since they rely on\n+/// vtable pointers. Vtable won't work without relocations.\n+///\n+/// We currently support R_X86_64_RELATIVE relocations only. And this type of\n+/// relocation seems to be the only existing type if we compile Rust code to\n+/// PIE ELF binaries.\n+///\n+/// # Safety\n+///\n+/// This function will modify the memory pointed by the relocations. And the\n+/// Rust memory safety mechanisms are not aware of these kind of modification.\n+/// Failure to do relocations will cause `dyn Trait` objects to break.\n+pub unsafe fn apply_rela_relocations() {\n+    use core::arch::asm;\n+    let image_loaded_offset = get_image_loaded_offset();\n+\n+    let mut start: usize;\n+    let end: usize;\n \n-fn get_rela_array() -> &'static [Elf64Rela] {\n-    extern \"C\" {\n-        fn __rela_dyn_start();\n-        fn __rela_dyn_end();\n+    unsafe {\n+        asm!(\n+            \"lea {}, [rip + __rela_start]\",\n+            out(reg) start,\n+        );\n+        asm!(\n+            \"lea {}, [rip + __rela_end]\",\n+            out(reg) end,\n+        );\n     }\n-    let start = __rela_dyn_start as *const Elf64Rela;\n-    let end = __rela_dyn_end as *const Elf64Rela;\n-    let len = unsafe { end.offset_from(start) } as usize;\n+\n     #[cfg(feature = \"debug_print\")]\n     unsafe {\n         use crate::console::{print_hex, print_str};\n-        print_str(\"[EFI stub debug] .rela.dyn section size = \");\n-        print_hex(len as u64);\n-        print_str(\"; __rela_dyn_start = \");\n+        print_str(\"[EFI stub debug] loaded offset = \");\n+        print_hex(image_loaded_offset as u64);\n+        print_str(\"\\n\");\n+        print_str(\"[EFI stub debug] .rela section start = \");\n         print_hex(start as u64);\n-        print_str(\", __rela_dyn_end = \");\n+        print_str(\", end = \");\n         print_hex(end as u64);\n         print_str(\"\\n\");\n     }\n-    // SAFETY: the linker will ensure that the symbols are valid.\n-    unsafe { core::slice::from_raw_parts(start, len) }\n-}\n \n-const R_X86_64_RELATIVE: u32 = 8;\n+    #[cfg(feature = \"debug_print\")]\n+    let mut count = 0;\n \n-/// Apply the relocations in the `.rela.dyn` section.\n-///\n-/// The function will enable dyn Trait objects to work since they rely on vtable pointers. Vtable\n-/// won't work without relocations.\n-///\n-/// We currently support R_X86_64_RELATIVE relocations only. And this type of relocation seems to\n-/// be the only existing type if we compile Rust code to PIC ELF binaries.\n-///\n-/// # Safety\n-/// This function will modify the memory pointed by the relocations. And the Rust memory safety\n-/// mechanisms are not aware of these kind of modification. Failure to do relocations will cause\n-/// dyn Trait objects to break.\n-pub unsafe fn apply_rela_dyn_relocations() {\n-    let image_loaded_offset = get_image_loaded_offset();\n-    let relas = get_rela_array();\n-    for rela in relas {\n+    while start < end {\n+        let rela = (start as *const Elf64Rela).read_volatile();\n         let r_type = (rela.r_info & 0xffffffff) as u32;\n         let _r_sym = (rela.r_info >> 32) as usize;\n-        let r_addend = rela.r_addend;\n-        let r_offset = rela.r_offset as usize;\n-        let target = (image_loaded_offset + r_offset as isize) as usize;\n+        let r_addend = rela.r_addend as isize;\n+        let r_offset = rela.r_offset as isize;\n+        let target = image_loaded_offset.wrapping_add(r_offset) as usize;\n         #[cfg(feature = \"debug_print\")]\n         unsafe {\n             use crate::console::{print_hex, print_str};\n-            print_str(\"[EFI stub debug] Applying relocation at offset \");\n+            count += 1;\n+            print_str(\"[EFI stub debug] Applying relocation #\");\n+            print_hex(count as u64);\n+            print_str(\" at offset \");\n             print_hex(r_offset as u64);\n             print_str(\", type = \");\n             print_hex(r_type as u64);\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -67,12 +73,23 @@ pub unsafe fn apply_rela_dyn_relocations() {\n         }\n         match r_type {\n             R_X86_64_RELATIVE => {\n-                let value = (image_loaded_offset as i64 + r_addend) as usize;\n-                *(target as *mut usize) = value;\n+                let value = image_loaded_offset.wrapping_add(r_addend) as usize;\n+                (target as *mut usize).write(value);\n             }\n             _ => {\n                 panic!(\"Unknown relocation type: {}\", r_type);\n             }\n         }\n+        start = start.wrapping_add(core::mem::size_of::<Elf64Rela>());\n     }\n }\n+\n+const R_X86_64_RELATIVE: u32 = 8;\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct Elf64Rela {\n+    r_offset: u64,\n+    r_info: u64,\n+    r_addend: i64,\n+}\ndiff --git a/ostd/libs/linux-bzimage/setup/src/x86/mod.rs b/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n--- a/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n+++ b/ostd/libs/linux-bzimage/setup/src/x86/mod.rs\n@@ -16,10 +16,23 @@ const START_OF_SETUP32_VA: usize = 0x100000;\n /// The setup is a position-independent executable. We can get the loaded base\n /// address from the symbol.\n #[inline]\n-#[allow(clippy::fn_to_numeric_cast)]\n pub fn get_image_loaded_offset() -> isize {\n-    extern \"C\" {\n-        fn start_of_setup32();\n+    let address_of_start: usize;\n+    #[cfg(target_arch = \"x86_64\")]\n+    unsafe {\n+        core::arch::asm!(\n+            \"lea {}, [rip + start_of_setup32]\",\n+            out(reg) address_of_start,\n+            options(pure, nomem, nostack)\n+        );\n     }\n-    start_of_setup32 as isize - START_OF_SETUP32_VA as isize\n+    #[cfg(target_arch = \"x86\")]\n+    unsafe {\n+        core::arch::asm!(\n+            \"lea {}, [start_of_setup32]\",\n+            out(reg) address_of_start,\n+            options(pure, nomem, nostack)\n+        );\n+    }\n+    address_of_start as isize - START_OF_SETUP32_VA as isize\n }\ndiff --git a/tools/github_workflows/publish_osdk_and_ostd.sh b/tools/github_workflows/publish_osdk_and_ostd.sh\n--- a/tools/github_workflows/publish_osdk_and_ostd.sh\n+++ b/tools/github_workflows/publish_osdk_and_ostd.sh\n@@ -60,6 +60,8 @@ do_publish_for() {\n }\n \n do_publish_for osdk\n+do_publish_for ostd/libs/linux-bzimage/build\n+do_publish_for ostd/libs/linux-bzimage/boot-params\n \n # All supported targets of OSTD, this array should keep consistent with\n # `package.metadata.docs.rs.targets` in `ostd/Cargo.toml`.\n",
        "test_patch": "",
        "problem_statement": "Invalid opcode after relocation for Linux EFI-handover boot\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nSometimes the Linux EFI-handover boot will fail due to invalid opcode failure during early booting.\r\n\r\n### To Reproduce\r\n\r\nWith KVM on,\r\n\r\n```bash\r\n make run AUTO_TEST=syscall BOOT_PROTOCOL=linux-efi-handover64\r\n```\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\n### Logs\r\n\r\n```\r\n...\r\n      Adding bitflags v1.3.2 (latest: v2.6.0)\r\n      Adding raw-cpuid v10.7.0 (latest: v11.1.0)\r\n      Adding syn v1.0.109 (latest: v2.0.77)\r\n      Adding uefi v0.26.0 (latest: v0.31.0)\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\n[EFI stub] Relocations applied.\r\n!!!! X64 Exception Type - 06(#UD - Invalid Opcode)  CPU Apic ID - 00000000 !!!!\r\nRIP  - 000000007CBC90F0, CS  - 0000000000000038, RFLAGS - 0000000000210217\r\nRAX  - 000000007FF12BB9, RCX - 000000007CBC19A8, RDX - 0000000000000001\r\nRBX  - 000000007CBC23B8, RSP - 000000007CBC2398, RBP - 0000000000000001\r\nRSI  - 000000007CBBBB77, RDI - 000000007CBC2408\r\nR8   - 00000000000000AF, R9  - 0000000000000014, R10 - 000000007E43F78D\r\nR11  - 0000000000000008, R12 - 000000007E43F78D, R13 - 0000000000000008\r\nR14  - 0000000000000002, R15 - 000000007E977518\r\nDS   - 0000000000000030, ES  - 0000000000000030, FS  - 0000000000000030\r\nGS   - 0000000000000030, SS  - 0000000000000030\r\nCR0  - 0000000080010033, CR2 - 0000000000000000, CR3 - 000000007FC01000\r\nCR4  - 0000000000000668, CR8 - 0000000000000000\r\nDR0  - 0000000000000000, DR1 - 0000000000000000, DR2 - 0000000000000000\r\nDR3  - 0000000000000000, DR6 - 00000000FFFF0FF0, DR7 - 0000000000000400\r\nGDTR - 000000007F9DE000 0000000000000047, LDTR - 0000000000000000\r\nIDTR - 000000007F470018 0000000000000FFF,   TR - 0000000000000000\r\nFXSAVE_STATE - 000000007CBC1FF0\r\n```\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\n",
        "hints_text": "",
        "created_at": "2024-10-14T14:03:58Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1103,
        "instance_id": "asterinas__asterinas-1103",
        "issue_numbers": [
            "1089"
        ],
        "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60",
        "patch": "diff --git a/docs/src/kernel/advanced-instructions.md b/docs/src/kernel/advanced-instructions.md\n--- a/docs/src/kernel/advanced-instructions.md\n+++ b/docs/src/kernel/advanced-instructions.md\n@@ -93,3 +93,6 @@ Your previous launch configs will be restored after the server is down.\n Press `F5`(Run and Debug) to start a debug session via VS Code. \n Click `Continue`(or, press `F5`) at the fisrt break to resume the paused server instance,\n then it will continue until reaching your first breakpoint. \n+\n+Note that if debugging with KVM enabled, you must use hardware assisted breakpoints. See \"hbreak\" in\n+[the GDB manual](https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html) for details.\ndiff --git a/kernel/aster-nix/src/syscall/read.rs b/kernel/aster-nix/src/syscall/read.rs\n--- a/kernel/aster-nix/src/syscall/read.rs\n+++ b/kernel/aster-nix/src/syscall/read.rs\n@@ -1,5 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use core::cmp::min;\n+\n use super::SyscallReturn;\n use crate::{fs::file_table::FileDesc, prelude::*, util::write_bytes_to_user};\n \ndiff --git a/kernel/aster-nix/src/syscall/read.rs b/kernel/aster-nix/src/syscall/read.rs\n--- a/kernel/aster-nix/src/syscall/read.rs\n+++ b/kernel/aster-nix/src/syscall/read.rs\n@@ -15,8 +17,20 @@ pub fn sys_read(fd: FileDesc, user_buf_addr: Vaddr, buf_len: usize) -> Result<Sy\n         file_table.get_file(fd)?.clone()\n     };\n \n-    let mut read_buf = vec![0u8; buf_len];\n-    let read_len = file.read(&mut read_buf)?;\n-    write_bytes_to_user(user_buf_addr, &mut VmReader::from(read_buf.as_slice()))?;\n+    // According to <https://man7.org/linux/man-pages/man2/read.2.html>, if\n+    // the user specified an empty buffer, we should detect errors by checking\n+    // the file discriptor. If no errors detected, return 0 successfully.\n+    let read_len = if buf_len != 0 {\n+        let mut read_buf = vec![0u8; buf_len];\n+        let read_len = file.read(&mut read_buf)?;\n+        write_bytes_to_user(\n+            user_buf_addr,\n+            &mut VmReader::from(&read_buf[..min(read_len, buf_len)]),\n+        )?;\n+        read_len\n+    } else {\n+        file.read(&mut [])?\n+    };\n+\n     Ok(SyscallReturn::Return(read_len as _))\n }\ndiff --git a/kernel/aster-nix/src/syscall/write.rs b/kernel/aster-nix/src/syscall/write.rs\n--- a/kernel/aster-nix/src/syscall/write.rs\n+++ b/kernel/aster-nix/src/syscall/write.rs\n@@ -20,9 +20,17 @@ pub fn sys_write(fd: FileDesc, user_buf_ptr: Vaddr, user_buf_len: usize) -> Resu\n         file_table.get_file(fd)?.clone()\n     };\n \n-    let mut buffer = vec![0u8; user_buf_len];\n-    read_bytes_from_user(user_buf_ptr, &mut VmWriter::from(buffer.as_mut_slice()))?;\n-    debug!(\"write content = {:?}\", buffer);\n-    let write_len = file.write(&buffer)?;\n+    // According to <https://man7.org/linux/man-pages/man2/write.2.html>, if\n+    // the user specified an empty buffer, we should detect errors by checking\n+    // the file discriptor. If no errors detected, return 0 successfully.\n+    let write_len = if user_buf_len != 0 {\n+        let mut buffer = vec![0u8; user_buf_len];\n+        read_bytes_from_user(user_buf_ptr, &mut VmWriter::from(buffer.as_mut_slice()))?;\n+        debug!(\"write content = {:?}\", buffer);\n+        file.write(&buffer)?\n+    } else {\n+        file.write(&[])?\n+    };\n+\n     Ok(SyscallReturn::Return(write_len as _))\n }\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -15,15 +15,25 @@ pub mod random;\n \n pub use iovec::{copy_iovs_from_user, IoVec};\n \n-/// Reads bytes into the `dest` `VmWriter`\n-/// from the user space of the current process.\n+/// Reads bytes into the destination `VmWriter` from the user space of the\n+/// current process.\n ///\n-/// If the reading is completely successful, returns `Ok`.\n-/// Otherwise, returns `Err`.\n+/// If the reading is completely successful, returns `Ok`. Otherwise, it\n+/// returns `Err`.\n+///\n+/// If the destination `VmWriter` (`dest`) is empty, this function still\n+/// checks if the current task and user space are available. If they are,\n+/// it returns `Ok`.\n ///\n /// TODO: this API can be discarded and replaced with the API of `VmReader`\n /// after replacing all related `buf` usages.\n pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n+    let copy_len = dest.avail();\n+\n+    if copy_len > 0 {\n+        check_vaddr(src)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -32,16 +42,18 @@ pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n         Errno::EFAULT,\n         \"the user space is missing\",\n     ))?;\n-    let copy_len = dest.avail();\n \n     let mut user_reader = user_space.vm_space().reader(src, copy_len)?;\n     user_reader.read_fallible(dest).map_err(|err| err.0)?;\n     Ok(())\n }\n \n-/// Reads a value of `Pod` type\n-/// from the user space of the current process.\n+/// Reads a value typed `Pod` from the user space of the current process.\n pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n+    if core::mem::size_of::<T>() > 0 {\n+        check_vaddr(src)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -57,15 +69,25 @@ pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n     Ok(user_reader.read_val()?)\n }\n \n-/// Writes bytes from the `src` `VmReader`\n-/// to the user space of the current process.\n+/// Writes bytes from the source `VmReader` to the user space of the current\n+/// process.\n+///\n+/// If the writing is completely successful, returns `Ok`. Otherwise, it\n+/// returns `Err`.\n ///\n-/// If the writing is completely successful, returns `Ok`,\n-/// Otherwise, returns `Err`.\n+/// If the source `VmReader` (`src`) is empty, this function still checks if\n+/// the current task and user space are available. If they are, it returns\n+/// `Ok`.\n ///\n /// TODO: this API can be discarded and replaced with the API of `VmWriter`\n /// after replacing all related `buf` usages.\n pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) -> Result<()> {\n+    let copy_len = src.remain();\n+\n+    if copy_len > 0 {\n+        check_vaddr(dest)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -74,7 +96,6 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n         Errno::EFAULT,\n         \"the user space is missing\",\n     ))?;\n-    let copy_len = src.remain();\n \n     let mut user_writer = user_space.vm_space().writer(dest, copy_len)?;\n     user_writer.write_fallible(src).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -83,6 +104,10 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n \n /// Writes `val` to the user space of the current process.\n pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n+    if core::mem::size_of::<T>() > 0 {\n+        check_vaddr(dest)?;\n+    }\n+\n     let current_task = current_task().ok_or(Error::with_message(\n         Errno::EFAULT,\n         \"the current task is missing\",\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -107,6 +132,10 @@ pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n /// The original Linux implementation can be found at:\n /// <https://elixir.bootlin.com/linux/v6.0.9/source/lib/strncpy_from_user.c#L28>\n pub fn read_cstring_from_user(addr: Vaddr, max_len: usize) -> Result<CString> {\n+    if max_len > 0 {\n+        check_vaddr(addr)?;\n+    }\n+\n     let current = current!();\n     let vmar = current.root_vmar();\n     read_cstring_from_vmar(vmar, addr, max_len)\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -114,6 +143,10 @@ pub fn read_cstring_from_user(addr: Vaddr, max_len: usize) -> Result<CString> {\n \n /// Read CString from `vmar`. If possible, use `read_cstring_from_user` instead.\n pub fn read_cstring_from_vmar(vmar: &Vmar<Full>, addr: Vaddr, max_len: usize) -> Result<CString> {\n+    if max_len > 0 {\n+        check_vaddr(addr)?;\n+    }\n+\n     let mut buffer: Vec<u8> = Vec::with_capacity(max_len);\n     let mut cur_addr = addr;\n \ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -175,3 +208,24 @@ const fn has_zero(value: usize) -> bool {\n \n     value.wrapping_sub(ONE_BITS) & !value & HIGH_BITS != 0\n }\n+\n+/// Check if the user space pointer is below the lowest userspace address.\n+///\n+/// If a pointer is below the lowest userspace address, it is likely to be a\n+/// NULL pointer. Reading from or writing to a NULL pointer should trigger a\n+/// segmentation fault.\n+///\n+/// If it is not checked here, a kernel page fault will happen and we would\n+/// deny the access in the page fault handler either. It may save a page fault\n+/// in some occasions. More importantly, double page faults may not be handled\n+/// quite well on some platforms.\n+fn check_vaddr(va: Vaddr) -> Result<()> {\n+    if va < crate::vm::vmar::ROOT_VMAR_LOWEST_ADDR {\n+        Err(Error::with_message(\n+            Errno::EFAULT,\n+            \"Bad user space pointer specified\",\n+        ))\n+    } else {\n+        Ok(())\n+    }\n+}\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -123,7 +123,7 @@ impl VmarInner {\n     }\n }\n \n-const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n+pub const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n const ROOT_VMAR_CAP_ADDR: Vaddr = MAX_USERSPACE_VADDR;\n \n impl Interval<usize> for Arc<Vmar_> {\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -3,7 +3,7 @@\n use super::{build::create_base_and_cached_build, util::DEFAULT_TARGET_RELPATH};\n use crate::{\n     cli::GdbServerArgs,\n-    config::{scheme::ActionChoice, unix_args::split_to_kv_array, Config},\n+    config::{scheme::ActionChoice, Config},\n     util::{get_current_crate_info, get_target_directory},\n };\n \ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -41,20 +41,6 @@ pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n         };\n         config.run.qemu.args += &qemu_gdb_args;\n \n-        // FIXME: Disable KVM from QEMU args in debug mode.\n-        // Currently, the QEMU GDB server does not work properly with KVM enabled.\n-        let mut splitted = split_to_kv_array(&config.run.qemu.args);\n-        let args_num = splitted.len();\n-        splitted.retain(|x| !x.contains(\"kvm\"));\n-        if splitted.len() != args_num {\n-            println!(\n-                \"[WARNING] KVM is forced to be disabled in GDB server currently. \\\n-                    Options related with KVM are ignored.\"\n-            );\n-        }\n-\n-        config.run.qemu.args = splitted.join(\" \");\n-\n         // Ensure debug info added when debugging in the release profile.\n         if config.run.build.profile.contains(\"release\") {\n             config\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -2,11 +2,8 @@\n \n //! Panic support.\n \n-use alloc::{boxed::Box, string::ToString};\n use core::ffi::c_void;\n \n-use log::error;\n-\n use crate::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n     early_print, early_println,\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -15,12 +12,9 @@ use crate::{\n extern crate cfg_if;\n extern crate gimli;\n use gimli::Register;\n-use unwinding::{\n-    abi::{\n-        UnwindContext, UnwindReasonCode, _Unwind_Backtrace, _Unwind_FindEnclosingFunction,\n-        _Unwind_GetGR, _Unwind_GetIP,\n-    },\n-    panic::begin_panic,\n+use unwinding::abi::{\n+    UnwindContext, UnwindReasonCode, _Unwind_Backtrace, _Unwind_FindEnclosingFunction,\n+    _Unwind_GetGR, _Unwind_GetIP,\n };\n \n /// The panic handler must be defined in the binary crate or in the crate that the binary\n",
        "test_patch": "",
        "problem_statement": "Syscall test at Ext2, MicroVM occasionally fails\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n### To Reproduce\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\nIn CI, the syscall test at Ext2, MicroVM randomly output bad characters and then hang without panicking. There are some runs that seemed irrelevant with the PR modification:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10053473151/job/27786308763?pr=1088\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10021055466/job/27699299104\r\n\r\nThey would pass the syscall test at ramfs (linux boot, normal VM), and then fail at Ext2, MicroVM.\r\n\r\n### Logs\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\r\nThe log would look like this:\r\n\r\n```\r\n[Bn\f\u0000\ufffd731ns] : p\ufffdb\f\u0000\ufffd\ufffd\ufffd\ufffd\u001cl\f\u0000\ufffd\ufffd\ufffd\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000R<\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffd1\ufffd\ufffd\ufffd\ufffd\ufffd\u0000\u0000protected range is not fully mappedp\u0000\u0000\u0000hk\f\u0000\ufffd\ufffd\ufffd\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"} \u0000\r\n```\r\n\n",
        "hints_text": "Another example:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10104476344/job/27943517035?pr=1030\nI found it being reproducible (randomly) locally. And it has nothing to do with Ext2. It seems to be a problem with MicroVM.\nIt is really easy to reproduce but once you need to debug (via printing or gdb), it is really hard to reproduce. It seems that it occurs lesser if the system is running more slowly (LOL).\r\n\r\nI GDBed it with KVM on (can't use breakpoints but can backtrace), I found that it hangs here:\r\n\r\n```\r\n(gdb) bt\r\n#0  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::acquire_lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:111\r\n#1  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:74\r\n#2  0xffffffff882765bd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#3  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#4  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#5  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#6  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#7  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#8  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#9  alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#10 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#11 alloc::string::String::with_capacity () at src/string.rs:492\r\n#12 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#13 0xffffffff8826174f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#14 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#15 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#16 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93d858) at src/logger.rs:37\r\n#17 0xffffffff880e2859 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#18 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#19 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#20 0xffffffff8827db32 in ostd::mm::vm_space::VmSpace::handle_page_fault (self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>, \r\n    info=0xffff8000ba93da00) at src/mm/vm_space.rs:109\r\n#21 ostd::arch::x86::trap::handle_user_page_fault (f=0xffff8000ba93dae0, page_fault_addr=7) at src/arch/x86/trap.rs:86\r\n#22 ostd::arch::x86::trap::trap_handler (f=0xffff8000ba93dae0) at src/arch/x86/trap.rs:54\r\n#23 0xffffffff8829911a in __from_kernel ()\r\n#24 0x0000000000000008 in ?? ()\r\n#25 0x0000000000000000 in ?? ()\r\n```\r\n\r\nhttps://github.com/asterinas/asterinas/issues/1085\r\n\r\nIt seemed, not reliable",
        "created_at": "2024-07-26T11:09:27Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1112,
        "instance_id": "asterinas__asterinas-1112",
        "issue_numbers": [
            "1089"
        ],
        "base_commit": "aa84b31634b9c710e04b337c5d1b8fa207f8dbde",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -398,6 +398,12 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"const-assert\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d8298db53081b3a951cadb6e0f4ebbe36def7bcb591a34676708d0d7ac87dd86\"\n+\n [[package]]\n name = \"controlled\"\n version = \"0.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1070,6 +1076,7 @@ dependencies = [\n  \"bitvec\",\n  \"buddy_system_allocator\",\n  \"cfg-if\",\n+ \"const-assert\",\n  \"gimli 0.28.0\",\n  \"iced-x86\",\n  \"id-alloc\",\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -129,17 +129,21 @@ impl VirtQueue {\n             let mut desc = descs.get(i as usize).unwrap().clone();\n             let next_i = i + 1;\n             if next_i != size {\n-                field_ptr!(&desc, Descriptor, next).write(&next_i).unwrap();\n+                field_ptr!(&desc, Descriptor, next)\n+                    .write_once(&next_i)\n+                    .unwrap();\n                 desc.add(1);\n                 descs.push(desc);\n             } else {\n-                field_ptr!(&desc, Descriptor, next).write(&(0u16)).unwrap();\n+                field_ptr!(&desc, Descriptor, next)\n+                    .write_once(&(0u16))\n+                    .unwrap();\n             }\n         }\n \n         let notify = transport.get_notify_ptr(idx).unwrap();\n         field_ptr!(&avail_ring_ptr, AvailRing, flags)\n-            .write(&(0u16))\n+            .write_once(&(0u16))\n             .unwrap();\n         Ok(VirtQueue {\n             descs,\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -177,10 +181,10 @@ impl VirtQueue {\n             let desc = &self.descs[self.free_head as usize];\n             set_dma_buf(&desc.borrow_vm().restrict::<TRights![Write, Dup]>(), *input);\n             field_ptr!(desc, Descriptor, flags)\n-                .write(&DescFlags::NEXT)\n+                .write_once(&DescFlags::NEXT)\n                 .unwrap();\n             last = self.free_head;\n-            self.free_head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+            self.free_head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n         }\n         for output in outputs.iter() {\n             let desc = &mut self.descs[self.free_head as usize];\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -189,17 +193,19 @@ impl VirtQueue {\n                 *output,\n             );\n             field_ptr!(desc, Descriptor, flags)\n-                .write(&(DescFlags::NEXT | DescFlags::WRITE))\n+                .write_once(&(DescFlags::NEXT | DescFlags::WRITE))\n                 .unwrap();\n             last = self.free_head;\n-            self.free_head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+            self.free_head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n         }\n         // set last_elem.next = NULL\n         {\n             let desc = &mut self.descs[last as usize];\n-            let mut flags: DescFlags = field_ptr!(desc, Descriptor, flags).read().unwrap();\n+            let mut flags: DescFlags = field_ptr!(desc, Descriptor, flags).read_once().unwrap();\n             flags.remove(DescFlags::NEXT);\n-            field_ptr!(desc, Descriptor, flags).write(&flags).unwrap();\n+            field_ptr!(desc, Descriptor, flags)\n+                .write_once(&flags)\n+                .unwrap();\n         }\n         self.num_used += (inputs.len() + outputs.len()) as u16;\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -210,7 +216,7 @@ impl VirtQueue {\n                 field_ptr!(&self.avail, AvailRing, ring);\n             let mut ring_slot_ptr = ring_ptr.cast::<u16>();\n             ring_slot_ptr.add(avail_slot as usize);\n-            ring_slot_ptr.write(&head).unwrap();\n+            ring_slot_ptr.write_once(&head).unwrap();\n         }\n         // write barrier\n         fence(Ordering::SeqCst);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -218,7 +224,7 @@ impl VirtQueue {\n         // increase head of avail ring\n         self.avail_idx = self.avail_idx.wrapping_add(1);\n         field_ptr!(&self.avail, AvailRing, idx)\n-            .write(&self.avail_idx)\n+            .write_once(&self.avail_idx)\n             .unwrap();\n \n         fence(Ordering::SeqCst);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -230,7 +236,7 @@ impl VirtQueue {\n         // read barrier\n         fence(Ordering::SeqCst);\n \n-        self.last_used_idx != field_ptr!(&self.used, UsedRing, idx).read().unwrap()\n+        self.last_used_idx != field_ptr!(&self.used, UsedRing, idx).read_once().unwrap()\n     }\n \n     /// The number of free descriptors.\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -247,19 +253,23 @@ impl VirtQueue {\n         loop {\n             let desc = &mut self.descs[head as usize];\n             // Sets the buffer address and length to 0\n-            field_ptr!(desc, Descriptor, addr).write(&(0u64)).unwrap();\n-            field_ptr!(desc, Descriptor, len).write(&(0u32)).unwrap();\n+            field_ptr!(desc, Descriptor, addr)\n+                .write_once(&(0u64))\n+                .unwrap();\n+            field_ptr!(desc, Descriptor, len)\n+                .write_once(&(0u32))\n+                .unwrap();\n             self.num_used -= 1;\n \n-            let flags: DescFlags = field_ptr!(desc, Descriptor, flags).read().unwrap();\n+            let flags: DescFlags = field_ptr!(desc, Descriptor, flags).read_once().unwrap();\n             if flags.contains(DescFlags::NEXT) {\n                 field_ptr!(desc, Descriptor, flags)\n-                    .write(&DescFlags::empty())\n+                    .write_once(&DescFlags::empty())\n                     .unwrap();\n-                head = field_ptr!(desc, Descriptor, next).read().unwrap();\n+                head = field_ptr!(desc, Descriptor, next).read_once().unwrap();\n             } else {\n                 field_ptr!(desc, Descriptor, next)\n-                    .write(&origin_free_head)\n+                    .write_once(&origin_free_head)\n                     .unwrap();\n                 break;\n             }\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -280,8 +290,8 @@ impl VirtQueue {\n             ptr.byte_add(offset_of!(UsedRing, ring) as usize + last_used_slot as usize * 8);\n             ptr.cast::<UsedElem>()\n         };\n-        let index = field_ptr!(&element_ptr, UsedElem, id).read().unwrap();\n-        let len = field_ptr!(&element_ptr, UsedElem, len).read().unwrap();\n+        let index = field_ptr!(&element_ptr, UsedElem, id).read_once().unwrap();\n+        let len = field_ptr!(&element_ptr, UsedElem, len).read_once().unwrap();\n \n         self.recycle_descriptors(index as u16);\n         self.last_used_idx = self.last_used_idx.wrapping_add(1);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -304,8 +314,8 @@ impl VirtQueue {\n             ptr.byte_add(offset_of!(UsedRing, ring) as usize + last_used_slot as usize * 8);\n             ptr.cast::<UsedElem>()\n         };\n-        let index = field_ptr!(&element_ptr, UsedElem, id).read().unwrap();\n-        let len = field_ptr!(&element_ptr, UsedElem, len).read().unwrap();\n+        let index = field_ptr!(&element_ptr, UsedElem, id).read_once().unwrap();\n+        let len = field_ptr!(&element_ptr, UsedElem, len).read_once().unwrap();\n \n         if index as u16 != token {\n             return Err(QueueError::WrongToken);\ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -326,7 +336,7 @@ impl VirtQueue {\n     pub fn should_notify(&self) -> bool {\n         // read barrier\n         fence(Ordering::SeqCst);\n-        let flags = field_ptr!(&self.used, UsedRing, flags).read().unwrap();\n+        let flags = field_ptr!(&self.used, UsedRing, flags).read_once().unwrap();\n         flags & 0x0001u16 == 0u16\n     }\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -353,10 +363,10 @@ fn set_dma_buf<T: DmaBuf>(desc_ptr: &DescriptorPtr, buf: &T) {\n     debug_assert_ne!(buf.len(), 0);\n     let daddr = buf.daddr();\n     field_ptr!(desc_ptr, Descriptor, addr)\n-        .write(&(daddr as u64))\n+        .write_once(&(daddr as u64))\n         .unwrap();\n     field_ptr!(desc_ptr, Descriptor, len)\n-        .write(&(buf.len() as u32))\n+        .write_once(&(buf.len() as u32))\n         .unwrap();\n }\n \ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -7,7 +7,7 @@ use aster_rights_proc::require;\n use inherit_methods_macro::inherit_methods;\n pub use ostd::Pod;\n use ostd::{\n-    mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, VmIo},\n+    mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, PodOnce, VmIo, VmIoOnce},\n     Result,\n };\n pub use typeflags_util::SetContain;\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -324,6 +324,28 @@ impl<T: Pod, M: VmIo, R: TRights> SafePtr<T, M, TRightSet<R>> {\n     }\n }\n \n+impl<T: PodOnce, M: VmIoOnce, R: TRights> SafePtr<T, M, TRightSet<R>> {\n+    /// Reads the value from the pointer using one non-tearing instruction.\n+    ///\n+    /// # Access rights\n+    ///\n+    /// This method requires the `Read` right.\n+    #[require(R > Read)]\n+    pub fn read_once(&self) -> Result<T> {\n+        self.vm_obj.read_once(self.offset)\n+    }\n+\n+    /// Overwrites the value at the pointer using one non-tearing instruction.\n+    ///\n+    /// # Access rights\n+    ///\n+    /// This method requires the `Write` right.\n+    #[require(R > Write)]\n+    pub fn write_once(&self, val: &T) -> Result<()> {\n+        self.vm_obj.write_once(self.offset, val)\n+    }\n+}\n+\n impl<T, M: HasDaddr, R> HasDaddr for SafePtr<T, M, R> {\n     fn daddr(&self) -> Daddr {\n         self.offset + self.vm_obj.daddr()\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -22,6 +22,7 @@ buddy_system_allocator = \"0.9.0\"\n bitflags = \"1.3\"\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n cfg-if = \"1.0\"\n+const-assert = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n id-alloc = { path = \"libs/id-alloc\", version = \"0.1.0\" }\n inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\", version = \"0.1.0\" }\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -13,10 +13,12 @@ use crate::{\n     arch::{iommu, mm::tlb_flush_addr_range},\n     mm::{\n         dma::{dma_type, Daddr, DmaType},\n+        io::VmIoOnce,\n         kspace::{paddr_to_vaddr, KERNEL_PAGE_TABLE},\n         page_prop::CachePolicy,\n-        HasPaddr, Paddr, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n+        HasPaddr, Paddr, PodOnce, Segment, VmIo, VmReader, VmWriter, PAGE_SIZE,\n     },\n+    prelude::*,\n };\n \n /// A coherent (or consistent) DMA mapping,\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -47,7 +49,10 @@ impl DmaCoherent {\n     ///\n     /// The method fails if any part of the given `vm_segment`\n     /// already belongs to a DMA mapping.\n-    pub fn map(vm_segment: Segment, is_cache_coherent: bool) -> Result<Self, DmaError> {\n+    pub fn map(\n+        vm_segment: Segment,\n+        is_cache_coherent: bool,\n+    ) -> core::result::Result<Self, DmaError> {\n         let frame_count = vm_segment.nframes();\n         let start_paddr = vm_segment.start_paddr();\n         if !check_and_insert_dma_mapping(start_paddr, frame_count) {\ndiff --git a/ostd/src/mm/dma/dma_coherent.rs b/ostd/src/mm/dma/dma_coherent.rs\n--- a/ostd/src/mm/dma/dma_coherent.rs\n+++ b/ostd/src/mm/dma/dma_coherent.rs\n@@ -160,15 +165,29 @@ impl Drop for DmaCoherentInner {\n }\n \n impl VmIo for DmaCoherent {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> crate::prelude::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         self.inner.vm_segment.read_bytes(offset, buf)\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> crate::prelude::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         self.inner.vm_segment.write_bytes(offset, buf)\n     }\n }\n \n+impl VmIoOnce for DmaCoherent {\n+    fn read_once<T: PodOnce>(&self, offset: usize) -> Result<T> {\n+        self.inner.vm_segment.reader().skip(offset).read_once()\n+    }\n+\n+    fn write_once<T: PodOnce>(&self, offset: usize, new_val: &T) -> Result<()> {\n+        self.inner\n+            .vm_segment\n+            .writer()\n+            .skip(offset)\n+            .write_once(new_val)\n+    }\n+}\n+\n impl<'a> DmaCoherent {\n     /// Returns a reader to read data from it.\n     pub fn reader(&'a self) -> VmReader<'a> {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -5,6 +5,7 @@\n use core::marker::PhantomData;\n \n use align_ext::AlignExt;\n+use const_assert::{Assert, IsTrue};\n use inherit_methods_macro::inherit_methods;\n \n use crate::{\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -155,7 +156,28 @@ pub trait VmIo: Send + Sync {\n     }\n }\n \n-macro_rules! impl_vmio_pointer {\n+/// A trait that enables reading/writing data from/to a VM object using one non-tearing memory\n+/// load/store.\n+///\n+/// See also [`VmIo`], which enables reading/writing data from/to a VM object without the guarantee\n+/// of using one non-tearing memory load/store.\n+pub trait VmIoOnce {\n+    /// Reads a value of the `PodOnce` type at the specified offset using one non-tearing memory\n+    /// load.\n+    ///\n+    /// Except that the offset is specified explicitly, the semantics of this method is the same as\n+    /// [`VmReader::read_once`].\n+    fn read_once<T: PodOnce>(&self, offset: usize) -> Result<T>;\n+\n+    /// Writes a value of the `PodOnce` type at the specified offset using one non-tearing memory\n+    /// store.\n+    ///\n+    /// Except that the offset is specified explicitly, the semantics of this method is the same as\n+    /// [`VmWriter::write_once`].\n+    fn write_once<T: PodOnce>(&self, offset: usize, new_val: &T) -> Result<()>;\n+}\n+\n+macro_rules! impl_vm_io_pointer {\n     ($typ:ty,$from:tt) => {\n         #[inherit_methods(from = $from)]\n         impl<T: VmIo> VmIo for $typ {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -169,10 +191,25 @@ macro_rules! impl_vmio_pointer {\n     };\n }\n \n-impl_vmio_pointer!(&T, \"(**self)\");\n-impl_vmio_pointer!(&mut T, \"(**self)\");\n-impl_vmio_pointer!(Box<T>, \"(**self)\");\n-impl_vmio_pointer!(Arc<T>, \"(**self)\");\n+impl_vm_io_pointer!(&T, \"(**self)\");\n+impl_vm_io_pointer!(&mut T, \"(**self)\");\n+impl_vm_io_pointer!(Box<T>, \"(**self)\");\n+impl_vm_io_pointer!(Arc<T>, \"(**self)\");\n+\n+macro_rules! impl_vm_io_once_pointer {\n+    ($typ:ty,$from:tt) => {\n+        #[inherit_methods(from = $from)]\n+        impl<T: VmIoOnce> VmIoOnce for $typ {\n+            fn read_once<F: PodOnce>(&self, offset: usize) -> Result<F>;\n+            fn write_once<F: PodOnce>(&self, offset: usize, new_val: &F) -> Result<()>;\n+        }\n+    };\n+}\n+\n+impl_vm_io_once_pointer!(&T, \"(**self)\");\n+impl_vm_io_once_pointer!(&mut T, \"(**self)\");\n+impl_vm_io_once_pointer!(Box<T>, \"(**self)\");\n+impl_vm_io_once_pointer!(Arc<T>, \"(**self)\");\n \n /// A marker structure used for [`VmReader`] and [`VmWriter`],\n /// representing their operated memory scope is in user space.\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -391,6 +428,34 @@ impl<'a> VmReader<'a, KernelSpace> {\n         self.read(&mut writer);\n         Ok(val)\n     }\n+\n+    /// Reads a value of the `PodOnce` type using one non-tearing memory load.\n+    ///\n+    /// If the length of the `PodOnce` type exceeds `self.remain()`, this method will return `Err`.\n+    ///\n+    /// This method will not compile if the `Pod` type is too large for the current architecture\n+    /// and the operation must be tear into multiple memory loads.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if the current position of the reader does not meet the alignment\n+    /// requirements of type `T`.\n+    pub fn read_once<T: PodOnce>(&mut self) -> Result<T> {\n+        if self.remain() < core::mem::size_of::<T>() {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let cursor = self.cursor.cast::<T>();\n+        assert!(cursor.is_aligned());\n+\n+        // SAFETY: We have checked that the number of bytes remaining is at least the size of `T`\n+        // and that the cursor is properly aligned with respect to the type `T`. All other safety\n+        // requirements are the same as for `Self::read`.\n+        let val = unsafe { cursor.read_volatile() };\n+        self.cursor = unsafe { self.cursor.add(core::mem::size_of::<T>()) };\n+\n+        Ok(val)\n+    }\n }\n \n impl<'a> VmReader<'a, UserSpace> {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -461,7 +526,7 @@ impl<'a, Space> VmReader<'a, Space> {\n     /// Skips the first `nbytes` bytes of data.\n     /// The length of remaining data is decreased accordingly.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// If `nbytes` is greater than `self.remain()`, then the method panics.\n     pub fn skip(mut self, nbytes: usize) -> Self {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -553,11 +618,36 @@ impl<'a> VmWriter<'a, KernelSpace> {\n         Ok(())\n     }\n \n+    /// Writes a value of the `PodOnce` type using one non-tearing memory store.\n+    ///\n+    /// If the length of the `PodOnce` type exceeds `self.remain()`, this method will return `Err`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if the current position of the writer does not meet the alignment\n+    /// requirements of type `T`.\n+    pub fn write_once<T: PodOnce>(&mut self, new_val: &T) -> Result<()> {\n+        if self.avail() < core::mem::size_of::<T>() {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let cursor = self.cursor.cast::<T>();\n+        assert!(cursor.is_aligned());\n+\n+        // SAFETY: We have checked that the number of bytes remaining is at least the size of `T`\n+        // and that the cursor is properly aligned with respect to the type `T`. All other safety\n+        // requirements are the same as for `Self::writer`.\n+        unsafe { cursor.cast::<T>().write_volatile(*new_val) };\n+        self.cursor = unsafe { self.cursor.add(core::mem::size_of::<T>()) };\n+\n+        Ok(())\n+    }\n+\n     /// Fills the available space by repeating `value`.\n     ///\n     /// Returns the number of values written.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// The size of the available space must be a multiple of the size of `value`.\n     /// Otherwise, the method would panic.\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -574,7 +664,7 @@ impl<'a> VmWriter<'a, KernelSpace> {\n             // hence the `add` operation and `write` operation are valid and will only manipulate\n             // the memory managed by this writer.\n             unsafe {\n-                (self.cursor as *mut T).add(i).write(value);\n+                (self.cursor as *mut T).add(i).write_volatile(value);\n             }\n         }\n \ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -650,7 +740,7 @@ impl<'a, Space> VmWriter<'a, Space> {\n     /// Skips the first `nbytes` bytes of data.\n     /// The length of available space is decreased accordingly.\n     ///\n-    /// # Panic\n+    /// # Panics\n     ///\n     /// If `nbytes` is greater than `self.avail()`, then the method panics.\n     pub fn skip(mut self, nbytes: usize) -> Self {\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -672,3 +762,23 @@ impl<'a> From<&'a mut [u8]> for VmWriter<'a> {\n         unsafe { Self::from_kernel_space(slice.as_mut_ptr(), slice.len()) }\n     }\n }\n+\n+/// A marker trait for POD types that can be read or written with one instruction.\n+///\n+/// We currently rely on this trait to ensure that the memory operation created by\n+/// `ptr::read_volatile` and `ptr::write_volatile` doesn't tear. However, the Rust documentation\n+/// makes no such guarantee, and even the wording in the LLVM LangRef is ambiguous.\n+///\n+/// At this point, we can only _hope_ that this doesn't break in future versions of the Rust or\n+/// LLVM compilers. However, this is unlikely to happen in practice, since the Linux kernel also\n+/// uses \"volatile\" semantics to implement `READ_ONCE`/`WRITE_ONCE`.\n+pub trait PodOnce: Pod {}\n+\n+impl<T: Pod> PodOnce for T where Assert<{ is_pod_once::<T>() }>: IsTrue {}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+const fn is_pod_once<T: Pod>() -> bool {\n+    let size = size_of::<T>();\n+\n+    size == 1 || size == 2 || size == 4 || size == 8\n+}\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -28,7 +28,7 @@ use spin::Once;\n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n     frame::{options::FrameAllocOptions, Frame, Segment},\n-    io::{KernelSpace, UserSpace, VmIo, VmReader, VmWriter},\n+    io::{KernelSpace, PodOnce, UserSpace, VmIo, VmIoOnce, VmReader, VmWriter},\n     page_prop::{CachePolicy, PageFlags, PageProperty},\n     vm_space::VmSpace,\n };\n",
        "test_patch": "",
        "problem_statement": "Syscall test at Ext2, MicroVM occasionally fails\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n### To Reproduce\r\n\r\n<!-- Steps to reproduce the behavior. Example:\r\n1. Go to '...'\r\n2. Click on '....'\r\n3. Scroll down to '....'\r\n4. See error -->\r\n\r\nIn CI, the syscall test at Ext2, MicroVM randomly output bad characters and then hang without panicking. There are some runs that seemed irrelevant with the PR modification:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10053473151/job/27786308763?pr=1088\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10021055466/job/27699299104\r\n\r\nThey would pass the syscall test at ramfs (linux boot, normal VM), and then fail at Ext2, MicroVM.\r\n\r\n### Logs\r\n\r\n<!-- If applicable, add log snippets or files to help explain and debug the problem. Please use code blocks (```) to format logs. -->\r\n\r\n<!-- Once again, thank you for helping us improve our project! -->\r\n\r\nThe log would look like this:\r\n\r\n```\r\n[Bn\f\u0000\ufffd731ns] : p\ufffdb\f\u0000\ufffd\ufffd\ufffd\ufffd\u001cl\f\u0000\ufffd\ufffd\ufffd\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000R<\ufffd\ufffd\ufffd\ufffd\ufffdp\ufffd1\ufffd\ufffd\ufffd\ufffd\ufffd\u0000\u0000protected range is not fully mappedp\u0000\u0000\u0000hk\f\u0000\ufffd\ufffd\ufffd\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"} \u0000\r\n```\r\n\n",
        "hints_text": "Another example:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10104476344/job/27943517035?pr=1030\nI found it being reproducible (randomly) locally. And it has nothing to do with Ext2. It seems to be a problem with MicroVM.\nIt is really easy to reproduce but once you need to debug (via printing or gdb), it is really hard to reproduce. It seems that it occurs lesser if the system is running more slowly (LOL).\r\n\r\nI GDBed it with KVM on (can't use breakpoints but can backtrace), I found that it hangs here:\r\n\r\n```\r\n(gdb) bt\r\n#0  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::acquire_lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:111\r\n#1  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>>::lock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingConsts>>>> (\r\n    self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>) at src/sync/spin.rs:74\r\n#2  0xffffffff882765bd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#3  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#4  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#5  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#6  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#7  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#8  alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#9  alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#10 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#11 alloc::string::String::with_capacity () at src/string.rs:492\r\n#12 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#13 0xffffffff8826174f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#14 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#15 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#16 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93d858) at src/logger.rs:37\r\n#17 0xffffffff880e2859 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#18 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#19 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#20 0xffffffff8827db32 in ostd::mm::vm_space::VmSpace::handle_page_fault (self=0xffffffff8836e370 <_ZN4ostd2mm14heap_allocator14HEAP_ALLOCATOR17he1684604edc78901E.llvm.13890399637656761890+8>, \r\n    info=0xffff8000ba93da00) at src/mm/vm_space.rs:109\r\n#21 ostd::arch::x86::trap::handle_user_page_fault (f=0xffff8000ba93dae0, page_fault_addr=7) at src/arch/x86/trap.rs:86\r\n#22 ostd::arch::x86::trap::trap_handler (f=0xffff8000ba93dae0) at src/arch/x86/trap.rs:54\r\n#23 0xffffffff8829911a in __from_kernel ()\r\n#24 0x0000000000000008 in ?? ()\r\n#25 0x0000000000000000 in ?? ()\r\n```\r\n\r\nhttps://github.com/asterinas/asterinas/issues/1085\r\n\r\nIt seemed, not reliable\nOk, the previous backtrace I offered is definitely resulted by a kernel mode page fault. After restoring the trapframe in GDB I had a backtrace at the state which the page fault happened:\r\n\r\n```\r\n(gdb) bt\r\n#0  core::sync::atomic::atomic_compare_exchange<u8> (dst=0x40, old=0, new=1, success=core::sync::atomic::Ordering::Acquire, failure=core::sync::atomic::Ordering::Relaxed)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3373\r\n#1  core::sync::atomic::AtomicBool::compare_exchange (self=0x40, current=false, new=true, success=core::sync::atomic::Ordering::Acquire, failure=core::sync::atomic::Ordering::Relaxed)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:811\r\n#2  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon:\r\n#3  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon \r\n    self=0x40) at src/sync/spin.rs:111\r\n#4  ostd::sync::spin::SpinLock<core::option::Option<core::mem::manually_drop::ManuallyDrop<ostd::mm::page_table::boot_pt::BootPageTable<ostd::arch::x86::mm::PageTableEntry, ostd::arch::x86::mm::PagingCon \r\n    self=0x40) at src/sync/spin.rs:74\r\n#5  0xffffffff88275edd in ostd::mm::heap_allocator::{impl#1}::alloc<32> (self=<optimized out>, layout=...) at src/mm/heap_allocator.rs:71\r\n#6  0xffffffff88049bf7 in ostd::mm::heap_allocator::_::__rust_alloc (size=4, align=1) at /root/asterinas/ostd/src/mm/heap_allocator.rs:22\r\n#7  alloc::alloc::alloc (layout=...) at src/alloc.rs:100\r\n#8  alloc::alloc::Global::alloc_impl (layout=..., zeroed=false, self=<optimized out>) at src/alloc.rs:183\r\n#9  alloc::alloc::{impl#1}::allocate (layout=..., self=<optimized out>) at src/alloc.rs:243\r\n#10 alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::try_allocate_in<u8, alloc::alloc::Global> (capacity=4, init=alloc::raw_vec::AllocInit::Uninitialized, alloc=...) at src/raw_vec.rs:230\r\n#11 alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/raw_vec.rs:158\r\n#12 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity_in<u8, alloc::alloc::Global> (capacity=<optimized out>) at src/vec/mod.rs:699\r\n#13 alloc::vec::Vec<u8, alloc::alloc::Global>::with_capacity<u8> (capacity=<optimized out>) at src/vec/mod.rs:481\r\n#14 alloc::string::String::with_capacity () at src/string.rs:492\r\n#15 alloc::fmt::format::format_inner (args=...) at src/fmt.rs:632\r\n#16 0xffffffff8826106f in alloc::fmt::format::{closure#0} () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#17 core::option::Option<&str>::map_or_else<&str, alloc::string::String, alloc::fmt::format::{closure_env#0}, fn(&str) -> alloc::string::String> (self=..., default=..., f=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:1207\r\n#18 alloc::fmt::format (args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:639\r\n#19 ostd::logger::{impl#0}::log (self=<optimized out>, record=0xffff8000ba93dbd8) at src/logger.rs:37\r\n#20 0xffffffff881234d9 in log::__private_api::log_impl (args=..., level=log::Level::Error, kvs=...) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:61\r\n#21 log::__private_api::log<()> (args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>, \r\n    args=<error reading variable: Cannot access memory at address 0x20>, target_module_path_and_loc=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/__private_api.rs:72\r\n#22 aster_nix::thread::exception::handle_page_fault (vm_space=<optimized out>, trap_info=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/macros.rs:49\r\n#23 0xffffffff8827617b in buddy_system_allocator::linked_list::{impl#5}::next (self=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/linked_list.rs:137\r\n#24 buddy_system_allocator::Heap<32>::dealloc<32> (ptr=..., layout=..., self=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/lib.rs:164\r\n#25 ostd::mm::heap_allocator::{impl#1}::dealloc<32> (self=<optimized out>, ptr=<optimized out>, layout=...) at src/mm/heap_allocator.rs:90\r\n#26 0x080000000000001f in ?? ()\r\n#27 0xffffffff883086b9 in ?? ()\r\n#28 0x0000000000000007 in ?? ()\r\n#29 0xffff8000ba93ddc8 in ?? ()\r\n#30 0xffff80000c389008 in ?? ()\r\n#31 0x0000000000000002 in ?? ()\r\n#32 0x0000000000000000 in ?? ()\r\n```\nAfter user space NULL pointers are checked, I attempted to backtraced the first page fault which leads to a lockout. Here's the stack:\r\n\r\n```\r\n(gdb) bt\r\n#0  0xffffffff8825e56b in buddy_system_allocator::linked_list::{impl#5}::next (self=<optimized out>)\r\n    at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/linked_list.rs:137\r\n#1  buddy_system_allocator::Heap<32>::dealloc<32> (ptr=..., layout=..., self=<optimized out>) at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/buddy_system_allocator-0.9.1/src/lib.rs:164\r\n#2  ostd::mm::heap_allocator::{impl#1}::dealloc<32> (self=<optimized out>, ptr=<optimized out>, layout=...) at src/mm/heap_allocator.rs:90\r\n#3  0x0000000000000020 in ?? ()\r\n#4  0x0000000000000040 in ?? ()\r\n#5  0x0000000000000001 in ?? ()\r\n#6  0xffffffff8825253b in core::alloc::global::GlobalAlloc::realloc<ostd::mm::heap_allocator::LockedHeapWithRescue<32>> (ptr=0xffff80000c8b1460, layout=..., new_size=18446603336431669952, \r\n    self=<optimized out>) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/global.rs:271\r\n#7  ostd::mm::heap_allocator::_::__rust_realloc (ptr=0xffff80000c8b1460, size=0, align=18446603339351457464, new_size=18446603336431669952) at src/mm/heap_allocator.rs:22\r\n#8  alloc::alloc::realloc () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:138\r\n#9  alloc::alloc::Global::grow_impl (ptr=..., old_layout=..., new_layout=..., zeroed=false, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:215\r\n#10 alloc::alloc::{impl#1}::grow (ptr=..., old_layout=..., new_layout=..., self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:268\r\n#11 alloc::raw_vec::finish_grow<alloc::alloc::Global> (new_layout=..., current_memory=..., alloc=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:570\r\n#12 0xffffffff88252628 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::grow_amortized<u8, alloc::alloc::Global> (len=<optimized out>, additional=<optimized out>, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:485\r\n#13 alloc::raw_vec::{impl#2}::reserve::do_reserve_and_handle<u8, alloc::alloc::Global> (slf=0xffff8000ba93fff0, len=<optimized out>, additional=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:349\r\n#14 0xffffffff882722d2 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::reserve<u8, alloc::alloc::Global> (self=<optimized out>, len=<optimized out>, additional=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:355\r\n#15 alloc::vec::Vec<u8, alloc::alloc::Global>::reserve<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, additional=1)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:972\r\n#16 alloc::vec::Vec<u8, alloc::alloc::Global>::append_elements<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, other=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2145\r\n#17 alloc::vec::spec_extend::{impl#4}::spec_extend<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, iterator=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:55\r\n#18 alloc::vec::Vec<u8, alloc::alloc::Global>::extend_from_slice<u8, alloc::alloc::Global> (self=0xffff8000ba93fff0, other=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2591\r\n#19 alloc::string::String::push_str () at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1067\r\n#20 alloc::string::{impl#58}::write_str (self=0xffff8000ba93fff0, s=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2921\r\n#21 0xffffffff88228d7f in core::fmt::num::imp::fmt_u64 (n=<optimized out>, is_nonnegative=true, f=<optimized out>) at src/fmt/num.rs:278\r\n#22 core::fmt::num::imp::{impl#7}::fmt (self=<optimized out>, f=0x20) at src/fmt/num.rs:324\r\n#23 0xffffffff8822453c in core::fmt::rt::Argument::fmt (self=0xffff8000ba940118, f=0xffff8000ba93ff68) at src/fmt/rt.rs:165\r\n#24 core::fmt::write (output=..., args=...) at src/fmt/mod.rs:1168\r\n#25 0xffffffff88273238 in core::fmt::Formatter::write_fmt (fmt=..., self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1640\r\n#26 core::panic::panic_info::{impl#3}::fmt (self=0xffff8000ba9400b8, formatter=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic/panic_info.rs:180\r\n#27 alloc::string::{impl#32}::to_string<core::panic::panic_info::PanicMessage> (self=0xffff8000ba9400b8)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2562\r\n#28 ostd::panicking::panic_handler (info=0xffff8000ba9400b8) at src/panicking.rs:33\r\n#29 0xffffffff8821c946 in asterinas_osdk_bin::panic (info=0x20) at src/main.rs:11\r\n#30 0xffffffff8822c3bf in core::panicking::panic_fmt (fmt=...) at src/panicking.rs:74\r\n#31 0xffffffff8822c5ef in core::panicking::panic_bounds_check (index=57088, len=2) at src/panicking.rs:276\r\n#32 0xffffffff881f38b5 in core::slice::index::{impl#2}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<aster_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>> (self=57088, slice=...)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:298\r\n#33 core::slice::index::{impl#1}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<ast--Type <RET> for more, q to quit, c to continue without paging--\r\ner_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>, usize> (self=..., index=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:27\r\n#34 alloc::vec::{impl#14}::index_mut<aster_util::safe_ptr::SafePtr<aster_virtio::queue::Descriptor, ostd::mm::dma::dma_coherent::DmaCoherent, aster_rights::TRightSet<typeflags_util::set::Cons<aster_rights::Signal, typeflags_util::set::Cons<aster_rights::Exec, typeflags_util::set::Cons<aster_rights::Write, typeflags_util::set::Cons<aster_rights::Read, typeflags_util::set::Cons<aster_rights::Dup, typeflags_util::set::Nil>>>>>>>, usize, alloc::alloc::Global> (index=57088, self=<optimized out>)\r\n    at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2917\r\n#35 aster_virtio::queue::VirtQueue::recycle_descriptors (self=<optimized out>, head=<optimized out>) at src/queue.rs:248\r\n#36 0xffffffff881f3b90 in aster_virtio::queue::VirtQueue::pop_used (self=0xffffffff88469258 <ostd::mm::heap_allocator::HEAP_SPACE+1032710>) at src/queue.rs:286\r\n#37 0xffffffff8821a0df in aster_virtio::device::console::device::ConsoleDevice::handle_recv_irq (self=0xffffffff88469210 <ostd::mm::heap_allocator::HEAP_SPACE+1032638>)\r\n    at src/device/console/device.rs:134\r\n#38 aster_virtio::device::console::device::{impl#2}::init::{closure#0} () at src/device/console/device.rs:115\r\n#39 0xffffffff8821a4ca in alloc::boxed::{impl#50}::call<(&trapframe::arch::trap::TrapFrame), (dyn core::ops::function::Fn<(&trapframe::arch::trap::TrapFrame), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=<optimized out>, args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2076\r\n#40 aster_virtio::transport::mmio::multiplex::{impl#0}::new::{closure#0} (trap_frame=0xffff8000ba940510) at src/transport/mmio/multiplex.rs:56\r\n#41 0xffffffff88256e0a in alloc::boxed::{impl#50}::call<(&trapframe::arch::trap::TrapFrame), (dyn core::ops::function::Fn<(&trapframe::arch::trap::TrapFrame), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=<optimized out>, args=...) at /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2076\r\n#42 ostd::arch::x86::irq::CallbackElement::call (self=<optimized out>, element=0xffff8000ba940510) at src/arch/x86/irq.rs:68\r\n#43 ostd::trap::handler::call_irq_callback_functions (trap_frame=0xffff8000ba940510, irq_number=38) at src/trap/handler.rs:19\r\n#44 0xffffffff88255c03 in ostd::arch::x86::trap::trap_handler (f=0x20) at src/arch/x86/trap.rs:68\r\n#45 0xffffffff882966de in __from_kernel ()\r\n#46 0x0000000000000000 in ?? ()\r\n```\nA further dig:\r\n\r\n```\r\n   0xffffffff8825e565 <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+245>:\tmov    %r15,%r10\r\n   0xffffffff8825e568 <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+248>:\tmov    %rsi,%r15\r\n=> 0xffffffff8825e56b <_ZN108_$LT$ostd..mm..heap_allocator..LockedHeapWithRescue$LT$_$GT$$u20$as$u20$core..alloc..global..GlobalAlloc$GT$7dealloc17hac09483596a107acE+251>:\tmov    (%rsi),%r11\r\n```\r\n\r\nThe PF happened at `0xffffffff8825e56b`, but in the trapframe, `$rsi=0xe0`, `$r15=0xe0`, `r10=0xffff80000c8b92a0`, which absolutely makes no sense.\nI've noticed that the issue is connected to the heap allocator. As a result, I think it could be the same problem as issue #1085. Can you try making the changes described in the `Additional context`? However, I'm not sure if this will solve the problem.\r\n\r\nUpdate: The problem described in #1085 does not seem to be related to PF, and may not be the same issue.\nThe root cause is:\r\n\r\n```\r\npanicked at /root/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\nindex out of bounds: the len is 2 but the index is 768\r\n```\r\n\r\nIt only happens randomly in MicroVM.\r\n\r\nSuch a panic results in a failing heap allocation, which in turn causes the kernel to hang.\r\n\r\n@sdww0 Do you have ideas about why the virtio queue driver failed?\n> The root cause is:\r\n> \r\n> ```\r\n> panicked at /root/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\n> index out of bounds: the len is 2 but the index is 768\r\n> ```\r\n> \r\n> It only happens randomly in MicroVM.\r\n> \r\n> Such a panic results in a failing heap allocation, which in turn causes the kernel to hang.\r\n> \r\n> @sdww0 Do you have ideas about why the virtio queue driver failed?\r\n\r\nThe only device that set the queue size to 2 is the console device. I think it is the [send function](https://github.com/asterinas/asterinas/blob/main/kernel/comps/virtio/src/device/console/device.rs#L34) cause this problem when calling `pop_used` (Since Github CI receive no input):\r\n\r\n```rust\r\nimpl AnyConsoleDevice for ConsoleDevice {\r\n    fn send(&self, value: &[u8]) {\r\n        let mut transmit_queue = self.transmit_queue.lock_irq_disabled();\r\n        let mut reader = VmReader::from(value);\r\n\r\n        while reader.remain() > 0 {\r\n            let mut writer = self.send_buffer.writer().unwrap();\r\n            let len = writer.write(&mut reader);\r\n            self.send_buffer.sync(0..len).unwrap();\r\n\r\n            let slice = DmaStreamSlice::new(&self.send_buffer, 0, len);\r\n            transmit_queue.add_dma_buf(&[&slice], &[]).unwrap();\r\n\r\n            if transmit_queue.should_notify() {\r\n                transmit_queue.notify();\r\n            }\r\n            while !transmit_queue.can_pop() {\r\n                spin_loop();\r\n            }\r\n            transmit_queue.pop_used().unwrap();\r\n        }\r\n    }\r\n\r\n    fn register_callback(&self, callback: &'static ConsoleCallback) {\r\n        self.callbacks.write_irq_disabled().push(callback);\r\n    }\r\n}\r\n```\r\n\r\n`send` -> `pop_used` -> `recycle_descriptor` -> `panic`\r\n\n> `send` -> `pop_used` -> `recycle_descriptor` -> `panic`\r\n\r\nThe call chain should be `handle_recv_irq` -> `pop_used` -> `recycle_descriptor` -> `panic`. The call chain can be discovered in https://github.com/asterinas/asterinas/issues/1089#issuecomment-2253719767, which is the backtrace in one failure case.\nHere is another CI failure after https://github.com/asterinas/asterinas/pull/1103:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10146669825/job/28055276772?pr=1109\r\n> panicked at /__w/asterinas/asterinas/kernel/comps/virtio/src/queue.rs:248:39:\r\nindex out of bounds: the len is 2 but the index is 512\r\nprinting stack trace:\r\n\r\nUnfortunately, the stack traces are still not available.\nhttps://github.com/asterinas/asterinas/actions/runs/10155075478/job/28081230243\r\n\r\nYes the CI reproduced the error. Reopening.\nI checked the assembly code and suspect that https://github.com/asterinas/asterinas/pull/1112 will fix the root cause. At least I can no longer reproduce the problem locally.",
        "created_at": "2024-07-30T04:20:46Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1073,
        "instance_id": "asterinas__asterinas-1073",
        "issue_numbers": [
            "1069"
        ],
        "base_commit": "5aa28eae7e14594bbe68827114443b31002bf742",
        "patch": "diff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -58,6 +58,16 @@ SECTIONS\n     # areas for the application processors.\n     .cpu_local              : AT(ADDR(.cpu_local) - KERNEL_VMA) {\n         __cpu_local_start = .;\n+\n+        # These 4 bytes are used to store the CPU ID.\n+        . += 4;\n+\n+        # These 4 bytes are used to store the number of preemption locks held.\n+        # The reason is stated in the Rust documentation of\n+        # [`ostd::task::processor::PreemptInfo`].\n+        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n+        . += 4;\n+\n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git /dev/null b/ostd/src/arch/x86/cpu/local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Architecture dependent CPU-local information utilities.\n+\n+use x86_64::registers::segmentation::{Segment64, FS};\n+\n+/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n+/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n+///\n+/// # Safety\n+///\n+///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n+///    and is not concurrently accessed for other purposes.\n+///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n+///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n+///    such as during processor initialization.\n+pub(crate) unsafe fn set_base(addr: u64) {\n+    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n+}\n+\n+/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n+pub(crate) fn get_base() -> u64 {\n+    FS::read_base().as_u64()\n+}\n+\n+pub mod preempt_lock_count {\n+    //! We need to increment/decrement the per-CPU preemption lock count using\n+    //! a single instruction. This requirement is stated by\n+    //! [`crate::task::processor::PreemptInfo`].\n+\n+    /// The GDT ensures that the FS segment is initialized to zero on boot.\n+    /// This assertion checks that the base address has been set.\n+    macro_rules! debug_assert_initialized {\n+        () => {\n+            // The compiler may think that [`super::get_base`] has side effects\n+            // so it may not be optimized out. We make sure that it will be\n+            // conditionally compiled only in debug builds.\n+            #[cfg(debug_assertions)]\n+            debug_assert_ne!(super::get_base(), 0);\n+        };\n+    }\n+\n+    /// Increments the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn inc() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly increments the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Decrements the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn dec() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly decrements the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Gets the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn get() -> u32 {\n+        debug_assert_initialized!();\n+\n+        let count: u32;\n+        // SAFETY: The inline assembly reads the lock count in one instruction\n+        // without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n+                out(reg) count,\n+                options(nostack, readonly),\n+            );\n+        }\n+        count\n+    }\n+}\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -2,6 +2,8 @@\n \n //! CPU.\n \n+pub mod local;\n+\n use alloc::vec::Vec;\n use core::{\n     arch::x86_64::{_fxrstor, _fxsave},\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -18,10 +20,7 @@ use log::debug;\n use tdx_guest::tdcall;\n pub use trapframe::GeneralRegs as RawGeneralRegs;\n use trapframe::UserContext as RawUserContext;\n-use x86_64::registers::{\n-    rflags::RFlags,\n-    segmentation::{Segment64, FS},\n-};\n+use x86_64::registers::rflags::RFlags;\n \n #[cfg(feature = \"intel_tdx\")]\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -673,22 +672,3 @@ impl Default for FpRegs {\n struct FxsaveArea {\n     data: [u8; 512], // 512 bytes\n }\n-\n-/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n-/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n-///\n-/// # Safety\n-///\n-///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n-///    and is not concurrently accessed for other purposes.\n-///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n-///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n-///    such as during processor initialization.\n-pub(crate) unsafe fn set_cpu_local_base(addr: u64) {\n-    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n-}\n-\n-/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n-pub(crate) fn get_cpu_local_base() -> u64 {\n-    FS::read_base().as_u64()\n-}\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -21,7 +21,7 @@\n use core::ops::Deref;\n \n use crate::{\n-    cpu::{get_cpu_local_base, set_cpu_local_base},\n+    arch,\n     trap::{disable_local, DisabledLocalIrqGuard},\n };\n \ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -82,6 +82,13 @@ impl<T> !Clone for CpuLocal<T> {}\n // other tasks as they should live on other CPUs to make sending useful.\n impl<T> !Send for CpuLocal<T> {}\n \n+// A check to ensure that the CPU-local object is never accessed before the\n+// initialization for all CPUs.\n+#[cfg(debug_assertions)]\n+use core::sync::atomic::{AtomicBool, Ordering};\n+#[cfg(debug_assertions)]\n+static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n+\n impl<T> CpuLocal<T> {\n     /// Initialize a CPU-local object.\n     ///\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -115,6 +122,11 @@ impl<T> CpuLocal<T> {\n     /// This function calculates the virtual address of the CPU-local object based on the per-\n     /// cpu base address and the offset in the BSP.\n     fn get(&self) -> *const T {\n+        // CPU-local objects should be initialized before being accessed. It should be ensured\n+        // by the implementation of OSTD initialization.\n+        #[cfg(debug_assertions)]\n+        debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n+\n         let offset = {\n             let bsp_va = self as *const _ as usize;\n             let bsp_base = __cpu_local_start as usize;\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -124,7 +136,7 @@ impl<T> CpuLocal<T> {\n             bsp_va - bsp_base as usize\n         };\n \n-        let local_base = get_cpu_local_base() as usize;\n+        let local_base = arch::cpu::local::get_base() as usize;\n         let local_va = local_base + offset;\n \n         // A sanity check about the alignment.\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -170,6 +182,24 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n     }\n }\n \n+/// Sets the base address of the CPU-local storage for the bootstrap processor.\n+///\n+/// It should be called early to let [`crate::task::disable_preempt`] work,\n+/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// panic when calling [`crate::task::disable_preempt`].\n+///\n+/// # Safety\n+///\n+/// It should be called only once and only on the BSP.\n+pub(crate) unsafe fn early_init_bsp_local_base() {\n+    let start_base_va = __cpu_local_start as usize as u64;\n+    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n+    // where accessing the CPU-local objects have defined behaviors.\n+    unsafe {\n+        arch::cpu::local::set_base(start_base_va);\n+    }\n+}\n+\n /// Initializes the CPU local data for the bootstrap processor (BSP).\n ///\n /// # Safety\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -179,9 +209,14 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n /// It must be guaranteed that the BSP will not access local data before\n /// this function being called, otherwise copying non-constant values\n /// will result in pretty bad undefined behavior.\n-pub unsafe fn init_on_bsp() {\n-    let start_base_va = __cpu_local_start as usize as u64;\n-    set_cpu_local_base(start_base_va);\n+pub(crate) unsafe fn init_on_bsp() {\n+    // TODO: allocate the pages for application processors and copy the\n+    // CPU-local objects to the allocated pages.\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        IS_INITIALIZED.store(true, Ordering::Relaxed);\n+    }\n }\n \n // These symbols are provided by the linker script.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -59,6 +59,9 @@ pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n pub fn init() {\n     arch::before_all_init();\n \n+    // SAFETY: This function is called only once and only on the BSP.\n+    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+\n     mm::heap_allocator::init();\n \n     boot::init();\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -340,8 +340,10 @@ impl<'a> VmReader<'a, KernelSpace> {\n     /// it should _not_ overlap with other `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *const u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -516,8 +518,10 @@ impl<'a> VmWriter<'a, KernelSpace> {\n     /// is typed, it should _not_ overlap with other `VmReader`s and `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *mut u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,17 +1,14 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::{\n-    cell::RefCell,\n-    sync::atomic::{AtomicUsize, Ordering::Relaxed},\n-};\n+use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::cpu_local;\n+use crate::{arch, cpu_local};\n \n pub struct Processor {\n     current: Option<Arc<Task>>,\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -154,38 +151,50 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-cpu_local! {\n-    static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-}\n+static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n \n-/// Currently, ``PreemptInfo`` only holds the number of spin\n-/// locks held by the current CPU. When it has a non-zero value,\n-/// the CPU cannot call ``schedule()``.\n-struct PreemptInfo {\n-    num_locks: AtomicUsize,\n-}\n+/// Currently, it only holds the number of preemption locks held by the\n+/// current CPU. When it has a non-zero value, the CPU cannot call\n+/// [`schedule()`].\n+///\n+/// For per-CPU preemption lock count, we cannot afford two non-atomic\n+/// operations to increment and decrement the count. The [`crate::cpu_local`]\n+/// implementation is free to read the base register and then calculate the\n+/// address of the per-CPU variable using an additional instruction. Interrupts\n+/// can happen between the address calculation and modification to that\n+/// address. If the task is preempted to another CPU by this interrupt, the\n+/// count of the original CPU will be mistakenly modified. To avoid this, we\n+/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n+/// can implement this using one instruction. In other less expressive\n+/// architectures, we may need to disable interrupts.\n+///\n+/// Also, the preemption count is reserved in the `.cpu_local` section\n+/// specified in the linker script. The reason is that we need to access the\n+/// preemption count before we can copy the section for application processors.\n+/// So, the preemption count is not copied from bootstrap processor's section\n+/// as the initialization. Instead it is initialized to zero for application\n+/// processors.\n+struct PreemptInfo {}\n \n impl PreemptInfo {\n     const fn new() -> Self {\n-        Self {\n-            num_locks: AtomicUsize::new(0),\n-        }\n+        Self {}\n     }\n \n     fn increase_num_locks(&self) {\n-        self.num_locks.fetch_add(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::inc();\n     }\n \n     fn decrease_num_locks(&self) {\n-        self.num_locks.fetch_sub(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::dec();\n     }\n \n     fn is_preemptive(&self) -> bool {\n-        self.num_locks.load(Relaxed) == 0\n+        arch::cpu::local::preempt_lock_count::get() == 0\n     }\n \n     fn num_locks(&self) -> usize {\n-        self.num_locks.load(Relaxed)\n+        arch::cpu::local::preempt_lock_count::get() as usize\n     }\n }\n \n",
        "test_patch": "",
        "problem_statement": "CPU local memory is used before initialized\nThe use (in `ostd`):\r\n`init` \u2192 `mm::heap_allocator::init` \u2192 `HEAP_ALLOCATOR.init` \u2192 `SpinLock::lock_irq_disabled` \u2192 `trap::irq::disable_local` \u2192 `task::processor::disable_preempt` \u2192 `PREEMPT_COUNT.increase_num_locks`, where `PREEMPT_COUNT` is a cpu-local variable.\r\n\r\nThe initialization:\r\n`init` \u2192 `cpu::cpu_local::init_on_bsp` \u2192 ...\r\n\r\nThe use is before the initialization since `mm::heap_allocator::init` is called prior to `cpu::cpu_local::init_on_bsp`.\r\nhttps://github.com/asterinas/asterinas/blob/94eba6d85eb9e62ddd904c1132d556b808cc3174/ostd/src/lib.rs#L51-L82\r\n\r\n---\r\n\r\nIt does not fault in x86 because `fsbase` is by default `0`, and the OS has write access to the memory near `0x0`, so the error is silent. But in RISC-V, this memory region is not writable, so it faults.\r\n\r\nAnd I guess this is not the only case since `SpinLock` is widely used in `ostd`, it might be other uses of `SpinLock` before CPU local memory is initialized, for example, `mm::kspace::init_boot_page_table` \u2192 `BOOT_PAGE_TABLE.lock`.\n",
        "hints_text": "Modifying `ostd::arch::x86::cpu::get_cpu_local_base` to\r\n``` rust\r\n/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\r\npub(crate) fn get_cpu_local_base() -> u64 {\r\n    let fsbase = FS::read_base().as_u64();\r\n    debug_assert_ne!(fsbase, 0, \"CPU local memory is used before initialized\");\r\n    fsbase\r\n}\r\n```\r\nmay help with discovering cpu local used before initialization bugs.\n> And I guess this is not the only case since SpinLock is widely used in ostd, it might be other uses of SpinLock before CPU local memory is initialized, for example, mm::kspace::init_boot_page_table \u2192 BOOT_PAGE_TABLE.lock.\r\n\r\nIndeed. CPU local variables should not be accessed before initialization of `mod cpu_local`. I will look into it.",
        "created_at": "2024-07-19T13:26:35Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 954,
        "instance_id": "asterinas__asterinas-954",
        "issue_numbers": [
            "871"
        ],
        "base_commit": "cd2b305fa890bca9c4374ccd83c9ccb24bf8dda3",
        "patch": "diff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -158,7 +158,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n     cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // FIXME: Uses a fixed tag instaed of relies on remote branch\n+    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n+    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\n",
        "test_patch": "",
        "problem_statement": "\"[ERROR]: Uncaught panic!\" when running the 100-line kernel example in the asterinas book.\nWhen running the 100-line kernel example in the asterinas book [https://asterinas.github.io/book/framework/a-100-line-kernel.html ](url), the following error is reported:\r\n```\r\nDrive current: -outdev 'stdio:/root/workspace/asterinas/target/osdk/myos-osdk-bin.iso'\r\nMedia current: stdio file, overwriteable\r\nMedia status : is blank\r\nMedia summary: 0 sessions, 0 data blocks, 0 data,  931g free\r\nAdded to ISO image: directory '/'='/tmp/grub.CQmOUp'\r\nxorriso : UPDATE :     341 files added in 1 seconds\r\nAdded to ISO image: directory '/'='/root/workspace/asterinas/target/osdk/iso_root'\r\nxorriso : UPDATE :     346 files added in 1 seconds\r\nxorriso : UPDATE :  0.00% done\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/scheduler.rs:44:24:\r\ncalled `Option::unwrap()` on a `None` value\r\nprinting stack trace:\r\n   1: fn 0xffffffff8809f660 - pc 0xffffffff8809f678 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047820;\r\n\r\n   2: fn 0xffffffff8809f160 - pc 0xffffffff8809f617 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047830;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a80;\r\n\r\n   4: fn 0xffffffff8818f4a0 - pc 0xffffffff8818f4ef / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a90;\r\n\r\n   5: fn 0xffffffff8818f5d0 - pc 0xffffffff8818f615 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047ae0;\r\n\r\n   6: fn 0xffffffff88124fd0 - pc 0xffffffff88125011 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b50;\r\n\r\n   7: fn 0xffffffff8806efa0 - pc 0xffffffff8806efce / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b80;\r\n\r\n   8: fn 0xffffffff8806f0c0 - pc 0xffffffff8806f16e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047bc0;\r\n\r\n   9: fn 0xffffffff8806e450 - pc 0xffffffff8806e462 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c20;\r\n\r\n  10: fn 0xffffffff880489e0 - pc 0xffffffff88048a30 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c30;\r\n\r\n  11: fn 0xffffffff880489d0 - pc 0xffffffff880489db / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f50;\r\n\r\n  12: fn 0xffffffff880a3b00 - pc 0xffffffff880a3b06 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f60;\r\n\r\n  13: fn 0xffffffff8810d3b0 - pc 0xffffffff8810d477 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f70;\r\n\r\n  14: fn                0x0 - pc 0xffffffff880ad052 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88048000;\r\n```\n",
        "hints_text": "It seems that the scheduler is not set. And the guide does not mention that.\r\n\r\n```rust\r\nuse aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\nlet simple_scheduler = Box::new(FifoScheduler::new());\r\nlet static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\nset_scheduler(static_scheduler);\r\n```\r\n\r\nCould you please check if this works? If so you can help us improve the guide!\nThanks. After adding your code into the example, the program runs successfully and outputs \"Hello, world\". However, the below error message follows. Is this normal? \r\n```\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\nHello, world\r\n\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/task.rs:191:9:\r\ninternal error: entered unreachable code\r\nprinting stack trace:\r\n   1: fn 0xffffffff880a1840 - pc 0xffffffff880a1858 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06d0;\r\n\r\n   2: fn 0xffffffff880a1340 - pc 0xffffffff880a17f7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06e0;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0930;\r\n\r\n   4: fn 0xffffffff88191e30 - pc 0xffffffff88191e7f / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0940;\r\n\r\n   5: fn 0xffffffff88191f60 - pc 0xffffffff88191fa5 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0990;\r\n\r\n   6: fn 0xffffffff8806ee80 - pc 0xffffffff8806eef9 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a00;\r\n\r\n   7: fn 0xffffffff88048660 - pc 0xffffffff880489c7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a40;\r\n\r\n   8: fn 0xffffffff880484d0 - pc 0xffffffff8804863c / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0c10;\r\n\r\n   9: fn 0xffffffff88049e60 - pc 0xffffffff88049e6e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0f90;\r\n\r\n  10: fn 0xffffffff880bae20 - pc 0xffffffff880bae36 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fb0;\r\n\r\n  11: fn 0xffffffff8806f710 - pc 0xffffffff8806f774 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fd0;\r\n```\nYes it is normal and the scheduler expect that the main task of the kernel will never return.\r\n\r\nSo a well formed hello world kernel may shut the system down after printing.\r\n\r\nHowever we do not have ACPI shutdown at this moment. Here is a debug fix.\r\n\r\n```rust\r\n#[aster_main]\r\npub fn main() {\r\n    let program_binary = include_bytes!(\"../hello_world\");\r\n    let user_space = create_user_space(program_binary);\r\n    let user_task = create_user_task(Arc::new(user_space));\r\n    user_task.run();\r\n    use aster_frame::arch::qemu::{exit_qemu, QemuExitCode};\r\n    exit_qemu(QemuExitCode::Success);\r\n}\r\n```\r\n\r\n\nOk! Thanks again.\n> It seems that the scheduler is not set. And the guide does not mention that.\r\n> \r\n> ```rust\r\n> use aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\n> let simple_scheduler = Box::new(FifoScheduler::new());\r\n> let static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\n> set_scheduler(static_scheduler);\r\n> ```\r\n> \r\n> Could you please check if this works? If so you can help us improve the guide!\r\n\r\n#748 introduces such a scheduler initialization for `ktest`. Maybe it will be better to set the scheduler in `aster_frame::init()` and it will work for both.",
        "created_at": "2024-06-20T08:52:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1018,
        "instance_id": "asterinas__asterinas-1018",
        "issue_numbers": [
            "1009"
        ],
        "base_commit": "8a9c012249d36c54712030c41388d20a608939f5",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -84,7 +84,6 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -141,7 +140,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"ringbuf\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -185,7 +183,6 @@ dependencies = [\n  \"lru\",\n  \"ostd\",\n  \"paste\",\n- \"pod\",\n  \"rand\",\n  \"ringbuf\",\n  \"smoltcp\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -238,7 +235,6 @@ dependencies = [\n  \"aster-rights-proc\",\n  \"inherit-methods-macro\",\n  \"ostd\",\n- \"pod\",\n  \"typeflags-util\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -261,7 +257,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\n  \"typeflags-util\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -277,7 +272,7 @@ dependencies = [\n  \"component\",\n  \"id-alloc\",\n  \"ostd\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -760,9 +755,9 @@ dependencies = [\n \n [[package]]\n name = \"intrusive-collections\"\n-version = \"0.9.5\"\n+version = \"0.9.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f4f90afb01281fdeffb0f8e082d230cbe4f888f837cc90759696b858db1a700\"\n+checksum = \"b694dc9f70c3bda874626d2aed13b780f137aab435f4e9814121955cf706122e\"\n dependencies = [\n  \"memoffset\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -891,7 +879,7 @@ dependencies = [\n  \"uart_16550\",\n  \"uefi\",\n  \"uefi-services\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xmas-elf 0.8.0\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -950,9 +938,9 @@ checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.8.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1\"\n+checksum = \"488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a\"\n dependencies = [\n  \"autocfg\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1113,13 +1101,13 @@ dependencies = [\n  \"unwinding\",\n  \"volatile\",\n  \"x86\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xarray\",\n ]\n \n [[package]]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1139,24 +1152,6 @@ version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n \n-[[package]]\n-name = \"pod\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"pod-derive\",\n-]\n-\n-[[package]]\n-name = \"pod-derive\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n [[package]]\n name = \"polonius-the-crab\"\n version = \"0.2.1\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1276,6 +1271,15 @@ dependencies = [\n  \"bitflags 1.3.2\",\n ]\n \n+[[package]]\n+name = \"raw-cpuid\"\n+version = \"11.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e29830cbb1290e404f24c73af91c5d8d631ce7e128691e9477556b540cd01ecd\"\n+dependencies = [\n+ \"bitflags 2.4.1\",\n+]\n+\n [[package]]\n name = \"ringbuf\"\n version = \"0.3.3\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1358,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.13.1\"\n+version = \"1.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n \n [[package]]\n name = \"smoltcp\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1462,8 +1466,8 @@ dependencies = [\n  \"bitflags 1.3.2\",\n  \"iced-x86\",\n  \"lazy_static\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 10.7.0\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1539,13 +1543,12 @@ dependencies = [\n \n [[package]]\n name = \"trapframe\"\n-version = \"0.9.0\"\n-source = \"git+https://github.com/asterinas/trapframe-rs?rev=4739428#4739428fd51685c74e6e88e73e5f04cb89f465ee\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"105000258ba41c463b63403c9341c55a298f35f6137b1cca08c10f0409ef8d3a\"\n dependencies = [\n- \"log\",\n- \"pod\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 11.0.2\",\n+ \"x86_64 0.15.1\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1723,7 +1726,7 @@ checksum = \"2781db97787217ad2a2845c396a5efe286f87467a5810836db6d74926e94a385\"\n dependencies = [\n  \"bit_field\",\n  \"bitflags 1.3.2\",\n- \"raw-cpuid\",\n+ \"raw-cpuid 10.7.0\",\n ]\n \n [[package]]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1738,6 +1741,18 @@ dependencies = [\n  \"volatile\",\n ]\n \n+[[package]]\n+name = \"x86_64\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4bc79523af8abf92fb1a970c3e086c5a343f6bcc1a0eb890f575cbb3b45743df\"\n+dependencies = [\n+ \"bit_field\",\n+ \"bitflags 2.4.1\",\n+ \"rustversion\",\n+ \"volatile\",\n+]\n+\n [[package]]\n name = \"xarray\"\n version = \"0.1.0\"\ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\n--- a/kernel/aster-nix/Cargo.toml\n+++ b/kernel/aster-nix/Cargo.toml\n@@ -6,9 +6,7 @@ edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-ostd = { path = \"../../ostd\" }\n align_ext = { path = \"../../ostd/libs/align_ext\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n aster-input = { path = \"../comps/input\" }\n aster-block = { path = \"../comps/block\" }\n aster-network = { path = \"../comps/network\" }\ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\n--- a/kernel/aster-nix/Cargo.toml\n+++ b/kernel/aster-nix/Cargo.toml\n@@ -17,6 +15,7 @@ aster-time = { path = \"../comps/time\" }\n aster-virtio = { path = \"../comps/virtio\" }\n aster-rights = { path = \"../libs/aster-rights\" }\n controlled = { path = \"../libs/comp-sys/controlled\" }\n+ostd = { path = \"../../ostd\" }\n typeflags = { path = \"../libs/typeflags\" }\n typeflags-util = { path = \"../libs/typeflags-util\" }\n aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/aster-nix/src/arch/x86/cpu.rs\n--- a/kernel/aster-nix/src/arch/x86/cpu.rs\n+++ b/kernel/aster-nix/src/arch/x86/cpu.rs\n@@ -1,6 +1,9 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use ostd::cpu::UserContext;\n+use ostd::{\n+    cpu::{RawGeneralRegs, UserContext},\n+    Pod,\n+};\n \n use crate::cpu::LinuxAbi;\n \ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/aster-nix/src/arch/x86/cpu.rs\n--- a/kernel/aster-nix/src/arch/x86/cpu.rs\n+++ b/kernel/aster-nix/src/arch/x86/cpu.rs\n@@ -36,3 +39,64 @@ impl LinuxAbi for UserContext {\n         self.fsbase()\n     }\n }\n+\n+/// General-purpose registers.\n+#[derive(Debug, Clone, Copy, Pod, Default)]\n+#[repr(C)]\n+pub struct GpRegs {\n+    pub rax: usize,\n+    pub rbx: usize,\n+    pub rcx: usize,\n+    pub rdx: usize,\n+    pub rsi: usize,\n+    pub rdi: usize,\n+    pub rbp: usize,\n+    pub rsp: usize,\n+    pub r8: usize,\n+    pub r9: usize,\n+    pub r10: usize,\n+    pub r11: usize,\n+    pub r12: usize,\n+    pub r13: usize,\n+    pub r14: usize,\n+    pub r15: usize,\n+    pub rip: usize,\n+    pub rflags: usize,\n+    pub fsbase: usize,\n+    pub gsbase: usize,\n+}\n+\n+macro_rules! copy_gp_regs {\n+    ($src: ident, $dst: ident) => {\n+        $dst.rax = $src.rax;\n+        $dst.rbx = $src.rax;\n+        $dst.rcx = $src.rcx;\n+        $dst.rdx = $src.rdx;\n+        $dst.rsi = $src.rsi;\n+        $dst.rdi = $src.rdi;\n+        $dst.rbp = $src.rbp;\n+        $dst.rsp = $src.rsp;\n+        $dst.r8 = $src.r8;\n+        $dst.r9 = $src.r9;\n+        $dst.r10 = $src.r10;\n+        $dst.r11 = $src.r11;\n+        $dst.r12 = $src.r12;\n+        $dst.r13 = $src.r13;\n+        $dst.r14 = $src.r14;\n+        $dst.r15 = $src.r15;\n+        $dst.rip = $src.rip;\n+        $dst.rflags = $src.rflags;\n+        $dst.fsbase = $src.fsbase;\n+        $dst.gsbase = $src.gsbase;\n+    };\n+}\n+\n+impl GpRegs {\n+    pub fn copy_to_raw(&self, dst: &mut RawGeneralRegs) {\n+        copy_gp_regs!(self, dst);\n+    }\n+\n+    pub fn copy_from_raw(&mut self, src: &RawGeneralRegs) {\n+        copy_gp_regs!(src, self);\n+    }\n+}\ndiff --git a/kernel/aster-nix/src/fs/exfat/super_block.rs b/kernel/aster-nix/src/fs/exfat/super_block.rs\n--- a/kernel/aster-nix/src/fs/exfat/super_block.rs\n+++ b/kernel/aster-nix/src/fs/exfat/super_block.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use pod::Pod;\n+use ostd::Pod;\n \n use super::constants::{EXFAT_FIRST_CLUSTER, EXFAT_RESERVED_CLUSTERS, MEDIA_FAILURE, VOLUME_DIRTY};\n use crate::prelude::*;\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -19,8 +19,8 @@ pub(crate) use log::{debug, error, info, log_enabled, trace, warn};\n pub(crate) use ostd::{\n     mm::{Vaddr, VmReader, VmWriter, PAGE_SIZE},\n     sync::{Mutex, MutexGuard, RwLock, RwMutex, SpinLock, SpinLockGuard},\n+    Pod,\n };\n-pub(crate) use pod::Pod;\n \n /// return current process\n #[macro_export]\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/aster-nix/src/process/signal/c_types.rs\n--- a/kernel/aster-nix/src/process/signal/c_types.rs\n+++ b/kernel/aster-nix/src/process/signal/c_types.rs\n@@ -6,10 +6,10 @@\n use core::mem::{self, size_of};\n \n use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n-use ostd::cpu::GeneralRegs;\n \n use super::sig_num::SigNum;\n use crate::{\n+    arch::cpu::GpRegs,\n     prelude::*,\n     process::{Pid, Uid},\n };\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/aster-nix/src/process/signal/c_types.rs\n--- a/kernel/aster-nix/src/process/signal/c_types.rs\n+++ b/kernel/aster-nix/src/process/signal/c_types.rs\n@@ -206,7 +206,7 @@ pub struct mcontext_t {\n #[derive(Debug, Clone, Copy, Pod, Default)]\n #[repr(C)]\n pub struct SignalCpuContext {\n-    pub gp_regs: GeneralRegs,\n+    pub gp_regs: GpRegs,\n     pub fpregs_on_heap: u64,\n     pub fpregs: Vaddr, // *mut FpRegs,\n }\ndiff --git a/kernel/aster-nix/src/process/signal/mod.rs b/kernel/aster-nix/src/process/signal/mod.rs\n--- a/kernel/aster-nix/src/process/signal/mod.rs\n+++ b/kernel/aster-nix/src/process/signal/mod.rs\n@@ -166,7 +166,11 @@ pub fn handle_user_signal(\n         uc_sigmask: mask.as_u64(),\n         ..Default::default()\n     };\n-    ucontext.uc_mcontext.inner.gp_regs = *context.general_regs();\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_from_raw(context.general_regs());\n     let mut sig_context = posix_thread.sig_context().lock();\n     if let Some(sig_context_addr) = *sig_context {\n         ucontext.uc_link = sig_context_addr;\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigreturn.rs b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n--- a/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n+++ b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n@@ -38,7 +38,11 @@ pub fn sys_rt_sigreturn(context: &mut UserContext) -> Result<SyscallReturn> {\n     } else {\n         *sig_context = Some(ucontext.uc_link);\n     };\n-    *context.general_regs_mut() = ucontext.uc_mcontext.inner.gp_regs;\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_to_raw(context.general_regs_mut());\n     // unblock sig mask\n     let sig_mask = ucontext.uc_sigmask;\n     posix_thread.sig_mask().lock().unblock(sig_mask);\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/aster-nix/src/vdso.rs\n--- a/kernel/aster-nix/src/vdso.rs\n+++ b/kernel/aster-nix/src/vdso.rs\n@@ -23,8 +23,8 @@ use aster_util::coeff::Coeff;\n use ostd::{\n     mm::{Frame, VmIo, PAGE_SIZE},\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::{\ndiff --git a/kernel/comps/block/Cargo.toml b/kernel/comps/block/Cargo.toml\n--- a/kernel/comps/block/Cargo.toml\n+++ b/kernel/comps/block/Cargo.toml\n@@ -8,7 +8,6 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ostd = { path = \"../../../ostd\" }\n align_ext = { path = \"../../../ostd/libs/align_ext\" }\n aster-util = { path = \"../../libs/aster-util\" }\ndiff --git a/kernel/comps/block/src/id.rs b/kernel/comps/block/src/id.rs\n--- a/kernel/comps/block/src/id.rs\n+++ b/kernel/comps/block/src/id.rs\n@@ -5,7 +5,7 @@ use core::{\n     ops::{Add, Sub},\n };\n \n-use pod::Pod;\n+use ostd::Pod;\n use static_assertions::const_assert;\n \n /// The block index used in the filesystem.\ndiff --git a/kernel/comps/network/Cargo.toml b/kernel/comps/network/Cargo.toml\n--- a/kernel/comps/network/Cargo.toml\n+++ b/kernel/comps/network/Cargo.toml\n@@ -15,7 +15,6 @@ component = { path = \"../../libs/comp-sys/component\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n log = \"0.4\"\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n smoltcp = { version = \"0.9.1\", default-features = false, features = [\"alloc\", \"log\", \"medium-ethernet\", \"medium-ip\", \"proto-dhcpv4\", \"proto-ipv4\", \"proto-igmp\", \"socket-icmp\", \"socket-udp\", \"socket-tcp\", \"socket-raw\", \"socket-dhcpv4\"] }\n spin = \"0.9.4\"\ndiff --git a/kernel/comps/network/src/buffer.rs b/kernel/comps/network/src/buffer.rs\n--- a/kernel/comps/network/src/buffer.rs\n+++ b/kernel/comps/network/src/buffer.rs\n@@ -8,8 +8,8 @@ use ostd::{\n         Daddr, DmaDirection, DmaStream, FrameAllocOptions, HasDaddr, VmReader, VmWriter, PAGE_SIZE,\n     },\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::dma_pool::{DmaPool, DmaSegment};\ndiff --git a/kernel/comps/network/src/lib.rs b/kernel/comps/network/src/lib.rs\n--- a/kernel/comps/network/src/lib.rs\n+++ b/kernel/comps/network/src/lib.rs\n@@ -15,11 +15,10 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, string::String, sync::Arc, vec::Vec};\n use core::{any::Any, fmt::Debug};\n \n-use aster_util::safe_ptr::Pod;\n pub use buffer::{RxBuffer, TxBuffer, RX_BUFFER_POOL, TX_BUFFER_POOL};\n use component::{init_component, ComponentInitError};\n pub use dma_pool::DmaSegment;\n-use ostd::sync::SpinLock;\n+use ostd::{sync::SpinLock, Pod};\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/kernel/comps/virtio/Cargo.toml b/kernel/comps/virtio/Cargo.toml\n--- a/kernel/comps/virtio/Cargo.toml\n+++ b/kernel/comps/virtio/Cargo.toml\n@@ -19,7 +19,6 @@ aster-rights = { path = \"../../libs/aster-rights\" }\n id-alloc = { path = \"../../../ostd/libs/id-alloc\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/kernel/comps/virtio/src/device/block/device.rs b/kernel/comps/virtio/src/device/block/device.rs\n--- a/kernel/comps/virtio/src/device/block/device.rs\n+++ b/kernel/comps/virtio/src/device/block/device.rs\n@@ -15,8 +15,8 @@ use ostd::{\n     mm::{DmaDirection, DmaStream, DmaStreamSlice, FrameAllocOptions, VmIo},\n     sync::SpinLock,\n     trap::TrapFrame,\n+    Pod,\n };\n-use pod::Pod;\n \n use super::{BlockFeatures, VirtioBlockConfig};\n use crate::{\ndiff --git a/kernel/comps/virtio/src/device/block/mod.rs b/kernel/comps/virtio/src/device/block/mod.rs\n--- a/kernel/comps/virtio/src/device/block/mod.rs\n+++ b/kernel/comps/virtio/src/device/block/mod.rs\n@@ -5,8 +5,7 @@ pub mod device;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/console/config.rs b/kernel/comps/virtio/src/device/console/config.rs\n--- a/kernel/comps/virtio/src/device/console/config.rs\n+++ b/kernel/comps/virtio/src/device/console/config.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/input/mod.rs b/kernel/comps/virtio/src/device/input/mod.rs\n--- a/kernel/comps/virtio/src/device/input/mod.rs\n+++ b/kernel/comps/virtio/src/device/input/mod.rs\n@@ -28,8 +28,7 @@\n \n pub mod device;\n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/config.rs b/kernel/comps/virtio/src/device/network/config.rs\n--- a/kernel/comps/virtio/src/device/network/config.rs\n+++ b/kernel/comps/virtio/src/device/network/config.rs\n@@ -3,8 +3,7 @@\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/header.rs b/kernel/comps/virtio/src/device/network/header.rs\n--- a/kernel/comps/virtio/src/device/network/header.rs\n+++ b/kernel/comps/virtio/src/device/network/header.rs\n@@ -2,7 +2,7 @@\n \n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n pub const VIRTIO_NET_HDR_LEN: usize = core::mem::size_of::<VirtioNetHdr>();\n \ndiff --git a/kernel/comps/virtio/src/device/socket/config.rs b/kernel/comps/virtio/src/device/socket/config.rs\n--- a/kernel/comps/virtio/src/device/socket/config.rs\n+++ b/kernel/comps/virtio/src/device/socket/config.rs\n@@ -2,8 +2,7 @@\n \n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/socket/device.rs b/kernel/comps/virtio/src/device/socket/device.rs\n--- a/kernel/comps/virtio/src/device/socket/device.rs\n+++ b/kernel/comps/virtio/src/device/socket/device.rs\n@@ -6,8 +6,7 @@ use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n use aster_network::{RxBuffer, TxBuffer};\n use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n-use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame};\n-use pod::Pod;\n+use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame, Pod};\n \n use super::{\n     config::{VirtioVsockConfig, VsockFeatures},\ndiff --git a/kernel/comps/virtio/src/device/socket/header.rs b/kernel/comps/virtio/src/device/socket/header.rs\n--- a/kernel/comps/virtio/src/device/socket/header.rs\n+++ b/kernel/comps/virtio/src/device/socket/header.rs\n@@ -27,7 +27,7 @@\n //\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n use super::error::{self, SocketError};\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -15,9 +15,8 @@ use log::debug;\n use ostd::{\n     io_mem::IoMem,\n     mm::{DmaCoherent, FrameAllocOptions},\n-    offset_of,\n+    offset_of, Pod,\n };\n-use pod::Pod;\n \n use crate::{dma_buf::DmaBuf, transport::VirtioTransport};\n \ndiff --git a/kernel/comps/virtio/src/transport/mmio/layout.rs b/kernel/comps/virtio/src/transport/mmio/layout.rs\n--- a/kernel/comps/virtio/src/transport/mmio/layout.rs\n+++ b/kernel/comps/virtio/src/transport/mmio/layout.rs\n@@ -2,7 +2,7 @@\n \n use core::fmt::Debug;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n #[derive(Clone, Copy, Pod)]\n #[repr(C)]\ndiff --git a/kernel/comps/virtio/src/transport/pci/common_cfg.rs b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use super::capability::VirtioPciCapabilityData;\n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/kernel/libs/aster-util/Cargo.toml b/kernel/libs/aster-util/Cargo.toml\n--- a/kernel/libs/aster-util/Cargo.toml\n+++ b/kernel/libs/aster-util/Cargo.toml\n@@ -7,7 +7,6 @@ edition = \"2021\"\n \n [dependencies]\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n typeflags-util = { path = \"../typeflags-util\" }\n aster-rights-proc = { path = \"../aster-rights-proc\" }\n aster-rights = { path = \"../aster-rights\" }\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -5,11 +5,11 @@ use core::{fmt::Debug, marker::PhantomData};\n use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n use aster_rights_proc::require;\n use inherit_methods_macro::inherit_methods;\n+pub use ostd::Pod;\n use ostd::{\n     mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, VmIo},\n     Result,\n };\n-pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \n /// Safe pointers.\ndiff --git a/kernel/libs/aster-util/src/union_read_ptr.rs b/kernel/libs/aster-util/src/union_read_ptr.rs\n--- a/kernel/libs/aster-util/src/union_read_ptr.rs\n+++ b/kernel/libs/aster-util/src/union_read_ptr.rs\n@@ -2,7 +2,7 @@\n \n use core::marker::PhantomData;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n /// This ptr is designed to read union field safely.\n /// Write to union field is safe operation. While reading union field is UB.\ndiff --git a/kernel/libs/int-to-c-enum/Cargo.toml b/kernel/libs/int-to-c-enum/Cargo.toml\n--- a/kernel/libs/int-to-c-enum/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/Cargo.toml\n@@ -2,11 +2,15 @@\n name = \"int-to-c-enum\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+readme = \"README.md\"\n+description = \"TryFromInt - A convenient derive macro for converting an integer to an enum\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-int-to-c-enum-derive = { path = \"derive\", optional = true }\n+int-to-c-enum-derive = { path = \"derive\", optional = true, version = \"0.1.0\"}\n \n [features]\n default = [\"derive\"]\ndiff --git a/kernel/libs/int-to-c-enum/derive/Cargo.toml b/kernel/libs/int-to-c-enum/derive/Cargo.toml\n--- a/kernel/libs/int-to-c-enum/derive/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/derive/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"int-to-c-enum-derive\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"int-to-c-enum's proc macros\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -157,10 +157,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    // FIXME: Uses a fixed tag instaed of relies on remote branch\n-    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n-    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // Remember to upgrade this version if new version of linux-bzimage-setup is released.\n+    const LINUX_BZIMAGE_SETUP_VERSION: &str = \"0.1.0\";\n+    cmd.arg(\"--version\").arg(LINUX_BZIMAGE_SETUP_VERSION);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\ndiff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -7,7 +7,7 @@ use crate::{\n     config::manifest::ProjectType,\n     error::Errno,\n     error_msg,\n-    util::{aster_crate_dep, cargo_new_lib, get_cargo_metadata},\n+    util::{cargo_new_lib, get_cargo_metadata, ostd_dep},\n };\n \n pub fn execute_new_command(args: &NewArgs) {\ndiff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -40,7 +40,7 @@ fn add_manifest_dependencies(cargo_metadata: &serde_json::Value, crate_name: &st\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let ostd_dep = toml::Table::from_str(&aster_crate_dep(\"ostd\")).unwrap();\n+    let ostd_dep = toml::Table::from_str(&ostd_dep()).unwrap();\n     dependencies.as_table_mut().unwrap().extend(ostd_dep);\n \n     let content = toml::to_string(&manifest).unwrap();\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -12,18 +12,12 @@ use crate::{error::Errno, error_msg};\n \n use quote::ToTokens;\n \n-/// FIXME: We should publish the asterinas crates to a public registry\n-/// and use the published version in the generated Cargo.toml.\n-pub const ASTER_GIT_LINK: &str = \"https://github.com/asterinas/asterinas\";\n-/// Make sure it syncs with the builder dependency in Cargo.toml.\n-/// We cannot use `include_str!(\"../../VERSION\")` here\n-/// because `cargo publish` does not allow using files outside of the crate directory.\n-pub const ASTER_GIT_TAG: &str = concat!(\"v\", env!(\"CARGO_PKG_VERSION\"));\n-pub fn aster_crate_dep(crate_name: &str) -> String {\n-    format!(\n-        \"{} = {{ git = \\\"{}\\\", tag = \\\"{}\\\" }}\",\n-        crate_name, ASTER_GIT_LINK, ASTER_GIT_TAG\n-    )\n+/// The version of OSTD on crates.io.\n+///\n+/// OSTD shares the same version with OSDK, so just use the version of OSDK here.\n+pub const OSTD_VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n+pub fn ostd_dep() -> String {\n+    format!(\"ostd = {{ version = \\\"{}\\\" }}\", OSTD_VERSION)\n }\n \n fn cargo() -> Command {\ndiff --git a/ostd/libs/id-alloc/Cargo.toml b/ostd/libs/id-alloc/Cargo.toml\n--- a/ostd/libs/id-alloc/Cargo.toml\n+++ b/ostd/libs/id-alloc/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"id-alloc\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"An id allocator implemented by the bitmap\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/boot-params/Cargo.toml b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n--- a/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-boot-params\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The Boot Parameters for Linux Boot Protocol\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-bzimage-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The linux bzImage setup binary\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n [[bin]]\n name = \"linux-bzimage-setup\"\ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -11,7 +14,7 @@ path = \"src/main.rs\"\n \n [dependencies]\n cfg-if = \"1.0.0\"\n-linux-boot-params = { path = \"../boot-params\" }\n+linux-boot-params = { path = \"../boot-params\", version = \"0.1.0\" }\n uart_16550 = \"0.3.0\"\n xmas-elf = \"0.8.0\"\n \ndiff --git a/ostd/libs/ostd-macros/Cargo.toml b/ostd/libs/ostd-macros/Cargo.toml\n--- a/ostd/libs/ostd-macros/Cargo.toml\n+++ b/ostd/libs/ostd-macros/Cargo.toml\n@@ -1,7 +1,10 @@\n [package]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n edition = \"2021\"\n+description = \"OSTD's proc macros\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -11,7 +11,9 @@ use syn::{parse_macro_input, Expr, Ident, ItemFn};\n ///\n /// # Example\n ///\n-/// ```norun\n+/// ```ignore\n+/// #![no_std]\n+///\n /// use ostd::prelude::*;\n ///\n /// #[ostd::main]\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -16,7 +16,8 @@ use bitvec::{\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\n use tdx_guest::tdcall;\n-use trapframe::{GeneralRegs, UserContext as RawUserContext};\n+pub use trapframe::GeneralRegs as RawGeneralRegs;\n+use trapframe::UserContext as RawUserContext;\n use x86_64::registers::{\n     rflags::RFlags,\n     segmentation::{Segment64, FS},\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -131,7 +132,7 @@ pub struct CpuExceptionInfo {\n }\n \n #[cfg(feature = \"intel_tdx\")]\n-impl TdxTrapFrame for GeneralRegs {\n+impl TdxTrapFrame for RawGeneralRegs {\n     fn rax(&self) -> usize {\n         self.rax\n     }\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -258,12 +259,12 @@ impl UserPreemption {\n \n impl UserContext {\n     /// Returns a reference to the general registers.\n-    pub fn general_regs(&self) -> &GeneralRegs {\n+    pub fn general_regs(&self) -> &RawGeneralRegs {\n         &self.user_context.general\n     }\n \n     /// Returns a mutable reference to the general registers\n-    pub fn general_regs_mut(&mut self) -> &mut GeneralRegs {\n+    pub fn general_regs_mut(&mut self) -> &mut RawGeneralRegs {\n         &mut self.user_context.general\n     }\n \ndiff --git a/ostd/src/arch/x86/iommu/context_table.rs b/ostd/src/arch/x86/iommu/context_table.rs\n--- a/ostd/src/arch/x86/iommu/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/context_table.rs\n@@ -6,7 +6,6 @@ use alloc::collections::BTreeMap;\n use core::mem::size_of;\n \n use log::warn;\n-use pod::Pod;\n \n use super::second_stage::{DeviceMode, PageTableEntry, PagingConsts};\n use crate::{\ndiff --git a/ostd/src/arch/x86/iommu/context_table.rs b/ostd/src/arch/x86/iommu/context_table.rs\n--- a/ostd/src/arch/x86/iommu/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/context_table.rs\n@@ -17,6 +16,7 @@ use crate::{\n         page_table::PageTableError,\n         Frame, FrameAllocOptions, Paddr, PageFlags, PageTable, VmIo, PAGE_SIZE,\n     },\n+    Pod,\n };\n \n /// Bit 0 is `Present` bit, indicating whether this entry is present.\ndiff --git a/ostd/src/arch/x86/iommu/second_stage.rs b/ostd/src/arch/x86/iommu/second_stage.rs\n--- a/ostd/src/arch/x86/iommu/second_stage.rs\n+++ b/ostd/src/arch/x86/iommu/second_stage.rs\n@@ -4,12 +4,13 @@\n \n use core::ops::Range;\n \n-use pod::Pod;\n-\n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n-    page_table::{PageTableEntryTrait, PageTableMode},\n-    Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n+        page_table::{PageTableEntryTrait, PageTableMode},\n+        Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+    },\n+    Pod,\n };\n \n /// The page table used by iommu maps the device address\ndiff --git a/ostd/src/arch/x86/mm/mod.rs b/ostd/src/arch/x86/mm/mod.rs\n--- a/ostd/src/arch/x86/mm/mod.rs\n+++ b/ostd/src/arch/x86/mm/mod.rs\n@@ -5,14 +5,16 @@\n use alloc::fmt;\n use core::ops::Range;\n \n-use pod::Pod;\n pub(crate) use util::__memcpy_fallible;\n use x86_64::{instructions::tlb, structures::paging::PhysFrame, VirtAddr};\n \n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n-    page_table::PageTableEntryTrait,\n-    Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n+        page_table::PageTableEntryTrait,\n+        Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+    },\n+    Pod,\n };\n \n mod util;\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -6,7 +6,6 @@ pub mod cpu_local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\n-        pub use trapframe::GeneralRegs;\n         pub use crate::arch::x86::cpu::*;\n     }\n }\ndiff --git a/ostd/src/io_mem.rs b/ostd/src/io_mem.rs\n--- a/ostd/src/io_mem.rs\n+++ b/ostd/src/io_mem.rs\n@@ -4,11 +4,9 @@\n \n use core::{mem::size_of, ops::Range};\n \n-use pod::Pod;\n-\n use crate::{\n     mm::{kspace::LINEAR_MAPPING_BASE_VADDR, paddr_to_vaddr, HasPaddr, Paddr, Vaddr, VmIo},\n-    Error, Result,\n+    Error, Pod, Result,\n };\n \n /// I/O memory.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -44,6 +44,7 @@ pub mod trap;\n pub mod user;\n \n pub use ostd_macros::main;\n+pub use ostd_pod::Pod;\n \n pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n \ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -6,7 +6,6 @@ use core::marker::PhantomData;\n \n use align_ext::AlignExt;\n use inherit_methods_macro::inherit_methods;\n-use pod::Pod;\n \n use crate::{\n     arch::mm::__memcpy_fallible,\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -15,7 +14,7 @@ use crate::{\n         MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    Error,\n+    Error, Pod,\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -2,14 +2,15 @@\n \n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n-use pod::Pod;\n-\n use super::{\n     nr_subpage_per_huge, paddr_to_vaddr,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    Pod,\n+};\n \n mod node;\n use node::*;\n",
        "test_patch": "",
        "problem_statement": "Tracking issue for publishing OSTD to crates.io\n# Description\r\n\r\nThis issue tracks the issue of publishing OSTD to `crates.io`\r\n\r\n- [x] Publishing all dependent crates of OSTD to `crates.io`\r\n  - [x] align_ext ([v0.1.0](https://crates.io/crates/align_ext))\r\n  - [x] ostd-macros([v0.1.1](https://crates.io/crates/ostd-macros))\r\n  - [x] linux-boot-params([v0.1.0](https://crates.io/crates/linux-boot-params))\r\n  - [x] inherit-methods-macro([v0.1.0](https://crates.io/crates/inherit-methods-macro))\r\n  - [x] xarray([v0.1.0](https://crates.io/crates/xarray))\r\n  - [x] int-to-c-enum([v0.1.0](https://crates.io/crates/int-to-c-enum))\r\n  - [x] ktest(renamed as `ostd-test`, [v0.1.0](https://crates.io/crates/ostd-test))\r\n  - [x] id-alloc([v0.1.0](https://crates.io/crates/id-alloc))\r\n  - [x] pod(renamed as `pod-rs`, [v0.1.1](https://crates.io/crates/pod-rs))\r\n  - [x] trapframe([v0.9.0](https://crates.io/crates/trapframe) works, just without our patch to speed)\r\n  - [x] unwinding([v0.2.2](https://crates.io/crates/unwinding) works)\r\n- [x] Publish OSTD itself to `crate.io`\r\n- [x] Publish API documentation of OSTD to `docs.rs`\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2024-07-03T08:57:04Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 928,
        "instance_id": "asterinas__asterinas-928",
        "issue_numbers": [
            "906"
        ],
        "base_commit": "e210e68920481c911f62f03ade0a780f96e48e24",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -161,13 +161,6 @@ impl PageTableEntryTrait for PageTableEntry {\n         let flags = PageTableFlags::PRESENT.bits()\n             | PageTableFlags::WRITABLE.bits()\n             | PageTableFlags::USER.bits();\n-        #[cfg(feature = \"intel_tdx\")]\n-        let flags = flags\n-            | parse_flags!(\n-                prop.priv_flags.bits(),\n-                PrivFlags::SHARED,\n-                PageTableFlags::SHARED\n-            );\n         Self(paddr & Self::PHYS_ADDR_MASK | flags)\n     }\n \ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -11,15 +11,12 @@ use tdx_guest::{\n };\n use trapframe::TrapFrame;\n \n-use crate::{\n-    arch::mm::PageTableFlags,\n-    mm::{\n-        kspace::KERNEL_PAGE_TABLE,\n-        paddr_to_vaddr,\n-        page_prop::{CachePolicy, PageProperty, PrivilegedPageFlags as PrivFlags},\n-        page_table::PageTableError,\n-        KERNEL_BASE_VADDR, KERNEL_END_VADDR, PAGE_SIZE,\n-    },\n+use crate::mm::{\n+    kspace::{BOOT_PAGE_TABLE, KERNEL_BASE_VADDR, KERNEL_END_VADDR, KERNEL_PAGE_TABLE},\n+    paddr_to_vaddr,\n+    page_prop::{PageProperty, PrivilegedPageFlags as PrivFlags},\n+    page_table::PageTableError,\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -416,16 +413,28 @@ pub unsafe fn unprotect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Pa\n     if gpa & PAGE_MASK != 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags | PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa(\n         (gpa & (!PAGE_MASK)) as u64 | SHARED_MASK,\n         (page_num * PAGE_SIZE) as u64,\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -452,16 +461,28 @@ pub unsafe fn protect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Page\n     if gpa & !PAGE_MASK == 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags - PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa((gpa & PAGE_MASK) as u64, (page_num * PAGE_SIZE) as u64)\n         .map_err(PageConvertError::TdVmcallError)?;\n     for i in 0..page_num {\ndiff --git a/framework/aster-frame/src/arch/x86/trap.rs b/framework/aster-frame/src/arch/x86/trap.rs\n--- a/framework/aster-frame/src/arch/x86/trap.rs\n+++ b/framework/aster-frame/src/arch/x86/trap.rs\n@@ -11,11 +11,7 @@ use tdx_guest::tdcall;\n use trapframe::TrapFrame;\n \n #[cfg(feature = \"intel_tdx\")]\n-use crate::arch::{\n-    cpu::VIRTUALIZATION_EXCEPTION,\n-    mm::PageTableFlags,\n-    tdx_guest::{handle_virtual_exception, TdxTrapFrame},\n-};\n+use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, PageFaultErrorCode, PAGE_FAULT},\n     cpu_local,\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -76,15 +76,15 @@ pub fn init() {\n     boot::init();\n \n     mm::page::allocator::init();\n-    let mut boot_pt = mm::get_boot_pt();\n-    let meta_pages = mm::init_page_meta(&mut boot_pt);\n+    mm::kspace::init_boot_page_table();\n+    mm::kspace::init_kernel_page_table(mm::init_page_meta());\n     mm::misc_init();\n \n     trap::init();\n     arch::after_all_init();\n     bus::init();\n \n-    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\n+    mm::kspace::activate_kernel_page_table();\n \n     invoke_ffi_init_funcs();\n }\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -7,24 +7,27 @@\n //! The kernel memory space is currently managed as follows, if the\n //! address width is 48 bits (with 47 bits kernel space).\n //!\n+//! TODO: the cap of linear mapping (the start of vm alloc) are raised\n+//! to workaround for high IO in TDX. We need actual vm alloc API to have\n+//! a proper fix.\n+//!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n //! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n-//! +-+ <- 0xffff_e100_0000_0000\n-//! | |         For frame metadata, 1 TiB. Mapped frames are untracked.\n-//! +-+ <- 0xffff_e000_0000_0000\n-//! | |\n-//! | |         For vm alloc/io mappings, 32 TiB.\n+//! +-+ <- 0xffff_ff00_0000_0000\n+//! | |         For frame metadata, 1 TiB.\n+//! | |         Mapped frames are untracked.\n+//! +-+ <- 0xffff_fe00_0000_0000\n+//! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\n+//! +-+ <- 0xffff_fd00_0000_0000\n //! | |\n-//! +-+ <- the middle of the higher half (0xffff_c000_0000_0000)\n //! | |\n //! | |\n-//! | |\n-//! | |         For linear mappings, 64 TiB.\n+//! | |         For linear mappings.\n //! | |         Mapped physical addresses are untracked.\n //! | |\n //! | |\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -36,7 +39,7 @@\n //! 39 bits or 57 bits, the memory space just adjust porportionally.\n \n use alloc::vec::Vec;\n-use core::ops::Range;\n+use core::{mem::ManuallyDrop, ops::Range};\n \n use align_ext::AlignExt;\n use log::info;\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -76,12 +82,12 @@ pub fn kernel_loaded_offset() -> usize {\n \n const KERNEL_CODE_BASE_VADDR: usize = 0xffff_ffff_8000_0000 << ADDR_WIDTH_SHIFT;\n \n-const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_e100_0000_0000 << ADDR_WIDTH_SHIFT;\n-const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_e000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_ff00_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_fe00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub(in crate::mm) const FRAME_METADATA_RANGE: Range<Vaddr> =\n     FRAME_METADATA_BASE_VADDR..FRAME_METADATA_CAP_VADDR;\n \n-const VMALLOC_BASE_VADDR: Vaddr = 0xffff_c000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const VMALLOC_BASE_VADDR: Vaddr = 0xffff_fd00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub const VMALLOC_VADDR_RANGE: Range<Vaddr> = VMALLOC_BASE_VADDR..FRAME_METADATA_BASE_VADDR;\n \n /// The base address of the linear mapping of all physical\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -95,9 +101,25 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// The boot page table instance.\n+///\n+/// It is used in the initialization phase before [`KERNEL_PAGE_TABLE`] is activated.\n+/// Since we want dropping the boot page table unsafe, it is wrapped in a [`ManuallyDrop`].\n+pub static BOOT_PAGE_TABLE: SpinLock<Option<ManuallyDrop<BootPageTable>>> = SpinLock::new(None);\n+\n+/// The kernel page table instance.\n+///\n+/// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\n+/// is unlikely to be activated.\n pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingConsts>> =\n     Once::new();\n \n+/// Initializes the boot page table.\n+pub(crate) fn init_boot_page_table() {\n+    let boot_pt = BootPageTable::from_current_pt();\n+    *BOOT_PAGE_TABLE.lock() = Some(ManuallyDrop::new(boot_pt));\n+}\n+\n /// Initializes the kernel page table.\n ///\n /// This function should be called after:\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -106,10 +128,7 @@ pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingC\n ///\n /// This function should be called before:\n ///  - any initializer that modifies the kernel page table.\n-pub fn init_kernel_page_table(\n-    boot_pt: BootPageTable<PageTableEntry, PagingConsts>,\n-    meta_pages: Vec<Range<Paddr>>,\n-) {\n+pub fn init_kernel_page_table(meta_pages: Vec<Range<Paddr>>) {\n     info!(\"Initializing the kernel page table\");\n \n     let regions = crate::boot::memory_regions();\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -201,15 +220,21 @@ pub fn init_kernel_page_table(\n         }\n     }\n \n+    KERNEL_PAGE_TABLE.call_once(|| kpt);\n+}\n+\n+pub fn activate_kernel_page_table() {\n+    let kpt = KERNEL_PAGE_TABLE\n+        .get()\n+        .expect(\"The kernel page table is not initialized yet\");\n     // SAFETY: the kernel page table is initialized properly.\n     unsafe {\n         kpt.first_activate_unchecked();\n         crate::arch::mm::tlb_flush_all_including_global();\n     }\n \n-    KERNEL_PAGE_TABLE.call_once(|| kpt);\n-\n-    // SAFETY: the boot page table is OK to be retired now since\n+    // SAFETY: the boot page table is OK to be dropped now since\n     // the kernel page table is activated.\n-    unsafe { boot_pt.retire() };\n+    let mut boot_pt = BOOT_PAGE_TABLE.lock().take().unwrap();\n+    unsafe { ManuallyDrop::drop(&mut boot_pt) };\n }\ndiff --git a/framework/aster-frame/src/mm/mod.rs b/framework/aster-frame/src/mm/mod.rs\n--- a/framework/aster-frame/src/mm/mod.rs\n+++ b/framework/aster-frame/src/mm/mod.rs\n@@ -131,7 +131,3 @@ pub(crate) fn misc_init() {\n     }\n     FRAMEBUFFER_REGIONS.call_once(|| framebuffer_regions);\n }\n-\n-pub(crate) fn get_boot_pt() -> page_table::boot_pt::BootPageTable {\n-    unsafe { page_table::boot_pt::BootPageTable::from_current_pt() }\n-}\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -53,12 +53,9 @@ use super::Page;\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr,\n-        page::allocator::FRAME_ALLOCATOR,\n-        page_size,\n-        page_table::{boot_pt::BootPageTable, PageTableEntryTrait},\n-        CachePolicy, Paddr, PageFlags, PageProperty, PagingConstsTrait, PagingLevel,\n-        PrivilegedPageFlags, PAGE_SIZE,\n+        kspace::BOOT_PAGE_TABLE, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, page_size,\n+        page_table::PageTableEntryTrait, CachePolicy, Paddr, PageFlags, PageProperty,\n+        PagingConstsTrait, PagingLevel, PrivilegedPageFlags, PAGE_SIZE,\n     },\n };\n \ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -191,7 +188,7 @@ impl PageMeta for KernelMeta {\n /// Initializes the metadata of all physical pages.\n ///\n /// The function returns a list of `Page`s containing the metadata.\n-pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n+pub(crate) fn init() -> Vec<Range<Paddr>> {\n     let max_paddr = {\n         let regions = crate::boot::memory_regions();\n         regions.iter().map(|r| r.base() + r.len()).max().unwrap()\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -207,8 +204,11 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n     let num_pages = max_paddr / page_size::<PagingConsts>(1);\n     let num_meta_pages = (num_pages * size_of::<MetaSlot>()).div_ceil(PAGE_SIZE);\n     let meta_pages = alloc_meta_pages(num_meta_pages);\n-\n     // Map the metadata pages.\n+    let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+    let boot_pt = boot_pt_lock\n+        .as_mut()\n+        .expect(\"boot page table not initialized\");\n     for (i, frame_paddr) in meta_pages.iter().enumerate() {\n         let vaddr = mapping::page_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n         let prop = PageProperty {\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -216,9 +216,9 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n             cache: CachePolicy::Writeback,\n             priv_flags: PrivilegedPageFlags::GLOBAL,\n         };\n-        boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop);\n+        // SAFETY: we are doing the metadata mappings for the kernel.\n+        unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n     }\n-\n     // Now the metadata pages are mapped, we can initialize the metadata.\n     meta_pages\n         .into_iter()\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -10,8 +10,8 @@ use super::{pte_index, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty, PagingConstsTrait, Vaddr,\n-        PAGE_SIZE,\n+        nr_subpage_per_huge, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty,\n+        PagingConstsTrait, Vaddr, PAGE_SIZE,\n     },\n };\n \ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -34,10 +34,7 @@ pub struct BootPageTable<\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     /// Creates a new boot page table from the current page table root physical address.\n-    ///\n-    /// The caller must ensure that the current page table may be set up by the firmware,\n-    /// loader or the setup code.\n-    pub unsafe fn from_current_pt() -> Self {\n+    pub fn from_current_pt() -> Self {\n         let root_paddr = crate::arch::mm::current_page_table_paddr();\n         Self {\n             root_pt: root_paddr / C::BASE_PAGE_SIZE,\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -47,8 +44,16 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     }\n \n     /// Maps a base page to a frame.\n+    ///\n+    /// # Panics\n+    ///\n     /// This function will panic if the page is already mapped.\n-    pub fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n         let mut pt = self.root_pt;\n         let mut level = C::NR_LEVELS;\n         // Walk to the last level of the page table.\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -77,6 +82,67 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { pte_ptr.write(E::new_frame(to * C::BASE_PAGE_SIZE, 1, prop)) };\n     }\n \n+    /// Maps a base page to a frame.\n+    ///\n+    /// This function may split a huge page into base pages, causing page allocations\n+    /// if the original mapping is a huge page.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the page is already mapped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn protect_base_page(\n+        &mut self,\n+        virt_addr: Vaddr,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) {\n+        let mut pt = self.root_pt;\n+        let mut level = C::NR_LEVELS;\n+        // Walk to the last level of the page table.\n+        while level > 1 {\n+            let index = pte_index::<C>(virt_addr, level);\n+            let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+            let pte = unsafe { pte_ptr.read() };\n+            pt = if !pte.is_present() {\n+                panic!(\"protecting an unmapped page in the boot page table\");\n+            } else if pte.is_last(level) {\n+                // Split the huge page.\n+                let frame = self.alloc_frame();\n+                let huge_pa = pte.paddr();\n+                for i in 0..nr_subpage_per_huge::<C>() {\n+                    let nxt_ptr =\n+                        unsafe { (paddr_to_vaddr(frame * C::BASE_PAGE_SIZE) as *mut E).add(i) };\n+                    unsafe {\n+                        nxt_ptr.write(E::new_frame(\n+                            huge_pa + i * C::BASE_PAGE_SIZE,\n+                            level - 1,\n+                            pte.prop(),\n+                        ))\n+                    };\n+                }\n+                unsafe { pte_ptr.write(E::new_pt(frame * C::BASE_PAGE_SIZE)) };\n+                frame\n+            } else {\n+                pte.paddr() / C::BASE_PAGE_SIZE\n+            };\n+            level -= 1;\n+        }\n+        // Do protection in the last level page table.\n+        let index = pte_index::<C>(virt_addr, 1);\n+        let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+        let pte = unsafe { pte_ptr.read() };\n+        if !pte.is_present() {\n+            panic!(\"protecting an unmapped page in the boot page table\");\n+        }\n+        let mut prop = pte.prop();\n+        op(&mut prop);\n+        unsafe { pte_ptr.write(E::new_frame(pte.paddr(), 1, prop)) };\n+    }\n+\n     fn alloc_frame(&mut self) -> FrameNumber {\n         let frame = FRAME_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n         self.frames.push(frame);\n",
        "test_patch": "",
        "problem_statement": "[TDX BUG] The TDX SHARED bit can\u2018t be set in the page table during IOAPIC initialization.\nIn `framework/aster-frame/src/arch/x86/tdx_guest.rs`:\r\n```rust\r\n    trap::init();\r\n    arch::after_all_init();\r\n    bus::init();\r\n\r\n    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\r\n```\r\n\r\nThe kernel page table is initialized and activated in the `init_kernel_page_table` function. This step occurs after ioapic is initialized (via `after_all_init` function).\r\n\r\nHowever, we should set the ioapic MMIO space as shared page in TDX env, this process manipulates the page table, but the page table is not yet activated.\r\n\n",
        "hints_text": "",
        "created_at": "2024-06-12T07:29:38Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1159,
        "instance_id": "asterinas__asterinas-1159",
        "issue_numbers": [
            "975"
        ],
        "base_commit": "c2a83427520f8263a8eb2c36edacdba261ad5cae",
        "patch": "diff --git a/.github/workflows/benchmark_asterinas.yml b/.github/workflows/benchmark_asterinas.yml\n--- a/.github/workflows/benchmark_asterinas.yml\n+++ b/.github/workflows/benchmark_asterinas.yml\n@@ -57,7 +57,7 @@ jobs:\n       fail-fast: false\n     timeout-minutes: 60\n     container: \n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\ndiff --git a/.github/workflows/push_git_tag.yml b/.github/workflows/push_git_tag.yml\n--- a/.github/workflows/push_git_tag.yml\n+++ b/.github/workflows/push_git_tag.yml\n@@ -17,4 +17,4 @@ jobs:\n         uses: pxpm/github-tag-action@1.0.1\n         with:\n           repo-token: ${{ secrets.GITHUB_TOKEN }}\n-          tag: v0.7.0\n+          tag: v0.8.0\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -153,6 +153,7 @@ dependencies = [\n  \"ascii\",\n  \"aster-block\",\n  \"aster-console\",\n+ \"aster-framebuffer\",\n  \"aster-input\",\n  \"aster-network\",\n  \"aster-rights\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -166,6 +167,7 @@ dependencies = [\n  \"bytemuck\",\n  \"bytemuck_derive\",\n  \"cfg-if\",\n+ \"component\",\n  \"controlled\",\n  \"core2\",\n  \"cpio-decoder\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -262,19 +264,6 @@ dependencies = [\n  \"typeflags-util\",\n ]\n \n-[[package]]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n-dependencies = [\n- \"aster-framebuffer\",\n- \"aster-nix\",\n- \"aster-time\",\n- \"component\",\n- \"id-alloc\",\n- \"ostd\",\n- \"x86_64 0.14.11\",\n-]\n-\n [[package]]\n name = \"atomic\"\n version = \"0.6.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1129,6 +1124,12 @@ version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n+[[package]]\n+name = \"owo-colors\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f\"\n+\n [[package]]\n name = \"paste\"\n version = \"1.0.14\"\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -8,8 +8,7 @@ console = { name = \"aster-console\" }\n time = { name = \"aster-time\" }\n framebuffer = { name = \"aster-framebuffer\" }\n network = { name = \"aster-network\" }\n-main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.nix.run_first_process]\n+[whitelist.nix.main]\n main = true\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -130,7 +130,10 @@ all: build\n # To uninstall, do `cargo uninstall cargo-osdk`\n .PHONY: install_osdk\n install_osdk:\n-\t@cargo install cargo-osdk --path osdk\n+\t@# The `OSDK_LOCAL_DEV` environment variable is used for local development\n+\t@# without the need to publish the changes of OSDK's self-hosted\n+\t@# dependencies to `crates.io`.\n+\t@OSDK_LOCAL_DEV=1 cargo install cargo-osdk --path osdk\n \n # This will install OSDK if it is not already installed\n # To update OSDK, we need to run `install_osdk` manually\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -52,7 +52,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/README_CN.md b/README_CN.md\n--- a/README_CN.md\n+++ b/README_CN.md\n@@ -49,7 +49,7 @@ git clone https://github.com/asterinas/asterinas\n 2. \u8fd0\u884c\u4e00\u4e2a\u4f5c\u4e3a\u5f00\u53d1\u73af\u5883\u7684Docker\u5bb9\u5668\u3002\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. \u5728\u5bb9\u5668\u5185\uff0c\u8fdb\u5165\u9879\u76ee\u6587\u4ef6\u5939\u6784\u5efa\u5e76\u8fd0\u884c\u661f\u7efd\u3002\ndiff --git a/VERSION b/VERSION\n--- a/VERSION\n+++ b/VERSION\n@@ -1,1 +1,1 @@\n-0.7.0\n\\ No newline at end of file\n+0.8.0\n\\ No newline at end of file\ndiff --git a/docs/src/kernel/README.md b/docs/src/kernel/README.md\n--- a/docs/src/kernel/README.md\n+++ b/docs/src/kernel/README.md\n@@ -44,7 +44,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/docs/src/kernel/intel_tdx.md b/docs/src/kernel/intel_tdx.md\n--- a/docs/src/kernel/intel_tdx.md\n+++ b/docs/src/kernel/intel_tdx.md\n@@ -66,7 +66,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0-tdx\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0-tdx\n ```\n \n 3. Inside the container,\ndiff --git a/docs/src/osdk/reference/manifest.md b/docs/src/osdk/reference/manifest.md\n--- a/docs/src/osdk/reference/manifest.md\n+++ b/docs/src/osdk/reference/manifest.md\n@@ -15,10 +15,10 @@ one is of the workspace\n (in the same directory as the workspace's `Cargo.toml`)\n and one of the crate\n (in the same directory as the crate's `Cargo.toml`).\n-OSDK will first refer to the crate-level manifest, then\n-query the workspace-level manifest for undefined fields.\n-In other words, missing fields of the crate manifest\n-will inherit values from the workspace manifest.\n+OSDK will firstly try to find the crate-level manifest.\n+If the crate-level manifest is found, OSDK uses it only.\n+If the manifest is not found, OSDK will look into the\n+workspace-level manifest.\n \n ## Configurations\n \ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -1,18 +1,82 @@\n [package]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n+name = \"aster-nix\"\n+version = \"0.1.0\"\n edition = \"2021\"\n \n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n [dependencies]\n-id-alloc = { path = \"../ostd/libs/id-alloc\" }\n-ostd = { path = \"../ostd\" }\n-aster-nix = { path = \"aster-nix\" }\n+align_ext = { path = \"../ostd/libs/align_ext\" }\n+aster-input = { path = \"comps/input\" }\n+aster-block = { path = \"comps/block\" }\n+aster-network = { path = \"comps/network\" }\n+aster-console = { path = \"comps/console\" }\n+aster-framebuffer = { path = \"comps/framebuffer\" }\n+aster-time = { path = \"comps/time\" }\n+aster-virtio = { path = \"comps/virtio\" }\n+aster-rights = { path = \"libs/aster-rights\" }\n component = { path = \"libs/comp-sys/component\" }\n+controlled = { path = \"libs/comp-sys/controlled\" }\n+ostd = { path = \"../ostd\" }\n+typeflags = { path = \"libs/typeflags\" }\n+typeflags-util = { path = \"libs/typeflags-util\" }\n+aster-rights-proc = { path = \"libs/aster-rights-proc\" }\n+aster-util = { path = \"libs/aster-util\" }\n+id-alloc = { path = \"../ostd/libs/id-alloc\" }\n+int-to-c-enum = { path = \"libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"libs/cpio-decoder\" }\n+ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n+intrusive-collections = \"0.9.5\"\n+paste = \"1.0\"\n+time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n+smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n+    \"alloc\",\n+    \"log\",\n+    \"medium-ethernet\",\n+    \"medium-ip\",\n+    \"proto-dhcpv4\",\n+    \"proto-ipv4\",\n+    \"proto-igmp\",\n+    \"socket-icmp\",\n+    \"socket-udp\",\n+    \"socket-tcp\",\n+    \"socket-raw\",\n+    \"socket-dhcpv4\",\n+] }\n+tdx-guest = { version = \"0.1.7\", optional = true }\n \n-[dev-dependencies]\n-x86_64 = \"0.14.2\"\n-aster-time = { path = \"comps/time\" }\n-aster-framebuffer = { path = \"comps/framebuffer\" }\n+# parse elf file\n+xmas-elf = \"0.8.0\"\n+# data-structures\n+bitflags = \"1.3\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"libs/keyable-arc\" }\n+# unzip initramfs\n+libflate = { version = \"2\", default-features = false }\n+core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n+lending-iterator = \"0.1.7\"\n+spin = \"0.9.4\"\n+vte = \"0.10\"\n+lru = \"0.12.3\"\n+log = \"0.4\"\n+bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n+hashbrown = \"0.14\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\n+    \"small_rng\",\n+    \"std_rng\",\n+] }\n+static_assertions = \"1.1.0\"\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n+getset = \"0.1.2\"\n+atomic = \"0.6\"\n+bytemuck = \"1.14.3\"\n+bytemuck_derive = \"1.5.0\"\n+takeable = \"0.2.2\"\n+cfg-if = \"1.0\"\n+\n+[dependencies.lazy_static]\n+version = \"1.0\"\n+features = [\"spin_no_std\"]\n \n [features]\n-cvm_guest = [\"ostd/cvm_guest\", \"aster-nix/cvm_guest\"]\n+cvm_guest = [\"dep:tdx-guest\", \"ostd/cvm_guest\"]\ndiff --git a/kernel/aster-nix/Cargo.toml /dev/null\n--- a/kernel/aster-nix/Cargo.toml\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-[package]\n-name = \"aster-nix\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-align_ext = { path = \"../../ostd/libs/align_ext\" }\n-aster-input = { path = \"../comps/input\" }\n-aster-block = { path = \"../comps/block\" }\n-aster-network = { path = \"../comps/network\" }\n-aster-console = { path = \"../comps/console\" }\n-aster-time = { path = \"../comps/time\" }\n-aster-virtio = { path = \"../comps/virtio\" }\n-aster-rights = { path = \"../libs/aster-rights\" }\n-controlled = { path = \"../libs/comp-sys/controlled\" }\n-ostd = { path = \"../../ostd\" }\n-typeflags = { path = \"../libs/typeflags\" }\n-typeflags-util = { path = \"../libs/typeflags-util\" }\n-aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n-aster-util = { path = \"../libs/aster-util\" }\n-id-alloc = { path = \"../../ostd/libs/id-alloc\" }\n-int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../libs/cpio-decoder\" }\n-ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n-intrusive-collections = \"0.9.5\"\n-paste = \"1.0\"\n-time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n-smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n-    \"alloc\",\n-    \"log\",\n-    \"medium-ethernet\",\n-    \"medium-ip\",\n-    \"proto-dhcpv4\",\n-    \"proto-ipv4\",\n-    \"proto-igmp\",\n-    \"socket-icmp\",\n-    \"socket-udp\",\n-    \"socket-tcp\",\n-    \"socket-raw\",\n-    \"socket-dhcpv4\",\n-] }\n-tdx-guest = { version = \"0.1.7\", optional = true }\n-\n-# parse elf file\n-xmas-elf = \"0.8.0\"\n-# goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n-# data-structures\n-bitflags = \"1.3\"\n-ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../libs/keyable-arc\" }\n-# unzip initramfs\n-libflate = { version = \"2\", default-features = false }\n-core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n-lending-iterator = \"0.1.7\"\n-spin = \"0.9.4\"\n-vte = \"0.10\"\n-lru = \"0.12.3\"\n-log = \"0.4\"\n-bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-hashbrown = \"0.14\"\n-rand = { version = \"0.8.5\", default-features = false, features = [\n-    \"small_rng\",\n-    \"std_rng\",\n-] }\n-static_assertions = \"1.1.0\"\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-getset = \"0.1.2\"\n-atomic = \"0.6\"\n-bytemuck = \"1.14.3\"\n-bytemuck_derive = \"1.5.0\"\n-takeable = \"0.2.2\"\n-cfg-if = \"1.0\"\n-\n-[dependencies.lazy_static]\n-version = \"1.0\"\n-features = [\"spin_no_std\"]\n-\n-[features]\n-cvm_guest = [\"dep:tdx-guest\"]\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"cargo-osdk\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Accelerate OS development with Asterinas OSDK\"\n license = \"MPL-2.0\"\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -171,7 +171,7 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    if std::env::var(\"AUTO_TEST\").is_ok() || std::env::var(\"OSDK_INTEGRATION_TEST\").is_ok() {\n+    if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n         cmd.arg(\"--path\")\n             .arg(\"../../../ostd/libs/linux-bzimage/setup\");\n     }\ndiff --git a/osdk/src/commands/build/mod.rs b/osdk/src/commands/build/mod.rs\n--- a/osdk/src/commands/build/mod.rs\n+++ b/osdk/src/commands/build/mod.rs\n@@ -72,6 +72,7 @@ pub fn create_base_and_cached_build(\n         &base_crate_path,\n         &get_current_crate_info().name,\n         get_current_crate_info().path,\n+        false,\n     );\n     let original_dir = std::env::current_dir().unwrap();\n     std::env::set_current_dir(&base_crate_path).unwrap();\ndiff --git a/osdk/src/commands/new/kernel.template b/osdk/src/commands/new/kernel.template\n--- a/osdk/src/commands/new/kernel.template\n+++ b/osdk/src/commands/new/kernel.template\n@@ -1,4 +1,6 @@\n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -50,60 +50,33 @@ impl TomlManifest {\n                     .unwrap(),\n             )\n         };\n-        // All the custom schemes should inherit settings from the default scheme, this is a helper.\n-        fn finalize(current_manifest: Option<TomlManifest>) -> TomlManifest {\n-            let Some(mut current_manifest) = current_manifest else {\n-                error_msg!(\n-                    \"Cannot find `OSDK.toml` in the current directory or the workspace root\"\n-                );\n-                process::exit(Errno::GetMetadata as _);\n-            };\n-            for scheme in current_manifest.map.values_mut() {\n-                scheme.inherit(&current_manifest.default_scheme);\n-            }\n-            current_manifest\n-        }\n \n         // Search for OSDK.toml in the current directory first.\n-        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize().ok();\n-        let mut current_manifest = match &current_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n-        };\n-        // Then search in the workspace root.\n-        let workspace_manifest_path = workspace_root.join(\"OSDK.toml\").canonicalize().ok();\n-        // The case that the current directory is also the workspace root.\n-        if let Some(current) = &current_manifest_path {\n-            if let Some(workspace) = &workspace_manifest_path {\n-                if current == workspace {\n-                    return finalize(current_manifest);\n+        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize();\n+        let current_manifest = match &current_manifest_path {\n+            Ok(path) => deserialize_toml_manifest(path),\n+            Err(_) => {\n+                // If not found, search in the workspace root.\n+                if let Ok(workspace_manifest_path) = workspace_root.join(\"OSDK.toml\").canonicalize()\n+                {\n+                    deserialize_toml_manifest(workspace_manifest_path)\n+                } else {\n+                    None\n                 }\n             }\n-        }\n-        let workspace_manifest = match workspace_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n         };\n-        // The current manifest should inherit settings from the workspace manifest.\n-        if let Some(workspace_manifest) = workspace_manifest {\n-            if current_manifest.is_none() {\n-                current_manifest = Some(workspace_manifest);\n-            } else {\n-                // Inherit one scheme at a time.\n-                let current_manifest = current_manifest.as_mut().unwrap();\n-                current_manifest\n-                    .default_scheme\n-                    .inherit(&workspace_manifest.default_scheme);\n-                for (scheme_string, scheme) in workspace_manifest.map {\n-                    let current_scheme = current_manifest\n-                        .map\n-                        .entry(scheme_string)\n-                        .or_insert_with(Scheme::empty);\n-                    current_scheme.inherit(&scheme);\n-                }\n-            }\n+\n+        let Some(mut current_manifest) = current_manifest else {\n+            error_msg!(\"Cannot find `OSDK.toml` in the current directory or the workspace root\");\n+            process::exit(Errno::GetMetadata as _);\n+        };\n+\n+        // All the schemes should inherit from the default scheme.\n+        for scheme in current_manifest.map.values_mut() {\n+            scheme.inherit(&current_manifest.default_scheme);\n         }\n-        finalize(current_manifest)\n+\n+        current_manifest\n     }\n \n     /// Get the scheme given the scheme from the command line arguments.\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -10,6 +10,7 @@ pub enum Errno {\n     ExecuteCommand = 5,\n     BuildCrate = 6,\n     RunBundle = 7,\n+    BadCrateName = 8,\n }\n \n /// Print error message to console\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n license = \"MPL-2.0\"\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -7,12 +7,13 @@ use quote::quote;\n use rand::{distributions::Alphanumeric, Rng};\n use syn::{parse_macro_input, Expr, Ident, ItemFn};\n \n-/// This macro is used to mark the kernel entry point.\n+/// A macro attribute to mark the kernel entry point.\n ///\n /// # Example\n ///\n /// ```ignore\n /// #![no_std]\n+/// #![feature(linkage)]\n ///\n /// use ostd::prelude::*;\n ///\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -56,10 +56,15 @@ pub(crate) use crate::cpu::local::cpu_local_cell;\n /// This function represents the first phase booting up the system. It makes\n /// all functionalities of OSTD available after the call.\n ///\n-/// TODO: We need to refactor this function to make it more modular and\n-/// make inter-initialization-dependencies more clear and reduce usages of\n-/// boot stage only global variables.\n-pub fn init() {\n+/// # Safety\n+///\n+/// This function should be called only once and only on the BSP.\n+//\n+// TODO: We need to refactor this function to make it more modular and\n+// make inter-initialization-dependencies more clear and reduce usages of\n+// boot stage only global variables.\n+#[doc(hidden)]\n+pub unsafe fn init() {\n     arch::enable_cpu_features();\n     arch::serial::init();\n \ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -20,6 +20,13 @@ update_package_version() {\n     sed -i \"0,/${pattern}/s/${pattern}/version = \\\"${new_version}\\\"/1\" $1\n }\n \n+# Update the version of the `ostd` dependency (`ostd = { version = \"\", ...`) in file $1\n+update_ostd_dep_version() {\n+    echo \"Updating file $1\"\n+    pattern=\"^ostd = { version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"\"\n+    sed -i \"0,/${pattern}/s/${pattern}/ostd = { version = \\\"${new_version}\\\"/1\" $1\n+}\n+\n # Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -114,9 +122,11 @@ new_version=$(bump_version ${current_version})\n # Update the package version in Cargo.toml\n update_package_version ${OSTD_CARGO_TOML_PATH}\n update_package_version ${OSDK_CARGO_TOML_PATH}\n+update_package_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n+update_ostd_dep_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p asterinas --precise $new_version\n+cargo update -p aster-nix --precise $new_version\n \n # Update Docker image versions in README files\n update_image_versions ${ASTER_SRC_DIR}/README.md\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -142,4 +152,4 @@ update_image_versions $GET_STARTED_PATH\n # `-n` is used to avoid adding a '\\n' in the VERSION file.\n echo -n \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Asterinas & OSDK version to $new_version\"\n+echo \"Bumped Asterinas OSTD & OSDK version to $new_version\"\n",
        "test_patch": "",
        "problem_statement": "ktest as a kernel\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nWell, I want to make ktest as a kernel built on top of aster-frame (OSTD), and run as a kernel. Currently the ktest crate is a dependency of aster-frame, which leads to many problems such as:\r\n - a lot of runtime needed when running ktest, which need to be passed as parameters #834 ;\r\n - need to pass cfg to aster-frame when rebuilding the test #974 ;\r\n\r\nBy making ktest a kernel depending on aster-frame, which has it's entrypoint as `#[aster_main]` (`#[ostd::main]`), it works for all the above problems.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\n### Proposal\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\nOriginally the dependency chain of testing a target crate `A` is:\r\n\r\n```text\r\nktest <---------------- ostd <--- A <--- base_crate\r\n                       /         / \r\nktest_proc_macro <----'---------'\r\n```\r\n\r\nThe proposed one is:\r\n\r\n```text\r\n\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nInstead of a conditional compilation to choose the ktest entry point at `aster_frame::boot::call_aster_main`, the ktest entry point should be registered as **STRONG** `#[aster_main]`, while other kernel's `#[aster_main]` should be WEAK. So during linking, if the ktest main exist ktests will be excecuted, other wise kernel main would be executed.\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n",
        "hints_text": "This proposal aims to address to problems.\r\n\r\n> * a lot of runtime needed when running ktest, which need to be passed as parameters https://github.com/asterinas/asterinas/pull/834 ;\r\n> * need to pass cfg to aster-frame when rebuilding the test https://github.com/asterinas/asterinas/issues/974 ;\r\n\r\nI can see why this proposal is able to resolve the first problem. But why can it address the second?\n> The proposed one is:\r\n\r\n```plain\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nUsers don't need to be aware of the existence of the `ktest_proc_macro` and `ktest` crates, correct? The `ktest` crate is solely a dependency of the `base_crate`, and the `ktest_proc_macro` is now re-exported from `ostd`. Therefore, the crate A to be tested can only depend on `ostd`.\nDue to the current implementation of both `#[ostd::ktest]` and `ktest` relying on `KtestItem` and `KtestItemInfo`, we cannot directly move `ktest` above `ostd`.\r\n\r\nThe most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n\r\n```text\r\n\t\t            .-- ktest_run <---(if testing)---.\r\n\t\t            v                                 \\\r\n  ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n               \\\t  v            \r\n                .----->  ktest \r\n```\r\n\r\nAn alternative solution might be to place the parameters that originally needed to be wrapped in `KtestItem` into a `.ktest_array`, and then retrieve these parameters to generate `KtestItem` objects during execution. However, this might not be an elegant solution.\r\n\r\nI haven't been able to think of a better approach\u2639\ufe0f. Could you give me some input @junyang-zh ?\n> The most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n> \r\n> ```\r\n> \t\t            .-- ktest_run <---(if testing)---.\r\n> \t\t            v                                 \\\r\n>   ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n>                \\\t  v            \r\n>                 .----->  ktest \r\n> ```\r\n\r\nYour question makes sense. And the best solution I can think of is just like yours, splitting the crate into two.\r\n\r\nSo it seems that we are just making the ktest runner a kernel. The ktest item definitions are still a dependency of OSTD.",
        "created_at": "2024-08-13T11:21:28Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1158,
        "instance_id": "asterinas__asterinas-1158",
        "issue_numbers": [
            "1264"
        ],
        "base_commit": "c68302f7007225fa47f22a1085a8c59dcdae2ad4",
        "patch": "diff --git a/kernel/src/sched/priority_scheduler.rs b/kernel/src/sched/priority_scheduler.rs\n--- a/kernel/src/sched/priority_scheduler.rs\n+++ b/kernel/src/sched/priority_scheduler.rs\n@@ -50,12 +50,12 @@ impl<T: PreemptSchedInfo> PreemptScheduler<T> {\n         let mut minimum_load = usize::MAX;\n \n         for candidate in runnable.cpu_affinity().iter() {\n-            let rq = self.rq[candidate].lock();\n+            let rq = self.rq[candidate as usize].lock();\n             // A wild guess measuring the load of a runqueue. We assume that\n             // real-time tasks are 4-times as important as normal tasks.\n             let load = rq.real_time_entities.len() * 4 + rq.normal_entities.len();\n             if load < minimum_load {\n-                selected = candidate as u32;\n+                selected = candidate;\n                 minimum_load = load;\n             }\n         }\ndiff --git a/kernel/src/thread/work_queue/simple_scheduler.rs b/kernel/src/thread/work_queue/simple_scheduler.rs\n--- a/kernel/src/thread/work_queue/simple_scheduler.rs\n+++ b/kernel/src/thread/work_queue/simple_scheduler.rs\n@@ -24,12 +24,12 @@ impl WorkerScheduler for SimpleScheduler {\n     fn schedule(&self) {\n         let worker_pool = self.worker_pool.upgrade().unwrap();\n         for cpu_id in worker_pool.cpu_set().iter() {\n-            if !worker_pool.heartbeat(cpu_id as u32)\n-                && worker_pool.has_pending_work_items(cpu_id as u32)\n-                && !worker_pool.wake_worker(cpu_id as u32)\n-                && worker_pool.num_workers(cpu_id as u32) < WORKER_LIMIT\n+            if !worker_pool.heartbeat(cpu_id)\n+                && worker_pool.has_pending_work_items(cpu_id)\n+                && !worker_pool.wake_worker(cpu_id)\n+                && worker_pool.num_workers(cpu_id) < WORKER_LIMIT\n             {\n-                worker_pool.add_worker(cpu_id as u32);\n+                worker_pool.add_worker(cpu_id);\n             }\n         }\n     }\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -128,10 +128,7 @@ impl WorkerPool {\n         Arc::new_cyclic(|pool_ref| {\n             let mut local_pools = Vec::new();\n             for cpu_id in cpu_set.iter() {\n-                local_pools.push(Arc::new(LocalWorkerPool::new(\n-                    pool_ref.clone(),\n-                    cpu_id as u32,\n-                )));\n+                local_pools.push(Arc::new(LocalWorkerPool::new(pool_ref.clone(), cpu_id)));\n             }\n             WorkerPool {\n                 local_pools,\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -336,7 +336,7 @@ impl Vmar_ {\n         if !self.is_root_vmar() {\n             return_errno_with_message!(Errno::EACCES, \"The vmar is not root vmar\");\n         }\n-        self.vm_space.clear();\n+        self.clear_vm_space();\n         let mut inner = self.inner.lock();\n         inner.child_vmar_s.clear();\n         inner.vm_mappings.clear();\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -346,6 +346,13 @@ impl Vmar_ {\n         Ok(())\n     }\n \n+    fn clear_vm_space(&self) {\n+        let start = ROOT_VMAR_LOWEST_ADDR;\n+        let end = ROOT_VMAR_CAP_ADDR;\n+        let mut cursor = self.vm_space.cursor_mut(&(start..end)).unwrap();\n+        cursor.unmap(end - start);\n+    }\n+\n     pub fn destroy(&self, range: Range<usize>) -> Result<()> {\n         self.check_destroy_range(&range)?;\n         let mut inner = self.inner.lock();\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -167,16 +167,6 @@ impl VmMapping {\n         self.vmo.as_ref()\n     }\n \n-    /// Adds a new committed page and map it to vmspace. If copy on write is set, it's allowed to unmap the page at the same address.\n-    /// FIXME: This implementation based on the truth that we map one page at a time. If multiple pages are mapped together, this implementation may have problems\n-    fn map_one_page(&self, map_addr: usize, frame: Frame, is_readonly: bool) -> Result<()> {\n-        let parent = self.parent.upgrade().unwrap();\n-        let vm_space = parent.vm_space();\n-        self.inner\n-            .lock()\n-            .map_one_page(vm_space, map_addr, frame, is_readonly)\n-    }\n-\n     /// Returns the mapping's start address.\n     pub fn map_to_addr(&self) -> Vaddr {\n         self.inner.lock().map_to_addr\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -193,11 +183,6 @@ impl VmMapping {\n         self.inner.lock().map_size\n     }\n \n-    /// Returns the mapping's offset in the VMO.\n-    pub fn vmo_offset(&self) -> Option<usize> {\n-        self.inner.lock().vmo_offset\n-    }\n-\n     /// Unmaps pages in the range\n     pub fn unmap(&self, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let parent = self.parent.upgrade().unwrap();\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -234,43 +219,84 @@ impl VmMapping {\n \n         let page_aligned_addr = page_fault_addr.align_down(PAGE_SIZE);\n \n+        let root_vmar = self.parent.upgrade().unwrap();\n+        let mut cursor = root_vmar\n+            .vm_space()\n+            .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n+        let current_mapping = cursor.query().unwrap();\n+\n+        // Perform COW if it is a write access to a shared mapping.\n         if write && !not_present {\n-            // Perform COW at page table.\n-            let root_vmar = self.parent.upgrade().unwrap();\n-            let mut cursor = root_vmar\n-                .vm_space()\n-                .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n             let VmItem::Mapped {\n                 va: _,\n                 frame,\n                 mut prop,\n-            } = cursor.query().unwrap()\n+            } = current_mapping\n             else {\n                 return Err(Error::new(Errno::EFAULT));\n             };\n \n-            if self.is_shared {\n+            // Skip if the page fault is already handled.\n+            if prop.flags.contains(PageFlags::W) {\n+                return Ok(());\n+            }\n+\n+            // If the forked child or parent immediately unmaps the page after\n+            // the fork without accessing it, we are the only reference to the\n+            // frame. We can directly map the frame as writable without\n+            // copying. In this case, the reference count of the frame is 2 (\n+            // one for the mapping and one for the frame handle itself).\n+            let only_reference = frame.reference_count() == 2;\n+\n+            if self.is_shared || only_reference {\n                 cursor.protect(PAGE_SIZE, |p| p.flags |= PageFlags::W);\n             } else {\n                 let new_frame = duplicate_frame(&frame)?;\n-                prop.flags |= PageFlags::W;\n+                prop.flags |= PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n                 cursor.map(new_frame, prop);\n             }\n             return Ok(());\n         }\n \n-        let (frame, is_readonly) = self.prepare_page(page_fault_addr, write)?;\n+        // Map a new frame to the page fault address.\n+        // Skip if the page fault is already handled.\n+        if let VmItem::NotMapped { .. } = current_mapping {\n+            let inner_lock = self.inner.lock();\n+            let (frame, is_readonly) = self.prepare_page(&inner_lock, page_fault_addr, write)?;\n+\n+            let vm_perms = {\n+                let mut perms = inner_lock.perms;\n+                if is_readonly {\n+                    // COW pages are forced to be read-only.\n+                    perms -= VmPerms::WRITE;\n+                }\n+                perms\n+            };\n+            let mut page_flags = vm_perms.into();\n+            page_flags |= PageFlags::ACCESSED;\n+            if write {\n+                page_flags |= PageFlags::DIRTY;\n+            }\n+            let map_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n+\n+            cursor.map(frame, map_prop);\n+        }\n \n-        self.map_one_page(page_aligned_addr, frame, is_readonly)\n+        Ok(())\n     }\n \n-    fn prepare_page(&self, page_fault_addr: Vaddr, write: bool) -> Result<(Frame, bool)> {\n+    fn prepare_page(\n+        &self,\n+        inner_lock: &MutexGuard<VmMappingInner>,\n+        page_fault_addr: Vaddr,\n+        write: bool,\n+    ) -> Result<(Frame, bool)> {\n         let mut is_readonly = false;\n         let Some(vmo) = &self.vmo else {\n             return Ok((FrameAllocOptions::new(1).alloc_single()?, is_readonly));\n         };\n \n-        let vmo_offset = self.vmo_offset().unwrap() + page_fault_addr - self.map_to_addr();\n+        let vmo_offset = inner_lock.vmo_offset.unwrap() + page_fault_addr - inner_lock.map_to_addr;\n         let page_idx = vmo_offset / PAGE_SIZE;\n         let Ok(page) = vmo.get_committed_frame(page_idx) else {\n             if !self.is_shared {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -314,14 +340,18 @@ impl VmMapping {\n         );\n \n         let vm_perms = inner.perms - VmPerms::WRITE;\n-        let vm_map_options = { PageProperty::new(vm_perms.into(), CachePolicy::Writeback) };\n         let parent = self.parent.upgrade().unwrap();\n         let vm_space = parent.vm_space();\n         let mut cursor = vm_space.cursor_mut(&(start_addr..end_addr))?;\n         let operate = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n-            if let VmItem::NotMapped { .. } = cursor.query().unwrap() {\n+            if let VmItem::NotMapped { va, len } = cursor.query().unwrap() {\n+                let mut page_flags = vm_perms.into();\n+                if (va..len).contains(&page_fault_addr) {\n+                    page_flags |= PageFlags::ACCESSED;\n+                }\n+                let page_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n                 let frame = commit_fn()?;\n-                cursor.map(frame, vm_map_options);\n+                cursor.map(frame, page_prop);\n             } else {\n                 let next_addr = cursor.virt_addr() + PAGE_SIZE;\n                 if next_addr < end_addr {\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -507,30 +537,6 @@ impl VmMapping {\n }\n \n impl VmMappingInner {\n-    fn map_one_page(\n-        &mut self,\n-        vm_space: &VmSpace,\n-        map_addr: usize,\n-        frame: Frame,\n-        is_readonly: bool,\n-    ) -> Result<()> {\n-        let map_range = map_addr..map_addr + PAGE_SIZE;\n-\n-        let vm_perms = {\n-            let mut perms = self.perms;\n-            if is_readonly {\n-                // COW pages are forced to be read-only.\n-                perms -= VmPerms::WRITE;\n-            }\n-            perms\n-        };\n-        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n-\n-        let mut cursor = vm_space.cursor_mut(&map_range).unwrap();\n-        cursor.map(frame, map_prop);\n-        Ok(())\n-    }\n-\n     /// Unmap pages in the range.\n     fn unmap(&mut self, vm_space: &VmSpace, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let map_addr = range.start.align_down(PAGE_SIZE);\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -150,7 +150,7 @@ fn send_startup_to_all_aps() {\n         (AP_BOOT_START_PA / PAGE_SIZE) as u8,\n     );\n     // SAFETY: we are sending startup IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_to_all_aps() {\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -165,7 +165,7 @@ fn send_init_to_all_aps() {\n         0,\n     );\n     // SAFETY: we are sending init IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_deassert() {\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -180,7 +180,7 @@ fn send_init_deassert() {\n         0,\n     );\n     // SAFETY: we are sending deassert IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n /// Spin wait approximately `c` cycles.\ndiff --git a/ostd/src/arch/x86/irq.rs b/ostd/src/arch/x86/irq.rs\n--- a/ostd/src/arch/x86/irq.rs\n+++ b/ostd/src/arch/x86/irq.rs\n@@ -153,3 +153,27 @@ impl Drop for IrqCallbackHandle {\n         CALLBACK_ID_ALLOCATOR.get().unwrap().lock().free(self.id);\n     }\n }\n+\n+/// Sends a general inter-processor interrupt (IPI) to the specified CPU.\n+///\n+/// # Safety\n+///\n+/// The caller must ensure that the CPU ID and the interrupt number corresponds\n+/// to a safe function to call.\n+pub(crate) unsafe fn send_ipi(cpu_id: u32, irq_num: u8) {\n+    use crate::arch::kernel::apic::{self, Icr};\n+\n+    let icr = Icr::new(\n+        apic::ApicId::from(cpu_id),\n+        apic::DestinationShorthand::NoShorthand,\n+        apic::TriggerMode::Edge,\n+        apic::Level::Assert,\n+        apic::DeliveryStatus::Idle,\n+        apic::DestinationMode::Physical,\n+        apic::DeliveryMode::Fixed,\n+        irq_num,\n+    );\n+    apic::with_borrow(|apic| {\n+        apic.send_ipi(icr);\n+    });\n+}\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -13,7 +13,7 @@ pub mod x2apic;\n pub mod xapic;\n \n cpu_local! {\n-    static APIC_INSTANCE: Once<RefCell<Box<dyn Apic + 'static>>> = Once::new();\n+    static APIC_INSTANCE: RefCell<Option<Box<dyn Apic + 'static>>> = RefCell::new(None);\n }\n \n static APIC_TYPE: Once<ApicType> = Once::new();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -24,23 +24,29 @@ static APIC_TYPE: Once<ApicType> = Once::new();\n /// local APIC instance. During the execution of the closure, the interrupts\n /// are guaranteed to be disabled.\n ///\n+/// This function also lazily initializes the Local APIC instance. It does\n+/// enable the Local APIC if it is not enabled.\n+///\n /// Example:\n /// ```rust\n /// use ostd::arch::x86::kernel::apic;\n ///\n-/// let ticks = apic::borrow(|apic| {\n+/// let ticks = apic::with_borrow(|apic| {\n ///     let ticks = apic.timer_current_count();\n ///     apic.set_timer_init_count(0);\n ///     ticks\n /// });\n /// ```\n-pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n+pub fn with_borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n     let irq_guard = crate::trap::disable_local();\n     let apic_guard = APIC_INSTANCE.get_with(&irq_guard);\n+    let mut apic_init_ref = apic_guard.borrow_mut();\n \n     // If it is not initialized, lazily initialize it.\n-    if !apic_guard.is_completed() {\n-        apic_guard.call_once(|| match APIC_TYPE.get().unwrap() {\n+    let apic_ref = if let Some(apic_ref) = apic_init_ref.as_mut() {\n+        apic_ref\n+    } else {\n+        *apic_init_ref = Some(match APIC_TYPE.get().unwrap() {\n             ApicType::XApic => {\n                 let mut xapic = xapic::XApic::new().unwrap();\n                 xapic.enable();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -51,7 +57,7 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(xapic))\n+                Box::new(xapic)\n             }\n             ApicType::X2Apic => {\n                 let mut x2apic = x2apic::X2Apic::new().unwrap();\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -63,13 +69,12 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(x2apic))\n+                Box::new(x2apic)\n             }\n         });\n-    }\n \n-    let apic_cell = apic_guard.get().unwrap();\n-    let mut apic_ref = apic_cell.borrow_mut();\n+        apic_init_ref.as_mut().unwrap()\n+    };\n \n     let ret = f.call_once((apic_ref.as_mut(),));\n \ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -238,7 +243,6 @@ impl From<u32> for ApicId {\n /// in the system excluding the sender.\n #[repr(u64)]\n pub enum DestinationShorthand {\n-    #[allow(dead_code)]\n     NoShorthand = 0b00,\n     #[allow(dead_code)]\n     MySelf = 0b01,\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -278,7 +282,6 @@ pub enum DestinationMode {\n #[repr(u64)]\n pub enum DeliveryMode {\n     /// Delivers the interrupt specified in the vector field to the target processor or processors.\n-    #[allow(dead_code)]\n     Fixed = 0b000,\n     /// Same as fixed mode, except that the interrupt is delivered to the processor executing at\n     /// the lowest priority among the set of processors specified in the destination field. The\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -108,10 +108,21 @@ pub(crate) fn init_on_bsp() {\n     kernel::pic::init();\n }\n \n+/// Architecture-specific initialization on the application processor.\n+///\n+/// # Safety\n+///\n+/// This function must be called only once on each application processor.\n+/// And it should be called after the BSP's call to [`init_on_bsp`].\n+pub(crate) unsafe fn init_on_ap() {\n+    // Trigger the initialization of the local APIC.\n+    crate::arch::x86::kernel::apic::with_borrow(|_| {});\n+}\n+\n pub(crate) fn interrupts_ack(irq_number: usize) {\n     if !cpu::CpuException::is_cpu_exception(irq_number as u16) {\n         kernel::pic::ack();\n-        kernel::apic::borrow(|apic| {\n+        kernel::apic::with_borrow(|apic| {\n             apic.eoi();\n         });\n     }\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -54,7 +54,7 @@ fn is_tsc_deadline_mode_supported() -> bool {\n fn init_tsc_mode() -> IrqLine {\n     let timer_irq = IrqLine::alloc().unwrap();\n     // Enable tsc deadline mode\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 18));\n     });\n     let tsc_step = TSC_FREQ.load(Ordering::Relaxed) / TIMER_FREQ;\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -81,7 +81,7 @@ fn init_periodic_mode() -> IrqLine {\n     super::pit::enable_ioapic_line(irq.clone());\n \n     // Set APIC timer count\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_div_config(DivideConfig::Divide64);\n         apic.set_timer_init_count(0xFFFF_FFFF);\n     });\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -99,7 +99,7 @@ fn init_periodic_mode() -> IrqLine {\n     // Init APIC Timer\n     let timer_irq = IrqLine::alloc().unwrap();\n \n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_init_count(INIT_COUNT.load(Ordering::Relaxed));\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 17));\n         apic.set_timer_div_config(DivideConfig::Divide64);\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -115,7 +115,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || IS_FINISH.load(Ordering::Acquire) {\n             if IN_TIME.load(Ordering::Relaxed) == 0 {\n-                let remain_ticks = apic::borrow(|apic| apic.timer_current_count());\n+                let remain_ticks = apic::with_borrow(|apic| apic.timer_current_count());\n                 APIC_FIRST_COUNT.store(0xFFFF_FFFF - remain_ticks, Ordering::Relaxed);\n             }\n             IN_TIME.fetch_add(1, Ordering::Relaxed);\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -124,7 +124,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         // Stop PIT and APIC Timer\n         super::pit::disable_ioapic_line();\n-        let remain_ticks = apic::borrow(|apic| {\n+        let remain_ticks = apic::with_borrow(|apic| {\n             let remain_ticks = apic.timer_current_count();\n             apic.set_timer_init_count(0);\n             remain_ticks\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -123,6 +123,13 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     unsafe {\n         trapframe::init();\n     }\n+\n+    // SAFETY: this function is only called once on this AP, after the BSP has\n+    // done the architecture-specific initialization.\n+    unsafe {\n+        crate::arch::init_on_ap();\n+    }\n+\n     crate::arch::irq::enable_local();\n \n     // SAFETY: this function is only called once on this AP.\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -10,12 +10,7 @@ cfg_if::cfg_if! {\n     }\n }\n \n-use alloc::vec::Vec;\n-\n-use bitvec::{\n-    prelude::{BitVec, Lsb0},\n-    slice::IterOnes,\n-};\n+use bitvec::prelude::BitVec;\n use local::cpu_local_cell;\n use spin::Once;\n \ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -122,13 +117,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, true);\n     }\n \n-    /// Adds a list of CPUs to the set.\n-    pub fn add_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.add(cpu_id)\n-        }\n-    }\n-\n     /// Adds all CPUs to the set.\n     pub fn add_all(&mut self) {\n         self.bitset.fill(true);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -139,13 +127,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, false);\n     }\n \n-    /// Removes a list of CPUs from the set.\n-    pub fn remove_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.remove(cpu_id);\n-        }\n-    }\n-\n     /// Removes all CPUs from the set.\n     pub fn clear(&mut self) {\n         self.bitset.fill(false);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -162,8 +143,8 @@ impl CpuSet {\n     }\n \n     /// Iterates over the CPUs in the set.\n-    pub fn iter(&self) -> IterOnes<'_, usize, Lsb0> {\n-        self.bitset.iter_ones()\n+    pub fn iter(&self) -> impl Iterator<Item = u32> + '_ {\n+        self.bitset.iter_ones().map(|idx| idx as u32)\n     }\n }\n \ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -39,6 +39,7 @@ pub mod logger;\n pub mod mm;\n pub mod panicking;\n pub mod prelude;\n+pub mod smp;\n pub mod sync;\n pub mod task;\n pub mod trap;\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -90,6 +91,8 @@ pub unsafe fn init() {\n     unsafe { trap::softirq::init() };\n     arch::init_on_bsp();\n \n+    smp::init();\n+\n     bus::init();\n \n     // SAFETY: This function is called only once on the BSP.\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -80,6 +80,21 @@ impl Frame {\n             core::ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.size());\n         }\n     }\n+\n+    /// Get the reference count of the frame.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Frame`]) and all the mappings in the page\n+    /// table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.page.reference_count()\n+    }\n }\n \n impl From<Page<FrameMeta>> for Frame {\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -156,7 +156,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n         for meta_page in meta_pages {\n             // SAFETY: we are doing the metadata mappings for the kernel.\n             unsafe {\n-                cursor.map(meta_page.into(), prop);\n+                let _old = cursor.map(meta_page.into(), prop);\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -199,7 +199,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n             let page = Page::<KernelMeta>::from_unused(frame_paddr, KernelMeta::default());\n             // SAFETY: we are doing mappings for the kernel.\n             unsafe {\n-                cursor.map(page.into(), prop);\n+                let _old = cursor.map(page.into(), prop);\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -164,6 +164,21 @@ impl<M: PageMeta> Page<M> {\n         unsafe { &*(self.ptr as *const M) }\n     }\n \n+    /// Get the reference count of the page.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Page`], [`DynPage`]), and all the mappings in the\n+    /// page table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.ref_count().load(Ordering::Relaxed)\n+    }\n+\n     fn ref_count(&self) -> &AtomicU32 {\n         unsafe { &(*self.ptr).ref_count }\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -73,7 +73,10 @@ use super::{\n     page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n-use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n+use crate::{\n+    mm::{page::DynPage, Paddr, PageProperty, Vaddr},\n+    task::{disable_preempt, DisabledPreemptGuard},\n+};\n \n #[derive(Clone, Debug)]\n pub enum PageTableItem {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -125,7 +128,8 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n-    phantom: PhantomData<&'a PageTable<M, E, C>>,\n+    preempt_guard: DisabledPreemptGuard,\n+    _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\n \n impl<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait> Cursor<'a, M, E, C>\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -162,7 +166,8 @@ where\n             guard_level: C::NR_LEVELS,\n             va: va.start,\n             barrier_va: va.clone(),\n-            phantom: PhantomData,\n+            preempt_guard: disable_preempt(),\n+            _phantom: PhantomData,\n         };\n \n         // Go down and get proper locks. The cursor should hold a lock of a\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -204,37 +209,28 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            let pte = self.read_cur_pte();\n-            if !pte.is_present() {\n-                return Ok(PageTableItem::NotMapped {\n-                    va,\n-                    len: page_size::<C>(level),\n-                });\n-            }\n-            if !pte.is_last(level) {\n-                self.level_down();\n-                continue;\n-            }\n-\n             match self.cur_child() {\n-                Child::Page(page) => {\n-                    return Ok(PageTableItem::Mapped {\n+                Child::PageTable(_) => {\n+                    self.level_down();\n+                    continue;\n+                }\n+                Child::None => {\n+                    return Ok(PageTableItem::NotMapped {\n                         va,\n-                        page,\n-                        prop: pte.prop(),\n+                        len: page_size::<C>(level),\n                     });\n                 }\n-                Child::Untracked(pa) => {\n+                Child::Page(page, prop) => {\n+                    return Ok(PageTableItem::Mapped { va, page, prop });\n+                }\n+                Child::Untracked(pa, prop) => {\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\n-                        prop: pte.prop(),\n+                        prop,\n                     });\n                 }\n-                Child::None | Child::PageTable(_) => {\n-                    unreachable!(); // Already checked with the PTE.\n-                }\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -289,6 +285,10 @@ where\n         self.va\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.preempt_guard\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -423,6 +423,8 @@ where\n \n     /// Maps the range starting from the current address to a [`DynPage`].\n     ///\n+    /// It returns the previously mapped [`DynPage`] if that exists.\n+    ///\n     /// # Panics\n     ///\n     /// This function will panic if\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -434,7 +436,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -458,8 +460,19 @@ where\n \n         // Map the current page.\n         let idx = self.0.cur_idx();\n-        self.cur_node_mut().set_child_page(idx, page, prop);\n+        let old = self\n+            .cur_node_mut()\n+            .replace_child(idx, Child::Page(page, prop), true);\n         self.0.move_forward();\n+\n+        match old {\n+            Child::Page(old_page, _) => Some(old_page),\n+            Child::None => None,\n+            Child::PageTable(_) => {\n+                todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n+            }\n+            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+        }\n     }\n \n     /// Maps the range starting from the current address to a physical address range.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -520,7 +533,9 @@ where\n             // Map the current page.\n             debug_assert!(!self.0.in_tracked_range());\n             let idx = self.0.cur_idx();\n-            self.cur_node_mut().set_child_untracked(idx, pa, prop);\n+            let _ = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::Untracked(pa, prop), false);\n \n             let level = self.0.level;\n             pa += page_size::<C>(level);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -605,23 +620,25 @@ where\n \n             // Unmap the current page and return it.\n             let idx = self.0.cur_idx();\n-            let ret = self.cur_node_mut().take_child(idx, is_tracked);\n+            let ret = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::None, is_tracked);\n             let ret_page_va = self.0.va;\n             let ret_page_size = page_size::<C>(self.0.level);\n \n             self.0.move_forward();\n \n             return match ret {\n-                Child::Page(page) => PageTableItem::Mapped {\n+                Child::Page(page, prop) => PageTableItem::Mapped {\n                     va: ret_page_va,\n                     page,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n-                Child::Untracked(pa) => PageTableItem::MappedUntracked {\n+                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n                     va: ret_page_va,\n                     pa,\n                     len: ret_page_size,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n                 Child::None | Child::PageTable(_) => unreachable!(),\n             };\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -717,6 +734,10 @@ where\n         None\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.0.preempt_guard\n+    }\n+\n     /// Consumes itself and leak the root guard for the caller if it locked the root level.\n     ///\n     /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -743,8 +764,12 @@ where\n         let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n         let idx = self.0.cur_idx();\n         let is_tracked = self.0.in_tracked_range();\n-        self.cur_node_mut()\n-            .set_child_pt(idx, new_node.clone_raw(), is_tracked);\n+        let old = self.cur_node_mut().replace_child(\n+            idx,\n+            Child::PageTable(new_node.clone_raw()),\n+            is_tracked,\n+        );\n+        debug_assert!(old.is_none());\n         self.0.level -= 1;\n         self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n     }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -162,7 +162,11 @@ impl PageTable<KernelMode> {\n         for i in start..end {\n             if !root_node.read_pte(i).is_present() {\n                 let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                root_node.set_child_pt(i, node.into_raw(), i < NR_PTES_PER_NODE * 3 / 4);\n+                let _ = root_node.replace_child(\n+                    i,\n+                    Child::PageTable(node.into_raw()),\n+                    i < NR_PTES_PER_NODE * 3 / 4,\n+                );\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -42,7 +42,6 @@ use crate::{\n         page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n-    task::{disable_preempt, DisabledPreemptGuard},\n };\n \n /// The raw handle to a page table node.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -80,8 +79,6 @@ where\n         // count is needed.\n         let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n \n-        let disable_preempt = disable_preempt();\n-\n         // Acquire the lock.\n         while page\n             .meta()\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -92,10 +89,7 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> {\n-            page,\n-            preempt_guard: disable_preempt,\n-        }\n+        PageTableNode::<E, C> { page, _private: () }\n     }\n \n     /// Creates a copy of the handle.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -190,7 +184,7 @@ pub(super) struct PageTableNode<\n     [(); C::NR_LEVELS as usize]:,\n {\n     pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    preempt_guard: DisabledPreemptGuard,\n+    _private: (),\n }\n \n // FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -215,12 +209,21 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage),\n+    Page(DynPage, PageProperty),\n     /// Pages not tracked by handles.\n-    Untracked(Paddr),\n+    Untracked(Paddr, PageProperty),\n     None,\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    pub(super) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -241,10 +244,7 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self {\n-            page,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { page, _private: () }\n     }\n \n     pub fn level(&self) -> PagingLevel {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -253,16 +253,11 @@ where\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n-        let mut this = ManuallyDrop::new(self);\n+        let this = ManuallyDrop::new(self);\n \n         let raw = this.page.paddr();\n \n         this.page.meta().lock.store(0, Ordering::Release);\n-        // SAFETY: The field will no longer be accessed and we need to drop the field to release\n-        // the preempt count.\n-        unsafe {\n-            core::ptr::drop_in_place(&mut this.preempt_guard);\n-        }\n \n         RawPageTableNode {\n             raw,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -300,40 +295,82 @@ where\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n+                // SAFETY: We have a reference count to the page and can safely\n+                // increase the reference count by one more.\n                 unsafe {\n                     DynPage::inc_ref_count(paddr);\n                 }\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the PTE points to a forgotten\n+                // page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, pte.prop())\n             }\n         }\n     }\n \n-    /// Remove the child at the given index and return it.\n-    pub(super) fn take_child(&mut self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n+    /// Replace the child at the given index with a new child.\n+    ///\n+    /// The old child is returned.\n+    pub(super) fn replace_child(\n+        &mut self,\n+        idx: usize,\n+        new_child: Child<E, C>,\n+        in_tracked_range: bool,\n+    ) -> Child<E, C> {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n \n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            let is_last = pte.is_last(self.level());\n-            *self.nr_children_mut() -= 1;\n-            self.write_pte(idx, E::new_absent());\n-            if !is_last {\n+        let old_pte = self.read_pte(idx);\n+\n+        let new_child_is_none = match new_child {\n+            Child::None => {\n+                if old_pte.is_present() {\n+                    self.write_pte(idx, E::new_absent());\n+                }\n+                true\n+            }\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                let new_pte = E::new_pt(pt.paddr());\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Page(page, prop) => {\n+                debug_assert!(in_tracked_range);\n+                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Untracked(pa, prop) => {\n+                debug_assert!(!in_tracked_range);\n+                let new_pte = E::new_page(pa, self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+        };\n+\n+        if old_pte.is_present() {\n+            if new_child_is_none {\n+                *self.nr_children_mut() -= 1;\n+            }\n+            let paddr = old_pte.paddr();\n+            if !old_pte.is_last(self.level()) {\n                 Child::PageTable(RawPageTableNode {\n                     raw: paddr,\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the old PTE points to a\n+                // forgotten page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, old_pte.prop())\n+            }\n+        } else {\n+            if !new_child_is_none {\n+                *self.nr_children_mut() += 1;\n             }\n+            Child::None\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -364,16 +401,17 @@ where\n                 Child::PageTable(pt) => {\n                     let guard = pt.clone_shallow().lock();\n                     let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    new_pt.set_child_pt(i, new_child.into_raw(), true);\n+                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n-                Child::Page(page) => {\n-                    let prop = self.read_pte_prop(i);\n-                    new_pt.set_child_page(i, page.clone(), prop);\n+                Child::Page(page, prop) => {\n+                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Untracked(_) => {\n+                Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -386,11 +424,16 @@ where\n             debug_assert_eq!(self.level(), C::NR_LEVELS);\n             match self.child(i, /*meaningless*/ true) {\n                 Child::PageTable(pt) => {\n-                    new_pt.set_child_pt(i, pt.clone_shallow(), /*meaningless*/ true);\n+                    let old = new_pt.replace_child(\n+                        i,\n+                        Child::PageTable(pt.clone_shallow()),\n+                        /*meaningless*/ true,\n+                    );\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Page(_) | Child::Untracked(_) => {\n+                Child::Page(_, _) | Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -399,73 +442,23 @@ where\n         new_pt\n     }\n \n-    /// Sets a child page table at a given index.\n-    pub(super) fn set_child_pt(\n-        &mut self,\n-        idx: usize,\n-        pt: RawPageTableNode<E, C>,\n-        in_tracked_range: bool,\n-    ) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // The ownership is transferred to a raw PTE. Don't drop the handle.\n-        let pt = ManuallyDrop::new(pt);\n-\n-        let pte = Some(E::new_pt(pt.paddr()));\n-        self.overwrite_pte(idx, pte, in_tracked_range);\n-    }\n-\n-    /// Map a page at a given index.\n-    pub(super) fn set_child_page(&mut self, idx: usize, page: DynPage, prop: PageProperty) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert_eq!(page.level(), self.level());\n-\n-        // Use the physical address rather than the page handle to track\n-        // the page, and record the physical address in the PTE.\n-        let pte = Some(E::new_page(page.into_raw(), self.level(), prop));\n-        self.overwrite_pte(idx, pte, true);\n-    }\n-\n-    /// Sets an untracked child page at a given index.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller must ensure that the physical address is valid and safe to map.\n-    pub(super) unsafe fn set_child_untracked(&mut self, idx: usize, pa: Paddr, prop: PageProperty) {\n-        // It should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = Some(E::new_page(pa, self.level(), prop));\n-        self.overwrite_pte(idx, pte, false);\n-    }\n-\n-    /// Reads the info from a page table entry at a given index.\n-    pub(super) fn read_pte_prop(&self, idx: usize) -> PageProperty {\n-        self.read_pte(idx).prop()\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n         debug_assert!(self.level() > 1);\n \n-        let Child::Untracked(pa) = self.child(idx, false) else {\n+        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n             panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n         };\n-        let prop = self.read_pte_prop(idx);\n \n         let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n         for i in 0..nr_subpage_per_huge::<C>() {\n             let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            // SAFETY: the index is within the bound and either physical address and\n-            // the property are valid.\n-            unsafe { new_page.set_child_untracked(i, small_pa, prop) };\n+            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n         }\n \n-        self.set_child_pt(idx, new_page.into_raw(), false);\n+        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n     }\n \n     /// Protects an already mapped child at a given index.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -512,47 +505,6 @@ where\n         unsafe { &mut *self.meta().nr_children.get() }\n     }\n \n-    /// Replaces a page table entry at a given index.\n-    ///\n-    /// This method will ensure that the child presented by the overwritten\n-    /// PTE is dropped, and the child count is updated.\n-    ///\n-    /// The caller in this module will ensure that the PTE points to initialized\n-    /// memory if the child is a page table.\n-    fn overwrite_pte(&mut self, idx: usize, pte: Option<E>, in_tracked_range: bool) {\n-        let existing_pte = self.read_pte(idx);\n-\n-        if existing_pte.is_present() {\n-            self.write_pte(idx, pte.unwrap_or(E::new_absent()));\n-\n-            // Drop the child. We must set the PTE before dropping the child.\n-            // Just restore the handle and drop the handle.\n-\n-            let paddr = existing_pte.paddr();\n-            // SAFETY: Both the `from_raw` operations here are safe as the physical\n-            // address is valid and casted from a handle.\n-            unsafe {\n-                if !existing_pte.is_last(self.level()) {\n-                    // This is a page table.\n-                    drop(Page::<PageTablePageMeta<E, C>>::from_raw(paddr));\n-                } else if in_tracked_range {\n-                    // This is a frame.\n-                    drop(DynPage::from_raw(paddr));\n-                }\n-            }\n-\n-            // Update the child count.\n-            if pte.is_none() {\n-                *self.nr_children_mut() -= 1;\n-            }\n-        } else if let Some(e) = pte {\n-            // SAFETY: This is safe as described in the above branch.\n-            unsafe { (self.as_ptr() as *mut E).add(idx).write(e) };\n-\n-            *self.nr_children_mut() += 1;\n-        }\n-    }\n-\n     fn as_ptr(&self) -> *const E {\n         paddr_to_vaddr(self.start_paddr()) as *const E\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,29 +9,31 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use core::ops::Range;\n+use alloc::collections::vec_deque::VecDeque;\n+use core::{\n+    ops::Range,\n+    sync::atomic::{AtomicPtr, Ordering},\n+};\n \n use spin::Once;\n \n use super::{\n     io::Fallible,\n     kspace::KERNEL_PAGE_TABLE,\n+    page::DynPage,\n     page_table::{PageTable, UserMode},\n     PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n };\n use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr, tlb_flush_addr_range,\n-        tlb_flush_all_excluding_global, PageTableEntry, PagingConsts,\n-    },\n-    cpu::{CpuExceptionInfo, CpuSet, PinCurrentCpu},\n-    cpu_local_cell,\n+    arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n+    cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n+    cpu_local,\n     mm::{\n         page_table::{self, PageTableItem},\n         Frame, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::SpinLock,\n+    sync::{RwLock, RwLockReadGuard, SpinLock},\n     task::disable_preempt,\n     Error,\n };\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -55,28 +57,18 @@ use crate::{\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-    /// The CPUs that the `VmSpace` is activated on.\n-    ///\n-    /// TODO: implement an atomic bitset to optimize the performance in cases\n-    /// that the number of CPUs is not large.\n-    activated_cpus: SpinLock<CpuSet>,\n+    /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n+    /// Cursors hold read locks and activation require a write lock.\n+    activation_lock: RwLock<()>,\n }\n \n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n impl VmSpace {\n     /// Creates a new VM address space.\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n             page_fault_handler: Once::new(),\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -102,74 +94,64 @@ impl VmSpace {\n     /// The creation of the cursor may block if another cursor having an\n     /// overlapping range is alive. The modification to the mapping by the\n     /// cursor may also block or be overridden the mapping of another cursor.\n-    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n-        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_, '_>> {\n+        Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n+            let activation_lock = self.activation_lock.read();\n+\n+            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n+\n+            let mut activated_cpus = CpuSet::new_empty();\n+            let mut need_self_flush = false;\n+            let mut need_remote_flush = false;\n+\n+            for cpu in 0..num_cpus() {\n+                // The activation lock is held; other CPUs cannot activate this `VmSpace`.\n+                let ptr =\n+                    ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n+                if ptr == self as *const VmSpace {\n+                    activated_cpus.add(cpu);\n+                    if cpu == cur_cpu {\n+                        need_self_flush = true;\n+                    } else {\n+                        need_remote_flush = true;\n+                    }\n+                }\n+            }\n+\n+            CursorMut {\n+                pt_cursor,\n+                activation_lock,\n+                activated_cpus,\n+                need_remote_flush,\n+                need_self_flush,\n+            }\n+        })?)\n     }\n \n     /// Activates the page table on the current CPU.\n     pub(crate) fn activate(self: &Arc<Self>) {\n-        cpu_local_cell! {\n-            /// The `Arc` pointer to the last activated VM space on this CPU. If the\n-            /// pointer is NULL, it means that the last activated page table is merely\n-            /// the kernel page table.\n-            static LAST_ACTIVATED_VM_SPACE: *const VmSpace = core::ptr::null();\n-        }\n-\n         let preempt_guard = disable_preempt();\n \n-        let mut activated_cpus = self.activated_cpus.lock();\n-        let cpu = preempt_guard.current_cpu();\n+        // Ensure no mutable cursors (which holds read locks) are alive.\n+        let _activation_lock = self.activation_lock.write();\n \n-        if !activated_cpus.contains(cpu) {\n-            activated_cpus.add(cpu);\n-            self.pt.activate();\n+        let cpu = preempt_guard.current_cpu();\n+        let activated_vm_space = ACTIVATED_VM_SPACE.get_on_cpu(cpu);\n \n-            let last_ptr = LAST_ACTIVATED_VM_SPACE.load();\n+        let last_ptr = activated_vm_space.load(Ordering::Relaxed) as *const VmSpace;\n \n+        if last_ptr != Arc::as_ptr(self) {\n+            self.pt.activate();\n+            let ptr = Arc::into_raw(Arc::clone(self)) as *mut VmSpace;\n+            activated_vm_space.store(ptr, Ordering::Relaxed);\n             if !last_ptr.is_null() {\n-                // SAFETY: If the pointer is not NULL, it must be a valid\n-                // pointer casted with `Arc::into_raw` on the last activated\n-                // `Arc<VmSpace>`.\n-                let last = unsafe { Arc::from_raw(last_ptr) };\n-                debug_assert!(!Arc::ptr_eq(self, &last));\n-                let mut last_cpus = last.activated_cpus.lock();\n-                debug_assert!(last_cpus.contains(cpu));\n-                last_cpus.remove(cpu);\n+                // SAFETY: The pointer is cast from an `Arc` when it's activated\n+                // the last time, so it can be restored and only restored once.\n+                drop(unsafe { Arc::from_raw(last_ptr) });\n             }\n-\n-            LAST_ACTIVATED_VM_SPACE.store(Arc::into_raw(Arc::clone(self)));\n-        }\n-\n-        if activated_cpus.count() > 1 {\n-            // We don't support remote TLB flushing yet. It is less desirable\n-            // to activate a `VmSpace` on more than one CPU.\n-            log::warn!(\"A `VmSpace` is activated on more than one CPU\");\n         }\n     }\n \n-    /// Clears all mappings.\n-    pub fn clear(&self) {\n-        let mut cursor = self.pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        loop {\n-            // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { cursor.take_next(MAX_USERSPACE_VADDR - cursor.virt_addr()) };\n-            match result {\n-                PageTableItem::Mapped { page, .. } => {\n-                    drop(page);\n-                }\n-                PageTableItem::NotMapped { .. } => {\n-                    break;\n-                }\n-                PageTableItem::MappedUntracked { .. } => {\n-                    panic!(\"found untracked memory mapped into `VmSpace`\");\n-                }\n-            }\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n-    }\n-\n     pub(crate) fn handle_page_fault(\n         &self,\n         info: &CpuExceptionInfo,\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -199,25 +181,12 @@ impl VmSpace {\n     pub fn fork_copy_on_write(&self) -> Self {\n         // Protect the parent VM space as read-only.\n         let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.pt.cursor_mut(&(0..end)).unwrap();\n+        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n         let mut op = |prop: &mut PageProperty| {\n             prop.flags -= PageFlags::W;\n         };\n \n-        loop {\n-            // SAFETY: It is safe to protect memory in the userspace.\n-            unsafe {\n-                if cursor\n-                    .protect_next(end - cursor.virt_addr(), &mut op)\n-                    .is_none()\n-                {\n-                    break;\n-                }\n-            };\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n+        cursor.protect(end, &mut op);\n \n         let page_fault_handler = {\n             let new_handler = Once::new();\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -227,10 +196,22 @@ impl VmSpace {\n             new_handler\n         };\n \n+        let CursorMut {\n+            pt_cursor,\n+            activation_lock,\n+            ..\n+        } = cursor;\n+\n+        let new_pt = self.pt.clone_with(pt_cursor);\n+\n+        // Release the activation lock after the page table is cloned to\n+        // prevent modification to the parent page table while cloning.\n+        drop(activation_lock);\n+\n         Self {\n-            pt: self.pt.clone_with(cursor),\n+            pt: new_pt,\n             page_fault_handler,\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -326,52 +307,55 @@ impl Cursor<'_> {\n ///\n /// It exclusively owns a sub-tree of the page table, preventing others from\n /// reading or modifying the same sub-tree.\n-pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n-\n-impl CursorMut<'_> {\n-    /// The threshold used to determine whether need to flush TLB all\n-    /// when flushing a range of TLB addresses. If the range of TLB entries\n-    /// to be flushed exceeds this threshold, the overhead incurred by\n-    /// flushing pages individually would surpass the overhead of flushing all entries at once.\n-    const TLB_FLUSH_THRESHOLD: usize = 32 * PAGE_SIZE;\n+pub struct CursorMut<'a, 'b> {\n+    pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n+    #[allow(dead_code)]\n+    activation_lock: RwLockReadGuard<'b, ()>,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead. We have a read lock so the stored set\n+    // is always a superset of actual activated CPUs.\n+    activated_cpus: CpuSet,\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+}\n \n+impl CursorMut<'_, '_> {\n     /// Query about the current slot.\n     ///\n     /// This is the same as [`Cursor::query`].\n     ///\n     /// This function won't bring the cursor to the next slot.\n     pub fn query(&mut self) -> Result<VmItem> {\n-        Ok(self.0.query().map(|item| item.try_into().unwrap())?)\n+        Ok(self\n+            .pt_cursor\n+            .query()\n+            .map(|item| item.try_into().unwrap())?)\n     }\n \n     /// Jump to the virtual address.\n     ///\n     /// This is the same as [`Cursor::jump`].\n     pub fn jump(&mut self, va: Vaddr) -> Result<()> {\n-        self.0.jump(va)?;\n+        self.pt_cursor.jump(va)?;\n         Ok(())\n     }\n \n     /// Get the virtual address of the current slot.\n     pub fn virt_addr(&self) -> Vaddr {\n-        self.0.virt_addr()\n+        self.pt_cursor.virt_addr()\n     }\n \n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n-    pub fn map(&mut self, frame: Frame, mut prop: PageProperty) {\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n         let start_va = self.virt_addr();\n         let end_va = start_va + frame.size();\n-        // TODO: this is a temporary fix to avoid the overhead of setting ACCESSED bit in userspace.\n-        // When this bit is truly enabled, it needs to be set at a more appropriate location.\n-        prop.flags |= PageFlags::ACCESSED;\n         // SAFETY: It is safe to map untyped memory into the userspace.\n-        unsafe {\n-            self.0.map(frame.into(), prop);\n-        }\n+        let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        tlb_flush_addr_range(&(start_va..end_va));\n+        self.issue_tlb_flush(TlbFlushOp::Range(start_va..end_va), old);\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Clear the mapping starting from the current slot.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -388,18 +372,13 @@ impl CursorMut<'_> {\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+\n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { self.0.take_next(end_va - self.virt_addr()) };\n+            let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !need_flush_all {\n-                        // TODO: Ask other processors to flush the TLB before we\n-                        // release the page back to the allocator.\n-                        tlb_flush_addr(va);\n-                    }\n-                    drop(page);\n+                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -409,9 +388,8 @@ impl CursorMut<'_> {\n                 }\n             }\n         }\n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n-        }\n+\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Change the mapping property starting from the current slot.\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -426,17 +404,121 @@ impl CursorMut<'_> {\n     /// This method will panic if `len` is not page-aligned.\n     pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n         assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.0.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+        let end = self.virt_addr() + len;\n+        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) = unsafe { self.0.protect_next(end - self.0.virt_addr(), &mut op) } {\n-            if !need_flush_all {\n-                tlb_flush_addr(range.start);\n+        while let Some(range) =\n+            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n+        {\n+            if !tlb_prefer_flush_all {\n+                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n+            }\n+        }\n+\n+        if tlb_prefer_flush_all {\n+            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        }\n+        self.dispatch_tlb_flush();\n+    }\n+\n+    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let request = TlbFlushRequest {\n+            op,\n+            drop_after_flush,\n+        };\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                request.do_flush();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.activated_cpus.iter() {\n+            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n+            queue.push_back(request.clone());\n+        }\n+    }\n+\n+    fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        fn do_remote_flush() {\n+            let preempt_guard = disable_preempt();\n+            let mut requests = TLB_FLUSH_REQUESTS\n+                .get_on_cpu(preempt_guard.current_cpu())\n+                .lock();\n+            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n+                // TODO: in most cases, we need only to flush all the TLB entries\n+                // for an ASID if it is enabled.\n+                crate::arch::mm::tlb_flush_all_excluding_global();\n+                requests.clear();\n+            } else {\n+                while let Some(request) = requests.pop_front() {\n+                    request.do_flush();\n+                    if matches!(request.op, TlbFlushOp::All) {\n+                        requests.clear();\n+                        break;\n+                    }\n+                }\n             }\n         }\n \n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n+        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    }\n+}\n+\n+/// The threshold used to determine whether we need to flush all TLB entries\n+/// when handling a bunch of TLB flush requests. If the number of requests\n+/// exceeds this threshold, the overhead incurred by flushing pages\n+/// individually would surpass the overhead of flushing all entries at once.\n+const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n+\n+cpu_local! {\n+    /// The queue of pending requests.\n+    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n+    /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n+    /// is NULL, it means that the activated page table is merely the kernel\n+    /// page table.\n+    // TODO: If we are enabling ASID, we need to maintain the TLB state of each\n+    // CPU, rather than merely the activated `VmSpace`. When ASID is enabled,\n+    // the non-active `VmSpace`s can still have their TLB entries in the CPU!\n+    static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TlbFlushRequest {\n+    op: TlbFlushOp,\n+    // If we need to remove a mapped page from the page table, we can only\n+    // recycle the page after all the relevant TLB entries in all CPUs are\n+    // flushed. Otherwise if the page is recycled for other purposes, the user\n+    // space program can still access the page through the TLB entries.\n+    #[allow(dead_code)]\n+    drop_after_flush: Option<DynPage>,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TlbFlushOp {\n+    All,\n+    Address(Vaddr),\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushRequest {\n+    /// Perform the TLB flush operation on the current CPU.\n+    fn do_flush(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match &self.op {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n         }\n     }\n }\ndiff --git /dev/null b/ostd/src/smp.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/smp.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Symmetric Multi-Processing (SMP) support.\n+//!\n+//! This module provides a way to execute code on other processors via inter-\n+//! processor interrupts.\n+\n+use alloc::collections::VecDeque;\n+\n+use spin::Once;\n+\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    trap::{self, IrqLine, TrapFrame},\n+};\n+\n+/// Execute a function on other processors.\n+///\n+/// The provided function `f` will be executed on all target processors\n+/// specified by `targets`. It can also be executed on the current processor.\n+/// The function should be short and non-blocking, as it will be executed in\n+/// interrupt context with interrupts disabled.\n+///\n+/// This function does not block until all the target processors acknowledges\n+/// the interrupt. So if any of the target processors disables IRQs for too\n+/// long that the controller cannot queue them, the function will not be\n+/// executed.\n+///\n+/// The function `f` will be executed asynchronously on the target processors.\n+/// However if called on the current processor, it will be synchronous.\n+pub fn inter_processor_call(targets: &CpuSet, f: fn()) {\n+    let irq_guard = trap::disable_local();\n+    let this_cpu_id = irq_guard.current_cpu();\n+    let irq_num = INTER_PROCESSOR_CALL_IRQ.get().unwrap().num();\n+\n+    let mut call_on_self = false;\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            call_on_self = true;\n+            continue;\n+        }\n+        CALL_QUEUES.get_on_cpu(cpu_id).lock().push_back(f);\n+    }\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            continue;\n+        }\n+        // SAFETY: It is safe to send inter processor call IPI to other CPUs.\n+        unsafe {\n+            crate::arch::irq::send_ipi(cpu_id, irq_num);\n+        }\n+    }\n+    if call_on_self {\n+        // Execute the function synchronously.\n+        f();\n+    }\n+}\n+\n+static INTER_PROCESSOR_CALL_IRQ: Once<IrqLine> = Once::new();\n+\n+cpu_local! {\n+    static CALL_QUEUES: SpinLock<VecDeque<fn()>> = SpinLock::new(VecDeque::new());\n+}\n+\n+fn do_inter_processor_call(_trapframe: &TrapFrame) {\n+    // TODO: in interrupt context, disabling interrupts is not necessary.\n+    let preempt_guard = trap::disable_local();\n+    let cur_cpu = preempt_guard.current_cpu();\n+\n+    let mut queue = CALL_QUEUES.get_on_cpu(cur_cpu).lock();\n+    while let Some(f) = queue.pop_front() {\n+        log::trace!(\n+            \"Performing inter-processor call to {:#?} on CPU {}\",\n+            f,\n+            cur_cpu\n+        );\n+        f();\n+    }\n+}\n+\n+pub(super) fn init() {\n+    let mut irq = IrqLine::alloc().unwrap();\n+    irq.on_active(do_inter_processor_call);\n+    INTER_PROCESSOR_CALL_IRQ.call_once(|| irq);\n+}\ndiff --git a/ostd/src/task/preempt/guard.rs b/ostd/src/task/preempt/guard.rs\n--- a/ostd/src/task/preempt/guard.rs\n+++ b/ostd/src/task/preempt/guard.rs\n@@ -3,6 +3,7 @@\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\n+#[derive(Debug)]\n pub struct DisabledPreemptGuard {\n     // This private field prevents user from constructing values of this type directly.\n     _private: (),\n",
        "test_patch": "",
        "problem_statement": "Sporadic SMP syscall test aborts\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nThe SMP syscall test aborts with no panicking information randomly. The abort does not happen in a specific test case. And there's possibility of such failures both in the CI ([an example](https://github.com/asterinas/asterinas/actions/runs/10615729536/job/29424463727)) and locally.\r\n\r\nOther CI failure logs:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10600745276/job/29378943424\r\n\r\nLink #999 \r\n\n",
        "hints_text": "",
        "created_at": "2024-08-13T09:28:07Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1372,
        "instance_id": "asterinas__asterinas-1372",
        "issue_numbers": [
            "1399",
            "919"
        ],
        "base_commit": "96efd620072a0cbdccc95b58901894111f17bb3a",
        "patch": "diff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -13,13 +13,13 @@\n //!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n-//! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n+//! | |         For the kernel code, 1 GiB. Mapped frames are tracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n //! +-+ <- 0xffff_ff00_0000_0000\n //! | |         For frame metadata, 1 TiB.\n-//! | |         Mapped frames are untracked.\n+//! | |         Mapped frames are tracked with handles.\n //! +-+ <- 0xffff_fe00_0000_0000\n //! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -104,6 +104,13 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// Returns whether the given address should be mapped as tracked.\n+///\n+/// About what is tracked mapping, see [`crate::mm::page::meta::MapTrackingStatus`].\n+pub(crate) fn should_map_as_tracked(addr: Vaddr) -> bool {\n+    !LINEAR_MAPPING_VADDR_RANGE.contains(&addr)\n+}\n+\n /// The kernel page table instance.\n ///\n /// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\ndiff --git a/ostd/src/mm/page/meta.rs b/ostd/src/mm/page/meta.rs\n--- a/ostd/src/mm/page/meta.rs\n+++ b/ostd/src/mm/page/meta.rs\n@@ -180,29 +180,50 @@ impl Sealed for FrameMeta {}\n /// Make sure the the generic parameters don't effect the memory layout.\n #[derive(Debug)]\n #[repr(C)]\n-pub struct PageTablePageMeta<\n+pub(in crate::mm) struct PageTablePageMeta<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n+    /// The number of valid PTEs. It is mutable if the lock is held.\n+    pub nr_children: UnsafeCell<u16>,\n+    /// The level of the page table page. A page table page cannot be\n+    /// referenced by page tables of different levels.\n     pub level: PagingLevel,\n+    /// Whether the pages mapped by the node is tracked.\n+    pub is_tracked: MapTrackingStatus,\n     /// The lock for the page table page.\n     pub lock: AtomicU8,\n-    /// The number of valid PTEs. It is mutable if the lock is held.\n-    pub nr_children: UnsafeCell<u16>,\n     _phantom: core::marker::PhantomData<(E, C)>,\n }\n \n+/// Describe if the physical address recorded in this page table refers to a\n+/// page tracked by metadata.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+#[repr(u8)]\n+pub(in crate::mm) enum MapTrackingStatus {\n+    /// The page table node cannot contain references to any pages. It can only\n+    /// contain references to child page table nodes.\n+    NotApplicable,\n+    /// The mapped pages are not tracked by metadata. If any child page table\n+    /// nodes exist, they should also be tracked.\n+    Untracked,\n+    /// The mapped pages are tracked by metadata. If any child page table nodes\n+    /// exist, they should also be tracked.\n+    Tracked,\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTablePageMeta<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub fn new_locked(level: PagingLevel) -> Self {\n+    pub fn new_locked(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n         Self {\n+            nr_children: UnsafeCell::new(0),\n             level,\n+            is_tracked,\n             lock: AtomicU8::new(1),\n-            nr_children: UnsafeCell::new(0),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -119,25 +119,6 @@ impl<M: PageMeta> Page<M> {\n         }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The physical address must represent a valid page.\n-    ///\n-    /// And the caller must ensure the metadata slot pointed through the corresponding\n-    /// virtual address is initialized by holding a reference count of the page firstly.\n-    /// Otherwise the function may add a reference count to an unused page.\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        // SAFETY: The virtual address points to an initialized metadata slot.\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address.\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -248,20 +229,6 @@ impl DynPage {\n         Self { ptr }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This is the same as [`Page::inc_ref_count`].\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address of the start of the page\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -363,3 +330,22 @@ impl Drop for DynPage {\n         }\n     }\n }\n+\n+/// Increases the reference count of the page by one.\n+///\n+/// # Safety\n+///\n+/// The caller should ensure the following conditions:\n+///  1. The physical address must represent a valid page;\n+///  2. The caller must have already held a reference to the page.\n+pub(in crate::mm) unsafe fn inc_page_ref_count(paddr: Paddr) {\n+    debug_assert!(paddr % PAGE_SIZE == 0);\n+    debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n+\n+    let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n+    // SAFETY: The virtual address points to an initialized metadata slot.\n+    let slot = unsafe { &*(vaddr as *const MetaSlot) };\n+    let old = slot.ref_count.fetch_add(1, Ordering::Relaxed);\n+\n+    debug_assert!(old > 0);\n+}\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -65,17 +65,21 @@\n //! table cursor should add additional entry point checks to prevent these defined\n //! behaviors if they are not wanted.\n \n-use core::{any::TypeId, marker::PhantomData, mem::ManuallyDrop, ops::Range};\n+use core::{any::TypeId, marker::PhantomData, ops::Range};\n \n use align_ext::AlignExt;\n \n use super::{\n-    page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n+    page_size, pte_index, Child, Entry, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n use crate::{\n     mm::{\n-        page::{meta::PageTablePageMeta, DynPage, Page},\n+        kspace::should_map_as_tracked,\n+        page::{\n+            meta::{MapTrackingStatus, PageTablePageMeta},\n+            DynPage, Page,\n+        },\n         Paddr, PageProperty, Vaddr,\n     },\n     task::{disable_preempt, DisabledPreemptGuard},\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -134,6 +138,7 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n+    #[allow(dead_code)]\n     preempt_guard: DisabledPreemptGuard,\n     _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -190,12 +195,15 @@ where\n                 break;\n             }\n \n-            let cur_pte = cursor.read_cur_pte();\n-            if !cur_pte.is_present() || cur_pte.is_last(cursor.level) {\n+            let entry = cursor.cur_entry();\n+            if !entry.is_node() {\n                 break;\n             }\n+            let Child::PageTable(child_pt) = entry.to_owned() else {\n+                unreachable!(\"Already checked\");\n+            };\n \n-            cursor.level_down();\n+            cursor.push_level(child_pt.lock());\n \n             // Release the guard of the previous (upper) level.\n             cursor.guards[cursor.level as usize] = None;\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -215,9 +223,9 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            match self.cur_child() {\n-                Child::PageTable(_) => {\n-                    self.level_down();\n+            match self.cur_entry().to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.push_level(pt.lock());\n                     continue;\n                 }\n                 Child::None => {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -229,7 +237,8 @@ where\n                 Child::Page(page, prop) => {\n                     return Ok(PageTableItem::Mapped { va, page, prop });\n                 }\n-                Child::Untracked(pa, prop) => {\n+                Child::Untracked(pa, plevel, prop) => {\n+                    debug_assert_eq!(plevel, level);\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -249,7 +258,7 @@ where\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\n-            self.level_up();\n+            self.pop_level();\n         }\n         self.va = next_va;\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -283,7 +292,7 @@ where\n             }\n \n             debug_assert!(self.level < self.guard_level);\n-            self.level_up();\n+            self.pop_level();\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -291,70 +300,37 @@ where\n         self.va\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.preempt_guard\n-    }\n-\n-    /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n-    /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n-    /// cursor is dropped.\n+    /// Goes up a level.\n+    ///\n+    /// We release the current page if it has no mappings since the cursor\n+    /// only moves forward. And if needed we will do the final cleanup using\n+    /// this method after re-walk when the cursor is dropped.\n     ///\n-    /// This method requires locks acquired before calling it. The discarded level will be unlocked.\n-    fn level_up(&mut self) {\n+    /// This method requires locks acquired before calling it. The discarded\n+    /// level will be unlocked.\n+    fn pop_level(&mut self) {\n         self.guards[(self.level - 1) as usize] = None;\n         self.level += 1;\n \n         // TODO: Drop page tables if page tables become empty.\n     }\n \n-    /// Goes down a level assuming a child page table exists.\n-    fn level_down(&mut self) {\n-        debug_assert!(self.level > 1);\n-\n-        let Child::PageTable(nxt_lvl_ptn) = self.cur_child() else {\n-            panic!(\"Trying to level down when it is not mapped to a page table\");\n-        };\n-\n-        let nxt_lvl_ptn_locked = nxt_lvl_ptn.lock();\n-\n+    /// Goes down a level to a child page table.\n+    fn push_level(&mut self, child_pt: PageTableNode<E, C>) {\n         self.level -= 1;\n-        debug_assert_eq!(self.level, nxt_lvl_ptn_locked.level());\n-\n-        self.guards[(self.level - 1) as usize] = Some(nxt_lvl_ptn_locked);\n+        debug_assert_eq!(self.level, child_pt.level());\n+        self.guards[(self.level - 1) as usize] = Some(child_pt);\n     }\n \n-    fn cur_node(&self) -> &PageTableNode<E, C> {\n-        self.guards[(self.level - 1) as usize].as_ref().unwrap()\n+    fn should_map_as_tracked(&self) -> bool {\n+        (TypeId::of::<M>() == TypeId::of::<KernelMode>()\n+            || TypeId::of::<M>() == TypeId::of::<UserMode>())\n+            && should_map_as_tracked(self.va)\n     }\n \n-    fn cur_idx(&self) -> usize {\n-        pte_index::<C>(self.va, self.level)\n-    }\n-\n-    fn cur_child(&self) -> Child<E, C> {\n-        self.cur_node()\n-            .child(self.cur_idx(), self.in_tracked_range())\n-    }\n-\n-    fn read_cur_pte(&self) -> E {\n-        self.cur_node().read_pte(self.cur_idx())\n-    }\n-\n-    /// Tells if the current virtual range must contain untracked mappings.\n-    ///\n-    /// _Tracked mappings_ means that the mapped physical addresses (in PTEs) points to pages\n-    /// tracked by the metadata system. _Tracked mappings_ must be created with page handles.\n-    /// While _untracked mappings_ solely maps to plain physical addresses.\n-    ///\n-    /// In the kernel mode, this is aligned with the definition in [`crate::mm::kspace`].\n-    /// Only linear mappings in the kernel should be considered as untracked mappings.\n-    ///\n-    /// All mappings in the user mode are tracked. And all mappings in the IOMMU\n-    /// page table are untracked.\n-    fn in_tracked_range(&self) -> bool {\n-        TypeId::of::<M>() == TypeId::of::<UserMode>()\n-            || TypeId::of::<M>() == TypeId::of::<KernelMode>()\n-                && !crate::mm::kspace::LINEAR_MAPPING_VADDR_RANGE.contains(&self.va)\n+    fn cur_entry(&mut self) -> Entry<'_, E, C> {\n+        let node = self.guards[(self.level - 1) as usize].as_mut().unwrap();\n+        node.entry(pte_index::<C>(self.va, self.level))\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -445,30 +421,38 @@ where\n     pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n-        debug_assert!(self.0.in_tracked_range());\n \n         // Go down if not applicable.\n         while self.0.level > C::HIGHEST_TRANSLATION_LEVEL\n             || self.0.va % page_size::<C>(self.0.level) != 0\n             || self.0.va + page_size::<C>(self.0.level) > end\n         {\n-            let pte = self.0.read_cur_pte();\n-            if pte.is_present() && !pte.is_last(self.0.level) {\n-                self.0.level_down();\n-            } else if !pte.is_present() {\n-                self.level_down_create();\n-            } else {\n-                panic!(\"Mapping a smaller page in an already mapped huge page\");\n+            debug_assert!(self.0.should_map_as_tracked());\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n+            match cur_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.0.push_level(pt.lock());\n+                }\n+                Child::None => {\n+                    let pt =\n+                        PageTableNode::<E, C>::alloc(cur_level - 1, MapTrackingStatus::Tracked);\n+                    let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                    self.0.push_level(pt);\n+                }\n+                Child::Page(_, _) => {\n+                    panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Mapping a tracked page in an untracked range\");\n+                }\n             }\n             continue;\n         }\n         debug_assert_eq!(self.0.level, page.level());\n \n         // Map the current page.\n-        let idx = self.0.cur_idx();\n-        let old = self\n-            .cur_node_mut()\n-            .replace_child(idx, Child::Page(page, prop), true);\n+        let old = self.0.cur_entry().replace(Child::Page(page, prop));\n         self.0.move_forward();\n \n         match old {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -477,7 +461,7 @@ where\n             Child::PageTable(_) => {\n                 todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n             }\n-            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+            Child::Untracked(_, _, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n         }\n     }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -525,25 +509,40 @@ where\n                 || self.0.va + page_size::<C>(self.0.level) > end\n                 || pa % page_size::<C>(self.0.level) != 0\n             {\n-                let pte = self.0.read_cur_pte();\n-                if pte.is_present() && !pte.is_last(self.0.level) {\n-                    self.0.level_down();\n-                } else if !pte.is_present() {\n-                    self.level_down_create();\n-                } else {\n-                    self.level_down_split();\n+                let cur_level = self.0.level;\n+                let cur_entry = self.0.cur_entry();\n+                match cur_entry.to_owned() {\n+                    Child::PageTable(pt) => {\n+                        self.0.push_level(pt.lock());\n+                    }\n+                    Child::None => {\n+                        let pt = PageTableNode::<E, C>::alloc(\n+                            cur_level - 1,\n+                            MapTrackingStatus::Untracked,\n+                        );\n+                        let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                        self.0.push_level(pt);\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Map the current page.\n-            debug_assert!(!self.0.in_tracked_range());\n-            let idx = self.0.cur_idx();\n+            debug_assert!(!self.0.should_map_as_tracked());\n+            let level = self.0.level;\n             let _ = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::Untracked(pa, prop), false);\n+                .0\n+                .cur_entry()\n+                .replace(Child::Untracked(pa, level, prop));\n \n-            let level = self.0.level;\n+            // Move forward.\n             pa += page_size::<C>(level);\n             self.0.move_forward();\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -580,11 +579,12 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            let is_tracked = self.0.in_tracked_range();\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n \n             // Skip if it is already absent.\n-            if !cur_pte.is_present() {\n+            if cur_entry.is_none() {\n                 if self.0.va + page_size::<C>(self.0.level) > end {\n                     self.0.va = end;\n                     break;\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -593,64 +593,61 @@ where\n                 continue;\n             }\n \n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if !is_tracked {\n-                    // Level down if we are removing part of a huge untracked page.\n-                    self.level_down_split();\n-                    continue;\n-                }\n-\n-                if cur_pte.is_last(self.0.level) {\n-                    panic!(\"removing part of a huge page\");\n-                }\n-\n-                // Level down if the current PTE points to a page table and we cannot\n-                // unmap this page table node entirely.\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n-                    self.0.move_forward();\n+            // Go down if not applicable.\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let child = cur_entry.to_owned();\n+                match child {\n+                    Child::PageTable(pt) => {\n+                        let pt = pt.lock();\n+                        // If there's no mapped PTEs in the next level, we can\n+                        // skip to save time.\n+                        if pt.nr_children() != 0 {\n+                            self.0.push_level(pt);\n+                        } else {\n+                            if self.0.va + page_size::<C>(self.0.level) > end {\n+                                self.0.va = end;\n+                                break;\n+                            }\n+                            self.0.move_forward();\n+                        }\n+                    }\n+                    Child::None => {\n+                        unreachable!(\"Already checked\");\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Removing part of a huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Unmap the current page and return it.\n-            let idx = self.0.cur_idx();\n-            let ret = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::None, is_tracked);\n-            let ret_page_va = self.0.va;\n-            let ret_page_size = page_size::<C>(self.0.level);\n+            let old = cur_entry.replace(Child::None);\n \n             self.0.move_forward();\n \n-            return match ret {\n+            return match old {\n                 Child::Page(page, prop) => PageTableItem::Mapped {\n-                    va: ret_page_va,\n+                    va: self.0.va,\n                     page,\n                     prop,\n                 },\n-                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n-                    va: ret_page_va,\n-                    pa,\n-                    len: ret_page_size,\n-                    prop,\n-                },\n-                Child::PageTable(node) => {\n-                    let node = ManuallyDrop::new(node);\n-                    let page = Page::<PageTablePageMeta<E, C>>::from_raw(node.paddr());\n-                    PageTableItem::PageTableNode { page: page.into() }\n+                Child::Untracked(pa, level, prop) => {\n+                    debug_assert_eq!(level, self.0.level);\n+                    PageTableItem::MappedUntracked {\n+                        va: self.0.va,\n+                        pa,\n+                        len: page_size::<C>(level),\n+                        prop,\n+                    }\n                 }\n+                Child::PageTable(node) => PageTableItem::PageTableNode {\n+                    page: Page::<PageTablePageMeta<E, C>>::from(node).into(),\n+                },\n                 Child::None => unreachable!(),\n             };\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -692,51 +689,46 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let mut cur_entry = self.0.cur_entry();\n+\n+            // Skip if it is already absent.\n+            if cur_entry.is_none() {\n                 self.0.move_forward();\n                 continue;\n             }\n \n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(self.0.level) {\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n+            // Go down if it's not a last entry.\n+            if cur_entry.is_node() {\n+                let Child::PageTable(pt) = cur_entry.to_owned() else {\n+                    unreachable!(\"Already checked\");\n+                };\n+                let pt = pt.lock();\n+                // If there's no mapped PTEs in the next level, we can\n+                // skip to save time.\n+                if pt.nr_children() != 0 {\n+                    self.0.push_level(pt);\n+                } else {\n                     self.0.move_forward();\n                 }\n-\n                 continue;\n             }\n \n             // Go down if the page size is too big and we are protecting part\n             // of untracked huge pages.\n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if self.0.in_tracked_range() {\n-                    panic!(\"protecting part of a huge page\");\n-                } else {\n-                    self.level_down_split();\n-                    continue;\n-                }\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let split_child = cur_entry\n+                    .split_if_untracked_huge()\n+                    .expect(\"Protecting part of a huge page\");\n+                self.0.push_level(split_child);\n+                continue;\n             }\n \n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+            // Protect the current page.\n+            cur_entry.protect(op);\n \n-            let idx = self.0.cur_idx();\n-            self.cur_node_mut().protect(idx, pte_prop);\n             let protected_va = self.0.va..self.0.va + page_size::<C>(self.0.level);\n-\n             self.0.move_forward();\n \n             return Some(protected_va);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -785,91 +777,46 @@ where\n         assert!(src_end <= src.0.barrier_va.end);\n \n         while self.0.va < this_end && src.0.va < src_end {\n-            let cur_pte = src.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n-                src.0.move_forward();\n-                continue;\n-            }\n-\n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(src.0.level) {\n-                src.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if src.0.guards[(src.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    src.0.level_up();\n+            let src_va = src.0.va;\n+            let mut src_entry = src.0.cur_entry();\n+\n+            match src_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    let pt = pt.lock();\n+                    // If there's no mapped PTEs in the next level, we can\n+                    // skip to save time.\n+                    if pt.nr_children() != 0 {\n+                        src.0.push_level(pt);\n+                    } else {\n+                        src.0.move_forward();\n+                    }\n+                    continue;\n+                }\n+                Child::None => {\n                     src.0.move_forward();\n+                    continue;\n                 }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Copying untracked mappings\");\n+                }\n+                Child::Page(page, mut prop) => {\n+                    let mapped_page_size = page.size();\n \n-                continue;\n-            }\n-\n-            // Do protection.\n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+                    // Do protection.\n+                    src_entry.protect(op);\n \n-            let idx = src.0.cur_idx();\n-            src.cur_node_mut().protect(idx, pte_prop);\n+                    // Do copy.\n+                    op(&mut prop);\n+                    self.jump(src_va).unwrap();\n+                    let original = self.map(page, prop);\n+                    assert!(original.is_none());\n \n-            // Do copy.\n-            let child = src.cur_node_mut().child(idx, true);\n-            let Child::<E, C>::Page(page, prop) = child else {\n-                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n-            };\n-            self.jump(src.0.va).unwrap();\n-            let mapped_page_size = page.size();\n-            let original = self.map(page, prop);\n-            debug_assert!(original.is_none());\n-\n-            // Only move the source cursor forward since `Self::map` will do it.\n-            // This assertion is to ensure that they move by the same length.\n-            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n-            src.0.move_forward();\n+                    // Only move the source cursor forward since `Self::map` will do it.\n+                    // This assertion is to ensure that they move by the same length.\n+                    debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+                    src.0.move_forward();\n+                }\n+            }\n         }\n     }\n-\n-    /// Goes down a level assuming the current slot is absent.\n-    ///\n-    /// This method will create a new child page table node and go down to it.\n-    fn level_down_create(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n-        let idx = self.0.cur_idx();\n-        let is_tracked = self.0.in_tracked_range();\n-        let old = self.cur_node_mut().replace_child(\n-            idx,\n-            Child::PageTable(new_node.clone_raw()),\n-            is_tracked,\n-        );\n-        debug_assert!(old.is_none());\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n-    }\n-\n-    /// Goes down a level assuming the current slot is an untracked huge page.\n-    ///\n-    /// This method will split the huge page and go down to the next level.\n-    fn level_down_split(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        debug_assert!(!self.0.in_tracked_range());\n-\n-        let idx = self.0.cur_idx();\n-        self.cur_node_mut().split_untracked_huge(idx);\n-\n-        let Child::PageTable(new_node) = self.0.cur_child() else {\n-            unreachable!();\n-        };\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node.lock());\n-    }\n-\n-    fn cur_node_mut(&mut self) -> &mut PageTableNode<E, C> {\n-        self.0.guards[(self.0.level - 1) as usize].as_mut().unwrap()\n-    }\n }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,8 +3,8 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, page_prop::PageProperty, page_size, Paddr, PagingConstsTrait, PagingLevel,\n-    Vaddr,\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size, Paddr,\n+    PagingConstsTrait, PagingLevel, Vaddr,\n };\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -100,16 +100,17 @@ impl PageTable<KernelMode> {\n     /// This should be the only way to create the user page table, that is to\n     /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n-        let root_node = self.root.clone_shallow().lock();\n-        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n+        let mut root_node = self.root.clone_shallow().lock();\n+        let mut new_node =\n+            PageTableNode::alloc(PagingConsts::NR_LEVELS, MapTrackingStatus::NotApplicable);\n \n         // Make a shallow copy of the root node in the kernel space range.\n         // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n         for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n-            let child = root_node.child(i, /* meaningless */ true);\n-            if !child.is_none() {\n-                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            let root_entry = root_node.entry(i);\n+            if !root_entry.is_none() {\n+                let _ = new_node.entry(i).replace(root_entry.to_owned());\n             }\n         }\n \ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -136,13 +137,18 @@ impl PageTable<KernelMode> {\n \n         let mut root_node = self.root.clone_shallow().lock();\n         for i in start..end {\n-            if !root_node.read_pte(i).is_present() {\n-                let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                let _ = root_node.replace_child(\n-                    i,\n-                    Child::PageTable(node.into_raw()),\n-                    i < NR_PTES_PER_NODE * 3 / 4,\n-                );\n+            let root_entry = root_node.entry(i);\n+            if root_entry.is_none() {\n+                let nxt_level = PagingConsts::NR_LEVELS - 1;\n+                let is_tracked = if super::kspace::should_map_as_tracked(\n+                    i * page_size::<PagingConsts>(nxt_level),\n+                ) {\n+                    MapTrackingStatus::Tracked\n+                } else {\n+                    MapTrackingStatus::Untracked\n+                };\n+                let node = PageTableNode::alloc(nxt_level, is_tracked);\n+                let _ = root_entry.replace(Child::PageTable(node.into_raw()));\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -175,7 +181,8 @@ where\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n     pub fn empty() -> Self {\n         PageTable {\n-            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n+            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS, MapTrackingStatus::NotApplicable)\n+                .into_raw(),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git /dev/null b/ostd/src/mm/page_table/node/child.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -0,0 +1,172 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module specifies the type of the children of a page table node.\n+\n+use core::{mem::ManuallyDrop, panic};\n+\n+use super::{PageTableEntryTrait, RawPageTableNode};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    mm::{\n+        page::{inc_page_ref_count, meta::MapTrackingStatus, DynPage},\n+        page_prop::PageProperty,\n+        Paddr, PagingConstsTrait, PagingLevel,\n+    },\n+};\n+\n+/// A child of a page table node.\n+///\n+/// This is a owning handle to a child of a page table node. If the child is\n+/// either a page table node or a page, it holds a reference count to the\n+/// corresponding page.\n+#[derive(Debug)]\n+pub(in crate::mm) enum Child<\n+    E: PageTableEntryTrait = PageTableEntry,\n+    C: PagingConstsTrait = PagingConsts,\n+> where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    PageTable(RawPageTableNode<E, C>),\n+    Page(DynPage, PageProperty),\n+    /// Pages not tracked by handles.\n+    Untracked(Paddr, PagingLevel, PageProperty),\n+    None,\n+}\n+\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns whether the child does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+\n+    /// Returns whether the child is compatible with the given node.\n+    ///\n+    /// In other words, it checks whether the child can be a child of a node\n+    /// with the given level and tracking status.\n+    pub(super) fn is_compatible(\n+        &self,\n+        node_level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> bool {\n+        match self {\n+            Child::PageTable(pt) => node_level == pt.level() + 1,\n+            Child::Page(p, _) => {\n+                node_level == p.level() && is_tracked == MapTrackingStatus::Tracked\n+            }\n+            Child::Untracked(_, level, _) => {\n+                node_level == *level && is_tracked == MapTrackingStatus::Untracked\n+            }\n+            Child::None => true,\n+        }\n+    }\n+\n+    /// Converts a child into a owning PTE.\n+    ///\n+    /// By conversion it loses information about whether the page is tracked\n+    /// or not. Also it loses the level information. However, the returned PTE\n+    /// takes the ownership (reference count) of the child.\n+    ///\n+    /// Usually this is for recording the PTE into a page table node. When the\n+    /// child is needed again by reading the PTE of a page table node, extra\n+    /// information should be provided using the [`Child::from_pte`] method.\n+    pub(super) fn into_pte(self) -> E {\n+        match self {\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                E::new_pt(pt.paddr())\n+            }\n+            Child::Page(page, prop) => {\n+                let level = page.level();\n+                E::new_page(page.into_raw(), level, prop)\n+            }\n+            Child::Untracked(pa, level, prop) => E::new_page(pa, level, prop),\n+            Child::None => E::new_absent(),\n+        }\n+    }\n+\n+    /// Converts a PTE back to a child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`]. And the\n+    /// provided information (level and tracking status) must be the same with\n+    /// the lost information during the conversion. Strictly speaking, the\n+    /// provided arguments must be compatible with the original child (\n+    /// specified by [`Child::is_compatible`]).\n+    ///\n+    /// This method should be only used no more than once for a PTE that has\n+    /// been converted from a child using the [`Child::into_pte`] method.\n+    pub(super) unsafe fn from_pte(\n+        pte: E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+\n+    /// Gains an extra owning reference to the child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`], which is\n+    /// the same requirement as the [`Child::from_pte`] method.\n+    ///\n+    /// This method must not be used with a PTE that has been restored to a\n+    /// child using the [`Child::from_pte`] method.\n+    pub(super) unsafe fn clone_from_pte(\n+        pte: &E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address is valid and the PTE already owns\n+            // the reference to the page.\n+            unsafe { inc_page_ref_count(paddr) };\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address is valid and the PTE already owns\n+                // the reference to the page.\n+                unsafe { inc_page_ref_count(paddr) };\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/mm/page_table/node/entry.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/entry.rs\n@@ -0,0 +1,161 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module provides accessors to the page table entries in a node.\n+\n+use super::{Child, PageTableEntryTrait, PageTableNode};\n+use crate::mm::{\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size,\n+    PagingConstsTrait,\n+};\n+\n+/// A view of an entry in a page table node.\n+///\n+/// It can be borrowed from a node using the [`PageTableNode::entry`] method.\n+///\n+/// This is a static reference to an entry in a node that does not account for\n+/// a dynamic reference count to the child. It can be used to create a owned\n+/// handle, which is a [`Child`].\n+pub(in crate::mm) struct Entry<'a, E: PageTableEntryTrait, C: PagingConstsTrait>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// The page table entry.\n+    ///\n+    /// We store the page table entry here to optimize the number of reads from\n+    /// the node. We cannot hold a `&mut E` reference to the entry because that\n+    /// other CPUs may modify the memory location for accessed/dirty bits. Such\n+    /// accesses will violate the aliasing rules of Rust and cause undefined\n+    /// behaviors.\n+    pte: E,\n+    /// The index of the entry in the node.\n+    idx: usize,\n+    /// The node that contains the entry.\n+    node: &'a mut PageTableNode<E, C>,\n+}\n+\n+impl<'a, E: PageTableEntryTrait, C: PagingConstsTrait> Entry<'a, E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns if the entry does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        !self.pte.is_present()\n+    }\n+\n+    /// Returns if the entry maps to a page table node.\n+    pub(in crate::mm) fn is_node(&self) -> bool {\n+        self.pte.is_present() && !self.pte.is_last(self.node.level())\n+    }\n+\n+    /// Gets a owned handle to the child.\n+    pub(in crate::mm) fn to_owned(&self) -> Child<E, C> {\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information.\n+        unsafe { Child::clone_from_pte(&self.pte, self.node.level(), self.node.is_tracked()) }\n+    }\n+\n+    /// Operates on the mapping properties of the entry.\n+    ///\n+    /// It only modifies the properties if the entry is present.\n+    // FIXME: in x86_64, you can protect a page with neither of the RWX\n+    // permissions. This would make the page not accessible and leaked. Such a\n+    // behavior is memory-safe but wrong. In RISC-V there's no problem.\n+    pub(in crate::mm) fn protect(&mut self, op: &mut impl FnMut(&mut PageProperty)) {\n+        if !self.pte.is_present() {\n+            return;\n+        }\n+\n+        let prop = self.pte.prop();\n+        let mut new_prop = prop;\n+        op(&mut new_prop);\n+\n+        if prop == new_prop {\n+            return;\n+        }\n+\n+        self.pte.set_prop(new_prop);\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. We replace the PTE with a new one, which differs only in\n+        //     `PageProperty`, so it is still compatible with the current\n+        //     page table node.\n+        unsafe { self.node.write_pte(self.idx, self.pte) };\n+    }\n+\n+    /// Replaces the entry with a new child.\n+    ///\n+    /// The old child is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The method panics if the given child is not compatible with the node.\n+    /// The compatibility is specified by the [`Child::is_compatible`].\n+    pub(in crate::mm) fn replace(self, new_child: Child<E, C>) -> Child<E, C> {\n+        assert!(new_child.is_compatible(self.node.level(), self.node.is_tracked()));\n+\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information. The old PTE is overwritten by the new child\n+        // so that it is not used anymore.\n+        let old_child =\n+            unsafe { Child::from_pte(self.pte, self.node.level(), self.node.is_tracked()) };\n+\n+        if old_child.is_none() && !new_child.is_none() {\n+            *self.node.nr_children_mut() += 1;\n+        } else if !old_child.is_none() && new_child.is_none() {\n+            *self.node.nr_children_mut() -= 1;\n+        }\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. The new PTE is compatible with the page table node, as asserted above.\n+        unsafe { self.node.write_pte(self.idx, new_child.into_pte()) };\n+\n+        old_child\n+    }\n+\n+    /// Splits the entry to smaller pages if it maps to a untracked huge page.\n+    ///\n+    /// If the entry does map to a untracked huge page, it is split into smaller\n+    /// pages mapped by a child page table node. The new child page table node\n+    /// is returned.\n+    ///\n+    /// If the entry does not map to a untracked huge page, the method returns\n+    /// `None`.\n+    pub(in crate::mm) fn split_if_untracked_huge(self) -> Option<PageTableNode<E, C>> {\n+        let level = self.node.level();\n+\n+        if !(self.pte.is_last(level)\n+            && level > 1\n+            && self.node.is_tracked() == MapTrackingStatus::Untracked)\n+        {\n+            return None;\n+        }\n+\n+        let pa = self.pte.paddr();\n+        let prop = self.pte.prop();\n+\n+        let mut new_page = PageTableNode::<E, C>::alloc(level - 1, MapTrackingStatus::Untracked);\n+        for i in 0..nr_subpage_per_huge::<C>() {\n+            let small_pa = pa + i * page_size::<C>(level - 1);\n+            let _ = new_page\n+                .entry(i)\n+                .replace(Child::Untracked(small_pa, level - 1, prop));\n+        }\n+\n+        let _ = self.replace(Child::PageTable(new_page.clone_raw()));\n+\n+        Some(new_page)\n+    }\n+\n+    /// Create a new entry at the node.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bounds of the node.\n+    pub(super) unsafe fn new_at(node: &'a mut PageTableNode<E, C>, idx: usize) -> Self {\n+        // SAFETY: The index is within the bound.\n+        let pte = unsafe { node.read_pte(idx) };\n+        Self { pte, idx, node }\n+    }\n+}\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -25,19 +25,22 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n+mod child;\n+mod entry;\n \n-use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n+use core::{marker::PhantomData, mem::ManuallyDrop, sync::atomic::Ordering};\n+\n+pub(in crate::mm) use self::{child::Child, entry::Entry};\n+use super::{nr_subpage_per_huge, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n         paddr_to_vaddr,\n         page::{\n-            self,\n-            meta::{PageMeta, PageTablePageMeta, PageUsage},\n+            self, inc_page_ref_count,\n+            meta::{MapTrackingStatus, PageMeta, PageTablePageMeta, PageUsage},\n             DynPage, Page,\n         },\n-        page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n };\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -55,7 +58,8 @@ pub(super) struct RawPageTableNode<E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) raw: Paddr,\n+    raw: Paddr,\n+    level: PagingLevel,\n     _phantom: PhantomData<(E, C)>,\n }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -67,15 +71,14 @@ where\n         self.raw\n     }\n \n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.level\n+    }\n+\n     /// Converts a raw handle to an accessible handle by pertaining the lock.\n     pub(super) fn lock(self) -> PageTableNode<E, C> {\n-        // Prevent dropping the handle.\n-        let this = ManuallyDrop::new(self);\n-\n-        // SAFETY: The physical address in the raw handle is valid and we are\n-        // transferring the ownership to a new handle. No increment of the reference\n-        // count is needed.\n-        let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n+        let level = self.level;\n+        let page: Page<PageTablePageMeta<E, C>> = self.into();\n \n         // Acquire the lock.\n         while page\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -87,7 +90,9 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> { page, _private: () }\n+        debug_assert_eq!(page.meta().level, level);\n+\n+        PageTableNode::<E, C> { page }\n     }\n \n     /// Creates a copy of the handle.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -96,6 +101,7 @@ where\n \n         Self {\n             raw: self.raw,\n+            level: self.level,\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -112,12 +118,18 @@ where\n     /// The caller must ensure that the page table to be activated has\n     /// proper mappings for the kernel and has the correct const parameters\n     /// matching the current CPU.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Only top-level page tables can be activated using this function.\n     pub(crate) unsafe fn activate(&self) {\n         use crate::{\n             arch::mm::{activate_page_table, current_page_table_paddr},\n             mm::CachePolicy,\n         };\n \n+        assert_eq!(self.level, C::NR_LEVELS);\n+\n         let last_activated_paddr = current_page_table_paddr();\n \n         if last_activated_paddr == self.raw {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -132,6 +144,7 @@ where\n         // Restore and drop the last activated page table.\n         drop(Self {\n             raw: last_activated_paddr,\n+            level: C::NR_LEVELS,\n             _phantom: PhantomData,\n         });\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -152,11 +165,40 @@ where\n         // SAFETY: We have a reference count to the page and can safely increase the reference\n         // count by one more.\n         unsafe {\n-            Page::<PageTablePageMeta<E, C>>::inc_ref_count(self.paddr());\n+            inc_page_ref_count(self.paddr());\n+        }\n+    }\n+\n+    /// Restores the handle from the physical address and level.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the physical address is valid and points to\n+    /// a forgotten page table node. A forgotten page table node can only be\n+    /// restored once. The level must match the level of the page table node.\n+    unsafe fn from_raw_parts(paddr: Paddr, level: PagingLevel) -> Self {\n+        Self {\n+            raw: paddr,\n+            level,\n+            _phantom: PhantomData,\n         }\n     }\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> From<RawPageTableNode<E, C>>\n+    for Page<PageTablePageMeta<E, C>>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    fn from(raw: RawPageTableNode<E, C>) -> Self {\n+        let raw = ManuallyDrop::new(raw);\n+        // SAFETY: The physical address in the raw handle is valid and we are\n+        // transferring the ownership to a new handle. No increment of the reference\n+        // count is needed.\n+        unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(raw.paddr()) }\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for RawPageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -175,64 +217,49 @@ where\n /// of the page table. Dropping the page table node will also drop all handles if the page\n /// table node has no references. You can set the page table node as a child of another\n /// page table node.\n+#[derive(Debug)]\n pub(super) struct PageTableNode<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    _private: (),\n+    page: Page<PageTablePageMeta<E, C>>,\n }\n \n-// FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\n-// this field or implement the `Debug` trait also for `DisabledPreemptGuard`?\n-impl<E, C> fmt::Debug for PageTableNode<E, C>\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n-    E: PageTableEntryTrait,\n-    C: PagingConstsTrait,\n     [(); C::NR_LEVELS as usize]:,\n {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"PageTableEntryTrait\")\n-            .field(\"page\", &self.page)\n-            .finish()\n+    /// Borrows an entry in the node at a given index.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the index is not within the bound of\n+    /// [`nr_subpage_per_huge<C>`].\n+    pub(super) fn entry(&mut self, idx: usize) -> Entry<'_, E, C> {\n+        assert!(idx < nr_subpage_per_huge::<C>());\n+        // SAFETY: The index is within the bound.\n+        unsafe { Entry::new_at(self, idx) }\n     }\n-}\n \n-/// A child of a page table node.\n-#[derive(Debug)]\n-pub(super) enum Child<E: PageTableEntryTrait = PageTableEntry, C: PagingConstsTrait = PagingConsts>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage, PageProperty),\n-    /// Pages not tracked by handles.\n-    Untracked(Paddr, PageProperty),\n-    None,\n-}\n+    /// Gets the level of the page table node.\n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.page.meta().level\n+    }\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    pub(super) fn is_none(&self) -> bool {\n-        matches!(self, Child::None)\n+    /// Gets the tracking status of the page table node.\n+    pub(super) fn is_tracked(&self) -> MapTrackingStatus {\n+        self.page.meta().is_tracked\n     }\n-}\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n     /// Allocates a new empty page table node.\n     ///\n     /// This function returns an owning handle. The newly created handle does not\n     /// set the lock bit for performance as it is exclusive and unlocking is an\n     /// extra unnecessary expensive operation.\n-    pub(super) fn alloc(level: PagingLevel) -> Self {\n-        let meta = PageTablePageMeta::new_locked(level);\n+    pub(super) fn alloc(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n+        let meta = PageTablePageMeta::new_locked(level, is_tracked);\n         let page = page::allocator::alloc_single::<PageTablePageMeta<E, C>>(meta).unwrap();\n \n         // Zero out the page table node.\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -242,209 +269,76 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self { page, _private: () }\n-    }\n-\n-    pub fn level(&self) -> PagingLevel {\n-        self.meta().level\n+        Self { page }\n     }\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n         let this = ManuallyDrop::new(self);\n \n-        let raw = this.page.paddr();\n-\n+        // Release the lock.\n         this.page.meta().lock.store(0, Ordering::Release);\n \n-        RawPageTableNode {\n-            raw,\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is not changed.\n+        unsafe { RawPageTableNode::from_raw_parts(this.page.paddr(), this.page.meta().level) }\n     }\n \n     /// Gets a raw handle while still preserving the original handle.\n     pub(super) fn clone_raw(&self) -> RawPageTableNode<E, C> {\n-        core::mem::forget(self.page.clone());\n+        let page = ManuallyDrop::new(self.page.clone());\n \n-        RawPageTableNode {\n-            raw: self.page.paddr(),\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is increased by one.\n+        unsafe { RawPageTableNode::from_raw_parts(page.paddr(), page.meta().level) }\n     }\n \n-    /// Gets an extra reference of the child at the given index.\n-    pub(super) fn child(&self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            if !pte.is_last(self.level()) {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n-                unsafe {\n-                    Page::<PageTablePageMeta<E, C>>::inc_ref_count(paddr);\n-                }\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely\n-                // increase the reference count by one more.\n-                unsafe {\n-                    DynPage::inc_ref_count(paddr);\n-                }\n-                // SAFETY: The physical address of the PTE points to a forgotten\n-                // page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n-            } else {\n-                Child::Untracked(paddr, pte.prop())\n-            }\n-        }\n+    /// Gets the number of valid PTEs in the node.\n+    pub(super) fn nr_children(&self) -> u16 {\n+        // SAFETY: The lock is held so we have an exclusive access.\n+        unsafe { *self.page.meta().nr_children.get() }\n     }\n \n-    /// Replace the child at the given index with a new child.\n+    /// Reads a non-owning PTE at the given index.\n     ///\n-    /// The old child is returned.\n-    pub(super) fn replace_child(\n-        &mut self,\n-        idx: usize,\n-        new_child: Child<E, C>,\n-        in_tracked_range: bool,\n-    ) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let old_pte = self.read_pte(idx);\n-\n-        let new_child_is_none = match new_child {\n-            Child::None => {\n-                if old_pte.is_present() {\n-                    self.write_pte(idx, E::new_absent());\n-                }\n-                true\n-            }\n-            Child::PageTable(pt) => {\n-                let pt = ManuallyDrop::new(pt);\n-                let new_pte = E::new_pt(pt.paddr());\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Page(page, prop) => {\n-                debug_assert!(in_tracked_range);\n-                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Untracked(pa, prop) => {\n-                debug_assert!(!in_tracked_range);\n-                let new_pte = E::new_page(pa, self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-        };\n-\n-        if old_pte.is_present() {\n-            if new_child_is_none {\n-                *self.nr_children_mut() -= 1;\n-            }\n-            let paddr = old_pte.paddr();\n-            if !old_pte.is_last(self.level()) {\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: The physical address of the old PTE points to a\n-                // forgotten page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n-            } else {\n-                Child::Untracked(paddr, old_pte.prop())\n-            }\n-        } else {\n-            if !new_child_is_none {\n-                *self.nr_children_mut() += 1;\n-            }\n-            Child::None\n-        }\n-    }\n-\n-    /// Splits the untracked huge page mapped at `idx` to smaller pages.\n-    pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n-        // These should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert!(self.level() > 1);\n-\n-        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n-            panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n-        };\n-\n-        let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n-        for i in 0..nr_subpage_per_huge::<C>() {\n-            let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n-        }\n-\n-        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n-    }\n-\n-    /// Protects an already mapped child at a given index.\n-    pub(super) fn protect(&mut self, idx: usize, prop: PageProperty) {\n-        let mut pte = self.read_pte(idx);\n-        debug_assert!(pte.is_present()); // This should be ensured by the cursor.\n-\n-        pte.set_prop(prop);\n-\n-        // SAFETY: the index is within the bound and the PTE is valid.\n-        unsafe {\n-            (self.as_ptr() as *mut E).add(idx).write(pte);\n-        }\n-    }\n-\n-    pub(super) fn read_pte(&self, idx: usize) -> E {\n-        // It should be ensured by the cursor.\n+    /// A non-owning PTE means that it does not account for a reference count\n+    /// of the a page if the PTE points to a page. The original PTE still owns\n+    /// the child page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bound.\n+    unsafe fn read_pte(&self, idx: usize) -> E {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { self.as_ptr().add(idx).read() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *const E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).read() }\n     }\n \n     /// Writes a page table entry at a given index.\n     ///\n-    /// This operation will leak the old child if the PTE is present.\n-    fn write_pte(&mut self, idx: usize, pte: E) {\n-        // It should be ensured by the cursor.\n+    /// This operation will leak the old child if the old PTE is present.\n+    ///\n+    /// The child represented by the given PTE will handover the ownership to\n+    /// the node. The PTE will be rendered invalid after this operation.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that:\n+    ///  1. The index must be within the bound;\n+    ///  2. The PTE must represent a child compatible with this page table node\n+    ///     (see [`Child::is_compatible`]).\n+    unsafe fn write_pte(&mut self, idx: usize, pte: E) {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { (self.as_ptr() as *mut E).add(idx).write(pte) };\n-    }\n-\n-    /// The number of valid PTEs.\n-    pub(super) fn nr_children(&self) -> u16 {\n-        // SAFETY: The lock is held so there is no mutable reference to it.\n-        // It would be safe to read.\n-        unsafe { *self.meta().nr_children.get() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *mut E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).write(pte) }\n     }\n \n+    /// Gets the mutable reference to the number of valid PTEs in the node.\n     fn nr_children_mut(&mut self) -> &mut u16 {\n         // SAFETY: The lock is held so we have an exclusive access.\n-        unsafe { &mut *self.meta().nr_children.get() }\n-    }\n-\n-    fn as_ptr(&self) -> *const E {\n-        paddr_to_vaddr(self.start_paddr()) as *const E\n-    }\n-\n-    fn start_paddr(&self) -> Paddr {\n-        self.page.paddr()\n-    }\n-\n-    fn meta(&self) -> &PageTablePageMeta<E, C> {\n-        self.page.meta()\n+        unsafe { &mut *self.page.meta().nr_children.get() }\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -465,8 +359,16 @@ where\n     const USAGE: PageUsage = PageUsage::PageTable;\n \n     fn on_drop(page: &mut Page<Self>) {\n+        // SAFETY: This is the last reference so we have an exclusive access.\n+        let nr_children = unsafe { *page.meta().nr_children.get() };\n+\n+        if nr_children == 0 {\n+            return;\n+        }\n+\n         let paddr = page.paddr();\n         let level = page.meta().level;\n+        let is_tracked = page.meta().is_tracked;\n \n         // Drop the children.\n         for i in 0..nr_subpage_per_huge::<C>() {\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -476,19 +378,21 @@ where\n             let pte_ptr = unsafe { (paddr_to_vaddr(paddr) as *const E).add(i) };\n             // SAFETY: The pointer is valid and the PTE is plain-old-data.\n             let pte = unsafe { pte_ptr.read() };\n+\n+            // Here if we use directly `Child::from_pte` we would experience a\n+            // 50% increase in the overhead of the `drop` function. It seems that\n+            // Rust is very conservative about inlining and optimizing dead code\n+            // for `unsafe` code. So we manually inline the function here.\n             if pte.is_present() {\n-                // Just restore the handle and drop the handle.\n+                let paddr = pte.paddr();\n                 if !pte.is_last(level) {\n-                    // This is a page table.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page table node.\n-                    drop(unsafe { Page::<Self>::from_raw(pte.paddr()) });\n-                } else {\n-                    // This is a page. You cannot drop a page table node that maps to\n-                    // untracked pages. This must be verified.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page.\n-                    drop(unsafe { DynPage::from_raw(pte.paddr()) });\n+                    // SAFETY: The PTE points to a page table node. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { Page::<Self>::from_raw(paddr) });\n+                } else if is_tracked == MapTrackingStatus::Tracked {\n+                    // SAFETY: The PTE points to a tracked page. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { DynPage::from_raw(paddr) });\n                 }\n             }\n         }\n",
        "test_patch": "",
        "problem_statement": "Silently failed ktest in OSTD: untracked_map_unmap\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/11101937778/job/30840638910#step:6:634\r\n\r\nThe ktest `test_untracked_map_unmap` failed, but CI doesn't notice it. The failure is reproducible locally.\r\n\r\n### To Reproduce\r\n\r\n```bash\r\ncd ostd && cargo osdk test test_untracked_map_unmap\r\n```\r\n\n[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "\nI've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-24T09:24:48Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1328,
        "instance_id": "asterinas__asterinas-1328",
        "issue_numbers": [
            "1244"
        ],
        "base_commit": "42e28763c59202486af4298d5305e5c5e5ab9b54",
        "patch": "diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -133,10 +133,7 @@ fn ap_init() -> ! {\n }\n \n fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n+    println!(\"[kernel] Spawn init thread\");\n     // Work queue should be initialized before interrupt is enabled,\n     // in case any irq handler uses work queue as bottom half\n     thread::work_queue::init();\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -4,11 +4,12 @@ use core::sync::atomic::Ordering;\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \n use super::{\n-    posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n+    posix_thread::{thread_table, PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n     process_table,\n     process_vm::ProcessVm,\n     signal::sig_disposition::SigDispositions,\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -18,7 +19,8 @@ use crate::{\n     cpu::LinuxAbi,\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n+    process::posix_thread::allocate_posix_tid,\n+    thread::{Thread, Tid},\n };\n \n bitflags! {\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -132,7 +134,8 @@ pub fn clone_child(\n ) -> Result<Tid> {\n     clone_args.clone_flags.check_unsupported_flags()?;\n     if clone_args.clone_flags.contains(CloneFlags::CLONE_THREAD) {\n-        let child_thread = clone_child_thread(ctx, parent_context, clone_args)?;\n+        let child_task = clone_child_task(ctx, parent_context, clone_args)?;\n+        let child_thread = Thread::borrow_from_task(&child_task);\n         child_thread.run();\n \n         let child_tid = child_thread.tid();\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -146,11 +149,11 @@ pub fn clone_child(\n     }\n }\n \n-fn clone_child_thread(\n+fn clone_child_task(\n     ctx: &Context,\n     parent_context: &UserContext,\n     clone_args: CloneArgs,\n-) -> Result<Arc<Thread>> {\n+) -> Result<Arc<Task>> {\n     let Context {\n         process,\n         posix_thread,\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -180,8 +183,8 @@ fn clone_child_thread(\n     // Inherit sigmask from current thread\n     let sig_mask = posix_thread.sig_mask().load(Ordering::Relaxed).into();\n \n-    let child_tid = allocate_tid();\n-    let child_thread = {\n+    let child_tid = allocate_posix_tid();\n+    let child_task = {\n         let credentials = {\n             let credentials = ctx.posix_thread.credentials();\n             Credentials::new_from(&credentials)\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -193,13 +196,13 @@ fn clone_child_thread(\n         thread_builder.build()\n     };\n \n-    process.threads().lock().push(child_thread.clone());\n+    process.tasks().lock().push(child_task.clone());\n \n-    let child_posix_thread = child_thread.as_posix_thread().unwrap();\n+    let child_posix_thread = child_task.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n     clone_child_settid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n-    Ok(child_thread)\n+    Ok(child_task)\n }\n \n fn clone_child_process(\ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -262,7 +265,7 @@ fn clone_child_process(\n     // inherit parent's nice value\n     let child_nice = process.nice().load(Ordering::Relaxed);\n \n-    let child_tid = allocate_tid();\n+    let child_tid = allocate_posix_tid();\n \n     let child = {\n         let child_elf_path = process.executable_path();\ndiff --git a/kernel/src/process/exit.rs b/kernel/src/process/exit.rs\n--- a/kernel/src/process/exit.rs\n+++ b/kernel/src/process/exit.rs\n@@ -4,9 +4,10 @@ use super::{process_table, Pid, Process, TermStatus};\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::do_exit,\n+        posix_thread::{do_exit, PosixThreadExt},\n         signal::{constants::SIGCHLD, signals::kernel::KernelSignal},\n     },\n+    thread::Thread,\n };\n \n pub fn do_exit_group(term_status: TermStatus) {\ndiff --git a/kernel/src/process/exit.rs b/kernel/src/process/exit.rs\n--- a/kernel/src/process/exit.rs\n+++ b/kernel/src/process/exit.rs\n@@ -18,9 +19,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     current.set_zombie(term_status);\n \n     // Exit all threads\n-    let threads = current.threads().lock().clone();\n-    for thread in threads {\n-        if let Err(e) = do_exit(thread, term_status) {\n+    let tasks = current.tasks().lock().clone();\n+    for task in tasks {\n+        let thread = Thread::borrow_from_task(&task);\n+        let posix_thread = thread.as_posix_thread().unwrap();\n+        if let Err(e) = do_exit(thread, posix_thread, term_status) {\n             debug!(\"Ignore error when call exit: {:?}\", e);\n         }\n     }\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -1,7 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{thread_table, PosixThreadExt},\n     process_table,\n     signal::{\n         constants::SIGCONT,\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -10,10 +10,7 @@ use super::{\n     },\n     Pgid, Pid, Process, Sid, Uid,\n };\n-use crate::{\n-    prelude::*,\n-    thread::{thread_table, Tid},\n-};\n+use crate::{prelude::*, thread::Tid};\n \n /// Sends a signal to a process, using the current process as the sender.\n ///\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -120,14 +117,14 @@ pub fn kill_all(signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n }\n \n fn kill_process(process: &Process, signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n-    let threads = process.threads().lock();\n+    let tasks = process.tasks().lock();\n \n     let signum = signal.map(|signal| signal.num());\n     let sender_ids = current_thread_sender_ids(signum.as_ref(), ctx);\n \n     let mut permitted_thread = None;\n-    for thread in threads.iter() {\n-        let posix_thread = thread.as_posix_thread().unwrap();\n+    for task in tasks.iter() {\n+        let posix_thread = task.as_posix_thread().unwrap();\n \n         // First check permission\n         if posix_thread\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -2,9 +2,9 @@\n \n #![allow(dead_code)]\n \n-use ostd::user::UserSpace;\n+use ostd::{task::Task, user::UserSpace};\n \n-use super::PosixThread;\n+use super::{thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -12,7 +12,7 @@ use crate::{\n         signal::{sig_mask::AtomicSigMask, sig_queues::SigQueues},\n         Credentials, Process,\n     },\n-    thread::{status::ThreadStatus, task, thread_table, Thread, Tid},\n+    thread::{status::ThreadStatus, task, Thread, Tid},\n     time::{clocks::ProfClock, TimerManager},\n };\n \ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -72,7 +72,7 @@ impl PosixThreadBuilder {\n         self\n     }\n \n-    pub fn build(self) -> Arc<Thread> {\n+    pub fn build(self) -> Arc<Task> {\n         let Self {\n             tid,\n             user_space,\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -85,34 +85,36 @@ impl PosixThreadBuilder {\n             sig_queues,\n         } = self;\n \n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let task = task::create_new_user_task(user_space, thread_ref.clone());\n-            let status = ThreadStatus::Init;\n-\n-            let prof_clock = ProfClock::new();\n-            let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n-            let prof_timer_manager = TimerManager::new(prof_clock.clone());\n-\n-            let posix_thread = PosixThread {\n-                process,\n-                name: Mutex::new(thread_name),\n-                set_child_tid: Mutex::new(set_child_tid),\n-                clear_child_tid: Mutex::new(clear_child_tid),\n-                credentials,\n-                sig_mask,\n-                sig_queues,\n-                sig_context: Mutex::new(None),\n-                sig_stack: Mutex::new(None),\n-                signalled_waker: SpinLock::new(None),\n-                robust_list: Mutex::new(None),\n-                prof_clock,\n-                virtual_timer_manager,\n-                prof_timer_manager,\n+        Arc::new_cyclic(|weak_task| {\n+            let posix_thread = {\n+                let prof_clock = ProfClock::new();\n+                let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n+                let prof_timer_manager = TimerManager::new(prof_clock.clone());\n+\n+                PosixThread {\n+                    process,\n+                    tid,\n+                    name: Mutex::new(thread_name),\n+                    set_child_tid: Mutex::new(set_child_tid),\n+                    clear_child_tid: Mutex::new(clear_child_tid),\n+                    credentials,\n+                    sig_mask,\n+                    sig_queues,\n+                    sig_context: Mutex::new(None),\n+                    sig_stack: Mutex::new(None),\n+                    signalled_waker: SpinLock::new(None),\n+                    robust_list: Mutex::new(None),\n+                    prof_clock,\n+                    virtual_timer_manager,\n+                    prof_timer_manager,\n+                }\n             };\n \n-            Thread::new(tid, task, posix_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n+            let status = ThreadStatus::Init;\n+            let thread = Arc::new(Thread::new(weak_task.clone(), posix_thread, status));\n+\n+            thread_table::add_thread(tid, thread.clone());\n+            task::create_new_user_task(user_space, thread)\n+        })\n     }\n }\ndiff --git a/kernel/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\n--- a/kernel/src/process/posix_thread/exit.rs\n+++ b/kernel/src/process/posix_thread/exit.rs\n@@ -1,10 +1,10 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use super::{futex::futex_wake, robust_list::wake_robust_futex, PosixThread, PosixThreadExt};\n+use super::{futex::futex_wake, robust_list::wake_robust_futex, thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{do_exit_group, TermStatus},\n-    thread::{thread_table, Thread, Tid},\n+    thread::{Thread, Tid},\n };\n \n /// Exits the thread if the thread is a POSIX thread.\ndiff --git a/kernel/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\n--- a/kernel/src/process/posix_thread/exit.rs\n+++ b/kernel/src/process/posix_thread/exit.rs\n@@ -12,15 +12,13 @@ use crate::{\n /// # Panics\n ///\n /// If the thread is not a POSIX thread, this method will panic.\n-pub fn do_exit(thread: Arc<Thread>, term_status: TermStatus) -> Result<()> {\n+pub fn do_exit(thread: &Thread, posix_thread: &PosixThread, term_status: TermStatus) -> Result<()> {\n     if thread.status().is_exited() {\n         return Ok(());\n     }\n     thread.exit();\n \n-    let tid = thread.tid();\n-\n-    let posix_thread = thread.as_posix_thread().unwrap();\n+    let tid = posix_thread.tid;\n \n     let mut clear_ctid = posix_thread.clear_child_tid().lock();\n     // If clear_ctid !=0 ,do a futex wake and write zero to the clear_ctid addr.\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -2,7 +2,7 @@\n \n #![allow(dead_code)]\n \n-use core::sync::atomic::Ordering;\n+use core::sync::atomic::{AtomicU32, Ordering};\n \n use aster_rights::{ReadOp, WriteOp};\n use ostd::sync::Waker;\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -22,7 +22,7 @@ use crate::{\n     events::Observer,\n     prelude::*,\n     process::signal::constants::SIGCONT,\n-    thread::Tid,\n+    thread::{Thread, Tid},\n     time::{clocks::ProfClock, Timer, TimerManager},\n };\n \ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -32,16 +32,19 @@ pub mod futex;\n mod name;\n mod posix_thread_ext;\n mod robust_list;\n+pub mod thread_table;\n \n pub use builder::PosixThreadBuilder;\n pub use exit::do_exit;\n pub use name::{ThreadName, MAX_THREAD_NAME_LEN};\n-pub use posix_thread_ext::PosixThreadExt;\n+pub use posix_thread_ext::{create_posix_task_from_executable, PosixThreadExt};\n pub use robust_list::RobustListHead;\n \n pub struct PosixThread {\n     // Immutable part\n     process: Weak<Process>,\n+    tid: Tid,\n+\n     // Mutable part\n     name: Mutex<Option<ThreadName>>,\n \ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -87,6 +90,11 @@ impl PosixThread {\n         Weak::clone(&self.process)\n     }\n \n+    /// Returns the thread id\n+    pub fn tid(&self) -> Tid {\n+        self.tid\n+    }\n+\n     pub fn thread_name(&self) -> &Mutex<Option<ThreadName>> {\n         &self.name\n     }\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -266,12 +274,10 @@ impl PosixThread {\n \n     fn is_last_thread(&self) -> bool {\n         let process = self.process.upgrade().unwrap();\n-        let threads = process.threads().lock();\n-        threads\n+        let tasks = process.tasks().lock();\n+        tasks\n             .iter()\n-            .filter(|thread| !thread.status().is_exited())\n-            .count()\n-            == 0\n+            .any(|task| !Thread::borrow_from_task(task).status().is_exited())\n     }\n \n     /// Gets the read-only credentials of the thread.\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -292,3 +298,10 @@ impl PosixThread {\n         self.credentials.dup().restrict()\n     }\n }\n+\n+static POSIX_TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n+\n+/// Allocates a new tid for the new posix thread\n+pub fn allocate_posix_tid() -> Tid {\n+    POSIX_TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n+}\ndiff --git a/kernel/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\n--- a/kernel/src/process/posix_thread/posix_thread_ext.rs\n+++ b/kernel/src/process/posix_thread/posix_thread_ext.rs\n@@ -2,6 +2,7 @@\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \ndiff --git a/kernel/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\n--- a/kernel/src/process/posix_thread/posix_thread_ext.rs\n+++ b/kernel/src/process/posix_thread/posix_thread_ext.rs\n@@ -13,52 +14,57 @@ use crate::{\n     thread::{Thread, Tid},\n };\n pub trait PosixThreadExt {\n+    /// Returns the thread id.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If the thread is not posix thread, this method will panic.\n+    fn tid(&self) -> Tid {\n+        self.as_posix_thread().unwrap().tid()\n+    }\n     fn as_posix_thread(&self) -> Option<&PosixThread>;\n-    #[allow(clippy::too_many_arguments)]\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>>;\n }\n \n impl PosixThreadExt for Thread {\n-    /// This function should only be called when launch shell()\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>> {\n-        let elf_file = {\n-            let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n-            fs_resolver.lookup(&fs_path)?\n-        };\n-        let (_, elf_load_info) =\n-            load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n-\n-        let vm_space = process_vm.root_vmar().vm_space().clone();\n-        let mut cpu_ctx = UserContext::default();\n-        cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n-        cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n-        let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n-        let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n-        let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n-            .thread_name(thread_name)\n-            .process(process);\n-        Ok(thread_builder.build())\n+    fn as_posix_thread(&self) -> Option<&PosixThread> {\n+        self.data().downcast_ref::<PosixThread>()\n     }\n+}\n \n+impl PosixThreadExt for Arc<Task> {\n     fn as_posix_thread(&self) -> Option<&PosixThread> {\n-        self.data().downcast_ref::<PosixThread>()\n+        Thread::borrow_from_task(self).as_posix_thread()\n     }\n }\n+\n+/// Creates a task for running an executable file.\n+///\n+/// This function should _only_ be used to create the init user task.\n+#[allow(clippy::too_many_arguments)]\n+pub fn create_posix_task_from_executable(\n+    tid: Tid,\n+    credentials: Credentials,\n+    process_vm: &ProcessVm,\n+    fs_resolver: &FsResolver,\n+    executable_path: &str,\n+    process: Weak<Process>,\n+    argv: Vec<CString>,\n+    envp: Vec<CString>,\n+) -> Result<Arc<Task>> {\n+    let elf_file = {\n+        let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n+        fs_resolver.lookup(&fs_path)?\n+    };\n+    let (_, elf_load_info) = load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n+\n+    let vm_space = process_vm.root_vmar().vm_space().clone();\n+    let mut cpu_ctx = UserContext::default();\n+    cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n+    cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n+    let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n+    let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n+    let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n+        .thread_name(thread_name)\n+        .process(process);\n+    Ok(thread_builder.build())\n+}\ndiff --git /dev/null b/kernel/src/process/posix_thread/thread_table.rs\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/src/process/posix_thread/thread_table.rs\n@@ -0,0 +1,22 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use super::{Thread, Tid};\n+use crate::{prelude::*, process::posix_thread::PosixThreadExt};\n+\n+static THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n+\n+/// Adds a posix thread to global thread table\n+pub fn add_thread(tid: Tid, thread: Arc<Thread>) {\n+    debug_assert_eq!(tid, thread.tid());\n+    THREAD_TABLE.lock().insert(tid, thread);\n+}\n+\n+/// Removes a posix thread to global thread table\n+pub fn remove_thread(tid: Tid) {\n+    THREAD_TABLE.lock().remove(&tid);\n+}\n+\n+/// Gets a posix thread from the global thread table\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n+    THREAD_TABLE.lock().get(&tid).cloned()\n+}\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -7,14 +7,13 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt},\n+        posix_thread::{create_posix_task_from_executable, PosixThreadBuilder},\n         process_vm::ProcessVm,\n         rlimit::ResourceLimits,\n         signal::sig_disposition::SigDispositions,\n         Credentials,\n     },\n     sched::nice::Nice,\n-    thread::Thread,\n };\n \n pub struct ProcessBuilder<'a> {\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -190,11 +189,11 @@ impl<'a> ProcessBuilder<'a> {\n             )\n         };\n \n-        let thread = if let Some(thread_builder) = main_thread_builder {\n+        let task = if let Some(thread_builder) = main_thread_builder {\n             let builder = thread_builder.process(Arc::downgrade(&process));\n             builder.build()\n         } else {\n-            Thread::new_posix_thread_from_executable(\n+            create_posix_task_from_executable(\n                 pid,\n                 credentials.unwrap(),\n                 process.vm(),\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -206,7 +205,7 @@ impl<'a> ProcessBuilder<'a> {\n             )?\n         };\n \n-        process.threads().lock().push(thread);\n+        process.tasks().lock().push(task);\n \n         process.set_runnable();\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -4,7 +4,7 @@ use core::sync::atomic::Ordering;\n \n use self::timer_manager::PosixTimerManager;\n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{allocate_posix_tid, PosixThreadExt},\n     process_table,\n     process_vm::{Heap, InitStackReader, ProcessVm},\n     rlimit::ResourceLimits,\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -21,7 +21,7 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     sched::nice::Nice,\n-    thread::{allocate_tid, Thread},\n+    thread::Thread,\n     time::clocks::ProfClock,\n     vm::vmar::Vmar,\n };\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -37,7 +37,7 @@ use aster_rights::Full;\n use atomic::Atomic;\n pub use builder::ProcessBuilder;\n pub use job_control::JobControl;\n-use ostd::sync::WaitQueue;\n+use ostd::{sync::WaitQueue, task::Task};\n pub use process_group::ProcessGroup;\n pub use session::Session;\n pub use terminal::Terminal;\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -68,7 +68,7 @@ pub struct Process {\n     /// The executable path.\n     executable_path: RwLock<String>,\n     /// The threads\n-    threads: Mutex<Vec<Arc<Thread>>>,\n+    tasks: Mutex<Vec<Arc<Task>>>,\n     /// Process status\n     status: ProcessStatus,\n     /// Parent process\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -167,14 +167,20 @@ impl Process {\n     ///  - the function is called in the bootstrap context;\n     ///  - or if the current task is not associated with a process.\n     pub fn current() -> Option<Arc<Process>> {\n-        Some(Thread::current()?.as_posix_thread()?.process())\n+        Some(\n+            Task::current()?\n+                .data()\n+                .downcast_ref::<Arc<Thread>>()?\n+                .as_posix_thread()?\n+                .process(),\n+        )\n     }\n \n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\n         parent: Weak<Process>,\n-        threads: Vec<Arc<Thread>>,\n+        tasks: Vec<Arc<Task>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -194,7 +200,7 @@ impl Process {\n \n         Arc::new_cyclic(|process_ref: &Weak<Process>| Self {\n             pid,\n-            threads: Mutex::new(threads),\n+            tasks: Mutex::new(tasks),\n             executable_path: RwLock::new(executable_path),\n             process_vm,\n             children_wait_queue,\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -236,7 +242,7 @@ impl Process {\n         envp: Vec<CString>,\n     ) -> Result<Arc<Self>> {\n         let process_builder = {\n-            let pid = allocate_tid();\n+            let pid = allocate_posix_tid();\n             let parent = Weak::new();\n \n             let credentials = Credentials::new_root();\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -271,13 +277,14 @@ impl Process {\n \n     /// start to run current process\n     pub fn run(&self) {\n-        let threads = self.threads.lock();\n+        let tasks = self.tasks.lock();\n         // when run the process, the process should has only one thread\n-        debug_assert!(threads.len() == 1);\n+        debug_assert!(tasks.len() == 1);\n         debug_assert!(self.is_runnable());\n-        let thread = threads[0].clone();\n+        let task = tasks[0].clone();\n         // should not hold the lock when run thread\n-        drop(threads);\n+        drop(tasks);\n+        let thread = Thread::borrow_from_task(&task);\n         thread.run();\n     }\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -297,8 +304,8 @@ impl Process {\n         &self.timer_manager\n     }\n \n-    pub fn threads(&self) -> &Mutex<Vec<Arc<Thread>>> {\n-        &self.threads\n+    pub fn tasks(&self) -> &Mutex<Vec<Arc<Task>>> {\n+        &self.tasks\n     }\n \n     pub fn executable_path(&self) -> String {\ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -318,10 +325,11 @@ impl Process {\n     }\n \n     pub fn main_thread(&self) -> Option<Arc<Thread>> {\n-        self.threads\n+        self.tasks\n             .lock()\n             .iter()\n-            .find(|thread| thread.tid() == self.pid)\n+            .find(|task| task.tid() == self.pid)\n+            .map(Thread::borrow_from_task)\n             .cloned()\n     }\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -644,7 +652,7 @@ impl Process {\n         // TODO: check that the signal is not user signal\n \n         // Enqueue signal to the first thread that does not block the signal\n-        let threads = self.threads.lock();\n+        let threads = self.tasks.lock();\n         for thread in threads.iter() {\n             let posix_thread = thread.as_posix_thread().unwrap();\n             if !posix_thread.has_signal_blocked(signal.num()) {\ndiff --git a/kernel/src/process/signal/pause.rs b/kernel/src/process/signal/pause.rs\n--- a/kernel/src/process/signal/pause.rs\n+++ b/kernel/src/process/signal/pause.rs\n@@ -86,16 +86,9 @@ impl Pause for Waiter {\n             return Ok(res);\n         }\n \n-        let current_thread = self\n-            .task()\n-            .data()\n-            .downcast_ref::<Weak<Thread>>()\n-            .and_then(|thread| thread.upgrade());\n-\n-        let Some(posix_thread) = current_thread\n-            .as_ref()\n-            .and_then(|thread| thread.as_posix_thread())\n-        else {\n+        let current_thread = self.task().data().downcast_ref::<Arc<Thread>>();\n+\n+        let Some(posix_thread) = current_thread.and_then(|thread| thread.as_posix_thread()) else {\n             if let Some(timeout) = timeout {\n                 return self.wait_until_or_timeout(cond, timeout);\n             } else {\ndiff --git a/kernel/src/process/wait.rs b/kernel/src/process/wait.rs\n--- a/kernel/src/process/wait.rs\n+++ b/kernel/src/process/wait.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use super::{\n-    process_filter::ProcessFilter,\n-    signal::{constants::SIGCHLD, with_signal_blocked},\n-    ExitCode, Pid, Process,\n+use super::{process_filter::ProcessFilter, signal::constants::SIGCHLD, ExitCode, Pid, Process};\n+use crate::{\n+    prelude::*,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+        signal::with_signal_blocked,\n+    },\n };\n-use crate::{prelude::*, process::process_table, thread::thread_table};\n \n // The definition of WaitOptions is from Occlum\n bitflags! {\ndiff --git a/kernel/src/process/wait.rs b/kernel/src/process/wait.rs\n--- a/kernel/src/process/wait.rs\n+++ b/kernel/src/process/wait.rs\n@@ -85,8 +88,8 @@ pub fn wait_child_exit(\n fn reap_zombie_child(process: &Process, pid: Pid) -> ExitCode {\n     let child_process = process.children().lock().remove(&pid).unwrap();\n     assert!(child_process.is_zombie());\n-    for thread in &*child_process.threads().lock() {\n-        thread_table::remove_thread(thread.tid());\n+    for task in &*child_process.tasks().lock() {\n+        thread_table::remove_thread(task.tid());\n     }\n \n     // Lock order: session table -> group table -> process table -> group of process\ndiff --git a/kernel/src/syscall/clock_gettime.rs b/kernel/src/syscall/clock_gettime.rs\n--- a/kernel/src/syscall/clock_gettime.rs\n+++ b/kernel/src/syscall/clock_gettime.rs\n@@ -7,8 +7,10 @@ use int_to_c_enum::TryFromInt;\n use super::SyscallReturn;\n use crate::{\n     prelude::*,\n-    process::{posix_thread::PosixThreadExt, process_table},\n-    thread::thread_table,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+    },\n     time::{\n         clockid_t,\n         clocks::{\ndiff --git a/kernel/src/syscall/exit.rs b/kernel/src/syscall/exit.rs\n--- a/kernel/src/syscall/exit.rs\n+++ b/kernel/src/syscall/exit.rs\n@@ -6,12 +6,11 @@ use crate::{\n     syscall::SyscallReturn,\n };\n \n-pub fn sys_exit(exit_code: i32, _ctx: &Context) -> Result<SyscallReturn> {\n+pub fn sys_exit(exit_code: i32, ctx: &Context) -> Result<SyscallReturn> {\n     debug!(\"exid code = {}\", exit_code);\n \n-    let current_thread = current_thread!();\n     let term_status = TermStatus::Exited(exit_code as _);\n-    do_exit(current_thread, term_status)?;\n+    do_exit(ctx.thread, ctx.posix_thread, term_status)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/kernel/src/syscall/futex.rs b/kernel/src/syscall/futex.rs\n--- a/kernel/src/syscall/futex.rs\n+++ b/kernel/src/syscall/futex.rs\n@@ -71,6 +71,6 @@ pub fn sys_futex(\n         _ => panic!(\"Unsupported futex operations\"),\n     }?;\n \n-    debug!(\"futex returns, tid= {} \", ctx.thread.tid());\n+    debug!(\"futex returns, tid= {} \", ctx.posix_thread.tid());\n     Ok(SyscallReturn::Return(res as _))\n }\ndiff --git a/kernel/src/syscall/gettid.rs b/kernel/src/syscall/gettid.rs\n--- a/kernel/src/syscall/gettid.rs\n+++ b/kernel/src/syscall/gettid.rs\n@@ -4,6 +4,6 @@ use super::SyscallReturn;\n use crate::prelude::*;\n \n pub fn sys_gettid(ctx: &Context) -> Result<SyscallReturn> {\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/mod.rs b/kernel/src/syscall/mod.rs\n--- a/kernel/src/syscall/mod.rs\n+++ b/kernel/src/syscall/mod.rs\n@@ -345,7 +345,10 @@ macro_rules! log_syscall_entry {\n         if log::log_enabled!(log::Level::Info) {\n             let syscall_name_str = stringify!($syscall_name);\n             let pid = $crate::current!().pid();\n-            let tid = $crate::current_thread!().tid();\n+            let tid = {\n+                use $crate::process::posix_thread::PosixThreadExt;\n+                $crate::current_thread!().tid()\n+            };\n             log::info!(\n                 \"[pid={}][tid={}][id={}][{}]\",\n                 pid,\ndiff --git a/kernel/src/syscall/set_tid_address.rs b/kernel/src/syscall/set_tid_address.rs\n--- a/kernel/src/syscall/set_tid_address.rs\n+++ b/kernel/src/syscall/set_tid_address.rs\n@@ -13,6 +13,6 @@ pub fn sys_set_tid_address(tidptr: Vaddr, ctx: &Context) -> Result<SyscallReturn\n     } else {\n         *clear_child_tid = tidptr;\n     }\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\n--- a/kernel/src/syscall/timer_create.rs\n+++ b/kernel/src/syscall/timer_create.rs\n@@ -7,7 +7,7 @@ use super::{\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::PosixThreadExt,\n+        posix_thread::{thread_table, PosixThreadExt},\n         process_table,\n         signal::{\n             c_types::{sigevent_t, SigNotify},\ndiff --git a/kernel/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\n--- a/kernel/src/syscall/timer_create.rs\n+++ b/kernel/src/syscall/timer_create.rs\n@@ -17,10 +17,7 @@ use crate::{\n         },\n     },\n     syscall::ClockId,\n-    thread::{\n-        thread_table,\n-        work_queue::{submit_work_item, work_item::WorkItem},\n-    },\n+    thread::work_queue::{submit_work_item, work_item::WorkItem},\n     time::{\n         clockid_t,\n         clocks::{BootTimeClock, MonotonicClock, RealTimeClock},\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -2,23 +2,22 @@\n \n use ostd::{\n     cpu::CpuSet,\n-    task::{Priority, TaskOptions},\n+    task::{Priority, Task, TaskOptions},\n };\n \n-use super::{allocate_tid, status::ThreadStatus, thread_table, Thread};\n+use super::{status::ThreadStatus, Thread};\n use crate::prelude::*;\n \n /// The inner data of a kernel thread\n pub struct KernelThread;\n \n pub trait KernelThreadExt {\n-    /// get the kernel_thread structure\n+    /// Gets the kernel_thread structure\n     fn as_kernel_thread(&self) -> Option<&KernelThread>;\n-    /// create a new kernel thread structure, **NOT** run the thread.\n-    fn new_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread>;\n-    /// create a new kernel thread structure, and then run the thread.\n+    /// Creates a new kernel thread, and then run the thread.\n     fn spawn_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread> {\n-        let thread = Self::new_kernel_thread(thread_options);\n+        let task = create_new_kernel_task(thread_options);\n+        let thread = Thread::borrow_from_task(&task).clone();\n         thread.run();\n         thread\n     }\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -31,31 +30,6 @@ impl KernelThreadExt for Thread {\n         self.data().downcast_ref::<KernelThread>()\n     }\n \n-    fn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\n-        let task_fn = thread_options.take_func();\n-        let thread_fn = move || {\n-            task_fn();\n-            let current_thread = current_thread!();\n-            // ensure the thread is exit\n-            current_thread.exit();\n-        };\n-        let tid = allocate_tid();\n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let weal_thread = thread_ref.clone();\n-            let task = TaskOptions::new(thread_fn)\n-                .data(weal_thread)\n-                .priority(thread_options.priority)\n-                .cpu_affinity(thread_options.cpu_affinity)\n-                .build()\n-                .unwrap();\n-            let status = ThreadStatus::Init;\n-            let kernel_thread = KernelThread;\n-            Thread::new(tid, task, kernel_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n-    }\n-\n     fn join(&self) {\n         loop {\n             if self.status().is_exited() {\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -67,6 +41,31 @@ impl KernelThreadExt for Thread {\n     }\n }\n \n+/// Creates a new task of kernel thread, **NOT** run the thread.\n+pub fn create_new_kernel_task(mut thread_options: ThreadOptions) -> Arc<Task> {\n+    let task_fn = thread_options.take_func();\n+    let thread_fn = move || {\n+        task_fn();\n+        // Ensures the thread is exit\n+        current_thread!().exit();\n+    };\n+\n+    Arc::new_cyclic(|weak_task| {\n+        let thread = {\n+            let kernel_thread = KernelThread;\n+            let status = ThreadStatus::Init;\n+            Arc::new(Thread::new(weak_task.clone(), kernel_thread, status))\n+        };\n+\n+        TaskOptions::new(thread_fn)\n+            .data(thread)\n+            .priority(thread_options.priority)\n+            .cpu_affinity(thread_options.cpu_affinity)\n+            .build()\n+            .unwrap()\n+    })\n+}\n+\n /// Options to create or spawn a new thread.\n pub struct ThreadOptions {\n     func: Option<Box<dyn Fn() + Send + Sync>>,\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -2,7 +2,7 @@\n \n //! Posix thread implementation\n \n-use core::sync::atomic::{AtomicU32, Ordering};\n+use core::sync::atomic::Ordering;\n \n use ostd::task::Task;\n \ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -13,20 +13,15 @@ pub mod exception;\n pub mod kernel_thread;\n pub mod status;\n pub mod task;\n-pub mod thread_table;\n pub mod work_queue;\n \n pub type Tid = u32;\n \n-static TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n-\n /// A thread is a wrapper on top of task.\n pub struct Thread {\n     // immutable part\n-    /// Thread id\n-    tid: Tid,\n     /// Low-level info\n-    task: Arc<Task>,\n+    task: Weak<Task>,\n     /// Data: Posix thread info/Kernel thread Info\n     data: Box<dyn Send + Sync + Any>,\n \ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -36,14 +31,8 @@ pub struct Thread {\n \n impl Thread {\n     /// Never call these function directly\n-    pub fn new(\n-        tid: Tid,\n-        task: Arc<Task>,\n-        data: impl Send + Sync + Any,\n-        status: ThreadStatus,\n-    ) -> Self {\n+    pub fn new(task: Weak<Task>, data: impl Send + Sync + Any, status: ThreadStatus) -> Self {\n         Thread {\n-            tid,\n             task,\n             data: Box::new(data),\n             status: AtomicThreadStatus::new(status),\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -57,18 +46,23 @@ impl Thread {\n     pub fn current() -> Option<Arc<Self>> {\n         Task::current()?\n             .data()\n-            .downcast_ref::<Weak<Thread>>()?\n-            .upgrade()\n+            .downcast_ref::<Arc<Thread>>()\n+            .cloned()\n     }\n \n-    pub(in crate::thread) fn task(&self) -> &Arc<Task> {\n-        &self.task\n+    /// Gets the Thread from task's data.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the task is not a thread.\n+    pub fn borrow_from_task(task: &Arc<Task>) -> &Arc<Self> {\n+        task.data().downcast_ref::<Arc<Thread>>().unwrap()\n     }\n \n     /// Runs this thread at once.\n     pub fn run(&self) {\n         self.set_status(ThreadStatus::Running);\n-        self.task.run();\n+        self.task.upgrade().unwrap().run();\n     }\n \n     pub(super) fn exit(&self) {\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -94,10 +88,6 @@ impl Thread {\n         Task::yield_now()\n     }\n \n-    pub fn tid(&self) -> Tid {\n-        self.tid\n-    }\n-\n     /// Returns the associated data.\n     ///\n     /// The return type must be borrowed box, otherwise the `downcast_ref` will fail.\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -106,8 +96,3 @@ impl Thread {\n         &self.data\n     }\n }\n-\n-/// Allocates a new tid for the new thread\n-pub fn allocate_tid() -> Tid {\n-    TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n-}\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -16,12 +16,12 @@ use crate::{\n };\n \n /// create new task with userspace and parent process\n-pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n+pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Arc<Thread>) -> Task {\n     fn user_task_entry() {\n         let current_thread = current_thread!();\n         let current_posix_thread = current_thread.as_posix_thread().unwrap();\n         let current_process = current_posix_thread.process();\n-        let current_task = current_thread.task();\n+        let current_task = Task::current().unwrap();\n \n         let user_space = current_task\n             .user_space()\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -47,7 +47,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         // in the child process.\n         if is_userspace_vaddr(child_tid_ptr) {\n             CurrentUserSpace::get()\n-                .write_val(child_tid_ptr, &current_thread.tid())\n+                .write_val(child_tid_ptr, &current_posix_thread.tid())\n                 .unwrap();\n         }\n \ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -77,7 +77,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             // If current is suspended, wait for a signal to wake up self\n             while current_thread.status().is_stopped() {\n                 Thread::yield_now();\n-                debug!(\"{} is suspended.\", current_thread.tid());\n+                debug!(\"{} is suspended.\", current_posix_thread.tid());\n                 handle_pending_signal(user_ctx, &current_thread).unwrap();\n             }\n             if current_thread.status().is_exited() {\ndiff --git a/kernel/src/thread/thread_table.rs /dev/null\n--- a/kernel/src/thread/thread_table.rs\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use super::{Thread, Tid};\n-use crate::prelude::*;\n-\n-lazy_static! {\n-    static ref THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n-}\n-\n-pub fn add_thread(thread: Arc<Thread>) {\n-    let tid = thread.tid();\n-    THREAD_TABLE.lock().insert(tid, thread);\n-}\n-\n-pub fn remove_thread(tid: Tid) {\n-    THREAD_TABLE.lock().remove(&tid);\n-}\n-\n-pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n-    THREAD_TABLE.lock().get(&tid).cloned()\n-}\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use ostd::{cpu::CpuSet, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    task::{Priority, Task},\n+};\n \n use super::worker_pool::WorkerPool;\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -17,7 +20,7 @@ use crate::{\n /// added to the `WorkerPool`.\n pub(super) struct Worker {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n     bound_cpu: u32,\n     inner: SpinLock<WorkerInner>,\n }\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -51,14 +54,14 @@ impl Worker {\n             if worker_pool.upgrade().unwrap().is_high_priority() {\n                 priority = Priority::high();\n             }\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n                 bound_cpu,\n                 inner: SpinLock::new(WorkerInner {\n                     worker_status: WorkerStatus::Running,\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -68,7 +71,8 @@ impl Worker {\n     }\n \n     pub(super) fn run(&self) {\n-        self.bound_thread.run();\n+        let thread = Thread::borrow_from_task(&self.bound_task);\n+        thread.run();\n     }\n \n     /// The thread function bound to normal workers.\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -97,8 +101,8 @@ impl Worker {\n         self.exit();\n     }\n \n-    pub(super) fn bound_thread(&self) -> &Arc<Thread> {\n-        &self.bound_thread\n+    pub(super) fn bound_task(&self) -> &Arc<Task> {\n+        &self.bound_task\n     }\n \n     pub(super) fn is_idle(&self) -> bool {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -7,12 +7,16 @@ use core::{\n     time::Duration,\n };\n \n-use ostd::{cpu::CpuSet, sync::WaitQueue, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    sync::WaitQueue,\n+    task::{Priority, Task},\n+};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -60,7 +64,7 @@ pub trait WorkerScheduler: Sync + Send {\n /// are found processing in the pool.\n pub struct Monitor {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n }\n \n impl LocalWorkerPool {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -77,7 +81,7 @@ impl LocalWorkerPool {\n     fn add_worker(&self) {\n         let worker = Worker::new(self.parent.clone(), self.cpu_id);\n         self.workers.disable_irq().lock().push_back(worker.clone());\n-        worker.bound_thread().run();\n+        Thread::borrow_from_task(worker.bound_task()).run();\n     }\n \n     fn remove_worker(&self) {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -236,20 +240,20 @@ impl Monitor {\n                 WorkPriority::High => Priority::high(),\n                 WorkPriority::Normal => Priority::normal(),\n             };\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n             }\n         })\n     }\n \n     pub fn run(&self) {\n-        self.bound_thread.run();\n+        Thread::borrow_from_task(&self.bound_task).run()\n     }\n \n     fn run_monitor_loop(self: &Arc<Self>) {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -166,7 +166,7 @@ impl TaskOptions {\n     }\n \n     /// Builds a new task without running it immediately.\n-    pub fn build(self) -> Result<Arc<Task>> {\n+    pub fn build(self) -> Result<Task> {\n         /// all task will entering this function\n         /// this function is mean to executing the task_fn in Task\n         extern \"C\" fn kernel_task_entry() {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -201,12 +201,12 @@ impl TaskOptions {\n         // have any arguments, so we only need to align the stack pointer to 16 bytes.\n         ctx.set_stack_pointer(crate::mm::paddr_to_vaddr(new_task.kstack.end_paddr() - 16));\n \n-        Ok(Arc::new(new_task))\n+        Ok(new_task)\n     }\n \n     /// Builds a new task and run it immediately.\n     pub fn spawn(self) -> Result<Arc<Task>> {\n-        let task = self.build()?;\n+        let task = Arc::new(self.build()?);\n         task.run();\n         Ok(task)\n     }\n",
        "test_patch": "",
        "problem_statement": "Reachable unwrap panic in `read_clock()`\n### Describe the bug\r\nThere is a reachable unwrap panic in `read_clock()` at kernel/src/syscall/clock_gettime.rs:141 when make a `clock_gettime` syscall with specific argument.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/aa77747f94c4b1cb1237ba52414642827a6efc25/kernel/src/syscall/clock_gettime.rs#L141\r\n\r\n\r\n### To Reproduce\r\n1. Compile a program which calls `clock_gettime`:\r\n```C\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <sys/syscall.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\nint main() {\r\n  clock_gettime(-10, 0x1);\r\n  perror(\"clock_gettime\");\r\n\r\n  return 0;\r\n}\r\n```\r\n2. Run the compiled program in Asterinas.\r\n\r\n### Expected behavior\r\nAsterinas reports panic and is terminated.\r\n\r\n### Environment\r\n- Official docker asterinas/asterinas:0.8.0\r\n- 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\r\n- Asterinas version: main aa77747f\r\n\r\n### Logs\r\n\r\n```\r\n~ # /root/clock_gettime.c \r\npanicked at /root/asterinas/kernel/src/syscall/clock_gettime.rs:141:61:\r\ncalled `Option::unwrap()` on a `None` value\r\nPrinting stack trace:\r\n   1: fn 0xffffffff8880e1c0 - pc 0xffffffff8880e1d8 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297c0;\r\n\r\n   2: fn 0xffffffff8880dfa0 - pc 0xffffffff8880e118 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297d0;\r\n\r\n   3: fn 0xffffffff88049000 - pc 0xffffffff8804900a / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629950;\r\n\r\n   4: fn 0xffffffff889b0fb0 - pc 0xffffffff889b1032 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629960;\r\n\r\n   5: fn 0xffffffff889b1150 - pc 0xffffffff889b1190 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6299f0;\r\n\r\n   6: fn 0xffffffff8899a710 - pc 0xffffffff8899a725 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a60;\r\n\r\n   7: fn 0xffffffff884f2290 - pc 0xffffffff884f289f / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a70;\r\n\r\n   8: fn 0xffffffff884f1d20 - pc 0xffffffff884f1d81 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629d30;\r\n\r\n   9: fn 0xffffffff88161a50 - pc 0xffffffff8818d4ab / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629f30;\r\n\r\n  10: fn 0xffffffff88152f60 - pc 0xffffffff88152fee / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6403d0;\r\n\r\n  11: fn 0xffffffff88110380 - pc 0xffffffff88110eff / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640570;\r\n\r\n  12: fn 0xffffffff8845cb70 - pc 0xffffffff8845cb7e / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640f90;\r\n\r\n  13: fn 0xffffffff887cdc50 - pc 0xffffffff887cdc66 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fb0;\r\n\r\n  14: fn 0xffffffff887b0280 - pc 0xffffffff887b02e9 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fd0;\r\n\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f641000;\r\n\r\n[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\r\n(  1) /root/asterinas/ostd/src/panicking.rs:106\r\n(  2) /root/asterinas/ostd/src/panicking.rs:59\r\n(  3) 89yvfinwjerz0clyodmhm6lzz:?\r\n(  4) ??:?\r\n(  5) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs:220\r\n(  6) ??:?\r\n(  7) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:961\r\n(  8) /root/asterinas/kernel/src/syscall/clock_gettime.rs:29\r\n(  9) /root/asterinas/kernel/src/syscall/mod.rs:164\r\n( 10) /root/asterinas/kernel/src/syscall/mod.rs:328\r\n( 11) /root/asterinas/kernel/src/thread/task.rs:69\r\n( 12) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n( 13) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2077\r\n( 14) /root/asterinas/ostd/src/task/task/mod.rs:341\r\nmake: *** [Makefile:167: run] Error 1\r\n```\n",
        "hints_text": "",
        "created_at": "2024-09-12T06:03:09Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1125,
        "instance_id": "asterinas__asterinas-1125",
        "issue_numbers": [
            "1106"
        ],
        "base_commit": "d04111079cb8edf03d9a58b2bd88d4af4b11543a",
        "patch": "diff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -26,7 +26,7 @@ pub(crate) use ostd::{\n #[macro_export]\n macro_rules! current {\n     () => {\n-        $crate::process::current()\n+        $crate::process::Process::current().unwrap()\n     };\n }\n \ndiff --git a/kernel/aster-nix/src/process/mod.rs b/kernel/aster-nix/src/process/mod.rs\n--- a/kernel/aster-nix/src/process/mod.rs\n+++ b/kernel/aster-nix/src/process/mod.rs\n@@ -23,8 +23,7 @@ pub use credentials::{credentials, credentials_mut, Credentials, Gid, Uid};\n pub use exit::do_exit_group;\n pub use kill::{kill, kill_all, kill_group, tgkill};\n pub use process::{\n-    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid,\n-    Terminal,\n+    ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid, Terminal,\n };\n pub use process_filter::ProcessFilter;\n pub use process_vm::{MAX_ARGV_NUMBER, MAX_ARG_LEN, MAX_ENVP_NUMBER, MAX_ENV_LEN};\ndiff --git a/kernel/aster-nix/src/process/process/mod.rs b/kernel/aster-nix/src/process/process/mod.rs\n--- a/kernel/aster-nix/src/process/process/mod.rs\n+++ b/kernel/aster-nix/src/process/process/mod.rs\n@@ -103,6 +103,15 @@ pub struct Process {\n }\n \n impl Process {\n+    /// Returns the current process.\n+    ///\n+    /// It returns `None` if:\n+    ///  - the function is called in the bootstrap context;\n+    ///  - or if the current task is not associated with a process.\n+    pub fn current() -> Option<Arc<Process>> {\n+        Some(Thread::current()?.as_posix_thread()?.process())\n+    }\n+\n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -1,7 +1,5 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-#![allow(dead_code)]\n-\n use alloc::{boxed::Box, sync::Arc};\n use core::{\n     cell::RefCell,\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -10,7 +8,7 @@ use core::{\n };\n \n use intrusive_collections::{intrusive_adapter, LinkedList, LinkedListAtomicLink};\n-use ostd::{cpu_local, trap::SoftIrqLine, CpuLocal};\n+use ostd::{cpu::local::CpuLocal, cpu_local, trap::SoftIrqLine};\n \n use crate::softirq_id::{TASKLESS_SOFTIRQ_ID, TASKLESS_URGENT_SOFTIRQ_ID};\n \ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -5,7 +5,7 @@ use core::mem;\n use aster_rights::Full;\n use ostd::{\n     mm::{KernelSpace, VmIo, VmReader, VmWriter},\n-    task::current_task,\n+    task::Task,\n };\n \n use crate::{prelude::*, vm::vmar::Vmar};\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -34,14 +34,8 @@ pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space.vm_space().reader(src, copy_len)?;\n     user_reader.read_fallible(dest).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -54,14 +48,8 @@ pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space\n         .vm_space()\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -88,14 +76,8 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space.vm_space().writer(dest, copy_len)?;\n     user_writer.write_fallible(src).map_err(|err| err.0)?;\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -108,14 +90,8 @@ pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space\n         .vm_space()\ndiff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -122,13 +122,7 @@ SECTIONS\n \n         # These 4 bytes are used to store the CPU ID.\n         . += 4;\n-\n-        # These 4 bytes are used to store the number of preemption locks held.\n-        # The reason is stated in the Rust documentation of\n-        # [`ostd::task::processor::PreemptInfo`].\n-        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n-        . += 4;\n-\n+        \n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -230,7 +230,7 @@ pub fn trace_panic_from_log(qemu_log: File, bin_path: PathBuf) {\n         .spawn()\n         .unwrap();\n     for line in lines.into_iter().rev() {\n-        if line.contains(\"printing stack trace:\") {\n+        if line.contains(\"Printing stack trace:\") {\n             println!(\"[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\");\n             trace_exists = true;\n         }\ndiff --git a/ostd/src/arch/x86/cpu/local.rs b/ostd/src/arch/x86/cpu/local.rs\n--- a/ostd/src/arch/x86/cpu/local.rs\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -23,65 +23,205 @@ pub(crate) fn get_base() -> u64 {\n     FS::read_base().as_u64()\n }\n \n-pub mod preempt_lock_count {\n-    //! We need to increment/decrement the per-CPU preemption lock count using\n-    //! a single instruction. This requirement is stated by\n-    //! [`crate::task::processor::PreemptInfo`].\n-\n-    /// The GDT ensures that the FS segment is initialized to zero on boot.\n-    /// This assertion checks that the base address has been set.\n-    macro_rules! debug_assert_initialized {\n-        () => {\n-            // The compiler may think that [`super::get_base`] has side effects\n-            // so it may not be optimized out. We make sure that it will be\n-            // conditionally compiled only in debug builds.\n-            #[cfg(debug_assertions)]\n-            debug_assert_ne!(super::get_base(), 0);\n-        };\n-    }\n+use crate::cpu::local::single_instr::{\n+    SingleInstructionAddAssign, SingleInstructionBitAndAssign, SingleInstructionBitOrAssign,\n+    SingleInstructionBitXorAssign, SingleInstructionLoad, SingleInstructionStore,\n+    SingleInstructionSubAssign,\n+};\n \n-    /// Increments the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn inc() {\n-        debug_assert_initialized!();\n+/// The GDT ensures that the FS segment is initialized to zero on boot.\n+/// This assertion checks that the base address has been set.\n+macro_rules! debug_assert_initialized {\n+    () => {\n+        // The compiler may think that [`super::get_base`] has side effects\n+        // so it may not be optimized out. We make sure that it will be\n+        // conditionally compiled only in debug builds.\n+        #[cfg(debug_assertions)]\n+        debug_assert_ne!(get_base(), 0);\n+    };\n+}\n+\n+macro_rules! impl_numeric_single_instruction_for {\n+    ($([$typ: ty, $inout_type: ident, $register_format: expr])*) => {$(\n+\n+        impl SingleInstructionAddAssign<$typ> for $typ {\n+            unsafe fn add_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly increments the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"add fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n-    }\n \n-    /// Decrements the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn dec() {\n-        debug_assert_initialized!();\n+        impl SingleInstructionSubAssign<$typ> for $typ {\n+            unsafe fn sub_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"sub fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitAndAssign<$typ> for $typ {\n+            unsafe fn bitand_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"and fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitOrAssign<$typ> for $typ {\n+            unsafe fn bitor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"or fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitXorAssign<$typ> for $typ {\n+            unsafe fn bitxor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"xor fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0\", $register_format, \"}, fs:[{1}]\"),\n+                    out($inout_type) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+    )*};\n+}\n+\n+impl_numeric_single_instruction_for!(\n+    [u64,   reg,    \":r\"]\n+    [usize, reg,    \":r\"]\n+    [u32,   reg,    \":e\"]\n+    [u16,   reg,    \":x\"]\n+    [u8,    reg_byte, \"\"]\n+    [i64,   reg,    \":r\"]\n+    [isize, reg,    \":r\"]\n+    [i32,   reg,    \":e\"]\n+    [i16,   reg,    \":x\"]\n+    [i8,    reg_byte, \"\"]\n+);\n+\n+macro_rules! impl_generic_single_instruction_for {\n+    ($([<$gen_type:ident $(, $more_gen_type:ident)*>, $typ:ty])*) => {$(\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0}, fs:[{1}]\"),\n+                    out(reg) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly decrements the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1}\"),\n+                    in(reg) offset,\n+                    in(reg) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n+    )*}\n+}\n+\n+impl_generic_single_instruction_for!(\n+    [<T>, *const T]\n+    [<T>, *mut T]\n+    [<T, R>, fn(T) -> R]\n+);\n+\n+// In this module, booleans are represented by the least significant bit of a\n+// `u8` type. Other bits must be zero. This definition is compatible with the\n+// Rust reference: <https://doc.rust-lang.org/reference/types/boolean.html>.\n+\n+impl SingleInstructionLoad for bool {\n+    unsafe fn load(offset: *const Self) -> Self {\n+        debug_assert_initialized!();\n+\n+        let val: u8;\n+        core::arch::asm!(\n+            \"mov {0}, fs:[{1}]\",\n+            out(reg_byte) val,\n+            in(reg) offset,\n+            options(nostack, readonly),\n+        );\n+        debug_assert!(val == 1 || val == 0);\n+        val == 1\n     }\n+}\n \n-    /// Gets the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn get() -> u32 {\n+impl SingleInstructionStore for bool {\n+    unsafe fn store(offset: *mut Self, val: Self) {\n         debug_assert_initialized!();\n \n-        let count: u32;\n-        // SAFETY: The inline assembly reads the lock count in one instruction\n-        // without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n-                out(reg) count,\n-                options(nostack, readonly),\n-            );\n-        }\n-        count\n+        let val: u8 = if val { 1 } else { 0 };\n+        core::arch::asm!(\n+            \"mov fs:[{0}], {1}\",\n+            in(reg) offset,\n+            in(reg_byte) val,\n+            options(nostack),\n+        );\n     }\n }\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -73,7 +73,7 @@ pub(crate) fn init_on_bsp() {\n \n     // SAFETY: no CPU local objects have been accessed by this far. And\n     // we are on the BSP.\n-    unsafe { crate::cpu::cpu_local::init_on_bsp() };\n+    unsafe { crate::cpu::local::init_on_bsp() };\n \n     crate::boot::smp::boot_all_aps();\n \ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -2,8 +2,6 @@\n \n //! Handles trap.\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use align_ext::AlignExt;\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -15,25 +13,25 @@ use super::ex_table::ExTable;\n use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, CpuExceptionInfo, PageFaultErrorCode, PAGE_FAULT},\n-    cpu_local,\n+    cpu_local_cell,\n     mm::{\n         kspace::{KERNEL_PAGE_TABLE, LINEAR_MAPPING_BASE_VADDR, LINEAR_MAPPING_VADDR_RANGE},\n         page_prop::{CachePolicy, PageProperty},\n         PageFlags, PrivilegedPageFlags as PrivFlags, MAX_USERSPACE_VADDR, PAGE_SIZE,\n     },\n-    task::current_task,\n+    task::Task,\n     trap::call_irq_callback_functions,\n };\n \n-cpu_local! {\n-    static IS_KERNEL_INTERRUPTED: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IS_KERNEL_INTERRUPTED: bool = false;\n }\n \n /// Returns true if this function is called within the context of an IRQ handler\n /// and the IRQ occurs while the CPU is executing in the kernel mode.\n /// Otherwise, it returns false.\n pub fn is_kernel_interrupted() -> bool {\n-    IS_KERNEL_INTERRUPTED.load(Ordering::Acquire)\n+    IS_KERNEL_INTERRUPTED.load()\n }\n \n /// Only from kernel\ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -64,15 +62,15 @@ extern \"sysv64\" fn trap_handler(f: &mut TrapFrame) {\n             }\n         }\n     } else {\n-        IS_KERNEL_INTERRUPTED.store(true, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(true);\n         call_irq_callback_functions(f, f.trap_num);\n-        IS_KERNEL_INTERRUPTED.store(false, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(false);\n     }\n }\n \n /// Handles page fault from user space.\n fn handle_user_page_fault(f: &mut TrapFrame, page_fault_addr: u64) {\n-    let current_task = current_task().unwrap();\n+    let current_task = Task::current().unwrap();\n     let user_space = current_task\n         .user_space()\n         .expect(\"the user space is missing when a page fault from the user happens.\");\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -115,7 +115,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n \n     // SAFETY: we are on the AP.\n     unsafe {\n-        cpu::cpu_local::init_on_ap(local_apic_id);\n+        cpu::local::init_on_ap(local_apic_id);\n     }\n \n     trap::init();\ndiff --git /dev/null b/ostd/src/cpu/local/cell.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/cell.rs\n@@ -0,0 +1,247 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The implementaion of CPU-local variables that have inner mutability.\n+\n+use core::cell::UnsafeCell;\n+\n+use super::{__cpu_local_end, __cpu_local_start, single_instr::*};\n+use crate::arch;\n+\n+/// Defines an inner-mutable CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocalCell`].\n+///\n+/// It should be noted that if the interrupts or preemption is enabled, two\n+/// operations on the same CPU-local cell variable may access different objects\n+/// since the task may live on different CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::cpu_local_cell;\n+///\n+/// cpu_local_cell! {\n+///     static FOO: u32 = 1;\n+///     pub static BAR: *const usize = core::ptr::null();\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let bar_var: usize = 1;\n+///     BAR.store(&bar_var as *const _);\n+///     // Note that the value of `BAR` here doesn't nessarily equal to the address\n+///     // of `bar_var`, since the task may be preempted and moved to another CPU.\n+///     // You can avoid this by disabling interrupts (and preemption, if needed).\n+///     println!(\"BAR VAL: {:?}\", BAR.load());\n+///\n+///     let _irq_guard = ostd::trap::disable_local_irq();\n+///     println!(\"1st FOO VAL: {:?}\", FOO.load());\n+///     // No suprises here, the two accesses must result in the same value.\n+///     println!(\"2nd FOO VAL: {:?}\", FOO.load());\n+/// }\n+/// ```\n+macro_rules! cpu_local_cell {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocalCell<$t> = {\n+                let val = $init;\n+                // SAFETY: The CPU local variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocalCell::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+pub(crate) use cpu_local_cell;\n+\n+/// Inner mutable CPU-local objects.\n+///\n+/// CPU-local cell objects are only accessible from the current CPU. When\n+/// accessing an underlying object using the same `CpuLocalCell` instance, the\n+/// actually accessed object is always on the current CPU. So in a preemptive\n+/// kernel task, the operated object may change if interrupts are enabled.\n+///\n+/// The inner mutability is provided by single instruction operations, and the\n+/// CPU-local cell objects will not ever be shared between CPUs. So it is safe\n+/// to modify the inner value without any locks.\n+///\n+/// You should only create the CPU-local cell object using the macro\n+/// [`cpu_local_cell!`].\n+///\n+/// For the difference between [`super::CpuLocal`] and [`CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocalCell<T: 'static>(UnsafeCell<T>);\n+\n+impl<T: 'static> CpuLocalCell<T> {\n+    /// Initialize a CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(UnsafeCell::new(val))\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that within the entire execution of this\n+    /// function, no interrupt or preemption can occur. Otherwise, the\n+    /// returned pointer may points to the variable in another CPU.\n+    pub unsafe fn as_ptr_mut(&'static self) -> *mut T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value T\n+// of a cpu-local variable even if `T` is not `Sync`.\n+unsafe impl<T: 'static> Sync for CpuLocalCell<T> {}\n+\n+// Prevent valid instances of CpuLocalCell from being copied to any memory\n+// area outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocalCell<T> {}\n+impl<T: 'static> !Clone for CpuLocalCell<T> {}\n+\n+// In general, it does not make any sense to send instances of CpuLocalCell to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocalCell<T> {}\n+\n+// Accessors for the per-CPU objects whose type implements the single-\n+// instruction operations.\n+\n+impl<T: 'static + SingleInstructionAddAssign<T>> CpuLocalCell<T> {\n+    /// Adds a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn add_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::add_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionSubAssign<T>> CpuLocalCell<T> {\n+    /// Subtracts a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn sub_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::sub_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitAndAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ANDs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitand_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitand_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitOrAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitXorAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise XORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitxor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitxor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionLoad> CpuLocalCell<T> {\n+    /// Gets the value of the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn load(&'static self) -> T {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid.\n+        unsafe { T::load(offset as *const T) }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionStore> CpuLocalCell<T> {\n+    /// Writes a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn store(&'static self, val: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::store(offset as *mut T, val);\n+        }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/cpu/local/cpu_local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/cpu_local.rs\n@@ -0,0 +1,210 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The CPU-local variable implementation.\n+\n+use core::{marker::Sync, ops::Deref};\n+\n+use super::{__cpu_local_end, __cpu_local_start};\n+use crate::{\n+    arch,\n+    trap::{self, DisabledLocalIrqGuard},\n+};\n+\n+/// Defines a CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocal`].\n+///\n+/// You can get the reference to the inner object by calling [`deref`]. But\n+/// it is worth noting that the object is always the one in the original core\n+/// when the reference is created. Use [`CpuLocal::borrow_irq_disabled`] if\n+/// this is not expected, or if the inner type can't be shared across CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::{cpu_local, sync::SpinLock};\n+/// use core::sync::atomic::{AtomicU32, Ordering};\n+///\n+/// cpu_local! {\n+///     static FOO: AtomicU32 = AtomicU32::new(1);\n+///     pub static BAR: SpinLock<usize> = SpinLock::new(2);\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let ref_of_foo = FOO.deref();\n+///     // Note that the value of `FOO` here doesn't necessarily equal to the value\n+///     // of `FOO` of exactly the __current__ CPU. Since that task may be preempted\n+///     // and moved to another CPU since `ref_of_foo` is created.\n+///     let val_of_foo = ref_of_foo.load(Ordering::Relaxed);\n+///     println!(\"FOO VAL: {}\", val_of_foo);\n+///\n+///     let bar_guard = BAR.lock_irq_disabled();\n+///     // Here the value of `BAR` is always the one in the __current__ CPU since\n+///     // interrupts are disabled and we do not explicitly yield execution here.\n+///     let val_of_bar = *bar_guard;\n+///     println!(\"BAR VAL: {}\", val_of_bar);\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! cpu_local {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocal<$t> = {\n+                let val = $init;\n+                // SAFETY: The per-CPU variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocal::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+/// CPU-local objects.\n+///\n+/// CPU-local objects are instanciated once per CPU core. They can be shared to\n+/// other cores. In the context of a preemptible kernel task, when holding the\n+/// reference to the inner object, the object is always the one in the original\n+/// core (when the reference is created), no matter which core the code is\n+/// currently running on.\n+///\n+/// For the difference between [`CpuLocal`] and [`super::CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocal<T: 'static>(T);\n+\n+impl<T: 'static> CpuLocal<T> {\n+    /// Creates a new CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(val)\n+    }\n+\n+    /// Get access to the underlying value with IRQs disabled.\n+    ///\n+    /// By this method, you can borrow a reference to the underlying value\n+    /// even if `T` is not `Sync`. Because that it is per-CPU and IRQs are\n+    /// disabled, no other running tasks can access it.\n+    pub fn borrow_irq_disabled(&'static self) -> CpuLocalDerefGuard<'_, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Created(trap::disable_local()),\n+        }\n+    }\n+\n+    /// Get access to the underlying value with a provided guard.\n+    ///\n+    /// Similar to [`CpuLocal::borrow_irq_disabled`], but you can provide\n+    /// a guard to disable IRQs if you already have one.\n+    pub fn borrow_with<'a>(\n+        &'static self,\n+        guard: &'a DisabledLocalIrqGuard,\n+    ) -> CpuLocalDerefGuard<'a, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Provided(guard),\n+        }\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the reference to `self` is static.\n+    unsafe fn as_ptr(&self) -> *const T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value `T` of a\n+// CPU-local variable if `T` is not `Sync`. We guarentee it by disabling the\n+// reference to the inner value, or turning off preemptions when creating\n+// the reference.\n+unsafe impl<T: 'static> Sync for CpuLocal<T> {}\n+\n+// Prevent valid instances of `CpuLocal` from being copied to any memory areas\n+// outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocal<T> {}\n+impl<T: 'static> !Clone for CpuLocal<T> {}\n+\n+// In general, it does not make any sense to send instances of `CpuLocal` to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocal<T> {}\n+\n+// For `Sync` types, we can create a reference over the inner type and allow\n+// it to be shared across CPUs. So it is sound to provide a `Deref`\n+// implementation. However it is up to the caller if sharing is desired.\n+impl<T: 'static + Sync> Deref for CpuLocal<T> {\n+    type Target = T;\n+\n+    /// Note that the reference to the inner object remains to the same object\n+    /// accessed on the original CPU where the reference is created. If this\n+    /// is not expected, turn off preemptions.\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. It is\n+        // `Sync` so it can be referenced from this task. Here dereferencing\n+        // from non-static instances is not feasible since no one can create\n+        // a non-static instance of `CpuLocal`.\n+        unsafe { &*self.as_ptr() }\n+    }\n+}\n+\n+/// A guard for accessing the CPU-local object.\n+///\n+/// It ensures that the CPU-local object is accessed with IRQs disabled.\n+/// It is created by [`CpuLocal::borrow_irq_disabled`] or\n+/// [`CpuLocal::borrow_with`]. Do not hold this guard for a longtime.\n+#[must_use]\n+pub struct CpuLocalDerefGuard<'a, T: 'static> {\n+    cpu_local: &'static CpuLocal<T>,\n+    _guard: InnerGuard<'a>,\n+}\n+\n+enum InnerGuard<'a> {\n+    #[allow(dead_code)]\n+    Created(DisabledLocalIrqGuard),\n+    #[allow(dead_code)]\n+    Provided(&'a DisabledLocalIrqGuard),\n+}\n+\n+impl<T: 'static> Deref for CpuLocalDerefGuard<'_, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. The IRQs\n+        // are disabled so it can only be referenced from this task.\n+        unsafe { &*self.cpu_local.as_ptr() }\n+    }\n+}\ndiff --git /dev/null b/ostd/src/cpu/local/single_instr.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/cpu/local/single_instr.rs\n@@ -0,0 +1,165 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Extensions for CPU-local types that allows single-instruction operations.\n+//!\n+//! For some per-CPU objects, fetching or modifying the values of them can be\n+//! done in a single instruction. Then we would avoid turning off interrupts\n+//! when accessing them, which incurs non-trivial overhead.\n+//!\n+//! These traits are the architecture-specific interface for single-instruction\n+//! operations. The architecture-specific module can implement these traits for\n+//! common integer types. For architectures that don't support such single-\n+//! instruction operations, we emulate a single-instruction implementation by\n+//! disabling interruptions and preemptions.\n+//!\n+//! Currently we implement some of the [`core::ops`] operations. Bitwise shift\n+//! implementations are missing. Also for less-fundamental types such as\n+//! enumerations or boolean types, the caller can cast it themselves to the\n+//! integer types, for which the operations are implemented.\n+//!\n+//! # Safety\n+//!\n+//! All operations in the provided traits are unsafe, and the caller should\n+//! ensure that the offset is a valid pointer to a static [`CpuLocalCell`]\n+//! object. The offset of the object is relative to the base address of the\n+//! CPU-local storage. These operations are not atomic. Accessing the same\n+//! address from multiple CPUs produces undefined behavior.\n+//!\n+//! [`CpuLocalCell`]: crate::cpu::local::CpuLocalCell\n+\n+/// An interface for architecture-specific single-instruction add operation.\n+pub trait SingleInstructionAddAssign<Rhs = Self> {\n+    /// Adds a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    ///\n+    unsafe fn add_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingAdd + Copy> SingleInstructionAddAssign<T> for T {\n+    default unsafe fn add_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_add(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction subtract operation.\n+pub trait SingleInstructionSubAssign<Rhs = Self> {\n+    /// Subtracts a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn sub_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingSub + Copy> SingleInstructionSubAssign<T> for T {\n+    default unsafe fn sub_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_sub(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise OR.\n+pub trait SingleInstructionBitOrAssign<Rhs = Self> {\n+    /// Bitwise ORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitOr<Output = T> + Copy> SingleInstructionBitOrAssign<T> for T {\n+    default unsafe fn bitor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() | rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise AND.\n+pub trait SingleInstructionBitAndAssign<Rhs = Self> {\n+    /// Bitwise ANDs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitand_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitAnd<Output = T> + Copy> SingleInstructionBitAndAssign<T> for T {\n+    default unsafe fn bitand_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() & rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise XOR.\n+pub trait SingleInstructionBitXorAssign<Rhs = Self> {\n+    /// Bitwise XORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitxor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitXor<Output = T> + Copy> SingleInstructionBitXorAssign<T> for T {\n+    default unsafe fn bitxor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() ^ rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction get operation.\n+pub trait SingleInstructionLoad {\n+    /// Gets the value of the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn load(offset: *const Self) -> Self;\n+}\n+\n+impl<T: Copy> SingleInstructionLoad for T {\n+    default unsafe fn load(offset: *const Self) -> Self {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *const Self;\n+        ptr.read()\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction set operation.\n+pub trait SingleInstructionStore {\n+    /// Writes a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn store(offset: *mut Self, val: Self);\n+}\n+\n+impl<T: Copy> SingleInstructionStore for T {\n+    default unsafe fn store(offset: *mut Self, val: Self) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *mut Self;\n+        ptr.write(val);\n+    }\n+}\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -2,7 +2,7 @@\n \n //! CPU-related definitions.\n \n-pub mod cpu_local;\n+pub mod local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -18,7 +18,7 @@ use bitvec::{\n     slice::IterOnes,\n };\n \n-use crate::{arch::boot::smp::get_num_processors, cpu};\n+use crate::arch::{self, boot::smp::get_num_processors};\n \n /// The number of CPUs. Zero means uninitialized.\n static NUM_CPUS: AtomicU32 = AtomicU32::new(0);\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -47,7 +47,7 @@ pub fn num_cpus() -> u32 {\n pub fn this_cpu() -> u32 {\n     // SAFETY: the cpu ID is stored at the beginning of the cpu local area, provided\n     // by the linker script.\n-    unsafe { (cpu::local::get_base() as usize as *mut u32).read() }\n+    unsafe { (arch::cpu::local::get_base() as usize as *mut u32).read() }\n }\n \n /// A subset of all CPUs in the system.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -11,6 +11,7 @@\n #![feature(generic_const_exprs)]\n #![feature(iter_from_coroutine)]\n #![feature(let_chains)]\n+#![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(panic_info_message)]\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -46,7 +47,9 @@ pub mod user;\n pub use ostd_macros::main;\n pub use ostd_pod::Pod;\n \n-pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n+pub use self::{error::Error, prelude::Result};\n+// [`CpuLocalCell`] is easy to be mis-used, so we don't expose it to the users.\n+pub(crate) use crate::cpu::local::cpu_local_cell;\n \n /// Initializes OSTD.\n ///\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -64,7 +67,7 @@ pub fn init() {\n     arch::check_tdx_init();\n \n     // SAFETY: This function is called only once and only on the BSP.\n-    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+    unsafe { cpu::local::early_init_bsp_local_base() };\n \n     mm::heap_allocator::init();\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -48,6 +48,7 @@ use crate::{\n /// A `VmSpace` can also attach a page fault handler, which will be invoked to\n /// handle page faults generated from user space.\n #[allow(clippy::type_complexity)]\n+#[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -6,7 +6,7 @@ use core::ffi::c_void;\n \n use crate::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n-    early_print, early_println,\n+    cpu_local_cell, early_print, early_println,\n };\n \n extern crate cfg_if;\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -35,12 +47,15 @@ pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n             file: info.location().unwrap().file().to_string(),\n             line: info.location().unwrap().line() as usize,\n             col: info.location().unwrap().column() as usize,\n+            resolve_panic: || {\n+                IN_PANIC.store(false);\n+            },\n         };\n         // Throw an exception and expecting it to be caught.\n         begin_panic(Box::new(throw_info.clone()));\n     }\n     early_println!(\"{}\", info);\n-    early_println!(\"printing stack trace:\");\n+    early_println!(\"Printing stack trace:\");\n     print_stack_trace();\n     abort();\n }\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -4,7 +4,7 @@ use alloc::{collections::VecDeque, sync::Arc};\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n \n use super::SpinLock;\n-use crate::task::{add_task, current_task, schedule, Task, TaskStatus};\n+use crate::task::{add_task, schedule, Task, TaskStatus};\n \n // # Explanation on the memory orders\n //\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -209,7 +209,7 @@ impl Waiter {\n     pub fn new_pair() -> (Self, Arc<Waker>) {\n         let waker = Arc::new(Waker {\n             has_woken: AtomicBool::new(false),\n-            task: current_task().unwrap(),\n+            task: Task::current().unwrap(),\n         });\n         let waiter = Self {\n             waker: waker.clone(),\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -10,7 +10,7 @@ mod task;\n \n pub use self::{\n     priority::Priority,\n-    processor::{current_task, disable_preempt, preempt, schedule, DisablePreemptGuard},\n+    processor::{disable_preempt, preempt, schedule, DisablePreemptGuard},\n     scheduler::{add_task, set_scheduler, FifoScheduler, Scheduler},\n     task::{Task, TaskAdapter, TaskContextApi, TaskOptions, TaskStatus},\n };\ndiff --git a/ostd/src/task/priority.rs b/ostd/src/task/priority.rs\n--- a/ostd/src/task/priority.rs\n+++ b/ostd/src/task/priority.rs\n@@ -7,7 +7,7 @@ pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n /// Similar to Linux, a larger value represents a lower priority,\n /// with a range of 0 to 139. Priorities ranging from 0 to 99 are considered real-time,\n /// while those ranging from 100 to 139 are considered normal.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct Priority(u16);\n \n impl Priority {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,59 +1,40 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::{arch, cpu_local};\n-\n-pub struct Processor {\n-    current: Option<Arc<Task>>,\n-    /// A temporary variable used in [`switch_to_task`] to avoid dropping `current` while running\n-    /// as `current`.\n-    prev_task: Option<Arc<Task>>,\n-    idle_task_ctx: TaskContext,\n+use crate::{cpu::local::PREEMPT_LOCK_COUNT, cpu_local_cell};\n+\n+cpu_local_cell! {\n+    /// The `Arc<Task>` (casted by [`Arc::into_raw`]) that is the current task.\n+    static CURRENT_TASK_PTR: *const Task = core::ptr::null();\n+    /// The previous task on the processor before switching to the current task.\n+    /// It is used for delayed resource release since it would be the current\n+    /// task's job to recycle the previous resources.\n+    static PREVIOUS_TASK_PTR: *const Task = core::ptr::null();\n+    /// An unsafe cell to store the context of the bootstrap code.\n+    static BOOTSTRAP_CONTEXT: TaskContext = TaskContext::new();\n }\n \n-impl Processor {\n-    pub const fn new() -> Self {\n-        Self {\n-            current: None,\n-            prev_task: None,\n-            idle_task_ctx: TaskContext::new(),\n-        }\n-    }\n-    fn get_idle_task_ctx_ptr(&mut self) -> *mut TaskContext {\n-        &mut self.idle_task_ctx as *mut _\n-    }\n-    pub fn take_current(&mut self) -> Option<Arc<Task>> {\n-        self.current.take()\n-    }\n-    pub fn current(&self) -> Option<Arc<Task>> {\n-        self.current.as_ref().map(Arc::clone)\n-    }\n-    pub fn set_current_task(&mut self, task: Arc<Task>) {\n-        self.current = Some(task.clone());\n-    }\n-}\n-\n-cpu_local! {\n-    static PROCESSOR: RefCell<Processor> = RefCell::new(Processor::new());\n-}\n-\n-/// Retrieves the current task running on the processor.\n-pub fn current_task() -> Option<Arc<Task>> {\n-    PROCESSOR.borrow_irq_disabled().borrow().current()\n-}\n-\n-pub(crate) fn get_idle_task_ctx_ptr() -> *mut TaskContext {\n-    PROCESSOR\n-        .borrow_irq_disabled()\n-        .borrow_mut()\n-        .get_idle_task_ctx_ptr()\n+/// Retrieves a reference to the current task running on the processor.\n+///\n+/// It returns `None` if the function is called in the bootstrap context.\n+pub(super) fn current_task() -> Option<Arc<Task>> {\n+    let ptr = CURRENT_TASK_PTR.load();\n+    if ptr.is_null() {\n+        return None;\n+    }\n+    // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+    // built with `Arc::into_raw`.\n+    let restored = unsafe { Arc::from_raw(ptr) };\n+    // To let the `CURRENT_TASK_PTR` still own the task, we clone and forget it\n+    // to increment the reference count.\n+    let _ = core::mem::ManuallyDrop::new(restored.clone());\n+    Some(restored)\n }\n \n /// Calls this function to switch to other task by using GLOBAL_SCHEDULER\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -85,36 +66,48 @@ pub fn preempt(task: &Arc<Task>) {\n \n /// Calls this function to switch to other task\n ///\n-/// if current task is none, then it will use the default task context and it will not return to this function again\n-///\n-/// if current task status is exit, then it will not add to the scheduler\n+/// If current task is none, then it will use the default task context and it\n+/// will not return to this function again.\n ///\n-/// before context switch, current task will switch to the next task\n+/// If the current task's status not [`TaskStatus::Runnable`], it will not be\n+/// added to the scheduler.\n fn switch_to_task(next_task: Arc<Task>) {\n-    if !PREEMPT_COUNT.is_preemptive() {\n+    let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n+    if preemt_lock_count != 0 {\n         panic!(\n             \"Calling schedule() while holding {} locks\",\n-            PREEMPT_COUNT.num_locks()\n+            preemt_lock_count\n         );\n     }\n \n-    let current_task_ctx_ptr = match current_task() {\n-        None => get_idle_task_ctx_ptr(),\n-        Some(current_task) => {\n-            let ctx_ptr = current_task.ctx().get();\n+    let irq_guard = crate::trap::disable_local();\n+\n+    let current_task_ptr = CURRENT_TASK_PTR.load();\n+\n+    let current_task_ctx_ptr = if current_task_ptr.is_null() {\n+        // SAFETY: Interrupts are disabled, so the pointer is safe to be fetched.\n+        unsafe { BOOTSTRAP_CONTEXT.as_ptr_mut() }\n+    } else {\n+        // SAFETY: The pointer is not NULL and set as the current task.\n+        let cur_task_arc = unsafe {\n+            let restored = Arc::from_raw(current_task_ptr);\n+            let _ = core::mem::ManuallyDrop::new(restored.clone());\n+            restored\n+        };\n \n-            let mut task_inner = current_task.inner_exclusive_access();\n+        let ctx_ptr = cur_task_arc.ctx().get();\n \n-            debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n-            if task_inner.task_status == TaskStatus::Runnable {\n-                drop(task_inner);\n-                GLOBAL_SCHEDULER.lock_irq_disabled().enqueue(current_task);\n-            } else if task_inner.task_status == TaskStatus::Sleepy {\n-                task_inner.task_status = TaskStatus::Sleeping;\n-            }\n+        let mut task_inner = cur_task_arc.inner_exclusive_access();\n \n-            ctx_ptr\n+        debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n+        if task_inner.task_status == TaskStatus::Runnable {\n+            drop(task_inner);\n+            GLOBAL_SCHEDULER.lock().enqueue(cur_task_arc);\n+        } else if task_inner.task_status == TaskStatus::Sleepy {\n+            task_inner.task_status = TaskStatus::Sleeping;\n         }\n+\n+        ctx_ptr\n     };\n \n     let next_task_ctx_ptr = next_task.ctx().get().cast_const();\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -124,16 +117,21 @@ fn switch_to_task(next_task: Arc<Task>) {\n     }\n \n     // Change the current task to the next task.\n-    {\n-        let processor_guard = PROCESSOR.borrow_irq_disabled();\n-        let mut processor = processor_guard.borrow_mut();\n-\n-        // We cannot directly overwrite `current` at this point. Since we are running as `current`,\n-        // we must avoid dropping `current`. Otherwise, the kernel stack may be unmapped, leading\n-        // to soundness problems.\n-        let old_current = processor.current.replace(next_task);\n-        processor.prev_task = old_current;\n-    }\n+    //\n+    // We cannot directly drop `current` at this point. Since we are running as\n+    // `current`, we must avoid dropping `current`. Otherwise, the kernel stack\n+    // may be unmapped, leading to instant failure.\n+    let old_prev = PREVIOUS_TASK_PTR.load();\n+    PREVIOUS_TASK_PTR.store(current_task_ptr);\n+    CURRENT_TASK_PTR.store(Arc::into_raw(next_task));\n+    // Drop the old-previously running task.\n+    if !old_prev.is_null() {\n+        // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+        // built with `Arc::into_raw`.\n+        drop(unsafe { Arc::from_raw(old_prev) });\n+    }\n+\n+    drop(irq_guard);\n \n     // SAFETY:\n     // 1. `ctx` is only used in `schedule()`. We have exclusive access to both the current task\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -151,53 +149,6 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-\n-/// Currently, it only holds the number of preemption locks held by the\n-/// current CPU. When it has a non-zero value, the CPU cannot call\n-/// [`schedule()`].\n-///\n-/// For per-CPU preemption lock count, we cannot afford two non-atomic\n-/// operations to increment and decrement the count. The [`crate::cpu_local`]\n-/// implementation is free to read the base register and then calculate the\n-/// address of the per-CPU variable using an additional instruction. Interrupts\n-/// can happen between the address calculation and modification to that\n-/// address. If the task is preempted to another CPU by this interrupt, the\n-/// count of the original CPU will be mistakenly modified. To avoid this, we\n-/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n-/// can implement this using one instruction. In other less expressive\n-/// architectures, we may need to disable interrupts.\n-///\n-/// Also, the preemption count is reserved in the `.cpu_local` section\n-/// specified in the linker script. The reason is that we need to access the\n-/// preemption count before we can copy the section for application processors.\n-/// So, the preemption count is not copied from bootstrap processor's section\n-/// as the initialization. Instead it is initialized to zero for application\n-/// processors.\n-struct PreemptInfo {}\n-\n-impl PreemptInfo {\n-    const fn new() -> Self {\n-        Self {}\n-    }\n-\n-    fn increase_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::inc();\n-    }\n-\n-    fn decrease_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::dec();\n-    }\n-\n-    fn is_preemptive(&self) -> bool {\n-        arch::cpu::local::preempt_lock_count::get() == 0\n-    }\n-\n-    fn num_locks(&self) -> usize {\n-        arch::cpu::local::preempt_lock_count::get() as usize\n-    }\n-}\n-\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -210,7 +161,7 @@ impl !Send for DisablePreemptGuard {}\n \n impl DisablePreemptGuard {\n     fn new() -> Self {\n-        PREEMPT_COUNT.increase_num_locks();\n+        PREEMPT_LOCK_COUNT.add_assign(1);\n         Self { _private: () }\n     }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -223,7 +174,7 @@ impl DisablePreemptGuard {\n \n impl Drop for DisablePreemptGuard {\n     fn drop(&mut self) {\n-        PREEMPT_COUNT.decrease_num_locks();\n+        PREEMPT_LOCK_COUNT.sub_assign(1);\n     }\n }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -3,9 +3,9 @@\n // FIXME: the `intrusive_adapter` macro will generate methods without docs.\n // So we temporary allow missing_docs for this module.\n #![allow(missing_docs)]\n-#![allow(dead_code)]\n \n-use core::cell::UnsafeCell;\n+use alloc::{boxed::Box, sync::Arc};\n+use core::{any::Any, cell::UnsafeCell};\n \n use intrusive_collections::{intrusive_adapter, LinkedListAtomicLink};\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -18,7 +18,7 @@ pub(crate) use crate::arch::task::{context_switch, TaskContext};\n use crate::{\n     arch::mm::tlb_flush_addr_range,\n     cpu::CpuSet,\n-    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, PageFlags, Segment, PAGE_SIZE},\n+    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, Paddr, PageFlags, Segment, PAGE_SIZE},\n     prelude::*,\n     sync::{SpinLock, SpinLockGuard},\n     user::UserSpace,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -41,6 +41,7 @@ pub trait TaskContextApi {\n     fn stack_pointer(&self) -> usize;\n }\n \n+#[derive(Debug)]\n pub struct KernelStack {\n     segment: Segment,\n     has_guard_page: bool,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -121,6 +122,7 @@ pub struct Task {\n     link: LinkedListAtomicLink,\n     priority: Priority,\n     // TODO: add multiprocessor support\n+    #[allow(dead_code)]\n     cpu_affinity: CpuSet,\n }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -131,14 +133,17 @@ intrusive_adapter!(pub TaskAdapter = Arc<Task>: Task { link: LinkedListAtomicLin\n // we have exclusive access to the field.\n unsafe impl Sync for Task {}\n \n+#[derive(Debug)]\n pub(crate) struct TaskInner {\n     pub task_status: TaskStatus,\n }\n \n impl Task {\n     /// Gets the current task.\n-    pub fn current() -> Arc<Task> {\n-        current_task().unwrap()\n+    ///\n+    /// It returns `None` if the function is called in the bootstrap context.\n+    pub fn current() -> Option<Arc<Task>> {\n+        current_task()\n     }\n \n     /// Gets inner\ndiff --git a/ostd/src/trap/handler.rs b/ostd/src/trap/handler.rs\n--- a/ostd/src/trap/handler.rs\n+++ b/ostd/src/trap/handler.rs\n@@ -1,17 +1,15 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use trapframe::TrapFrame;\n \n-use crate::{arch::irq::IRQ_LIST, cpu_local};\n+use crate::{arch::irq::IRQ_LIST, cpu_local_cell};\n \n pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: usize) {\n     // For x86 CPUs, interrupts are not re-entrant. Local interrupts will be disabled when\n     // an interrupt handler is called (Unless interrupts are re-enabled in an interrupt handler).\n     //\n     // FIXME: For arch that supports re-entrant interrupts, we may need to record nested level here.\n-    IN_INTERRUPT_CONTEXT.store(true, Ordering::Release);\n+    IN_INTERRUPT_CONTEXT.store(true);\n \n     let irq_line = IRQ_LIST.get().unwrap().get(irq_number).unwrap();\n     let callback_functions = irq_line.callback_list();\ndiff --git a/ostd/src/trap/handler.rs b/ostd/src/trap/handler.rs\n--- a/ostd/src/trap/handler.rs\n+++ b/ostd/src/trap/handler.rs\n@@ -22,20 +20,17 @@ pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: us\n \n     crate::arch::interrupts_ack(irq_number);\n \n-    IN_INTERRUPT_CONTEXT.store(false, Ordering::Release);\n-\n     crate::arch::irq::enable_local();\n     crate::trap::softirq::process_pending();\n+\n+    IN_INTERRUPT_CONTEXT.store(false);\n }\n \n-cpu_local! {\n-    static IN_INTERRUPT_CONTEXT: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IN_INTERRUPT_CONTEXT: bool = false;\n }\n \n /// Returns whether we are in the interrupt context.\n-///\n-/// FIXME: Here only hardware irq is taken into account. According to linux implementation, if\n-/// we are in softirq context, or bottom half is disabled, this function also returns true.\n pub fn in_interrupt_context() -> bool {\n-    IN_INTERRUPT_CONTEXT.load(Ordering::Acquire)\n+    IN_INTERRUPT_CONTEXT.load()\n }\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -2,14 +2,12 @@\n \n //! Software interrupt.\n \n-#![allow(unused_variables)]\n-\n use alloc::boxed::Box;\n-use core::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n+use core::sync::atomic::{AtomicU8, Ordering};\n \n use spin::Once;\n \n-use crate::{cpu_local, task::disable_preempt};\n+use crate::{cpu_local_cell, task::disable_preempt};\n \n /// A representation of a software interrupt (softirq) line.\n ///\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -70,7 +68,7 @@ impl SoftIrqLine {\n     ///\n     /// If this line is not enabled yet, the method has no effect.\n     pub fn raise(&self) {\n-        PENDING_MASK.fetch_or(1 << self.id, Ordering::Release);\n+        PENDING_MASK.bitor_assign(1 << self.id);\n     }\n \n     /// Enables a softirq line by registering its callback.\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -105,24 +103,24 @@ pub(super) fn init() {\n \n static ENABLED_MASK: AtomicU8 = AtomicU8::new(0);\n \n-cpu_local! {\n-    static PENDING_MASK: AtomicU8 = AtomicU8::new(0);\n-    static IS_ENABLED: AtomicBool = AtomicBool::new(true);\n+cpu_local_cell! {\n+    static PENDING_MASK: u8 = 0;\n+    static IS_ENABLED: bool = true;\n }\n \n /// Enables softirq in current processor.\n fn enable_softirq_local() {\n-    IS_ENABLED.store(true, Ordering::Release);\n+    IS_ENABLED.store(true);\n }\n \n /// Disables softirq in current processor.\n fn disable_softirq_local() {\n-    IS_ENABLED.store(false, Ordering::Release);\n+    IS_ENABLED.store(false);\n }\n \n /// Checks whether the softirq is enabled in current processor.\n fn is_softirq_enabled() -> bool {\n-    IS_ENABLED.load(Ordering::Acquire)\n+    IS_ENABLED.load()\n }\n \n /// Processes pending softirqs.\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -136,12 +134,13 @@ pub(crate) fn process_pending() {\n         return;\n     }\n \n-    let preempt_guard = disable_preempt();\n+    let _preempt_guard = disable_preempt();\n     disable_softirq_local();\n \n-    for i in 0..SOFTIRQ_RUN_TIMES {\n+    for _i in 0..SOFTIRQ_RUN_TIMES {\n         let mut action_mask = {\n-            let pending_mask = PENDING_MASK.fetch_and(0, Ordering::Acquire);\n+            let pending_mask = PENDING_MASK.load();\n+            PENDING_MASK.store(0);\n             pending_mask & ENABLED_MASK.load(Ordering::Acquire)\n         };\n \ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -12,6 +12,7 @@ use crate::{cpu::UserContext, mm::VmSpace, prelude::*, task::Task};\n ///\n /// Each user space has a VM address space and allows a task to execute in\n /// user mode.\n+#[derive(Debug)]\n pub struct UserSpace {\n     /// vm space\n     vm_space: Arc<VmSpace>,\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -94,7 +95,7 @@ pub trait UserContextApi {\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\n-///     .expect(\"the current task is associated with a user space\");\n+///     .expect(\"the current task is not associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n ///     // Execute in the user space until some interesting events occur.\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -108,14 +109,14 @@ pub struct UserMode<'a> {\n     context: UserContext,\n }\n \n-// An instance of `UserMode` is bound to the current task. So it cannot be\n+// An instance of `UserMode` is bound to the current task. So it cannot be [`Send`].\n impl<'a> !Send for UserMode<'a> {}\n \n impl<'a> UserMode<'a> {\n     /// Creates a new `UserMode`.\n     pub fn new(user_space: &'a Arc<UserSpace>) -> Self {\n         Self {\n-            current: Task::current(),\n+            current: Task::current().unwrap(),\n             user_space,\n             context: user_space.init_ctx,\n         }\ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -136,7 +137,7 @@ impl<'a> UserMode<'a> {\n     where\n         F: FnMut() -> bool,\n     {\n-        debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n+        debug_assert!(Arc::ptr_eq(&self.current, &Task::current().unwrap()));\n         self.context.execute(has_kernel_event)\n     }\n \n",
        "test_patch": "",
        "problem_statement": "Lockless mutability for current task data.\n**This is currently a work-in-progress RFC**\r\n\r\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nThis RFC plans to introduce a mechanism for implementing lock-less inner mutability of task data that would be only accessible through the current task.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\nIn `aster-nix`, there would be a hell lot of inner mutability patterns using `Mutex` or `SpinLock` in the thread structures, such as `SigMask`, `SigStack` and `sig_context`, etc. They are all implemented with locks. However, they should only be accessed through the current thread. There would be no syncing required. Modifying them from non-current threads should be illegal. Locks are too heavy-weighted for such kind of inner mutability patterns.\r\n\r\nAlso, for shared thread/task data, we access them using `current!` in thread/task contexts. These operations would also require fetching the task from a `cpu_local!` object that incurs heavy type-checking and interrupt/preempt blocking operations. Such jobs can be ignored when the caller is definitely in the current task's contexts. As #1105 points out, even the most simple system call `getpid` would access such task exclusive variables many times. Current implementation would require multiple locking operations and IRQ/preempt guarding operations. Many cycles are wasted doing so.\r\n\r\nWe currently only have per-task data storage that is shared (the implementer should provide `Send + Sync` types). Most of the data that don't need to be shared are also stored here, which would require a lock for inner mutability. In this RFC, I would like to introduce a new kind of data in the `ostd::Task` that is exclusive (not shared, no need to be `Send + Sync`). It would offer a chance to implement the above mentioned per-task storage without locks, boosting the performance by a lot.\r\n\r\n### Proposal\r\n\r\nCurrently we access them via `current!()`, which would return a reference over the current task and it's corresponding data. The data is defined within a structure (either `PosixThread` or `KernelThread` currently).\r\n\r\nIn `aster-nix`, most code are running in the context of a task (other code runs in interrupt contexts). So the code would only have one replica of task local exclusive data that is accessible. Such data would only be accessed by the code in the corresponding task context also. Such kind of data should be safely mutably accessed. OSTD should provide a way to define task-context-global per-task mutable variables that are not visible in interrupt contexts. By doing so, many of the data specific to a task can be implemented lock-less.\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\n#### Task entry point\r\n\r\nThe optimal solution would let the task function receive references to the task data as arguments. Then all the functions that requires the data of the current task would like to receive arguments like so. This is the requirement of a function that should be used as a task entry point:\r\n\r\n```rust\r\n/// The entrypoint function of a task takes 4 arguments:\r\n///  1. the mutable task context,\r\n///  2. the shared task context,\r\n///  3. the reference to the mutable per-task data,\r\n///  4. and the reference to the per-task data.\r\npub trait TaskFn =\r\n    Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n```\r\n\r\nAn example of usage:\r\n\r\n```rust\r\n// In `aster-nix`\r\n\r\nuse ostd::task::{MutTaskInfo, Priority, SharedTaskInfo};\r\nuse crate::thread::{\r\n    MutKernelThreadInfo, MutThreadInfo, SharedKernelThreadInfo, SharedThreadInfo, ThreadExt,\r\n};\r\n\r\nfn init_thread(\r\n    task_ctx_mut: &mut MutTaskInfo,\r\n    task_ctx: &SharedTaskInfo,\r\n    thread_ctx_mut: &mut MutThreadInfo,\r\n    thread_ctx: &SharedThreadInfo,\r\n    kthread_ctx_mut: &mut MutKernelThreadInfo,\r\n    kthread_ctx: &SharedKernelThreadInfo,\r\n) {\r\n    println!(\r\n        \"[kernel] Spawn init thread, tid = {}\",\r\n        thread_ctx.tid\r\n    );\r\n    let initproc = Process::spawn_user_process(\r\n        karg.get_initproc_path().unwrap(),\r\n        karg.get_initproc_argv().to_vec(),\r\n        karg.get_initproc_envp().to_vec(),\r\n    )\r\n    .expect(\"Run init process failed.\");\r\n    // Wait till initproc become zombie.\r\n    while !initproc.is_zombie() {\r\n        // We don't have preemptive scheduler now.\r\n        // The long running init thread should yield its own execution to allow other tasks to go on.\r\n        task_ctx_mut.yield_now();\r\n    }\r\n}\r\n\r\n#[controlled]\r\npub fn run_first_process() -> ! {\r\n    let _thread = thread::new_kernel(init_thread, Priority::normal(), CpuSet::new_full());\r\n}\r\n```\r\n\r\nSuch approach can eliminate the need of neither `current!` nor `current_thread!`, but introduces verbose parameters for the functions. This approach would be implemented by #1108 .\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n#### Context markers\r\n\r\nOf course, the easiest way to block IRQ code from accessing task exclusive local data is to have a global state `IN_INTERRUPT_CONTEXT` and check for this state every time when accessing the task exclusive local variables. This would incur some (but not much) runtime overhead. Such overhead can be eliminated by static analysis, which we would encourage.\r\n\r\nThere would be 3 kind of contexts: the bootstrap context, the task context and the interrupt context. So the code would have $2^3=8$ types of possibilities to run in different contexts. But there are only 4 types that are significant:\r\n\r\n 1. Utility code that could run in all 3 kind of contexts;\r\n 2. Bootstrap code that only runs in the bootstrap context;\r\n 3. The IRQ handler that would only run in the interrupt context;\r\n 4. Task code that would only run in the task context.\r\n\r\nOther code can be regarded as the type 1., since we do not know where would it run (for example, the page table cursor methods).\r\n\r\nCode must be written in functions (except for some really low level bootstrap code, which are all in OSTD). So we can mark functions with the above types, and check if type 1./2./3. functions accessed task local exclusive global variables.\r\n\r\nHere are the rules for function types:\r\n\r\n - All functions that may call 2. should be 2., the root of type 2. function is `ostd::main` and `ostd::ap_entry`;\r\n - all functions that may call 3. should be 3., the root of type 3. functions are send to `IrqLine::on_active`;\r\n - all functions that may call 4. should be 4., the root of type 4. functions are send to `TaskOptions`;\r\n - if a function can be call with multiple types of functions, it is type 1.\r\n\r\nIn this alternative, two tools will be introduced:\r\n\r\n 1. A procedural macro crate `code_context` (re-exported by OSTD) that provides function attributes `#[code_context::task]`, `#[code_context::interrupt]`, `#[code_context::boot]`. If not specified, the function is type 1.;\r\n 2. A tools that uses rustc to check the above rules ([an example](https://github.com/heinzelotto/rust-callgraph/tree/master)). OSDK would run this tool before compilation to reject unsound code.\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n",
        "hints_text": "Let's say we have a function `foo` with `#[code_context::task]` attribute. How would this `foo` function \"receive references to the task data as arguments\"? What would the user code look like?\n> ```rust\r\n> /// The entrypoint function of a task takes 4 arguments:\r\n> ///  1. the mutable task context,\r\n> ///  2. the shared task context,\r\n> ///  3. the reference to the mutable per-task data,\r\n> ///  4. and the reference to the per-task data.\r\n> pub trait TaskFn =\r\n>     Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n> ```\r\n\r\nCould you please change it to `FnOnce`?\r\n\r\nhttps://github.com/asterinas/asterinas/blob/20a856b07fa8210fdd2d46d3feb5087004c27afb/kernel/aster-nix/src/fs/pipe.rs#L233-L235",
        "created_at": "2024-08-03T03:09:32Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1026,
        "instance_id": "asterinas__asterinas-1026",
        "issue_numbers": [
            "681"
        ],
        "base_commit": "94eba6d85eb9e62ddd904c1132d556b808cc3174",
        "patch": "diff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -5,7 +5,9 @@\n \n use core::ops::Range;\n \n-use ostd::mm::{Frame, FrameVec, PageFlags, VmIo, VmMapOptions, VmSpace};\n+use ostd::mm::{\n+    vm_space::VmQueryResult, CachePolicy, Frame, PageFlags, PageProperty, VmIo, VmSpace,\n+};\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\n use crate::{\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -194,22 +196,41 @@ impl VmMapping {\n         let write_perms = VmPerms::WRITE;\n         self.check_perms(&write_perms)?;\n \n-        let mut page_addr =\n-            self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n-        for page_idx in page_idx_range {\n-            let parent = self.parent.upgrade().unwrap();\n-            let vm_space = parent.vm_space();\n-\n-            // The `VmMapping` has the write permission but the corresponding PTE is present and is read-only.\n-            // This means this PTE is set to read-only due to the COW mechanism. In this situation we need to trigger a\n-            // page fault before writing at the VMO to guarantee the consistency between VMO and the page table.\n-            let need_page_fault = vm_space\n-                .query(page_addr)?\n-                .is_some_and(|prop| !prop.flags.contains(PageFlags::W));\n-            if need_page_fault {\n-                self.handle_page_fault(page_addr, false, true)?;\n+        // We need to make sure the mapping exists.\n+        //\n+        // Also, if the `VmMapping` has the write permission but the corresponding\n+        // PTE is present and is read-only, it would be a copy-on-write page. In\n+        // this situation we need to trigger a page fault before writing at the\n+        // VMO to guarantee the consistency between VMO and the page table.\n+        {\n+            let virt_addr =\n+                self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n+            let virt_range = virt_addr..virt_addr + page_idx_range.len() * PAGE_SIZE;\n+\n+            // FIXME: any sane developer would recommend using `parent.vm_space().cursor(&virt_range)`\n+            // to lock the range and check the mapping status. However, this will cause a deadlock because\n+            // `Self::handle_page_fault` would like to create a cursor again. The following implementation\n+            // indeed introduces a TOCTOU bug.\n+            for page_va in virt_range.step_by(PAGE_SIZE) {\n+                let parent = self.parent.upgrade().unwrap();\n+                let mut cursor = parent\n+                    .vm_space()\n+                    .cursor(&(page_va..page_va + PAGE_SIZE))\n+                    .unwrap();\n+                let map_info = cursor.query().unwrap();\n+                drop(cursor);\n+\n+                match map_info {\n+                    VmQueryResult::Mapped { va, prop, .. } => {\n+                        if !prop.flags.contains(PageFlags::W) {\n+                            self.handle_page_fault(va, false, true)?;\n+                        }\n+                    }\n+                    VmQueryResult::NotMapped { va, .. } => {\n+                        self.handle_page_fault(va, true, true)?;\n+                    }\n+                }\n             }\n-            page_addr += PAGE_SIZE;\n         }\n \n         self.vmo.write_bytes(vmo_write_offset, buf)?;\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -458,7 +479,8 @@ impl VmMappingInner {\n         frame: Frame,\n         is_readonly: bool,\n     ) -> Result<()> {\n-        let map_addr = self.page_map_addr(page_idx);\n+        let map_va = self.page_map_addr(page_idx);\n+        let map_va = map_va..map_va + PAGE_SIZE;\n \n         let vm_perms = {\n             let mut perms = self.perms;\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -468,23 +490,11 @@ impl VmMappingInner {\n             }\n             perms\n         };\n+        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n \n-        let vm_map_options = {\n-            let mut options = VmMapOptions::new();\n-            options.addr(Some(map_addr));\n-            options.flags(vm_perms.into());\n-\n-            // After `fork()`, the entire memory space of the parent and child processes is\n-            // protected as read-only. Therefore, whether the pages need to be COWed (if the memory\n-            // region is private) or not (if the memory region is shared), it is necessary to\n-            // overwrite the page table entry to make the page writable again when the parent or\n-            // child process first tries to write to the memory region.\n-            options.can_overwrite(true);\n-\n-            options\n-        };\n+        let mut cursor = vm_space.cursor_mut(&map_va).unwrap();\n+        cursor.map(frame, map_prop);\n \n-        vm_space.map(FrameVec::from_one_frame(frame), &vm_map_options)?;\n         self.mapped_pages.insert(page_idx);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -492,9 +502,10 @@ impl VmMappingInner {\n     fn unmap_one_page(&mut self, vm_space: &VmSpace, page_idx: usize) -> Result<()> {\n         let map_addr = self.page_map_addr(page_idx);\n         let range = map_addr..(map_addr + PAGE_SIZE);\n-        if vm_space.query(map_addr)?.is_some() {\n-            vm_space.unmap(&range)?;\n-        }\n+\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.unmap(PAGE_SIZE);\n+\n         self.mapped_pages.remove(&page_idx);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -528,17 +539,8 @@ impl VmMappingInner {\n     ) -> Result<()> {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n-        let start_page = (range.start - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let end_page = (range.end - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let flags: PageFlags = perms.into();\n-        for page_idx in start_page..end_page {\n-            let page_addr = self.page_map_addr(page_idx);\n-            if vm_space.query(page_addr)?.is_some() {\n-                // If the page is already mapped, we will modify page table\n-                let page_range = page_addr..(page_addr + PAGE_SIZE);\n-                vm_space.protect(&page_range, |p| p.flags = flags)?;\n-            }\n-        }\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.protect(range.len(), |p| p.flags = perms.into(), true)?;\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/frame/frame_vec.rs /dev/null\n--- a/ostd/src/mm/frame/frame_vec.rs\n+++ /dev/null\n@@ -1,172 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Page frames.\n-\n-use alloc::{vec, vec::Vec};\n-\n-use crate::{\n-    mm::{Frame, VmIo, VmReader, VmWriter, PAGE_SIZE},\n-    Error, Result,\n-};\n-\n-/// A collection of base page frames (regular physical memory pages).\n-///\n-/// For the most parts, `FrameVec` is like `Vec<Frame>`. But the\n-/// implementation may or may not be based on [`Vec`]. Having a dedicated\n-/// type to represent a series of page frames is convenient because,\n-/// more often than not, one needs to operate on a batch of frames rather\n-/// a single frame.\n-#[derive(Debug, Clone)]\n-pub struct FrameVec(pub(crate) Vec<Frame>);\n-\n-impl FrameVec {\n-    /// Retrieves a reference to a [`Frame`] at the specified index.\n-    pub fn get(&self, index: usize) -> Option<&Frame> {\n-        self.0.get(index)\n-    }\n-\n-    /// Creates an empty `FrameVec`.\n-    pub fn empty() -> Self {\n-        Self(Vec::new())\n-    }\n-\n-    /// Creates a new `FrameVec` with the specified capacity.\n-    pub fn new_with_capacity(capacity: usize) -> Self {\n-        Self(Vec::with_capacity(capacity))\n-    }\n-\n-    /// Pushes a new frame to the collection.\n-    pub fn push(&mut self, new_frame: Frame) {\n-        self.0.push(new_frame);\n-    }\n-\n-    /// Pops a frame from the collection.\n-    pub fn pop(&mut self) -> Option<Frame> {\n-        self.0.pop()\n-    }\n-\n-    /// Removes a frame at a position.\n-    pub fn remove(&mut self, at: usize) -> Frame {\n-        self.0.remove(at)\n-    }\n-\n-    /// Appends all the [`Frame`]s from `more` to the end of this collection.\n-    /// and clears the frames in `more`.\n-    pub fn append(&mut self, more: &mut FrameVec) -> Result<()> {\n-        self.0.append(&mut more.0);\n-        Ok(())\n-    }\n-\n-    /// Truncates the `FrameVec` to the specified length.\n-    ///\n-    /// If `new_len >= self.len()`, then this method has no effect.\n-    pub fn truncate(&mut self, new_len: usize) {\n-        if new_len >= self.0.len() {\n-            return;\n-        }\n-        self.0.truncate(new_len)\n-    }\n-\n-    /// Returns an iterator over all frames.\n-    pub fn iter(&self) -> core::slice::Iter<'_, Frame> {\n-        self.0.iter()\n-    }\n-\n-    /// Returns the number of frames.\n-    pub fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    /// Returns whether the frame collection is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    /// Returns the number of bytes.\n-    ///\n-    /// This method is equivalent to `self.len() * BASE_PAGE_SIZE`.\n-    pub fn nbytes(&self) -> usize {\n-        self.0.len() * PAGE_SIZE\n-    }\n-\n-    /// Creates a new `FrameVec` from a single [`Frame`].\n-    pub fn from_one_frame(frame: Frame) -> Self {\n-        Self(vec![frame])\n-    }\n-}\n-\n-impl IntoIterator for FrameVec {\n-    type Item = Frame;\n-\n-    type IntoIter = alloc::vec::IntoIter<Self::Item>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.into_iter()\n-    }\n-}\n-\n-impl VmIo for FrameVec {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unread_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_writer: VmWriter = buf.into();\n-        for frame in self.0.iter().skip(num_unread_pages) {\n-            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n-            if read_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-\n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unwrite_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_reader: VmReader = buf.into();\n-        for frame in self.0.iter().skip(num_unwrite_pages) {\n-            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n-            if write_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// An iterator for frames.\n-pub struct FrameVecIter<'a> {\n-    frames: &'a FrameVec,\n-    current: usize,\n-}\n-\n-impl<'a> FrameVecIter<'a> {\n-    /// Creates a new `FrameVecIter` from the given [`FrameVec`].\n-    pub fn new(frames: &'a FrameVec) -> Self {\n-        Self { frames, current: 0 }\n-    }\n-}\n-\n-impl<'a> Iterator for FrameVecIter<'a> {\n-    type Item = &'a Frame;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.current >= self.frames.0.len() {\n-            return None;\n-        }\n-        Some(self.frames.0.get(self.current).unwrap())\n-    }\n-}\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -8,13 +8,11 @@\n //! frames. Frames, with all the properties of pages, can additionally be safely\n //! read and written by the kernel or the user.\n \n-pub mod frame_vec;\n pub mod options;\n pub mod segment;\n \n use core::mem::ManuallyDrop;\n \n-pub use frame_vec::{FrameVec, FrameVecIter};\n pub use segment::Segment;\n \n use super::page::{\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -155,6 +153,48 @@ impl VmIo for Frame {\n     }\n }\n \n+impl VmIo for alloc::vec::Vec<Frame> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_writer: VmWriter = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n+            if read_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_reader: VmReader = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n+            if write_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl PageMeta for FrameMeta {\n     const USAGE: PageUsage = PageUsage::Frame;\n \ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -2,7 +2,7 @@\n \n //! Options for allocating frames\n \n-use super::{Frame, FrameVec, Segment};\n+use super::{Frame, Segment};\n use crate::{\n     mm::{\n         page::{self, meta::FrameMeta},\ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -55,7 +55,7 @@ impl FrameAllocOptions {\n     }\n \n     /// Allocates a collection of page frames according to the given options.\n-    pub fn alloc(&self) -> Result<FrameVec> {\n+    pub fn alloc(&self) -> Result<Vec<Frame>> {\n         let pages = if self.is_contiguous {\n             page::allocator::alloc(self.nframes * PAGE_SIZE).ok_or(Error::NoMemory)?\n         } else {\ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -63,7 +63,7 @@ impl FrameAllocOptions {\n                 .ok_or(Error::NoMemory)?\n                 .into()\n         };\n-        let frames = FrameVec(pages.into_iter().map(|page| Frame { page }).collect());\n+        let frames: Vec<_> = pages.into_iter().map(|page| Frame { page }).collect();\n         if !self.uninit {\n             for frame in frames.iter() {\n                 frame.writer().fill(0);\ndiff --git a/ostd/src/mm/frame/segment.rs b/ostd/src/mm/frame/segment.rs\n--- a/ostd/src/mm/frame/segment.rs\n+++ b/ostd/src/mm/frame/segment.rs\n@@ -16,15 +16,10 @@ use crate::{\n \n /// A handle to a contiguous range of page frames (physical memory pages).\n ///\n-/// The biggest difference between `Segment` and [`FrameVec`] is that\n-/// the page frames must be contiguous for `Segment`.\n-///\n /// A cloned `Segment` refers to the same page frames as the original.\n /// As the original and cloned instances point to the same physical address,  \n /// they are treated as equal to each other.\n ///\n-/// [`FrameVec`]: crate::mm::FrameVec\n-///\n /// #Example\n ///\n /// ```rust\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -18,7 +18,7 @@ use crate::{\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\n-/// e.g., [`VmSpace`], [`FrameVec`], and [`Frame`].\n+/// e.g., [`Segment`], [`Vec<Frame>`] and [`Frame`].\n ///\n /// # Concurrency\n ///\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -27,8 +27,7 @@ use crate::{\n /// desire predictability or atomicity, the users should add extra mechanism\n /// for such properties.\n ///\n-/// [`VmSpace`]: crate::mm::VmSpace\n-/// [`FrameVec`]: crate::mm::FrameVec\n+/// [`Segment`]: crate::mm::Segment\n /// [`Frame`]: crate::mm::Frame\n pub trait VmIo: Send + Sync {\n     /// Reads a specified number of bytes at a specified offset into a given buffer.\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -17,7 +17,7 @@ mod offset;\n pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n-mod space;\n+pub mod vm_space;\n \n use alloc::vec::Vec;\n use core::{fmt::Debug, ops::Range};\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -26,10 +26,10 @@ use spin::Once;\n \n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n-    frame::{options::FrameAllocOptions, Frame, FrameVec, FrameVecIter, Segment},\n+    frame::{options::FrameAllocOptions, Frame, Segment},\n     io::{KernelSpace, UserSpace, VmIo, VmReader, VmWriter},\n     page_prop::{CachePolicy, PageFlags, PageProperty},\n-    space::{VmMapOptions, VmSpace},\n+    vm_space::VmSpace,\n };\n pub(crate) use self::{\n     kspace::paddr_to_vaddr, page::meta::init as init_page_meta, page_prop::PrivilegedPageFlags,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -76,7 +76,7 @@ use super::{\n use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n \n #[derive(Clone, Debug)]\n-pub(crate) enum PageTableQueryResult {\n+pub enum PageTableQueryResult {\n     NotMapped {\n         va: Vaddr,\n         len: usize,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -105,7 +105,7 @@ pub(crate) enum PageTableQueryResult {\n /// simulate the recursion, and adpot a page table locking protocol to\n /// provide concurrency.\n #[derive(Debug)]\n-pub(crate) struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n+pub struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -140,10 +140,7 @@ where\n     ///\n     /// Note that this function does not ensure exclusive access to the claimed\n     /// virtual address range. The accesses using this cursor may block or fail.\n-    pub(crate) fn new(\n-        pt: &'a PageTable<M, E, C>,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Self, PageTableError> {\n+    pub fn new(pt: &'a PageTable<M, E, C>, va: &Range<Vaddr>) -> Result<Self, PageTableError> {\n         if !M::covers(va) {\n             return Err(PageTableError::InvalidVaddrRange(va.start, va.end));\n         }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -198,9 +195,9 @@ where\n     }\n \n     /// Gets the information of the current slot.\n-    pub(crate) fn query(&mut self) -> Option<PageTableQueryResult> {\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n         if self.va >= self.barrier_va.end {\n-            return None;\n+            return Err(PageTableError::InvalidVaddr(self.va));\n         }\n \n         loop {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -209,7 +206,7 @@ where\n \n             let pte = self.read_cur_pte();\n             if !pte.is_present() {\n-                return Some(PageTableQueryResult::NotMapped {\n+                return Ok(PageTableQueryResult::NotMapped {\n                     va,\n                     len: page_size::<C>(level),\n                 });\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -221,14 +218,14 @@ where\n \n             match self.cur_child() {\n                 Child::Page(page) => {\n-                    return Some(PageTableQueryResult::Mapped {\n+                    return Ok(PageTableQueryResult::Mapped {\n                         va,\n                         page,\n                         prop: pte.prop(),\n                     });\n                 }\n                 Child::Untracked(pa) => {\n-                    return Some(PageTableQueryResult::MappedUntracked {\n+                    return Ok(PageTableQueryResult::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -246,7 +243,7 @@ where\n     ///\n     /// If reached the end of a page table node, it leads itself up to the next page of the parent\n     /// page if possible.\n-    fn move_forward(&mut self) {\n+    pub(in crate::mm) fn move_forward(&mut self) {\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -255,6 +252,41 @@ where\n         self.va = next_va;\n     }\n \n+    /// Jumps to the given virtual address.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the address is out of the range where the cursor is required to operate,\n+    /// or has bad alignment.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        assert!(self.barrier_va.contains(&va));\n+        assert!(va % C::BASE_PAGE_SIZE == 0);\n+\n+        loop {\n+            let cur_node_start = self.va & !(page_size::<C>(self.level + 1) - 1);\n+            let cur_node_end = cur_node_start + page_size::<C>(self.level + 1);\n+            // If the address is within the current node, we can jump directly.\n+            if cur_node_start <= va && va < cur_node_end {\n+                self.va = va;\n+                return;\n+            }\n+\n+            // There is a corner case that the cursor is depleted, sitting at the start of the\n+            // next node but the next node is not locked because the parent is not locked.\n+            if self.va >= self.barrier_va.end && self.level == self.guard_level {\n+                self.va = va;\n+                return;\n+            }\n+\n+            debug_assert!(self.level < self.guard_level);\n+            self.level_up();\n+        }\n+    }\n+\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.va\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -327,10 +359,10 @@ where\n \n     fn next(&mut self) -> Option<Self::Item> {\n         let result = self.query();\n-        if result.is_some() {\n+        if result.is_ok() {\n             self.move_forward();\n         }\n-        result\n+        result.ok()\n     }\n }\n \ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -339,7 +371,7 @@ where\n /// Also, it has all the capabilities of a [`Cursor`]. A virtual address range\n /// in a page table can only be accessed by one cursor whether it is mutable or not.\n #[derive(Debug)]\n-pub(crate) struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n+pub struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n     Cursor<'a, M, E, C>,\n )\n where\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -365,43 +397,26 @@ where\n         Cursor::new(pt, va).map(|inner| Self(inner))\n     }\n \n-    /// Gets the information of the current slot and go to the next slot.\n-    ///\n-    /// We choose not to implement `Iterator` or `IterMut` for [`CursorMut`]\n-    /// because the mutable cursor is indeed not an iterator.\n-    pub(crate) fn next(&mut self) -> Option<PageTableQueryResult> {\n-        self.0.next()\n-    }\n-\n     /// Jumps to the given virtual address.\n     ///\n+    /// This is the same as [`Cursor::jump`].\n+    ///\n     /// # Panics\n     ///\n     /// This method panics if the address is out of the range where the cursor is required to operate,\n     /// or has bad alignment.\n-    pub(crate) fn jump(&mut self, va: Vaddr) {\n-        assert!(self.0.barrier_va.contains(&va));\n-        assert!(va % C::BASE_PAGE_SIZE == 0);\n-\n-        loop {\n-            let cur_node_start = self.0.va & !(page_size::<C>(self.0.level + 1) - 1);\n-            let cur_node_end = cur_node_start + page_size::<C>(self.0.level + 1);\n-            // If the address is within the current node, we can jump directly.\n-            if cur_node_start <= va && va < cur_node_end {\n-                self.0.va = va;\n-                return;\n-            }\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va)\n+    }\n \n-            // There is a corner case that the cursor is depleted, sitting at the start of the\n-            // next node but the next node is not locked because the parent is not locked.\n-            if self.0.va >= self.0.barrier_va.end && self.0.level == self.0.guard_level {\n-                self.0.va = va;\n-                return;\n-            }\n+    /// Gets the current virtual address.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n \n-            debug_assert!(self.0.level < self.0.guard_level);\n-            self.0.level_up();\n-        }\n+    /// Gets the information of the current slot.\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n+        self.0.query()\n     }\n \n     /// Maps the range starting from the current address to a [`DynPage`].\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -417,7 +432,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub(crate) unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -472,7 +487,7 @@ where\n     ///  - the range being mapped does not affect kernel's memory safety;\n     ///  - the physical address to be mapped is valid and safe to use;\n     ///  - it is allowed to map untracked pages in this virtual address range.\n-    pub(crate) unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n+    pub unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n         let end = self.0.va + pa.len();\n         let mut pa = pa.start;\n         assert!(end <= self.0.barrier_va.end);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -522,7 +537,7 @@ where\n     /// This function will panic if:\n     ///  - the range to be unmapped is out of the range where the cursor is required to operate;\n     ///  - the range covers only a part of a page.\n-    pub(crate) unsafe fn unmap(&mut self, len: usize) {\n+    pub unsafe fn unmap(&mut self, len: usize) {\n         let end = self.0.va + len;\n         assert!(end <= self.0.barrier_va.end);\n         assert!(end % C::BASE_PAGE_SIZE == 0);\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -579,7 +594,7 @@ where\n     ///\n     /// This function will panic if:\n     ///  - the range to be protected is out of the range where the cursor is required to operate.\n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &mut self,\n         len: usize,\n         mut op: impl FnMut(&mut PageProperty),\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,7 +3,7 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, paddr_to_vaddr,\n+    nr_subpage_per_huge,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -23,8 +23,10 @@ pub(in crate::mm) mod boot_pt;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PageTableError {\n-    /// The virtual address range is invalid.\n+    /// The provided virtual address range is invalid.\n     InvalidVaddrRange(Vaddr, Vaddr),\n+    /// The provided virtual address is invalid.\n+    InvalidVaddr(Vaddr),\n     /// Using virtual address not aligned.\n     UnalignedVaddr,\n     /// Protecting a mapping that does not exist.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -76,7 +78,7 @@ const fn pte_index<C: PagingConstsTrait>(va: Vaddr, level: PagingLevel) -> usize\n /// A handle to a page table.\n /// A page table can track the lifetime of the mapped physical pages.\n #[derive(Debug)]\n-pub(crate) struct PageTable<\n+pub struct PageTable<\n     M: PageTableMode,\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -88,7 +90,7 @@ pub(crate) struct PageTable<\n }\n \n impl PageTable<UserMode> {\n-    pub(crate) fn activate(&self) {\n+    pub fn activate(&self) {\n         // SAFETY: The usermode page table is safe to activate since the kernel\n         // mappings are shared.\n         unsafe {\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -100,7 +102,7 @@ impl PageTable<UserMode> {\n     /// new page table.\n     ///\n     /// TODO: We may consider making the page table itself copy-on-write.\n-    pub(crate) fn fork_copy_on_write(&self) -> Self {\n+    pub fn fork_copy_on_write(&self) -> Self {\n         let mut cursor = self.cursor_mut(&UserMode::VADDR_RANGE).unwrap();\n \n         // SAFETY: Protecting the user page table is safe.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -139,7 +141,7 @@ impl PageTable<KernelMode> {\n     ///\n     /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n     /// other child page tables.\n-    pub(crate) fn create_user_page_table(&self) -> PageTable<UserMode> {\n+    pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n \n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -157,7 +159,7 @@ impl PageTable<KernelMode> {\n     /// The virtual address range should be aligned to the root level page size. Considering\n     /// usize overflows, the caller should provide the index range of the root level pages\n     /// instead of the virtual address range.\n-    pub(crate) fn make_shared_tables(&self, root_index: Range<usize>) {\n+    pub fn make_shared_tables(&self, root_index: Range<usize>) {\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n \n         let start = root_index.start;\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -182,7 +184,7 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n-    pub(crate) fn empty() -> Self {\n+    pub fn empty() -> Self {\n         PageTable {\n             root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n             _phantom: PhantomData,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -197,11 +199,11 @@ where\n     ///\n     /// It is dangerous to directly provide the physical address of the root page table to the\n     /// hardware since the page table node may be dropped, resulting in UAF.\n-    pub(crate) unsafe fn root_paddr(&self) -> Paddr {\n+    pub unsafe fn root_paddr(&self) -> Paddr {\n         self.root.paddr()\n     }\n \n-    pub(crate) unsafe fn map(\n+    pub unsafe fn map(\n         &self,\n         vaddr: &Range<Vaddr>,\n         paddr: &Range<Paddr>,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -211,12 +213,12 @@ where\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n+    pub unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n         self.cursor_mut(vaddr)?.unmap(vaddr.len());\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &self,\n         vaddr: &Range<Vaddr>,\n         op: impl FnMut(&mut PageProperty),\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -250,19 +253,17 @@ where\n \n     /// Create a new cursor exclusively accessing the virtual address range for querying.\n     ///\n-    /// If another cursor is already accessing the range, the new cursor will wait until the\n-    /// previous cursor is dropped.\n-    pub(crate) fn cursor(\n-        &'a self,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n+    /// If another cursor is already accessing the range, the new cursor may wait until the\n+    /// previous cursor is dropped. The modification to the mapping by the cursor may also\n+    /// block or be overriden by the mapping of another cursor.\n+    pub fn cursor(&'a self, va: &Range<Vaddr>) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n         Cursor::new(self, va)\n     }\n \n     /// Create a new reference to the same page table.\n     /// The caller must ensure that the kernel page table is not copied.\n     /// This is only useful for IOMMU page tables. Think twice before using it in other cases.\n-    pub(crate) unsafe fn shallow_copy(&self) -> Self {\n+    pub unsafe fn shallow_copy(&self) -> Self {\n         PageTable {\n             root: self.root.clone_shallow(),\n             _phantom: PhantomData,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -336,9 +338,7 @@ pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n /// The interface for defining architecture-specific page table entries.\n ///\n /// Note that a default PTE shoud be a PTE that points to nothing.\n-pub(crate) trait PageTableEntryTrait:\n-    Clone + Copy + Debug + Default + Pod + Sized + Sync\n-{\n+pub trait PageTableEntryTrait: Clone + Copy + Debug + Default + Pod + Sized + Sync {\n     /// Create a set of new invalid page table flags that indicates an absent page.\n     ///\n     /// Note that currently the implementation requires an all zero PTE to be an absent PTE.\ndiff --git a/ostd/src/mm/space.rs /dev/null\n--- a/ostd/src/mm/space.rs\n+++ /dev/null\n@@ -1,408 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use core::ops::Range;\n-\n-use spin::Once;\n-\n-use super::{\n-    io::UserSpace,\n-    is_page_aligned,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page_table::{PageTable, PageTableMode, UserMode},\n-    CachePolicy, FrameVec, PageFlags, PageProperty, PagingConstsTrait, PrivilegedPageFlags,\n-    VmReader, VmWriter, PAGE_SIZE,\n-};\n-use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        PageTableEntry, PagingConsts,\n-    },\n-    cpu::CpuExceptionInfo,\n-    mm::{\n-        page_table::{Cursor, PageTableQueryResult as PtQr},\n-        Frame, MAX_USERSPACE_VADDR,\n-    },\n-    prelude::*,\n-    Error,\n-};\n-\n-/// Virtual memory space.\n-///\n-/// A virtual memory space (`VmSpace`) can be created and assigned to a user space so that\n-/// the virtual memory of the user space can be manipulated safely. For example,\n-/// given an arbitrary user-space pointer, one can read and write the memory\n-/// location referred to by the user-space pointer without the risk of breaking the\n-/// memory safety of the kernel space.\n-///\n-/// A newly-created `VmSpace` is not backed by any physical memory pages.\n-/// To provide memory pages for a `VmSpace`, one can allocate and map\n-/// physical memory ([`Frame`]s) to the `VmSpace`.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-#[allow(clippy::type_complexity)]\n-pub struct VmSpace {\n-    pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-}\n-\n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n-\n-impl VmSpace {\n-    /// Creates a new VM address space.\n-    pub fn new() -> Self {\n-        Self {\n-            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n-        }\n-    }\n-\n-    /// Activates the page table.\n-    pub(crate) fn activate(&self) {\n-        self.pt.activate();\n-    }\n-\n-    pub(crate) fn handle_page_fault(\n-        &self,\n-        info: &CpuExceptionInfo,\n-    ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n-            return func(self, info);\n-        }\n-        Err(())\n-    }\n-\n-    /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n-    pub fn register_page_fault_handler(\n-        &self,\n-        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n-    ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Maps some physical memory pages into the VM space according to the given\n-    /// options, returning the address where the mapping is created.\n-    ///\n-    /// The ownership of the frames will be transferred to the `VmSpace`.\n-    ///\n-    /// For more information, see [`VmMapOptions`].\n-    pub fn map(&self, frames: FrameVec, options: &VmMapOptions) -> Result<Vaddr> {\n-        if options.addr.is_none() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let addr = options.addr.unwrap();\n-\n-        if addr % PAGE_SIZE != 0 {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let size = frames.nbytes();\n-        let end = addr.checked_add(size).ok_or(Error::InvalidArgs)?;\n-\n-        let va_range = addr..end;\n-        if !UserMode::covers(&va_range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let mut cursor = self.pt.cursor_mut(&va_range)?;\n-\n-        // If overwrite is forbidden, we should check if there are existing mappings\n-        if !options.can_overwrite {\n-            while let Some(qr) = cursor.next() {\n-                if matches!(qr, PtQr::Mapped { .. }) {\n-                    return Err(Error::MapAlreadyMappedVaddr);\n-                }\n-            }\n-            cursor.jump(va_range.start);\n-        }\n-\n-        let prop = PageProperty {\n-            flags: options.flags,\n-            cache: CachePolicy::Writeback,\n-            priv_flags: PrivilegedPageFlags::USER,\n-        };\n-\n-        for frame in frames.into_iter() {\n-            // SAFETY: mapping in the user space with `Frame` is safe.\n-            unsafe {\n-                cursor.map(frame.into(), prop);\n-            }\n-        }\n-\n-        drop(cursor);\n-        tlb_flush_addr_range(&va_range);\n-\n-        Ok(addr)\n-    }\n-\n-    /// Queries about a range of virtual memory.\n-    /// You will get an iterator of `VmQueryResult` which contains the information of\n-    /// each parts of the range.\n-    pub fn query_range(&self, range: &Range<Vaddr>) -> Result<VmQueryIter> {\n-        Ok(VmQueryIter {\n-            cursor: self.pt.cursor(range)?,\n-        })\n-    }\n-\n-    /// Queries about the mapping information about a byte in virtual memory.\n-    /// This is more handy than [`query_range`], but less efficient if you want\n-    /// to query in a batch.\n-    ///\n-    /// [`query_range`]: VmSpace::query_range\n-    pub fn query(&self, vaddr: Vaddr) -> Result<Option<PageProperty>> {\n-        if !(0..MAX_USERSPACE_VADDR).contains(&vaddr) {\n-            return Err(Error::AccessDenied);\n-        }\n-        Ok(self.pt.query(vaddr).map(|(_pa, prop)| prop))\n-    }\n-\n-    /// Unmaps the physical memory pages within the VM address range.\n-    ///\n-    /// The range is allowed to contain gaps, where no physical memory pages\n-    /// are mapped.\n-    pub fn unmap(&self, range: &Range<Vaddr>) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: unmapping in the user space is safe.\n-        unsafe {\n-            self.pt.unmap(range)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Clears all mappings\n-    pub fn clear(&self) {\n-        // SAFETY: unmapping user space is safe, and we don't care unmapping\n-        // invalid ranges.\n-        unsafe {\n-            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        }\n-        tlb_flush_all_excluding_global();\n-    }\n-\n-    /// Updates the VM protection permissions within the VM address range.\n-    ///\n-    /// If any of the page in the given range is not mapped, it is skipped.\n-    /// The method panics when virtual address is not aligned to base page\n-    /// size.\n-    ///\n-    /// It is guarenteed that the operation is called once for each valid\n-    /// page found in the range.\n-    ///\n-    /// TODO: It returns error when invalid operations such as protect\n-    /// partial huge page happens, and efforts are not reverted, leaving us\n-    /// in a bad state.\n-    pub fn protect(&self, range: &Range<Vaddr>, op: impl FnMut(&mut PageProperty)) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: protecting in the user space is safe.\n-        unsafe {\n-            self.pt.protect(range, op)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-        let new_space = Self {\n-            pt: self.pt.fork_copy_on_write(),\n-            page_fault_handler,\n-        };\n-        tlb_flush_all_excluding_global();\n-        new_space\n-    }\n-\n-    /// Creates a reader to read data from the user space of the current task.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmReader`.\n-        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n-    }\n-\n-    /// Creates a writer to write data into the user space.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmWriter`.\n-        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n-    }\n-}\n-\n-impl Default for VmSpace {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// Options for mapping physical memory pages into a VM address space.\n-/// See [`VmSpace::map`].\n-#[derive(Clone, Debug)]\n-pub struct VmMapOptions {\n-    /// Starting virtual address\n-    addr: Option<Vaddr>,\n-    /// Map align\n-    align: usize,\n-    /// Page permissions and status\n-    flags: PageFlags,\n-    /// Can overwrite\n-    can_overwrite: bool,\n-}\n-\n-impl VmMapOptions {\n-    /// Creates the default options.\n-    pub fn new() -> Self {\n-        Self {\n-            addr: None,\n-            align: PagingConsts::BASE_PAGE_SIZE,\n-            flags: PageFlags::empty(),\n-            can_overwrite: false,\n-        }\n-    }\n-\n-    /// Sets the alignment of the address of the mapping.\n-    ///\n-    /// The alignment must be a power-of-2 and greater than or equal to the\n-    /// page size.\n-    ///\n-    /// The default value of this option is the page size.\n-    pub fn align(&mut self, align: usize) -> &mut Self {\n-        self.align = align;\n-        self\n-    }\n-\n-    /// Sets the permissions of the mapping, which affects whether\n-    /// the mapping can be read, written, or executed.\n-    ///\n-    /// The default value of this option is read-only.\n-    pub fn flags(&mut self, flags: PageFlags) -> &mut Self {\n-        self.flags = flags;\n-        self\n-    }\n-\n-    /// Sets the address of the new mapping.\n-    ///\n-    /// The default value of this option is `None`.\n-    pub fn addr(&mut self, addr: Option<Vaddr>) -> &mut Self {\n-        if addr.is_none() {\n-            return self;\n-        }\n-        self.addr = Some(addr.unwrap());\n-        self\n-    }\n-\n-    /// Sets whether the mapping can overwrite any existing mappings.\n-    ///\n-    /// If this option is `true`, then the address option must be `Some(_)`.\n-    ///\n-    /// The default value of this option is `false`.\n-    pub fn can_overwrite(&mut self, can_overwrite: bool) -> &mut Self {\n-        self.can_overwrite = can_overwrite;\n-        self\n-    }\n-}\n-\n-impl Default for VmMapOptions {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// The iterator for querying over the VM space without modifying it.\n-pub struct VmQueryIter<'a> {\n-    cursor: Cursor<'a, UserMode, PageTableEntry, PagingConsts>,\n-}\n-\n-pub enum VmQueryResult {\n-    NotMapped {\n-        va: Vaddr,\n-        len: usize,\n-    },\n-    Mapped {\n-        va: Vaddr,\n-        frame: Frame,\n-        prop: PageProperty,\n-    },\n-}\n-\n-impl Iterator for VmQueryIter<'_> {\n-    type Item = VmQueryResult;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.cursor.next().map(|ptqr| match ptqr {\n-            PtQr::NotMapped { va, len } => VmQueryResult::NotMapped { va, len },\n-            PtQr::Mapped { va, page, prop } => VmQueryResult::Mapped {\n-                va,\n-                frame: page.try_into().unwrap(),\n-                prop,\n-            },\n-            // It is not possible to map untyped memory in user space.\n-            PtQr::MappedUntracked { .. } => unreachable!(),\n-        })\n-    }\n-}\ndiff --git /dev/null b/ostd/src/mm/vm_space.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/vm_space.rs\n@@ -0,0 +1,373 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Virtual memory space management.\n+//!\n+//! The [`VmSpace`] struct is provided to manage the virtual memory space of a\n+//! user. Cursors are used to traverse and modify over the virtual memory space\n+//! concurrently. The VM space cursor [`self::Cursor`] is just a wrapper over\n+//! the page table cursor [`super::page_table::Cursor`], providing efficient,\n+//! powerful concurrent accesses to the page table, and suffers from the same\n+//! validity concerns as described in [`super::page_table::cursor`].\n+\n+use core::ops::Range;\n+\n+use spin::Once;\n+\n+use super::{\n+    io::UserSpace,\n+    kspace::KERNEL_PAGE_TABLE,\n+    page_table::{PageTable, UserMode},\n+    PageProperty, VmReader, VmWriter,\n+};\n+use crate::{\n+    arch::mm::{\n+        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        PageTableEntry, PagingConsts,\n+    },\n+    cpu::CpuExceptionInfo,\n+    mm::{\n+        page_table::{self, PageTableQueryResult as PtQr},\n+        Frame, MAX_USERSPACE_VADDR,\n+    },\n+    prelude::*,\n+    Error,\n+};\n+\n+/// Virtual memory space.\n+///\n+/// A virtual memory space (`VmSpace`) can be created and assigned to a user\n+/// space so that the virtual memory of the user space can be manipulated\n+/// safely. For example,  given an arbitrary user-space pointer, one can read\n+/// and write the memory location referred to by the user-space pointer without\n+/// the risk of breaking the memory safety of the kernel space.\n+///\n+/// A newly-created `VmSpace` is not backed by any physical memory pages. To\n+/// provide memory pages for a `VmSpace`, one can allocate and map physical\n+/// memory ([`Frame`]s) to the `VmSpace` using the cursor.\n+///\n+/// A `VmSpace` can also attach a page fault handler, which will be invoked to\n+/// handle page faults generated from user space.\n+#[allow(clippy::type_complexity)]\n+pub struct VmSpace {\n+    pt: PageTable<UserMode>,\n+    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+}\n+\n+// Notes on TLB flushing:\n+//\n+// We currently assume that:\n+// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n+//    immediately after we make changes to the page table entries. So we must invalidate the\n+//    corresponding TLB caches accordingly.\n+// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n+//    support is not yet available. But we need to consider this situation in the future (TODO).\n+impl VmSpace {\n+    /// Creates a new VM address space.\n+    pub fn new() -> Self {\n+        Self {\n+            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n+            page_fault_handler: Once::new(),\n+        }\n+    }\n+\n+    /// Gets an immutable cursor in the virtual address range.\n+    ///\n+    /// The cursor behaves like a lock guard, exclusively owning a sub-tree of\n+    /// the page table, preventing others from creating a cursor in it. So be\n+    /// sure to drop the cursor as soon as possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive.\n+    pub fn cursor(&self, va: &Range<Vaddr>) -> Result<Cursor<'_>> {\n+        Ok(self.pt.cursor(va).map(Cursor)?)\n+    }\n+\n+    /// Gets an mutable cursor in the virtual address range.\n+    ///\n+    /// The same as [`Self::cursor`], the cursor behaves like a lock guard,\n+    /// exclusively owning a sub-tree of the page table, preventing others\n+    /// from creating a cursor in it. So be sure to drop the cursor as soon as\n+    /// possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive. The modification to the mapping by the\n+    /// cursor may also block or be overriden the mapping of another cursor.\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n+        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    }\n+\n+    /// Activates the page table.\n+    pub(crate) fn activate(&self) {\n+        self.pt.activate();\n+    }\n+\n+    pub(crate) fn handle_page_fault(\n+        &self,\n+        info: &CpuExceptionInfo,\n+    ) -> core::result::Result<(), ()> {\n+        if let Some(func) = self.page_fault_handler.get() {\n+            return func(self, info);\n+        }\n+        Err(())\n+    }\n+\n+    /// Registers the page fault handler in this `VmSpace`.\n+    ///\n+    /// The page fault handler of a `VmSpace` can only be initialized once.\n+    /// If it has been initialized before, calling this method will have no effect.\n+    pub fn register_page_fault_handler(\n+        &self,\n+        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n+    ) {\n+        self.page_fault_handler.call_once(|| func);\n+    }\n+\n+    /// Clears all mappings\n+    pub fn clear(&self) {\n+        // SAFETY: unmapping user space is safe, and we don't care unmapping\n+        // invalid ranges.\n+        unsafe {\n+            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n+        }\n+        tlb_flush_all_excluding_global();\n+    }\n+\n+    /// Forks a new VM space with copy-on-write semantics.\n+    ///\n+    /// Both the parent and the newly forked VM space will be marked as\n+    /// read-only. And both the VM space will take handles to the same\n+    /// physical memory pages.\n+    pub fn fork_copy_on_write(&self) -> Self {\n+        let page_fault_handler = {\n+            let new_handler = Once::new();\n+            if let Some(handler) = self.page_fault_handler.get() {\n+                new_handler.call_once(|| *handler);\n+            }\n+            new_handler\n+        };\n+        let new_space = Self {\n+            pt: self.pt.fork_copy_on_write(),\n+            page_fault_handler,\n+        };\n+        tlb_flush_all_excluding_global();\n+        new_space\n+    }\n+\n+    /// Creates a reader to read data from the user space of the current task.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmReader`.\n+        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n+    }\n+\n+    /// Creates a writer to write data into the user space.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmWriter`.\n+        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n+    }\n+}\n+\n+impl Default for VmSpace {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+/// The cursor for querying over the VM space without modifying it.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree. Two read-only cursors can not be\n+/// created from the same virtual address range either.\n+pub struct Cursor<'a>(page_table::Cursor<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl Iterator for Cursor<'_> {\n+    type Item = VmQueryResult;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let result = self.query();\n+        if result.is_ok() {\n+            self.0.move_forward();\n+        }\n+        result.ok()\n+    }\n+}\n+\n+impl Cursor<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+}\n+\n+/// The cursor for modifying the mappings in VM space.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree.\n+pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl CursorMut<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This is the same as [`Cursor::query`].\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    ///\n+    /// This is the same as [`Cursor::jump`].\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+\n+    /// Map a frame into the current slot.\n+    ///\n+    /// This method will bring the cursor to the next slot after the modification.\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + frame.size();\n+\n+        // SAFETY: It is safe to map untyped memory into the userspace.\n+        unsafe {\n+            self.0.map(frame.into(), prop);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Clear the mapping starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn unmap(&mut self, len: usize) {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to un-map memory in the userspace.\n+        unsafe {\n+            self.0.unmap(len);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Change the mapping property starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// The way to change the property is specified by the closure `op`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn protect(\n+        &mut self,\n+        len: usize,\n+        op: impl FnMut(&mut PageProperty),\n+        allow_protect_absent: bool,\n+    ) -> Result<()> {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to protect memory in the userspace.\n+        let result = unsafe { self.0.protect(len, op, allow_protect_absent) };\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+\n+        Ok(result?)\n+    }\n+}\n+\n+/// The result of a query over the VM space.\n+#[derive(Debug)]\n+pub enum VmQueryResult {\n+    /// The current slot is not mapped.\n+    NotMapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The length of the slot.\n+        len: usize,\n+    },\n+    /// The current slot is mapped.\n+    Mapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The mapped frame.\n+        frame: Frame,\n+        /// The property of the slot.\n+        prop: PageProperty,\n+    },\n+}\n+\n+impl TryFrom<PtQr> for VmQueryResult {\n+    type Error = &'static str;\n+\n+    fn try_from(ptqr: PtQr) -> core::result::Result<Self, Self::Error> {\n+        match ptqr {\n+            PtQr::NotMapped { va, len } => Ok(VmQueryResult::NotMapped { va, len }),\n+            PtQr::Mapped { va, page, prop } => Ok(VmQueryResult::Mapped {\n+                va,\n+                frame: page\n+                    .try_into()\n+                    .map_err(|_| \"found typed memory mapped into `VmSpace`\")?,\n+                prop,\n+            }),\n+            PtQr::MappedUntracked { .. } => Err(\"found untracked memory mapped into `VmSpace`\"),\n+        }\n+    }\n+}\n",
        "test_patch": "",
        "problem_statement": "The APIs of `VmSpace` are vulnerable to race conditions\n```rust\r\n#[derive(Debug, Clone)]\r\npub struct VmSpace {\r\n    memory_set: Arc<Mutex<MemorySet>>,\r\n}\r\n\r\nimpl VmSpace {\r\n    /// determine whether a vaddr is already mapped\r\n    pub fn is_mapped(&self, vaddr: Vaddr) -> bool {\r\n        let memory_set = self.memory_set.lock();\r\n        memory_set.is_mapped(vaddr)\r\n    }\r\n}\r\n```\r\n\r\n- This API is racy by design *unless an external lock is used properly*.\r\n   - `is_mapped` returns whether the page is mapped or not *when the method is called*, but the result can be changed immediately just after the method returns (because it releases the `VmSpace`'s lock).\r\n - Even `type VmSpace = Arc<Mutex<MemorySet>>` is probably better, at least it makes the lock explicit.\r\n   - Something like `vm_space.lock().is_mapped(vaddr1) && vm_space.lock().is_mapped(vaddr2)` is obviously wrong (or at least not optimized) code.\n",
        "hints_text": "",
        "created_at": "2024-07-04T11:40:07Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1098,
        "instance_id": "asterinas__asterinas-1098",
        "issue_numbers": [
            "819"
        ],
        "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -59,14 +59,7 @@ impl AnyUnboundSocket {\n     }\n }\n \n-pub struct AnyBoundSocket {\n-    iface: Arc<dyn Iface>,\n-    handle: smoltcp::iface::SocketHandle,\n-    port: u16,\n-    socket_family: SocketFamily,\n-    observer: RwLock<Weak<dyn Observer<()>>>,\n-    weak_self: Weak<Self>,\n-}\n+pub struct AnyBoundSocket(Arc<AnyBoundSocketInner>);\n \n impl AnyBoundSocket {\n     pub(super) fn new(\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -75,21 +68,18 @@ impl AnyBoundSocket {\n         port: u16,\n         socket_family: SocketFamily,\n         observer: Weak<dyn Observer<()>>,\n-    ) -> Arc<Self> {\n-        Arc::new_cyclic(|weak_self| Self {\n+    ) -> Self {\n+        Self(Arc::new(AnyBoundSocketInner {\n             iface,\n             handle,\n             port,\n             socket_family,\n             observer: RwLock::new(observer),\n-            weak_self: weak_self.clone(),\n-        })\n+        }))\n     }\n \n-    pub(super) fn on_iface_events(&self) {\n-        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n-            observer.on_events(&())\n-        }\n+    pub(super) fn inner(&self) -> &Arc<AnyBoundSocketInner> {\n+        &self.0\n     }\n \n     /// Set the observer whose `on_events` will be called when certain iface events happen. After\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -99,34 +89,32 @@ impl AnyBoundSocket {\n     /// that the old observer will never be called after the setting. Users should be aware of this\n     /// and proactively handle the race conditions if necessary.\n     pub fn set_observer(&self, handler: Weak<dyn Observer<()>>) {\n-        *self.observer.write() = handler;\n+        *self.0.observer.write() = handler;\n \n-        self.on_iface_events();\n+        self.0.on_iface_events();\n     }\n \n     pub fn local_endpoint(&self) -> Option<IpEndpoint> {\n         let ip_addr = {\n-            let ipv4_addr = self.iface.ipv4_addr()?;\n+            let ipv4_addr = self.0.iface.ipv4_addr()?;\n             IpAddress::Ipv4(ipv4_addr)\n         };\n-        Some(IpEndpoint::new(ip_addr, self.port))\n+        Some(IpEndpoint::new(ip_addr, self.0.port))\n     }\n \n     pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n         &self,\n-        mut f: F,\n+        f: F,\n     ) -> R {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<T>(self.handle);\n-        f(socket)\n+        self.0.raw_with(f)\n     }\n \n     /// Try to connect to a remote endpoint. Tcp socket only.\n     pub fn do_connect(&self, remote_endpoint: IpEndpoint) -> Result<()> {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<RawTcpSocket>(self.handle);\n-        let port = self.port;\n-        let mut iface_inner = self.iface.iface_inner();\n+        let mut sockets = self.0.iface.sockets();\n+        let socket = sockets.get_mut::<RawTcpSocket>(self.0.handle);\n+        let port = self.0.port;\n+        let mut iface_inner = self.0.iface.iface_inner();\n         let cx = iface_inner.context();\n         socket\n             .connect(cx, remote_endpoint, port)\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -135,28 +123,84 @@ impl AnyBoundSocket {\n     }\n \n     pub fn iface(&self) -> &Arc<dyn Iface> {\n-        &self.iface\n+        &self.0.iface\n     }\n+}\n \n-    pub(super) fn weak_ref(&self) -> Weak<Self> {\n-        self.weak_self.clone()\n+impl Drop for AnyBoundSocket {\n+    fn drop(&mut self) {\n+        if self.0.start_closing() {\n+            self.0.iface.common().remove_bound_socket_now(&self.0);\n+        } else {\n+            self.0\n+                .iface\n+                .common()\n+                .remove_bound_socket_when_closed(&self.0);\n+        }\n     }\n+}\n \n-    fn close(&self) {\n+pub(super) struct AnyBoundSocketInner {\n+    iface: Arc<dyn Iface>,\n+    handle: smoltcp::iface::SocketHandle,\n+    port: u16,\n+    socket_family: SocketFamily,\n+    observer: RwLock<Weak<dyn Observer<()>>>,\n+}\n+\n+impl AnyBoundSocketInner {\n+    pub(super) fn on_iface_events(&self) {\n+        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n+            observer.on_events(&())\n+        }\n+    }\n+\n+    pub(super) fn is_closed(&self) -> bool {\n+        match self.socket_family {\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => true,\n+        }\n+    }\n+\n+    /// Starts closing the socket and returns whether the socket is closed.\n+    ///\n+    /// For sockets that can be closed immediately, such as UDP sockets and TCP listening sockets,\n+    /// this method will always return `true`.\n+    ///\n+    /// For other sockets, such as TCP connected sockets, they cannot be closed immediately because\n+    /// we at least need to send the FIN packet and wait for the remote end to send an ACK packet.\n+    /// In this case, this method will return `false` and [`Self::is_closed`] can be used to\n+    /// determine if the closing process is complete.\n+    fn start_closing(&self) -> bool {\n         match self.socket_family {\n-            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| socket.close()),\n-            SocketFamily::Udp => self.raw_with(|socket: &mut RawUdpSocket| socket.close()),\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.close();\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => {\n+                self.raw_with(|socket: &mut RawUdpSocket| socket.close());\n+                true\n+            }\n         }\n     }\n+\n+    pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n+        &self,\n+        mut f: F,\n+    ) -> R {\n+        let mut sockets = self.iface.sockets();\n+        let socket = sockets.get_mut::<T>(self.handle);\n+        f(socket)\n+    }\n }\n \n-impl Drop for AnyBoundSocket {\n+impl Drop for AnyBoundSocketInner {\n     fn drop(&mut self) {\n-        self.close();\n-        self.iface.poll();\n-        self.iface.common().remove_socket(self.handle);\n-        self.iface.common().release_port(self.port);\n-        self.iface.common().remove_bound_socket(self.weak_ref());\n+        let iface_common = self.iface.common();\n+        iface_common.remove_socket(self.handle);\n+        iface_common.release_port(self.port);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,7 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n-use keyable_arc::KeyableWeak;\n+use keyable_arc::KeyableArc;\n use ostd::sync::WaitQueue;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -12,10 +12,10 @@ use smoltcp::{\n };\n \n use super::{\n-    any_socket::{AnyBoundSocket, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n+    any_socket::{AnyBoundSocketInner, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n     time::get_network_timestamp,\n     util::BindPortConfig,\n-    Iface, Ipv4Address,\n+    AnyBoundSocket, Iface, Ipv4Address,\n };\n use crate::prelude::*;\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -25,7 +25,8 @@ pub struct IfaceCommon {\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n     /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n-    bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    bound_sockets: RwLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n+    closing_sockets: SpinLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n     /// The wait queue that background polling thread will sleep on\n     polling_wait_queue: WaitQueue,\n }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -40,14 +41,21 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            closing_sockets: SpinLock::new(BTreeSet::new()),\n             polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \n+    /// Acquires the lock to the interface.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn interface(&self) -> SpinLockGuard<smoltcp::iface::Interface> {\n         self.interface.lock_irq_disabled()\n     }\n \n+    /// Acuqires the lock to the sockets.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn sockets(&self) -> SpinLockGuard<smoltcp::iface::SocketSet<'static>> {\n         self.sockets.lock_irq_disabled()\n     }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -109,7 +117,7 @@ impl IfaceCommon {\n         iface: Arc<dyn Iface>,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let port = if let Some(port) = config.port() {\n             port\n         } else {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -135,7 +143,7 @@ impl IfaceCommon {\n             ),\n         };\n         let bound_socket = AnyBoundSocket::new(iface, handle, port, socket_family, observer);\n-        self.insert_bound_socket(&bound_socket).unwrap();\n+        self.insert_bound_socket(bound_socket.inner());\n \n         Ok(bound_socket)\n     }\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -146,37 +154,60 @@ impl IfaceCommon {\n     }\n \n     pub(super) fn poll<D: Device + ?Sized>(&self, device: &mut D) {\n+        let mut sockets = self.sockets.lock_irq_disabled();\n         let mut interface = self.interface.lock_irq_disabled();\n+\n         let timestamp = get_network_timestamp();\n-        let has_events = {\n-            let mut sockets = self.sockets.lock_irq_disabled();\n-            interface.poll(timestamp, device, &mut sockets)\n-            // drop sockets here to avoid deadlock\n-        };\n-        if has_events {\n-            self.bound_sockets.read().iter().for_each(|bound_socket| {\n-                if let Some(bound_socket) = bound_socket.upgrade() {\n-                    bound_socket.on_iface_events();\n+        let (has_events, poll_at) = {\n+            let mut has_events = false;\n+            let mut poll_at;\n+            loop {\n+                has_events |= interface.poll(timestamp, device, &mut sockets);\n+                poll_at = interface.poll_at(timestamp, &sockets);\n+                let Some(instant) = poll_at else {\n+                    break;\n+                };\n+                if instant > timestamp {\n+                    break;\n                 }\n-            });\n-        }\n+            }\n+            (has_events, poll_at)\n+        };\n+\n+        // drop sockets here to avoid deadlock\n+        drop(interface);\n+        drop(sockets);\n \n-        let sockets = self.sockets.lock_irq_disabled();\n-        if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n-            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+        if let Some(instant) = poll_at {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Relaxed);\n             let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms.store(new_instant, Ordering::Relaxed);\n \n-            if new_instant < old_instant {\n+            if old_instant == 0 || new_instant < old_instant {\n                 self.polling_wait_queue.wake_all();\n             }\n         } else {\n             self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n+\n+        if has_events {\n+            // We never try to hold the write lock in the IRQ context, and we disable IRQ when\n+            // holding the write lock. So we don't need to disable IRQ when holding the read lock.\n+            self.bound_sockets.read().iter().for_each(|bound_socket| {\n+                bound_socket.on_iface_events();\n+            });\n+\n+            let closed_sockets = self\n+                .closing_sockets\n+                .lock_irq_disabled()\n+                .extract_if(|closing_socket| closing_socket.is_closed())\n+                .collect::<Vec<_>>();\n+            drop(closed_sockets);\n+        }\n     }\n \n     pub(super) fn next_poll_at_ms(&self) -> Option<u64> {\n-        let millis = self.next_poll_at_ms.load(Ordering::SeqCst);\n+        let millis = self.next_poll_at_ms.load(Ordering::Relaxed);\n         if millis == 0 {\n             None\n         } else {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -184,19 +215,44 @@ impl IfaceCommon {\n         }\n     }\n \n-    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocket>) -> Result<()> {\n-        let weak_ref = KeyableWeak::from(Arc::downgrade(socket));\n-        let mut bound_sockets = self.bound_sockets.write();\n-        if bound_sockets.contains(&weak_ref) {\n-            return_errno_with_message!(Errno::EINVAL, \"the socket is already bound\");\n-        }\n-        bound_sockets.insert(weak_ref);\n-        Ok(())\n+    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let inserted = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .insert(keyable_socket);\n+        assert!(inserted);\n     }\n \n-    pub(super) fn remove_bound_socket(&self, socket: Weak<AnyBoundSocket>) {\n-        let weak_ref = KeyableWeak::from(socket);\n-        self.bound_sockets.write().remove(&weak_ref);\n+    pub(super) fn remove_bound_socket_now(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+    }\n+\n+    pub(super) fn remove_bound_socket_when_closed(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+\n+        let mut closing_sockets = self.closing_sockets.lock_irq_disabled();\n+\n+        // Check `is_closed` after holding the lock to avoid race conditions.\n+        if keyable_socket.is_closed() {\n+            return;\n+        }\n+\n+        let inserted = closing_sockets.insert(keyable_socket);\n+        assert!(inserted);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -45,7 +45,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n         &self,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let common = self.common();\n         common.bind_socket(self.arc_self(), socket, config)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/common.rs b/kernel/aster-nix/src/net/socket/ip/common.rs\n--- a/kernel/aster-nix/src/net/socket/ip/common.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/common.rs\n@@ -46,7 +46,7 @@ pub(super) fn bind_socket(\n     unbound_socket: Box<AnyUnboundSocket>,\n     endpoint: &IpEndpoint,\n     can_reuse: bool,\n-) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n     let iface = match get_iface_to_bind(&endpoint.addr) {\n         Some(iface) => iface,\n         None => {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n--- a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n@@ -13,12 +13,12 @@ use crate::{\n };\n \n pub struct BoundDatagram {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: Option<IpEndpoint>,\n }\n \n impl BoundDatagram {\n-    pub fn new(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new(bound_socket: AnyBoundSocket) -> Self {\n         Self {\n             bound_socket,\n             remote_endpoint: None,\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -15,7 +15,7 @@ use crate::{\n };\n \n pub struct ConnectedStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     /// Indicates whether this connection is \"new\" in a `connect()` system call.\n     ///\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -32,7 +32,7 @@ pub struct ConnectedStream {\n \n impl ConnectedStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n         is_new_connection: bool,\n     ) -> Self {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub struct ConnectingStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     conn_result: RwLock<Option<ConnResult>>,\n }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -26,9 +26,9 @@ pub enum NonConnectedStream {\n \n impl ConnectingStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         if let Err(err) = bound_socket.do_connect(remote_endpoint) {\n             return Err((err, bound_socket));\n         }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -15,7 +15,7 @@ use crate::{\n \n pub enum InitStream {\n     Unbound(Box<AnyUnboundSocket>),\n-    Bound(Arc<AnyBoundSocket>),\n+    Bound(AnyBoundSocket),\n }\n \n impl InitStream {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -23,14 +23,14 @@ impl InitStream {\n         InitStream::Unbound(Box::new(AnyUnboundSocket::new_tcp(observer)))\n     }\n \n-    pub fn new_bound(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new_bound(bound_socket: AnyBoundSocket) -> Self {\n         InitStream::Bound(bound_socket)\n     }\n \n     pub fn bind(\n         self,\n         endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let unbound_socket = match self {\n             InitStream::Unbound(unbound_socket) => unbound_socket,\n             InitStream::Bound(bound_socket) => {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -50,7 +50,7 @@ impl InitStream {\n     fn bind_to_ephemeral_endpoint(\n         self,\n         remote_endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let endpoint = get_ephemeral_endpoint(remote_endpoint);\n         self.bind(&endpoint)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -13,16 +13,16 @@ use crate::{\n pub struct ListenStream {\n     backlog: usize,\n     /// A bound socket held to ensure the TCP port cannot be released\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     /// Backlog sockets listening at the local endpoint\n     backlog_sockets: RwLock<Vec<BacklogSocket>>,\n }\n \n impl ListenStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         backlog: usize,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         let listen_stream = Self {\n             backlog,\n             bound_socket,\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -99,13 +99,13 @@ impl ListenStream {\n }\n \n struct BacklogSocket {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n }\n \n impl BacklogSocket {\n     // FIXME: All of the error codes below seem to have no Linux equivalents, and I see no reason\n     // why the error may occur. Perhaps it is better to call `unwrap()` directly?\n-    fn new(bound_socket: &Arc<AnyBoundSocket>) -> Result<Self> {\n+    fn new(bound_socket: &AnyBoundSocket) -> Result<Self> {\n         let local_endpoint = bound_socket.local_endpoint().ok_or(Error::with_message(\n             Errno::EINVAL,\n             \"the socket is not bound\",\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -143,7 +143,7 @@ impl BacklogSocket {\n             .raw_with(|socket: &mut RawTcpSocket| socket.remote_endpoint())\n     }\n \n-    fn into_bound_socket(self) -> Arc<AnyBoundSocket> {\n+    fn into_bound_socket(self) -> AnyBoundSocket {\n         self.bound_socket\n     }\n }\n",
        "test_patch": "",
        "problem_statement": "Polling ifaces may not ensure packets be transmitted\nThe problem occurs when I trying to send two messages to the same TCP socket, and trying to receive the two messages at once.\r\n\r\n```C\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\n\r\n// Ensure two messages are ready for receiving\r\nsleep(1);\r\n\r\nTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\r\n```\r\n\r\nThe test program always succeeds when running on Linux.\r\n\r\nHowever, when running on Asterinas, `sk_connected` can only accept the first message.\r\n\r\nThe problem disappears when I running in set log level as TRACE. So it may be some problems with timeout.......\r\n\r\n# Possible solution\r\n\r\nThis problem may be related to the [nagle-enabled feature](https://docs.rs/smoltcp/latest/smoltcp/socket/tcp/struct.Socket.html#method.set_nagle_enabled), which disables small packets to be transmitted. If set `nagle-enabled` as false, the problem will also disappear.\r\n\r\nBut totally disabling this feature may affect performance. This feature is same as the `TCP_NODELAY` option in Linux, but Linux keeps this option on by default.\n",
        "hints_text": "",
        "created_at": "2024-07-26T01:51:02Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 637,
        "instance_id": "asterinas__asterinas-637",
        "issue_numbers": [
            "592"
        ],
        "base_commit": "8d456ebe8fc200fc11c75654fdca2f0dd896e656",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -221,37 +221,7 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"aster-rights\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"aster-rights-proc\",\n- \"bitflags 1.3.2\",\n- \"typeflags\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"aster-rights-proc\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n-[[package]]\n-name = \"aster-runner\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anyhow\",\n- \"clap\",\n- \"linux-bzimage-builder\",\n- \"rand\",\n- \"xmas-elf 0.8.0\",\n-]\n-\n-[[package]]\n-name = \"aster-std\"\n+name = \"aster-nix\"\n version = \"0.1.0\"\n dependencies = [\n  \"align_ext\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -296,6 +266,36 @@ dependencies = [\n  \"xmas-elf 0.8.0\",\n ]\n \n+[[package]]\n+name = \"aster-rights\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-rights-proc\",\n+ \"bitflags 1.3.2\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-rights-proc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"aster-runner\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"clap\",\n+ \"linux-bzimage-builder\",\n+ \"rand\",\n+ \"xmas-elf 0.8.0\",\n+]\n+\n [[package]]\n name = \"aster-time\"\n version = \"0.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -350,7 +350,7 @@ version = \"0.3.0\"\n dependencies = [\n  \"aster-frame\",\n  \"aster-framebuffer\",\n- \"aster-std\",\n+ \"aster-nix\",\n  \"aster-time\",\n  \"component\",\n  \"x86_64\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -9,7 +9,7 @@ path = \"kernel/main.rs\"\n \n [dependencies]\n aster-frame = { path = \"framework/aster-frame\" }\n-aster-std = { path = \"services/libs/aster-std\" }\n+aster-nix = { path = \"services/aster-nix\" }\n component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -52,7 +53,6 @@ members = [\n     \"services/libs/int-to-c-enum/derive\",\n     \"services/libs/aster-rights\",\n     \"services/libs/aster-rights-proc\",\n-    \"services/libs/aster-std\",\n     \"services/libs/aster-util\",\n     \"services/libs/keyable-arc\",\n     \"services/libs/typeflags\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -67,4 +67,4 @@ exclude = [\n ]\n \n [features]\n-intel_tdx = [\"aster-frame/intel_tdx\", \"aster-std/intel_tdx\"]\n+intel_tdx = [\"aster-frame/intel_tdx\", \"aster-nix/intel_tdx\"]\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -1,6 +1,6 @@\n # template\n [components]\n-std = { name = \"aster-std\" }\n+nix = { name = \"aster-nix\" }\n virtio = { name = \"aster-virtio\" }\n input = { name = \"aster-input\" }\n block = { name = \"aster-block\" }\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -11,5 +11,5 @@ network = { name = \"aster-network\" }\n main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.std.run_first_process]\n+[whitelist.nix.run_first_process]\n main = true\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -14,6 +14,6 @@ pub fn main() -> ! {\n     aster_frame::init();\n     early_println!(\"[kernel] finish init aster_frame\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    aster_std::init();\n-    aster_std::run_first_process();\n+    aster_nix::init();\n+    aster_nix::run_first_process();\n }\ndiff --git a/services/libs/aster-std/Cargo.toml b/services/aster-nix/Cargo.toml\n--- a/services/libs/aster-std/Cargo.toml\n+++ b/services/aster-nix/Cargo.toml\n@@ -1,28 +1,28 @@\n [package]\n-name = \"aster-std\"\n+name = \"aster-nix\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-aster-frame = { path = \"../../../framework/aster-frame\" }\n-align_ext = { path = \"../../../framework/libs/align_ext\" }\n+aster-frame = { path = \"../../framework/aster-frame\" }\n+align_ext = { path = \"../../framework/libs/align_ext\" }\n pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n-aster-input = { path = \"../../comps/input\" }\n-aster-block = { path = \"../../comps/block\" }\n-aster-network = { path = \"../../comps/network\" }\n-aster-console = { path = \"../../comps/console\" }\n-aster-time = { path = \"../../comps/time\" }\n-aster-virtio = { path = \"../../comps/virtio\" }\n-aster-rights = { path = \"../aster-rights\" }\n-controlled = { path = \"../../libs/comp-sys/controlled\" }\n-typeflags = { path = \"../typeflags\" }\n-typeflags-util = { path = \"../typeflags-util\" }\n-aster-rights-proc = { path = \"../aster-rights-proc\" }\n-aster-util = { path = \"../aster-util\" }\n-int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../cpio-decoder\" }\n+aster-input = { path = \"../comps/input\" }\n+aster-block = { path = \"../comps/block\" }\n+aster-network = { path = \"../comps/network\" }\n+aster-console = { path = \"../comps/console\" }\n+aster-time = { path = \"../comps/time\" }\n+aster-virtio = { path = \"../comps/virtio\" }\n+aster-rights = { path = \"../libs/aster-rights\" }\n+controlled = { path = \"../libs/comp-sys/controlled\" }\n+typeflags = { path = \"../libs/typeflags\" }\n+typeflags-util = { path = \"../libs/typeflags-util\" }\n+aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n+aster-util = { path = \"../libs/aster-util\" }\n+int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"../libs/cpio-decoder\" }\n ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n intrusive-collections = \"0.9.5\"\n time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\ndiff --git a/services/libs/aster-std/Cargo.toml b/services/aster-nix/Cargo.toml\n--- a/services/libs/aster-std/Cargo.toml\n+++ b/services/aster-nix/Cargo.toml\n@@ -49,7 +49,7 @@ xmas-elf = \"0.8.0\"\n # data-structures\n bitflags = \"1.3\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../keyable-arc\" }\n+keyable-arc = { path = \"../libs/keyable-arc\" }\n # unzip initramfs\n libflate = { git = \"https://github.com/asterinas/libflate\", rev = \"b781da6\", features = [\n     \"no_std\",\ndiff --git a/services/libs/aster-std/src/lib.rs b/services/aster-nix/src/lib.rs\n--- a/services/libs/aster-std/src/lib.rs\n+++ b/services/aster-nix/src/lib.rs\n@@ -89,7 +89,7 @@ fn init_thread() {\n     }));\n     thread.join();\n     info!(\n-        \"[aster-std/lib.rs] spawn kernel thread, tid = {}\",\n+        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n         thread.tid()\n     );\n     thread::work_queue::init();\n",
        "test_patch": "",
        "problem_statement": "Rename `aster-std` to `aster-nix`\n# Background\r\n\r\nIn the current codebase, the Linux/UNIX layer is implemented in the `aster-std` crate under `services/libs`. The crate does the heavy-lifting job of implementing high-level OS concepts like processes, signals, file systems, sockets, etc. Ideally, we would like to have the system call layer to be more modular, breaking up the large crate into smaller ones. But this is going to take time and is probably done in an incremental fashion. So in the near future, we will still have to make peace with the sheer size of the `aster-std` crate.\r\n\r\n# Goal\r\n\r\nGiven the role and size of the `aster-std` crate, I propose to change the name and location of the crate.\r\n\r\nIts current name is only for historic reason: the crate is originally positioned as the std library for Asterinas, but it ends up with all system calls implemented in it. So calling it std is no longer appropriate. **I propose renaming it `aster-nix`**, as it implements the Linux and UNIX concepts and system calls.\r\n\r\nThe crate is currently buried in the third level of the project hierarchy, under `services/libs`. This crate is probably the second most important crate (after `aster-frame`) and the most frequently-updated one. Given its importance, I think it makes sense to given the crate a more _visible_ location. So **I propose to move the crate to `services/`**.\n",
        "hints_text": "",
        "created_at": "2024-02-05T08:00:55Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 650,
        "instance_id": "asterinas__asterinas-650",
        "issue_numbers": [
            "646"
        ],
        "base_commit": "07fbbcfd8c22459719c9af7eeeb3dee5ad24ba92",
        "patch": "diff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -105,14 +105,9 @@ static ssize_t receive_all(int sockfd)\n \tsize_t recv_len = 0;\n \tssize_t ret;\n \n-\tif (mark_filde_nonblock(sockfd) < 0) {\n-\t\tperror(\"receive_all: mark_filde_nonblock\");\n-\t\treturn -1;\n-\t}\n-\n \tfor (;;) {\n \t\tret = recv(sockfd, buffer, sizeof(buffer), 0);\n-\t\tif (ret < 0 && errno == EAGAIN)\n+\t\tif (ret == 0)\n \t\t\tbreak;\n \n \t\tif (ret < 0) {\n",
        "test_patch": "",
        "problem_statement": "The send_buf_full test fails on host linux\nThe test is run within Asterinas dev container. \r\n\r\nTo replay the results, commands are \r\n```bash\r\nmake build\r\ncd regression/build/initramfs/regression/network\r\n./send_buf_full\r\n```\r\nI run `./send_buf_full` for four times, the results are\r\n```\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2586567\r\nTest passed: Equal sent bytes and received bytes\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nnew_bound_socket: bind: Address already in use\r\nTest failed: Error occurs in new_bound_socket\r\n```\r\nI have repeated the test several time and find the same results: the test fails at the first run and succeeds in some following run. And once the test succeeds, the following run will report `Address already in use` error.\r\n\n",
        "hints_text": "",
        "created_at": "2024-02-23T12:37:06Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 990,
        "instance_id": "asterinas__asterinas-990",
        "issue_numbers": [
            "944"
        ],
        "base_commit": "4844e7ca7ca6d78896a51a71487a6fdfe9ca6654",
        "patch": "diff --git a/kernel/aster-nix/src/sched/priority_scheduler.rs b/kernel/aster-nix/src/sched/priority_scheduler.rs\n--- a/kernel/aster-nix/src/sched/priority_scheduler.rs\n+++ b/kernel/aster-nix/src/sched/priority_scheduler.rs\n@@ -1,56 +1,234 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use intrusive_collections::LinkedList;\n-use ostd::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n+use ostd::{\n+    cpu::{num_cpus, this_cpu},\n+    task::{\n+        scheduler::{inject_scheduler, EnqueueFlags, LocalRunQueue, Scheduler, UpdateFlags},\n+        AtomicCpuId, Priority, Task,\n+    },\n+};\n \n use crate::prelude::*;\n \n pub fn init() {\n-    let preempt_scheduler = Box::new(PreemptScheduler::new());\n-    let scheduler = Box::<PreemptScheduler>::leak(preempt_scheduler);\n-    set_scheduler(scheduler);\n+    let preempt_scheduler = Box::new(PreemptScheduler::default());\n+    let scheduler = Box::<PreemptScheduler<Task>>::leak(preempt_scheduler);\n+    inject_scheduler(scheduler);\n }\n \n-/// The preempt scheduler\n+/// The preempt scheduler.\n ///\n-/// Real-time tasks are placed in the `real_time_tasks` queue and\n+/// Real-time tasks are placed in the `real_time_entities` queue and\n /// are always prioritized during scheduling.\n-/// Normal tasks are placed in the `normal_tasks` queue and are only\n+/// Normal tasks are placed in the `normal_entities` queue and are only\n /// scheduled for execution when there are no real-time tasks.\n-struct PreemptScheduler {\n-    /// Tasks with a priority of less than 100 are regarded as real-time tasks.\n-    real_time_tasks: SpinLock<LinkedList<TaskAdapter>>,\n-    /// Tasks with a priority greater than or equal to 100 are regarded as normal tasks.\n-    normal_tasks: SpinLock<LinkedList<TaskAdapter>>,\n+struct PreemptScheduler<T: PreemptSchedInfo> {\n+    rq: Vec<SpinLock<PreemptRunQueue<T>>>,\n }\n \n-impl PreemptScheduler {\n+impl<T: PreemptSchedInfo> PreemptScheduler<T> {\n+    fn new(nr_cpus: u32) -> Self {\n+        let mut rq = Vec::with_capacity(nr_cpus as usize);\n+        for _ in 0..nr_cpus {\n+            rq.push(SpinLock::new(PreemptRunQueue::new()));\n+        }\n+        Self { rq }\n+    }\n+\n+    /// Selects a cpu for task to run on.\n+    fn select_cpu(&self, _runnable: &Arc<T>) -> u32 {\n+        // FIXME: adopt more reasonable policy once we fully enable SMP.\n+        0\n+    }\n+}\n+\n+impl<T: Sync + Send + PreemptSchedInfo> Scheduler<T> for PreemptScheduler<T> {\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32> {\n+        let mut still_in_rq = false;\n+        let target_cpu = {\n+            let mut cpu_id = self.select_cpu(&runnable);\n+            if let Err(task_cpu_id) = runnable.cpu().set_if_is_none(cpu_id) {\n+                debug_assert!(flags != EnqueueFlags::Spawn);\n+                still_in_rq = true;\n+                cpu_id = task_cpu_id;\n+            }\n+\n+            cpu_id\n+        };\n+\n+        let mut rq = self.rq[target_cpu as usize].lock_irq_disabled();\n+        if still_in_rq && let Err(_) = runnable.cpu().set_if_is_none(target_cpu) {\n+            return None;\n+        }\n+        let entity = PreemptSchedEntity::new(runnable);\n+        if entity.is_real_time() {\n+            rq.real_time_entities.push_back(entity);\n+        } else {\n+            rq.normal_entities.push_back(entity);\n+        }\n+\n+        Some(target_cpu)\n+    }\n+\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>)) {\n+        let local_rq: &PreemptRunQueue<T> = &self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>)) {\n+        let local_rq: &mut PreemptRunQueue<T> =\n+            &mut self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+}\n+\n+impl Default for PreemptScheduler<Task> {\n+    fn default() -> Self {\n+        Self::new(num_cpus())\n+    }\n+}\n+\n+struct PreemptRunQueue<T: PreemptSchedInfo> {\n+    current: Option<PreemptSchedEntity<T>>,\n+    real_time_entities: VecDeque<PreemptSchedEntity<T>>,\n+    normal_entities: VecDeque<PreemptSchedEntity<T>>,\n+}\n+\n+impl<T: PreemptSchedInfo> PreemptRunQueue<T> {\n     pub fn new() -> Self {\n         Self {\n-            real_time_tasks: SpinLock::new(LinkedList::new(TaskAdapter::new())),\n-            normal_tasks: SpinLock::new(LinkedList::new(TaskAdapter::new())),\n+            current: None,\n+            real_time_entities: VecDeque::new(),\n+            normal_entities: VecDeque::new(),\n         }\n     }\n }\n \n-impl Scheduler for PreemptScheduler {\n-    fn enqueue(&self, task: Arc<Task>) {\n-        if task.is_real_time() {\n-            self.real_time_tasks.lock_irq_disabled().push_back(task);\n-        } else {\n-            self.normal_tasks.lock_irq_disabled().push_back(task);\n+impl<T: Sync + Send + PreemptSchedInfo> LocalRunQueue<T> for PreemptRunQueue<T> {\n+    fn current(&self) -> Option<&Arc<T>> {\n+        self.current.as_ref().map(|entity| &entity.runnable)\n+    }\n+\n+    fn update_current(&mut self, flags: UpdateFlags) -> bool {\n+        match flags {\n+            UpdateFlags::Tick => {\n+                let Some(ref mut current_entity) = self.current else {\n+                    return false;\n+                };\n+                current_entity.tick()\n+                    || (!current_entity.is_real_time() && !self.real_time_entities.is_empty())\n+            }\n+            _ => true,\n         }\n     }\n \n-    fn dequeue(&self) -> Option<Arc<Task>> {\n-        if !self.real_time_tasks.lock_irq_disabled().is_empty() {\n-            self.real_time_tasks.lock_irq_disabled().pop_front()\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>> {\n+        let next_entity = if !self.real_time_entities.is_empty() {\n+            self.real_time_entities.pop_front()\n         } else {\n-            self.normal_tasks.lock_irq_disabled().pop_front()\n+            self.normal_entities.pop_front()\n+        }?;\n+        if let Some(prev_entity) = self.current.replace(next_entity) {\n+            if prev_entity.is_real_time() {\n+                self.real_time_entities.push_back(prev_entity);\n+            } else {\n+                self.normal_entities.push_back(prev_entity);\n+            }\n         }\n+\n+        Some(&self.current.as_ref().unwrap().runnable)\n     }\n \n-    fn should_preempt(&self, task: &Arc<Task>) -> bool {\n-        !task.is_real_time() && !self.real_time_tasks.lock_irq_disabled().is_empty()\n+    fn dequeue_current(&mut self) -> Option<Arc<T>> {\n+        self.current.take().map(|entity| {\n+            let runnable = entity.runnable;\n+            runnable.cpu().set_to_none();\n+\n+            runnable\n+        })\n+    }\n+}\n+\n+struct PreemptSchedEntity<T: PreemptSchedInfo> {\n+    runnable: Arc<T>,\n+    time_slice: TimeSlice,\n+}\n+\n+impl<T: PreemptSchedInfo> PreemptSchedEntity<T> {\n+    fn new(runnable: Arc<T>) -> Self {\n+        Self {\n+            runnable,\n+            time_slice: TimeSlice::default(),\n+        }\n+    }\n+\n+    fn is_real_time(&self) -> bool {\n+        self.runnable.is_real_time()\n+    }\n+\n+    fn tick(&mut self) -> bool {\n+        self.time_slice.elapse()\n+    }\n+}\n+\n+impl<T: PreemptSchedInfo> Clone for PreemptSchedEntity<T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            runnable: self.runnable.clone(),\n+            time_slice: self.time_slice,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct TimeSlice {\n+    elapsed_ticks: u32,\n+}\n+\n+impl TimeSlice {\n+    const DEFAULT_TIME_SLICE: u32 = 100;\n+\n+    pub const fn new() -> Self {\n+        TimeSlice { elapsed_ticks: 0 }\n+    }\n+\n+    pub fn elapse(&mut self) -> bool {\n+        self.elapsed_ticks = (self.elapsed_ticks + 1) % Self::DEFAULT_TIME_SLICE;\n+\n+        self.elapsed_ticks == 0\n+    }\n+}\n+\n+impl Default for TimeSlice {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl PreemptSchedInfo for Task {\n+    type PRIORITY = Priority;\n+\n+    const REAL_TIME_TASK_PRIORITY: Self::PRIORITY = Priority::new(100);\n+\n+    fn priority(&self) -> Self::PRIORITY {\n+        self.priority()\n+    }\n+\n+    fn cpu(&self) -> &AtomicCpuId {\n+        self.cpu()\n+    }\n+}\n+\n+trait PreemptSchedInfo {\n+    type PRIORITY: Ord + PartialOrd + Eq + PartialEq;\n+\n+    const REAL_TIME_TASK_PRIORITY: Self::PRIORITY;\n+\n+    fn priority(&self) -> Self::PRIORITY;\n+\n+    fn cpu(&self) -> &AtomicCpuId;\n+\n+    fn is_real_time(&self) -> bool {\n+        self.priority() < Self::REAL_TIME_TASK_PRIORITY\n     }\n }\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -1,7 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use ostd::{\n-    task::{preempt, Task, TaskOptions},\n+    task::{Task, TaskOptions},\n     user::{ReturnReason, UserContextApi, UserMode, UserSpace},\n };\n \ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -84,8 +84,6 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n                 debug!(\"exit due to signal\");\n                 break;\n             }\n-            // a preemption point after handling user event.\n-            preempt(current_task);\n         }\n         debug!(\"exit user loop\");\n     }\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n--- a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n@@ -7,11 +7,7 @@ use core::{\n     time::Duration,\n };\n \n-use ostd::{\n-    cpu::CpuSet,\n-    sync::WaitQueue,\n-    task::{add_task, Priority},\n-};\n+use ostd::{cpu::CpuSet, sync::WaitQueue, task::Priority};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\n use crate::{\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n--- a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/aster-nix/src/thread/work_queue/worker_pool.rs\n@@ -81,7 +77,7 @@ impl LocalWorkerPool {\n     fn add_worker(&self) {\n         let worker = Worker::new(self.parent.clone(), self.cpu_id);\n         self.workers.lock_irq_disabled().push_back(worker.clone());\n-        add_task(worker.bound_thread().task().clone());\n+        worker.bound_thread().run();\n     }\n \n     fn remove_worker(&self) {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -17,6 +17,7 @@ use trapframe::UserContext as RawUserContext;\n use x86_64::registers::rflags::RFlags;\n \n use crate::{\n+    task::scheduler,\n     trap::call_irq_callback_functions,\n     user::{ReturnReason, UserContextApi, UserContextApiInternal},\n };\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -50,32 +51,6 @@ pub struct CpuExceptionInfo {\n     pub page_fault_addr: usize,\n }\n \n-/// User Preemption.\n-pub struct UserPreemption {\n-    count: u32,\n-}\n-\n-impl UserPreemption {\n-    const PREEMPTION_INTERVAL: u32 = 100;\n-\n-    /// Creates a new instance of `UserPreemption`.\n-    #[allow(clippy::new_without_default)]\n-    pub const fn new() -> Self {\n-        UserPreemption { count: 0 }\n-    }\n-\n-    /// Checks if preemption might occur and takes necessary actions.\n-    pub fn might_preempt(&mut self) {\n-        self.count = (self.count + 1) % Self::PREEMPTION_INTERVAL;\n-\n-        if self.count == 0 {\n-            crate::arch::irq::enable_local();\n-            crate::task::schedule();\n-            crate::arch::irq::disable_local();\n-        }\n-    }\n-}\n-\n impl UserContext {\n     /// Returns a reference to the general registers.\n     pub fn general_regs(&self) -> &RawGeneralRegs {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -115,9 +90,9 @@ impl UserContextApiInternal for UserContext {\n         let return_reason: ReturnReason;\n         const SYSCALL_TRAPNUM: u16 = 0x100;\n \n-        let mut user_preemption = UserPreemption::new();\n         // return when it is syscall or cpu exception type is Fault or Trap.\n         loop {\n+            scheduler::might_preempt();\n             self.user_context.run();\n             match CpuException::to_cpu_exception(self.user_context.trap_num as u16) {\n                 Some(exception) => {\ndiff --git a/ostd/src/arch/x86/cpu/mod.rs b/ostd/src/arch/x86/cpu/mod.rs\n--- a/ostd/src/arch/x86/cpu/mod.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -146,8 +121,6 @@ impl UserContextApiInternal for UserContext {\n                 return_reason = ReturnReason::KernelEvent;\n                 break;\n             }\n-\n-            user_preemption.might_preempt();\n         }\n \n         crate::arch::irq::enable_local();\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -129,7 +129,7 @@ pub fn call_ostd_main() -> ! {\n     unsafe {\n         use alloc::boxed::Box;\n \n-        use crate::task::{set_scheduler, FifoScheduler, Scheduler, TaskOptions};\n+        use crate::task::TaskOptions;\n \n         crate::init();\n         // The whitelists that will be generated by OSDK runner as static consts.\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -59,20 +59,10 @@ extern \"C\" {\n     fn __cpu_local_end();\n }\n \n-cpu_local_cell! {\n-    /// The count of the preempt lock.\n-    ///\n-    /// We need to access the preemption count before we can copy the section\n-    /// for application processors. So, the preemption count is not copied from\n-    /// bootstrap processor's section as the initialization. Instead it is\n-    /// initialized to zero for application processors.\n-    pub(crate) static PREEMPT_LOCK_COUNT: u32 = 0;\n-}\n-\n /// Sets the base address of the CPU-local storage for the bootstrap processor.\n ///\n /// It should be called early to let [`crate::task::disable_preempt`] work,\n-/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// which needs to update a CPU-local preemption info. Otherwise it may\n /// panic when calling [`crate::task::disable_preempt`].\n ///\n /// # Safety\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\n--- a/ostd/src/cpu/local/mod.rs\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -133,24 +123,6 @@ pub unsafe fn init_on_bsp() {\n             (ap_pages_ptr as *mut u32).write(cpu_i);\n         }\n \n-        // SAFETY: the `PREEMPT_LOCK_COUNT` may be dirty on the BSP, so we need\n-        // to ensure that it is initialized to zero for APs. The safety\n-        // requirements are met since the static is defined in the `.cpu_local`\n-        // section and the pointer to that static is the offset in the CPU-\n-        // local area. It is a `usize` so it is safe to be overwritten.\n-        unsafe {\n-            let preempt_count_ptr = &PREEMPT_LOCK_COUNT as *const _ as usize;\n-            let preempt_count_offset = preempt_count_ptr - __cpu_local_start as usize;\n-            let ap_preempt_count_ptr = ap_pages_ptr.add(preempt_count_offset) as *mut usize;\n-            ap_preempt_count_ptr.write(0);\n-        }\n-\n-        // SAFETY: bytes `8:16` are reserved for storing the pointer to the\n-        // current task. We initialize it to null.\n-        unsafe {\n-            (ap_pages_ptr as *mut u64).add(1).write(0);\n-        }\n-\n         cpu_local_storages.push(ap_pages);\n     }\n \ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -4,7 +4,7 @@ use alloc::{collections::VecDeque, sync::Arc};\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n \n use super::SpinLock;\n-use crate::task::{add_task, schedule, Task, TaskStatus};\n+use crate::task::{scheduler, Task};\n \n // # Explanation on the memory orders\n //\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -255,36 +255,15 @@ impl Waker {\n         if self.has_woken.swap(true, Ordering::Release) {\n             return false;\n         }\n-\n-        let mut task = self.task.inner_exclusive_access();\n-        match task.task_status {\n-            TaskStatus::Sleepy => {\n-                task.task_status = TaskStatus::Runnable;\n-            }\n-            TaskStatus::Sleeping => {\n-                task.task_status = TaskStatus::Runnable;\n-\n-                // Avoid holding the lock when doing `add_task`\n-                drop(task);\n-                add_task(self.task.clone());\n-            }\n-            _ => (),\n-        }\n+        scheduler::unpark_target(self.task.clone());\n \n         true\n     }\n \n     fn do_wait(&self) {\n-        while !self.has_woken.swap(false, Ordering::Acquire) {\n-            let mut task = self.task.inner_exclusive_access();\n-            // After holding the lock, check again to avoid races\n-            if self.has_woken.swap(false, Ordering::Acquire) {\n-                break;\n-            }\n-            task.task_status = TaskStatus::Sleepy;\n-            drop(task);\n-\n-            schedule();\n+        let has_woken = &self.has_woken;\n+        while !has_woken.swap(false, Ordering::Acquire) {\n+            scheduler::park_current(has_woken);\n         }\n     }\n \ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -2,15 +2,13 @@\n \n //! Tasks are the unit of code execution.\n \n-mod priority;\n+mod preempt;\n mod processor;\n-mod scheduler;\n+pub mod scheduler;\n #[allow(clippy::module_inception)]\n mod task;\n \n pub use self::{\n-    priority::Priority,\n-    processor::{disable_preempt, preempt, schedule, DisablePreemptGuard},\n-    scheduler::{add_task, set_scheduler, FifoScheduler, Scheduler},\n-    task::{Task, TaskAdapter, TaskContextApi, TaskOptions, TaskStatus},\n+    preempt::{disable_preempt, DisablePreemptGuard},\n+    task::{AtomicCpuId, Priority, Task, TaskAdapter, TaskContextApi, TaskOptions},\n };\ndiff --git /dev/null b/ostd/src/task/preempt/cpu_local.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/cpu_local.rs\n@@ -0,0 +1,61 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module maintains preemption-related information for the curren task\n+//! on a CPU with a single 32-bit, CPU-local integer value.\n+//!\n+//! * Bits from 0 to 30 represents an unsigned counter called `guard_count`,\n+//!   which is the number of `DisablePreemptGuard` instances held by the\n+//!   current CPU;\n+//! * Bit 31 is set to `!need_preempt`, where `need_preempt` is a boolean value\n+//!   that will be set by the scheduler when it decides that the current task\n+//!   _needs_ to be preempted.\n+//!\n+//! Thus, the current task on a CPU _should_ be preempted if and only if this\n+//! integer is equal to zero.\n+//!\n+//! The initial value of this integer is equal to `1 << 31`.\n+//!\n+//! This module provides a set of functions to access and manipulate\n+//! `guard_count` and `need_preempt`.\n+\n+use crate::cpu_local_cell;\n+\n+/// Returns whether the current task _should_ be preempted or not.\n+///\n+/// `should_preempt() == need_preempt() && get_guard_count() == 0`.\n+pub(in crate::task) fn should_preempt() -> bool {\n+    PREEMPT_INFO.load() == 0\n+}\n+\n+#[allow(dead_code)]\n+pub(in crate::task) fn need_preempt() -> bool {\n+    PREEMPT_INFO.load() & NEED_PREEMPT_MASK == 0\n+}\n+\n+pub(in crate::task) fn set_need_preempt() {\n+    PREEMPT_INFO.bitand_assign(!NEED_PREEMPT_MASK);\n+}\n+\n+pub(in crate::task) fn clear_need_preempt() {\n+    PREEMPT_INFO.bitor_assign(NEED_PREEMPT_MASK);\n+}\n+\n+pub(in crate::task) fn get_guard_count() -> u32 {\n+    PREEMPT_INFO.load() & GUARD_COUNT_MASK\n+}\n+\n+pub(in crate::task) fn inc_guard_count() {\n+    PREEMPT_INFO.add_assign(1);\n+}\n+\n+pub(in crate::task) fn dec_guard_count() {\n+    debug_assert!(get_guard_count() > 0);\n+    PREEMPT_INFO.sub_assign(1);\n+}\n+\n+cpu_local_cell! {\n+    static PREEMPT_INFO: u32 = NEED_PREEMPT_MASK;\n+}\n+\n+const NEED_PREEMPT_MASK: u32 = 1 << 31;\n+const GUARD_COUNT_MASK: u32 = (1 << 31) - 1;\ndiff --git /dev/null b/ostd/src/task/preempt/guard.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/guard.rs\n@@ -0,0 +1,35 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+/// A guard for disable preempt.\n+#[clippy::has_significant_drop]\n+#[must_use]\n+pub struct DisablePreemptGuard {\n+    // This private field prevents user from constructing values of this type directly.\n+    _private: (),\n+}\n+\n+impl !Send for DisablePreemptGuard {}\n+\n+impl DisablePreemptGuard {\n+    fn new() -> Self {\n+        super::cpu_local::inc_guard_count();\n+        Self { _private: () }\n+    }\n+\n+    /// Transfer this guard to a new guard.\n+    /// This guard must be dropped after this function.\n+    pub fn transfer_to(&self) -> Self {\n+        disable_preempt()\n+    }\n+}\n+\n+impl Drop for DisablePreemptGuard {\n+    fn drop(&mut self) {\n+        super::cpu_local::dec_guard_count();\n+    }\n+}\n+\n+/// Disables preemption.\n+pub fn disable_preempt() -> DisablePreemptGuard {\n+    DisablePreemptGuard::new()\n+}\ndiff --git /dev/null b/ostd/src/task/preempt/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/preempt/mod.rs\n@@ -0,0 +1,6 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+pub(super) mod cpu_local;\n+mod guard;\n+\n+pub use self::guard::{disable_preempt, DisablePreemptGuard};\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -3,11 +3,10 @@\n use alloc::sync::Arc;\n \n use super::{\n-    scheduler::{fetch_task, GLOBAL_SCHEDULER},\n-    task::{context_switch, TaskContext},\n-    Task, TaskStatus,\n+    preempt::cpu_local,\n+    task::{context_switch, Task, TaskContext},\n };\n-use crate::{cpu::local::PREEMPT_LOCK_COUNT, cpu_local_cell};\n+use crate::cpu_local_cell;\n \n cpu_local_cell! {\n     /// The `Arc<Task>` (casted by [`Arc::into_raw`]) that is the current task.\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -37,51 +36,21 @@ pub(super) fn current_task() -> Option<Arc<Task>> {\n     Some(restored)\n }\n \n-/// Calls this function to switch to other task by using GLOBAL_SCHEDULER\n-pub fn schedule() {\n-    if let Some(task) = fetch_task() {\n-        switch_to_task(task);\n-    }\n-}\n-\n-/// Preempts the `task`.\n-///\n-/// TODO: This interface of this method is error prone.\n-/// The method takes an argument for the current task to optimize its efficiency,\n-/// but the argument provided by the caller may not be the current task, really.\n-/// Thus, this method should be removed or reworked in the future.\n-pub fn preempt(task: &Arc<Task>) {\n-    // TODO: Refactor `preempt` and `schedule`\n-    // after the Atomic mode and `might_break` is enabled.\n-    let mut scheduler = GLOBAL_SCHEDULER.lock_irq_disabled();\n-    if !scheduler.should_preempt(task) {\n-        return;\n-    }\n-    let Some(next_task) = scheduler.dequeue() else {\n-        return;\n-    };\n-    drop(scheduler);\n-    switch_to_task(next_task);\n-}\n-\n /// Calls this function to switch to other task\n ///\n /// If current task is none, then it will use the default task context and it\n /// will not return to this function again.\n ///\n-/// If the current task's status not [`TaskStatus::Runnable`], it will not be\n-/// added to the scheduler.\n-///\n /// # Panics\n ///\n /// This function will panic if called while holding preemption locks or with\n /// local IRQ disabled.\n-fn switch_to_task(next_task: Arc<Task>) {\n-    let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n-    if preemt_lock_count != 0 {\n+pub(super) fn switch_to_task(next_task: Arc<Task>) {\n+    let guard_count = cpu_local::get_guard_count();\n+    if guard_count != 0 {\n         panic!(\n-            \"Calling schedule() while holding {} locks\",\n-            preemt_lock_count\n+            \"Switching task with preemption disabled (nesting depth: {})\",\n+            guard_count\n         );\n     }\n \ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -93,7 +62,6 @@ fn switch_to_task(next_task: Arc<Task>) {\n     let irq_guard = crate::trap::disable_local();\n \n     let current_task_ptr = CURRENT_TASK_PTR.load();\n-\n     let current_task_ctx_ptr = if current_task_ptr.is_null() {\n         // SAFETY: Interrupts are disabled, so the pointer is safe to be fetched.\n         unsafe { BOOTSTRAP_CONTEXT.as_ptr_mut() }\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -104,24 +72,12 @@ fn switch_to_task(next_task: Arc<Task>) {\n             let _ = core::mem::ManuallyDrop::new(restored.clone());\n             restored\n         };\n-\n         let ctx_ptr = cur_task_arc.ctx().get();\n \n-        let mut task_inner = cur_task_arc.inner_exclusive_access();\n-\n-        debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n-        if task_inner.task_status == TaskStatus::Runnable {\n-            drop(task_inner);\n-            GLOBAL_SCHEDULER.lock().enqueue(cur_task_arc);\n-        } else if task_inner.task_status == TaskStatus::Sleepy {\n-            task_inner.task_status = TaskStatus::Sleeping;\n-        }\n-\n         ctx_ptr\n     };\n \n     let next_task_ctx_ptr = next_task.ctx().get().cast_const();\n-\n     if let Some(next_user_space) = next_task.user_space() {\n         next_user_space.vm_space().activate();\n     }\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -144,7 +100,7 @@ fn switch_to_task(next_task: Arc<Task>) {\n     drop(irq_guard);\n \n     // SAFETY:\n-    // 1. `ctx` is only used in `schedule()`. We have exclusive access to both the current task\n+    // 1. `ctx` is only used in `reschedule()`. We have exclusive access to both the current task\n     //    context and the next task context.\n     // 2. The next task context is a valid task context.\n     unsafe {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -158,37 +114,3 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // next task. Not dropping is just fine because the only consequence is that we delay the drop\n     // to the next task switching.\n }\n-\n-/// A guard for disable preempt.\n-#[clippy::has_significant_drop]\n-#[must_use]\n-pub struct DisablePreemptGuard {\n-    // This private field prevents user from constructing values of this type directly.\n-    _private: (),\n-}\n-\n-impl !Send for DisablePreemptGuard {}\n-\n-impl DisablePreemptGuard {\n-    fn new() -> Self {\n-        PREEMPT_LOCK_COUNT.add_assign(1);\n-        Self { _private: () }\n-    }\n-\n-    /// Transfer this guard to a new guard.\n-    /// This guard must be dropped after this function.\n-    pub fn transfer_to(&self) -> Self {\n-        disable_preempt()\n-    }\n-}\n-\n-impl Drop for DisablePreemptGuard {\n-    fn drop(&mut self) {\n-        PREEMPT_LOCK_COUNT.sub_assign(1);\n-    }\n-}\n-\n-/// Disables preemption.\n-pub fn disable_preempt() -> DisablePreemptGuard {\n-    DisablePreemptGuard::new()\n-}\ndiff --git a/ostd/src/task/scheduler.rs /dev/null\n--- a/ostd/src/task/scheduler.rs\n+++ /dev/null\n@@ -1,107 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-#![allow(dead_code)]\n-\n-use alloc::collections::VecDeque;\n-\n-use crate::{prelude::*, sync::SpinLock, task::Task};\n-\n-static DEFAULT_SCHEDULER: FifoScheduler = FifoScheduler::new();\n-pub(crate) static GLOBAL_SCHEDULER: SpinLock<GlobalScheduler> = SpinLock::new(GlobalScheduler {\n-    scheduler: &DEFAULT_SCHEDULER,\n-});\n-\n-/// A scheduler for tasks.\n-///\n-/// An implementation of scheduler can attach scheduler-related information\n-/// with the `TypeMap` returned from `task.data()`.\n-pub trait Scheduler: Sync + Send {\n-    /// Enqueues a task to the scheduler.\n-    fn enqueue(&self, task: Arc<Task>);\n-\n-    /// Dequeues a task from the scheduler.\n-    fn dequeue(&self) -> Option<Arc<Task>>;\n-\n-    /// Tells whether the given task should be preempted by other tasks in the queue.\n-    fn should_preempt(&self, task: &Arc<Task>) -> bool;\n-}\n-\n-pub struct GlobalScheduler {\n-    scheduler: &'static dyn Scheduler,\n-}\n-\n-impl GlobalScheduler {\n-    pub const fn new(scheduler: &'static dyn Scheduler) -> Self {\n-        Self { scheduler }\n-    }\n-\n-    /// dequeue a task using scheduler\n-    /// require the scheduler is not none\n-    pub fn dequeue(&mut self) -> Option<Arc<Task>> {\n-        self.scheduler.dequeue()\n-    }\n-    /// enqueue a task using scheduler\n-    /// require the scheduler is not none\n-    pub fn enqueue(&mut self, task: Arc<Task>) {\n-        self.scheduler.enqueue(task)\n-    }\n-\n-    pub fn should_preempt(&self, task: &Arc<Task>) -> bool {\n-        self.scheduler.should_preempt(task)\n-    }\n-}\n-/// Sets the global task scheduler.\n-///\n-/// This must be called before invoking `Task::spawn`.\n-pub fn set_scheduler(scheduler: &'static dyn Scheduler) {\n-    let mut global_scheduler = GLOBAL_SCHEDULER.lock_irq_disabled();\n-    // When setting a new scheduler, the old scheduler should be empty\n-    assert!(global_scheduler.dequeue().is_none());\n-    global_scheduler.scheduler = scheduler;\n-}\n-\n-pub fn fetch_task() -> Option<Arc<Task>> {\n-    GLOBAL_SCHEDULER.lock_irq_disabled().dequeue()\n-}\n-\n-/// Adds a task to the global scheduler.\n-pub fn add_task(task: Arc<Task>) {\n-    GLOBAL_SCHEDULER.lock_irq_disabled().enqueue(task);\n-}\n-\n-/// A simple FIFO (First-In-First-Out) task scheduler.\n-pub struct FifoScheduler {\n-    /// A thread-safe queue to hold tasks waiting to be executed.\n-    task_queue: SpinLock<VecDeque<Arc<Task>>>,\n-}\n-\n-impl FifoScheduler {\n-    /// Creates a new instance of `FifoScheduler`.\n-    pub const fn new() -> Self {\n-        FifoScheduler {\n-            task_queue: SpinLock::new(VecDeque::new()),\n-        }\n-    }\n-}\n-\n-impl Default for FifoScheduler {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl Scheduler for FifoScheduler {\n-    /// Enqueues a task to the end of the queue.\n-    fn enqueue(&self, task: Arc<Task>) {\n-        self.task_queue.lock_irq_disabled().push_back(task);\n-    }\n-    /// Dequeues a task from the front of the queue, if any.\n-    fn dequeue(&self) -> Option<Arc<Task>> {\n-        self.task_queue.lock_irq_disabled().pop_front()\n-    }\n-    /// In this simple implementation, task preemption is not supported.\n-    /// Once a task starts running, it will continue to run until completion.\n-    fn should_preempt(&self, _task: &Arc<Task>) -> bool {\n-        false\n-    }\n-}\ndiff --git /dev/null b/ostd/src/task/scheduler/fifo_scheduler.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/scheduler/fifo_scheduler.rs\n@@ -0,0 +1,125 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use alloc::{boxed::Box, collections::VecDeque, sync::Arc, vec::Vec};\n+\n+use super::{inject_scheduler, EnqueueFlags, LocalRunQueue, Scheduler, UpdateFlags};\n+use crate::{\n+    cpu::{num_cpus, this_cpu},\n+    sync::SpinLock,\n+    task::{AtomicCpuId, Task},\n+};\n+\n+pub fn init() {\n+    let fifo_scheduler = Box::new(FifoScheduler::default());\n+    let scheduler = Box::<FifoScheduler<Task>>::leak(fifo_scheduler);\n+    inject_scheduler(scheduler);\n+}\n+\n+/// A simple FIFO (First-In-First-Out) task scheduler.\n+struct FifoScheduler<T: FifoSchedInfo> {\n+    /// A thread-safe queue to hold tasks waiting to be executed.\n+    rq: Vec<SpinLock<FifoRunQueue<T>>>,\n+}\n+\n+impl<T: FifoSchedInfo> FifoScheduler<T> {\n+    /// Creates a new instance of `FifoScheduler`.\n+    fn new(nr_cpus: u32) -> Self {\n+        let mut rq = Vec::new();\n+        for _ in 0..nr_cpus {\n+            rq.push(SpinLock::new(FifoRunQueue::new()));\n+        }\n+        Self { rq }\n+    }\n+\n+    fn select_cpu(&self) -> u32 {\n+        // FIXME: adopt more reasonable policy once we fully enable SMP.\n+        0\n+    }\n+}\n+\n+impl<T: FifoSchedInfo + Send + Sync> Scheduler<T> for FifoScheduler<T> {\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32> {\n+        let mut still_in_rq = false;\n+        let target_cpu = {\n+            let mut cpu_id = self.select_cpu();\n+            if let Err(task_cpu_id) = runnable.cpu().set_if_is_none(cpu_id) {\n+                debug_assert!(flags != EnqueueFlags::Spawn);\n+                still_in_rq = true;\n+                cpu_id = task_cpu_id;\n+            }\n+\n+            cpu_id\n+        };\n+\n+        let mut rq = self.rq[target_cpu as usize].lock_irq_disabled();\n+        if still_in_rq && let Err(_) = runnable.cpu().set_if_is_none(target_cpu) {\n+            return None;\n+        }\n+        rq.queue.push_back(runnable);\n+\n+        Some(target_cpu)\n+    }\n+\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>)) {\n+        let local_rq: &FifoRunQueue<T> = &self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>)) {\n+        let local_rq: &mut FifoRunQueue<T> = &mut self.rq[this_cpu() as usize].lock_irq_disabled();\n+        f(local_rq);\n+    }\n+}\n+\n+struct FifoRunQueue<T: FifoSchedInfo> {\n+    current: Option<Arc<T>>,\n+    queue: VecDeque<Arc<T>>,\n+}\n+\n+impl<T: FifoSchedInfo> FifoRunQueue<T> {\n+    pub const fn new() -> Self {\n+        Self {\n+            current: None,\n+            queue: VecDeque::new(),\n+        }\n+    }\n+}\n+\n+impl<T: FifoSchedInfo> LocalRunQueue<T> for FifoRunQueue<T> {\n+    fn current(&self) -> Option<&Arc<T>> {\n+        self.current.as_ref()\n+    }\n+\n+    fn update_current(&mut self, flags: super::UpdateFlags) -> bool {\n+        !matches!(flags, UpdateFlags::Tick)\n+    }\n+\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>> {\n+        let next_task = self.queue.pop_front()?;\n+        if let Some(prev_task) = self.current.replace(next_task) {\n+            self.queue.push_back(prev_task);\n+        }\n+\n+        self.current.as_ref()\n+    }\n+\n+    fn dequeue_current(&mut self) -> Option<Arc<T>> {\n+        self.current.take().inspect(|task| task.cpu().set_to_none())\n+    }\n+}\n+\n+impl Default for FifoScheduler<Task> {\n+    fn default() -> Self {\n+        Self::new(num_cpus())\n+    }\n+}\n+\n+impl FifoSchedInfo for Task {\n+    fn cpu(&self) -> &AtomicCpuId {\n+        self.cpu()\n+    }\n+}\n+\n+trait FifoSchedInfo {\n+    fn cpu(&self) -> &AtomicCpuId;\n+}\ndiff --git /dev/null b/ostd/src/task/scheduler/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/task/scheduler/mod.rs\n@@ -0,0 +1,241 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Scheduling subsystem (in-OSTD part).\n+//!\n+//! This module defines what OSTD expects from a scheduling implementation\n+//! and provides useful functions for controlling the execution flow.\n+\n+mod fifo_scheduler;\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+use spin::Once;\n+\n+use super::{preempt::cpu_local, processor, task::Task};\n+use crate::{arch::timer, cpu::this_cpu, prelude::*};\n+\n+/// Injects a scheduler implementation into framework.\n+///\n+/// This function can only be called once and must be called during the initialization of kernel.\n+pub fn inject_scheduler(scheduler: &'static dyn Scheduler<Task>) {\n+    SCHEDULER.call_once(|| scheduler);\n+\n+    timer::register_callback(|| {\n+        SCHEDULER.get().unwrap().local_mut_rq_with(&mut |local_rq| {\n+            if local_rq.update_current(UpdateFlags::Tick) {\n+                cpu_local::set_need_preempt();\n+            }\n+        })\n+    });\n+}\n+\n+static SCHEDULER: Once<&'static dyn Scheduler<Task>> = Once::new();\n+\n+/// A per-CPU task scheduler.\n+pub trait Scheduler<T = Task>: Sync + Send {\n+    /// Enqueues a runnable task.\n+    ///\n+    /// Scheduler developers can perform load-balancing or some accounting work here.\n+    ///\n+    /// If the `current` of a CPU needs to be preempted, this method returns the id of\n+    /// that CPU.\n+    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<u32>;\n+\n+    /// Gets an immutable access to the local runqueue of the current CPU core.\n+    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>));\n+\n+    /// Gets a mutable access to the local runqueue of the current CPU core.\n+    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>));\n+}\n+\n+/// The _local_ view of a per-CPU runqueue.\n+///\n+/// This local view provides the interface for the runqueue of a CPU core\n+/// to be inspected and manipulated by the code running on this particular CPU core.\n+///\n+/// Conceptually, a local runqueue consists of two parts:\n+/// (1) a priority queue of runnable tasks;\n+/// (2) the current running task.\n+/// The exact definition of \"priority\" is left for the concrete implementation to decide.\n+pub trait LocalRunQueue<T = Task> {\n+    /// Gets the current runnable task.\n+    fn current(&self) -> Option<&Arc<T>>;\n+\n+    /// Updates the current runnable task's scheduling statistics and potentially its\n+    /// position in the queue.\n+    ///\n+    /// If the current runnable task needs to be preempted, the method returns `true`.\n+    fn update_current(&mut self, flags: UpdateFlags) -> bool;\n+\n+    /// Picks the next current runnable task.\n+    ///\n+    /// This method returns the chosen next current runnable task. If there is no\n+    /// candidate for next current runnable task, this method returns `None`.\n+    fn pick_next_current(&mut self) -> Option<&Arc<T>>;\n+\n+    /// Removes the current runnable task from runqueue.\n+    ///\n+    /// This method returns the current runnable task. If there is no current runnable\n+    /// task, this method returns `None`.\n+    fn dequeue_current(&mut self) -> Option<Arc<T>>;\n+}\n+\n+/// Possible triggers of an `enqueue` action.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum EnqueueFlags {\n+    /// Spawn a new task.\n+    Spawn,\n+    /// Wake a sleeping task.\n+    Wake,\n+}\n+\n+/// Possible triggers of an `update_current` action.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum UpdateFlags {\n+    /// Timer interrupt.\n+    Tick,\n+    /// Task waiting.\n+    Wait,\n+    /// Task yielding.\n+    Yield,\n+}\n+\n+/// Preempts the current task.\n+pub(crate) fn might_preempt() {\n+    if !cpu_local::should_preempt() {\n+        return;\n+    }\n+    yield_now();\n+}\n+\n+/// Blocks the current task unless `has_woken` is `true`.\n+pub(crate) fn park_current(has_woken: &AtomicBool) {\n+    let mut current = None;\n+    let mut is_first_try = true;\n+    reschedule(&mut |local_rq: &mut dyn LocalRunQueue| {\n+        if is_first_try {\n+            if has_woken.load(Ordering::Acquire) {\n+                return ReschedAction::DoNothing;\n+            }\n+            current = local_rq.dequeue_current();\n+            local_rq.update_current(UpdateFlags::Wait);\n+        }\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            if Arc::ptr_eq(current.as_ref().unwrap(), next_task) {\n+                return ReschedAction::DoNothing;\n+            }\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            is_first_try = false;\n+            ReschedAction::Retry\n+        }\n+    });\n+}\n+\n+/// Unblocks a target task.\n+pub(crate) fn unpark_target(runnable: Arc<Task>) {\n+    let need_preempt_info = SCHEDULER\n+        .get()\n+        .unwrap()\n+        .enqueue(runnable, EnqueueFlags::Wake);\n+    if need_preempt_info.is_some() {\n+        let cpu_id = need_preempt_info.unwrap();\n+        // FIXME: send IPI to set remote CPU's need_preempt if needed.\n+        if cpu_id == this_cpu() {\n+            cpu_local::set_need_preempt();\n+        }\n+    }\n+}\n+\n+/// Enqueues a newly built task.\n+///\n+/// Note that the new task is not guranteed to run at once.\n+pub(super) fn run_new_task(runnable: Arc<Task>) {\n+    // FIXME: remove this check for `SCHEDULER`.\n+    // Currently OSTD cannot know whether its user has injected a scheduler.\n+    if !SCHEDULER.is_completed() {\n+        fifo_scheduler::init();\n+    }\n+\n+    let need_preempt_info = SCHEDULER\n+        .get()\n+        .unwrap()\n+        .enqueue(runnable, EnqueueFlags::Spawn);\n+    if need_preempt_info.is_some() {\n+        let cpu_id = need_preempt_info.unwrap();\n+        // FIXME: send IPI to set remote CPU's need_preempt if needed.\n+        if cpu_id == this_cpu() {\n+            cpu_local::set_need_preempt();\n+        }\n+    }\n+\n+    might_preempt();\n+}\n+\n+/// Dequeues the current task from its runqueue.\n+///\n+/// This should only be called if the current is to exit.\n+pub(super) fn exit_current() {\n+    reschedule(&mut |local_rq: &mut dyn LocalRunQueue| {\n+        let _ = local_rq.dequeue_current();\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            ReschedAction::Retry\n+        }\n+    })\n+}\n+\n+/// Yields execution.\n+pub(super) fn yield_now() {\n+    reschedule(&mut |local_rq| {\n+        local_rq.update_current(UpdateFlags::Yield);\n+\n+        if let Some(next_task) = local_rq.pick_next_current() {\n+            ReschedAction::SwitchTo(next_task.clone())\n+        } else {\n+            ReschedAction::DoNothing\n+        }\n+    })\n+}\n+\n+/// Do rescheduling by acting on the scheduling decision (`ReschedAction`) made by a\n+/// user-given closure.\n+///\n+/// The closure makes the scheduling decision by taking the local runqueue has its input.\n+fn reschedule<F>(f: &mut F)\n+where\n+    F: FnMut(&mut dyn LocalRunQueue) -> ReschedAction,\n+{\n+    let next_task = loop {\n+        let mut action = ReschedAction::DoNothing;\n+        SCHEDULER.get().unwrap().local_mut_rq_with(&mut |rq| {\n+            action = f(rq);\n+        });\n+\n+        match action {\n+            ReschedAction::DoNothing => {\n+                return;\n+            }\n+            ReschedAction::Retry => {\n+                continue;\n+            }\n+            ReschedAction::SwitchTo(next_task) => {\n+                break next_task;\n+            }\n+        };\n+    };\n+\n+    cpu_local::clear_need_preempt();\n+    processor::switch_to_task(next_task);\n+}\n+\n+/// Possible actions of a rescheduling.\n+enum ReschedAction {\n+    /// Keep running current task and do nothing.\n+    DoNothing,\n+    /// Loop until finding a task to swap out the current.\n+    Retry,\n+    /// Switch to target task.\n+    SwitchTo(Arc<Task>),\n+}\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -4,22 +4,23 @@\n // So we temporary allow missing_docs for this module.\n #![allow(missing_docs)]\n \n-use alloc::{boxed::Box, sync::Arc};\n-use core::{any::Any, cell::UnsafeCell};\n+mod priority;\n+\n+use core::{\n+    any::Any,\n+    cell::UnsafeCell,\n+    sync::atomic::{AtomicU32, Ordering},\n+};\n \n use intrusive_collections::{intrusive_adapter, LinkedListAtomicLink};\n+pub use priority::Priority;\n \n-use super::{\n-    add_task,\n-    priority::Priority,\n-    processor::{current_task, schedule},\n-};\n+use super::{processor::current_task, scheduler};\n pub(crate) use crate::arch::task::{context_switch, TaskContext};\n use crate::{\n     cpu::CpuSet,\n     mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, Paddr, PageFlags, Segment, PAGE_SIZE},\n     prelude::*,\n-    sync::{SpinLock, SpinLockGuard},\n     user::UserSpace,\n };\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -103,6 +104,41 @@ impl Drop for KernelStack {\n     }\n }\n \n+/// An atomic CPUID container.\n+pub struct AtomicCpuId(AtomicU32);\n+\n+impl AtomicCpuId {\n+    /// The null value of CPUID.\n+    ///\n+    /// An `AtomicCpuId` with `AtomicCpuId::NONE` as its inner value is empty.\n+    const NONE: u32 = u32::MAX;\n+\n+    fn new(cpu_id: u32) -> Self {\n+        Self(AtomicU32::new(cpu_id))\n+    }\n+\n+    /// Sets the inner value of an `AtomicCpuId` if it's empty.\n+    ///\n+    /// The return value is a result indicating whether the new value was written\n+    /// and containing the previous value.\n+    pub fn set_if_is_none(&self, cpu_id: u32) -> core::result::Result<u32, u32> {\n+        self.0\n+            .compare_exchange(Self::NONE, cpu_id, Ordering::Relaxed, Ordering::Relaxed)\n+    }\n+\n+    /// Sets the inner value of an `AtomicCpuId` to `AtomicCpuId::NONE`, i.e. makes\n+    /// an `AtomicCpuId` empty.\n+    pub fn set_to_none(&self) {\n+        self.0.store(Self::NONE, Ordering::Relaxed);\n+    }\n+}\n+\n+impl Default for AtomicCpuId {\n+    fn default() -> Self {\n+        Self::new(Self::NONE)\n+    }\n+}\n+\n /// A task that executes a function to the end.\n ///\n /// Each task is associated with per-task data and an optional user space.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -112,11 +148,11 @@ pub struct Task {\n     func: Box<dyn Fn() + Send + Sync>,\n     data: Box<dyn Any + Send + Sync>,\n     user_space: Option<Arc<UserSpace>>,\n-    task_inner: SpinLock<TaskInner>,\n     ctx: UnsafeCell<TaskContext>,\n     /// kernel stack, note that the top is SyscallFrame/TrapFrame\n     kstack: KernelStack,\n     link: LinkedListAtomicLink,\n+    cpu: AtomicCpuId,\n     priority: Priority,\n     // TODO: add multiprocessor support\n     #[allow(dead_code)]\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -130,11 +166,6 @@ intrusive_adapter!(pub TaskAdapter = Arc<Task>: Task { link: LinkedListAtomicLin\n // we have exclusive access to the field.\n unsafe impl Sync for Task {}\n \n-#[derive(Debug)]\n-pub(crate) struct TaskInner {\n-    pub task_status: TaskStatus,\n-}\n-\n impl Task {\n     /// Gets the current task.\n     ///\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -143,11 +174,6 @@ impl Task {\n         current_task()\n     }\n \n-    /// Gets inner\n-    pub(crate) fn inner_exclusive_access(&self) -> SpinLockGuard<TaskInner> {\n-        self.task_inner.lock_irq_disabled()\n-    }\n-\n     pub(super) fn ctx(&self) -> &UnsafeCell<TaskContext> {\n         &self.ctx\n     }\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -157,18 +183,14 @@ impl Task {\n     /// Note that this method cannot be simply named \"yield\" as the name is\n     /// a Rust keyword.\n     pub fn yield_now() {\n-        schedule();\n+        scheduler::yield_now()\n     }\n \n     /// Runs the task.\n+    ///\n+    /// BUG: This method highly depends on the current scheduling policy.\n     pub fn run(self: &Arc<Self>) {\n-        add_task(self.clone());\n-        schedule();\n-    }\n-\n-    /// Returns the task status.\n-    pub fn status(&self) -> TaskStatus {\n-        self.task_inner.lock_irq_disabled().task_status\n+        scheduler::run_new_task(self.clone());\n     }\n \n     /// Returns the task data.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -185,6 +207,16 @@ impl Task {\n         }\n     }\n \n+    // Returns the cpu of this task.\n+    pub fn cpu(&self) -> &AtomicCpuId {\n+        &self.cpu\n+    }\n+\n+    /// Returns the priority.\n+    pub fn priority(&self) -> Priority {\n+        self.priority\n+    }\n+\n     /// Exits the current task.\n     ///\n     /// The task `self` must be the task that is currently running.\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -192,13 +224,10 @@ impl Task {\n     /// **NOTE:** If there is anything left on the stack, it will be forgotten. This behavior may\n     /// lead to resource leakage.\n     fn exit(self: Arc<Self>) -> ! {\n-        self.inner_exclusive_access().task_status = TaskStatus::Exited;\n-\n         // `current_task()` still holds a strong reference, so nothing is destroyed at this point,\n         // neither is the kernel stack.\n         drop(self);\n-\n-        schedule();\n+        scheduler::exit_current();\n         unreachable!()\n     }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -208,19 +237,6 @@ impl Task {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-/// The status of a task.\n-pub enum TaskStatus {\n-    /// The task is runnable.\n-    Runnable,\n-    /// The task is running in the foreground but will sleep when it goes to the background.\n-    Sleepy,\n-    /// The task is sleeping in the background.\n-    Sleeping,\n-    /// The task has exited.\n-    Exited,\n-}\n-\n /// Options to create or spawn a new task.\n pub struct TaskOptions {\n     func: Option<Box<dyn Fn() + Send + Sync>>,\ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -236,13 +252,12 @@ impl TaskOptions {\n     where\n         F: Fn() + Send + Sync + 'static,\n     {\n-        let cpu_affinity = CpuSet::new_full();\n         Self {\n             func: Some(Box::new(func)),\n             data: None,\n             user_space: None,\n             priority: Priority::normal(),\n-            cpu_affinity,\n+            cpu_affinity: CpuSet::new_full(),\n         }\n     }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task/mod.rs\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -300,11 +315,9 @@ impl TaskOptions {\n             func: self.func.unwrap(),\n             data: self.data.unwrap(),\n             user_space: self.user_space,\n-            task_inner: SpinLock::new(TaskInner {\n-                task_status: TaskStatus::Runnable,\n-            }),\n             ctx: UnsafeCell::new(TaskContext::default()),\n             kstack: KernelStack::new_with_guard_page()?,\n+            cpu: AtomicCpuId::default(),\n             link: LinkedListAtomicLink::new(),\n             priority: self.priority,\n             cpu_affinity: self.cpu_affinity,\ndiff --git a/ostd/src/task/priority.rs b/ostd/src/task/task/priority.rs\n--- a/ostd/src/task/priority.rs\n+++ b/ostd/src/task/task/priority.rs\n@@ -7,7 +7,7 @@ pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n /// Similar to Linux, a larger value represents a lower priority,\n /// with a range of 0 to 139. Priorities ranging from 0 to 99 are considered real-time,\n /// while those ranging from 100 to 139 are considered normal.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd)]\n pub struct Priority(u16);\n \n impl Priority {\n",
        "test_patch": "",
        "problem_statement": "RFC: The new scheduling API of Asterinas Framework\n## Introduction\r\n\r\nThis RFC proposes a new set of API for the scheduling subsystem of Asterinas Framework. The new API aims at enabling the Framework users to implement advanced scheduler algorithms such as Linux's CFS and support multiple schedulers such as Linux's scheduling classes.\r\n\r\n## Background\r\n\r\nWhile Asterinas Framework grows out of Asterinas, it is intended to serve as a general OS development framework that may be used to build OS kernels with different characteristics, including different scheduling policies and algorithms.\r\n\r\nThe current scheduler API is summarized below.\r\n\r\n```rust\r\n/// Set the global task scheduler.\r\n///\r\n/// This must be called before invoking `Task::spawn`.\r\npub fn set_scheduler(scheduler: &'static dyn Scheduler) {\r\n    GLOBAL_SCHEDULER.lock_irq_disabled().scheduler = Some(scheduler);\r\n}\r\n\r\n/// A scheduler for tasks.\r\n///\r\n/// An implementation of scheduler can attach scheduler-related information\r\n/// with the `TypeMap` returned from `task.data()`.\r\npub trait Scheduler: Sync + Send {\r\n    /// Enqueues a task to the scheduler.\r\n    fn enqueue(&self, task: Arc<Task>);\r\n\r\n    /// Dequeues a task from the scheduler.\r\n    fn dequeue(&self) -> Option<Arc<Task>>;\r\n\r\n    /// Tells whether the given task should be preempted by other tasks in the queue.\r\n    fn should_preempt(&self, task: &Arc<Task>) -> bool;\r\n}\r\n```\r\n\r\nThe drawbacks of the current design are:\r\n\r\n* No API to do time accounting\r\n* No SMP support\r\n* Unable to do unit testing\r\n\r\n## Proposal\r\n\r\nWe now provide a high-level overview of the new API and its usage.\r\n\r\n### Initialization\r\n\r\nUpon initialization, the kernel (e.g., `aster-nix`) injects a task scheduler into the Framework (i.e., `aster-frame`).\r\n\r\n```rust\r\n/// Injects a task scheduler into the Framework.\r\n///\r\n/// # Panics\r\n///\r\n/// This function can only be called once and \r\n/// should only be done at the initialization state of the kernel.\r\npub fn inject_scheduler(scheduler: &'static dyn Scheduler) { ... }\r\n\r\n/// Abstracts a task scheduler.\r\npub trait Scheduler<T = Task> {\r\n    /// Enqueue a runnable task.\r\n    fn enqueue(&self, runnable: Arc<T>, flags: EnqueueFlags) -> Option<QueueReceipt>;\r\n\r\n    /// Get an immutable access to the local runqueue of the current CPU core.\r\n    fn local_rq_with(&self, f: &mut dyn FnMut(&dyn LocalRunQueue<T>));\r\n\r\n    /// Get a mutable access to the local runqueue of the current CPU core.\r\n    fn local_mut_rq_with(&self, f: &mut dyn FnMut(&mut dyn LocalRunQueue<T>));\r\n\r\n    /// Get the runqueue of a particular CPU core.\r\n    fn rq(&self, cpu: CpuId) -> &Arc<dyn RunQueue>;\r\n}\r\n```\r\n\r\nThis abstract scheduler maintains a local runqueue represented by `RunQueue` and `LocalRunqueue` for each CPU core.\r\n\r\n```rust\r\n/// The _remote_ view of a per-CPU runqueue.\r\n///\r\n/// This remote view provides the interface for the runqueue of a CPU core\r\n/// to be inspected by the code running on an another CPU core.\r\npub trait RunQueue: Sync + Send {\r\n    /// Returns whether there are any runnable tasks managed by the scheduler.\r\n    fn is_empty(&self) -> bool;\r\n\r\n    /// Returns whether the number of runnable tasks managed by the scheduler.\r\n    fn len(&self) -> usize;\r\n}\r\n\r\n/// The _local_ view of a per-CPU runqueue.\r\n///\r\n/// This local view provides the interface for the runqueue of a CPU core\r\n/// to be inspected and manipulated by the code running on this particular CPU core.\r\n///\r\n/// Conceptually, a local runqueue consists of two parts:\r\n/// (1) a priority queue of runnable tasks;\r\n/// (2) the current running task.\r\n/// The exact definition of \"priority\" is left for the concrete implementation to decide.\r\npub trait LocalRunQueue<T = Task>: RunQueue {\r\n    /// Update the current runnable task's time statistics and \r\n    /// potentially its position in the queue.\r\n    fn update_current(&mut self, flags: UpdateFlags) -> bool;\r\n\r\n    /// Dequeue the current runnable task.\r\n    ///\r\n    /// The current task should be dequeued if it needs to go to sleep or has exited.\r\n    fn dequeue_current(&mut self) -> Option<Arc<T>>;\r\n\r\n    /// Pick the next current runnable task, returning the new currenet.\r\n    ///\r\n    /// If there is no runnable task, the method returns `None`.\r\n    fn pick_next_current(&mut self) -> Option<&Arc<T>>;\r\n\r\n    /// Gets the current task.\r\n    ///\r\n    /// The current task is the head of the queue.\r\n    /// If the queue is empty, the method returns `None`.\r\n    fn current(&self) -> Option<&Arc<T>>;\r\n}\r\n```\r\n\r\n### Task spawning\r\n\r\nAfter creating a new task or waking up a sleeping task, calls `Scheduler::enqueue` to put this new runnable task into the scheduler. This `enqueue` method selects a suitable CPU core properly (e.g., by taking into account CPU affinity and load balanacing) and enqueues the new runnable task into the local runqueue of the target CPU core.\r\n\r\n```rust\r\nimpl TaskOptions {\r\n    pub fn spawn(self) -> Result<Arc<Task>> {\r\n        let task = self.build()?;\r\n        task.run();\r\n        Ok(task)\r\n    }\r\n}\r\n\r\nimpl Task {\r\n    pub fn run(self: &Arc<Self>) {\r\n        sched::spawn_task(self);\r\n    }\r\n}\r\n```\r\n\r\nThe `sched::spawn_task` function calls the `enqueue` method of the injected scheduler singleton.\r\n\r\n```rust\r\npub(crate) fn spawn_task(task: &Arc<Task>) {\r\n    let should_reschedule = SCHEDULER.enqueue(task, EnqueueFlags::Spawn);\r\n    if !should_reschedule {\r\n        return;\r\n    }\r\n\r\n    reschedule(|local_rq| {\r\n        let Some(next_current) = local_rq.pick_next_current() else {\r\n            return ReschedAction::DoNothing;\r\n        };\r\n\r\n        ReschedAction::SwitchTo(next_current.clone())\r\n    });\r\n}\r\n```\r\n\r\nThe `sched::reschedule` function do the rescheduling according to the rescheduling action returned by the given closure. \r\n\r\n```rust\r\npub(crate) ReschedAction {\r\n    DoNothing,\r\n    Retry,\r\n    SwitchTo(Arc<Task>),\r\n}\r\n\r\npub(crate) fn reschedule<F>(f: F) \r\n    F: Fn(&mut dyn LocalRunQueue) -> ReschedAction\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n### Yielding\r\n\r\n```rust\r\nimpl Task {\r\n    pub fn yield_now() {\r\n        sched::reschedule(|local_rq| {\r\n            let should_pick_next = local_rq.update_current(UpdateFlags::YIELD);\r\n            if !should_pick_next {\r\n                return ReschedAction::DoNothing;\r\n            }\r\n\r\n            let Some(next_current) = local_rq.pick_next_current() else {\r\n                return ReschedAction::DoNothing;\r\n            };\r\n\r\n            ReschedAction::SwitchTo(next_current.clone())\r\n        });\r\n    }\r\n}\r\n````\r\n\r\n### Sleeping\r\n\r\n```rust\r\nimpl Waker {\r\n    fn do_wait(&self) {\r\n        while !self.has_woken.load(Ordering::Acquire) {\r\n            let mut task = self.task.inner_exclusive_access();\r\n            // After holding the lock, check again to avoid races\r\n            if self.has_woken.load(Ordering::Acquire) {\r\n                break;\r\n            }\r\n            task.task_status = TaskStatus::Sleepy;\r\n            drop(task);\r\n\r\n            sched::reschedule(|local_rq| {\r\n                let should_pick_next = local_rq.update_current(UpdateFlags::WAIT);\r\n                local_rq.dequeue_current();\r\n\r\n                let Some(next_current) = local_rq.pick_next_current() else {\r\n                    return ReschedAction::Retry;\r\n                };\r\n\r\n                ReschedAction::SwitchTo(next_current.clone())\r\n            });\r\n        }\r\n\r\n        self.has_woken.store(false, Ordering::Release);\r\n    }\r\n}\r\n```\r\n\r\n### Preemption\r\n\r\nPeriodically (e.g., on system timer interrupts), a CPU to get its local runqueue using `Scheduler::local_mut_rq_with` to do time accounting for the current task.\r\n\r\n```rust\r\nfn do_timer_interrupt(...) {\r\n    SCHEDULER.local_rq_with(|local_rq| {\r\n        let should_preempt = local_rq.update_current(SchedEvent::Tick);\r\n        if should_preempt {\r\n            local_rq.current().set_should_preempt(true);    \r\n        }\r\n    });\r\n}\r\n```\r\n\r\nOn the next most convenient timing, the current task can be preempted by doing this.\r\n\r\n```rust\r\nfn might_preempt(current: &Arc<Task>) {\r\n    if !current.should_preempt() {\r\n        return;\r\n    }\r\n\r\n    current.set_should_preempt(false);\r\n\r\n    sched::reschedule(|local_rq| {\r\n        let Some(next_current) = local_rq.pick_next_current() else {\r\n            return ReschedAction::DoNothing;\r\n        };\r\n\r\n        Resched::SwitchTo(next_current.clone())\r\n    });\r\n}\r\n```\r\n\r\n## Detailed Design\r\n\r\nMore details need to be worked out, but I don't have the time to do so...\r\n\r\n\n",
        "hints_text": "From my point of view, I suggest removing the `RunQueue` trait and the `fn rq(&self, cpu: CpuId) -> &Arc<dyn RunQueue>` method _if_ we cannot figure out any real use cases for them in the Asterinas framework.\r\n\r\nWe can easily add them in the future if we find them useful in some way, but at least for the use cases listed in this RFC, they are not useful.\r\n\r\nThe local and remote views of run queues make sense to me, but they do not outweigh the fact that we should not add code or APIs whose usefulness cannot be justified.",
        "created_at": "2024-06-28T06:42:22Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 782,
        "instance_id": "asterinas__asterinas-782",
        "issue_numbers": [
            "774",
            "790"
        ],
        "base_commit": "34e9d71fe4501bf4cac4d8263ccb568a814ac4b7",
        "patch": "diff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -55,7 +55,7 @@ use alloc::vec;\n use aster_frame::cpu::UserContext;\n use aster_frame::prelude::*;\n use aster_frame::task::{Task, TaskOptions};\n-use aster_frame::user::{UserEvent, UserMode, UserSpace};\n+use aster_frame::user::{ReturnReason, UserMode, UserSpace};\n use aster_frame::vm::{PageFlags, PAGE_SIZE, Vaddr, VmAllocOptions, VmIo, VmMapOptions, VmSpace};\n \n /// The kernel's boot and initialization process is managed by Asterinas Framework.\ndiff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -116,13 +116,15 @@ fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n \n         loop {\n             // The execute method returns when system\n-            // calls or CPU exceptions occur.\n-            let user_event = user_mode.execute();\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n             // The CPU registers of the user space\n             // can be accessed and manipulated via\n             // the `UserContext` abstraction.\n             let user_context = user_mode.context_mut();\n-            if UserEvent::Syscall == user_event {\n+            if ReturnReason::UserSyscall == return_reason {\n                 handle_syscall(user_context, current.user_space().unwrap());\n             }\n         }\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -23,7 +23,7 @@ use x86_64::registers::rflags::RFlags;\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\n use crate::{\n     trap::call_irq_callback_functions,\n-    user::{UserContextApi, UserContextApiInternal, UserEvent},\n+    user::{ReturnReason, UserContextApi, UserContextApiInternal},\n };\n \n /// Returns the number of CPUs.\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -257,11 +257,15 @@ impl UserContext {\n }\n \n impl UserContextApiInternal for UserContext {\n-    fn execute(&mut self) -> crate::user::UserEvent {\n+    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         // set interrupt flag so that in user mode it can receive external interrupts\n         // set ID flag which means cpu support CPUID instruction\n         self.user_context.general.rflags |= (RFlags::INTERRUPT_FLAG | RFlags::ID).bits() as usize;\n \n+        let return_reason: ReturnReason;\n         const SYSCALL_TRAPNUM: u16 = 0x100;\n \n         let mut user_preemption = UserPreemption::new();\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -281,31 +285,36 @@ impl UserContextApiInternal for UserContext {\n                         || exception.typ == CpuExceptionType::Fault\n                         || exception.typ == CpuExceptionType::Trap\n                     {\n+                        return_reason = ReturnReason::UserException;\n                         break;\n                     }\n                 }\n                 None => {\n                     if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\n+                        return_reason = ReturnReason::UserSyscall;\n                         break;\n                     }\n                 }\n             };\n             call_irq_callback_functions(&self.as_trap_frame());\n+            if has_kernel_event() {\n+                return_reason = ReturnReason::KernelEvent;\n+                break;\n+            }\n \n             user_preemption.might_preempt();\n         }\n \n         crate::arch::irq::enable_local();\n-        if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\n+        if return_reason == ReturnReason::UserException {\n             self.cpu_exception_info = CpuExceptionInfo {\n                 page_fault_addr: unsafe { x86::controlregs::cr2() },\n                 id: self.user_context.trap_num,\n                 error_code: self.user_context.error_code,\n             };\n-            UserEvent::Exception\n-        } else {\n-            UserEvent::Syscall\n         }\n+\n+        return_reason\n     }\n \n     fn as_trap_frame(&self) -> trapframe::TrapFrame {\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -51,7 +51,9 @@ impl UserSpace {\n /// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n-    fn execute(&mut self) -> UserEvent;\n+    fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool;\n \n     /// Use the information inside CpuContext to build a trapframe\n     fn as_trap_frame(&self) -> TrapFrame;\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -93,9 +95,9 @@ pub trait UserContextApi {\n ///     .expect(\"the current task is associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n-///     // Execute in the user space until some interesting user event occurs\n-///     let user_event = user_mode.execute();\n-///     todo!(\"handle the user event, e.g., syscall\");\n+///     // Execute in the user space until some interesting events occur.\n+///     let return_reason = user_mode.execute(|| false);\n+///     todo!(\"handle the event, e.g., syscall\");\n /// }\n /// ```\n pub struct UserMode<'a> {\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -118,17 +120,22 @@ impl<'a> UserMode<'a> {\n \n     /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\n     ///\n-    /// The method returns for one of three possible reasons indicated by `UserEvent`.\n-    /// 1. The user invokes a system call;\n-    /// 2. The user triggers an exception;\n-    /// 3. The user triggers a fault.\n+    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\n+    /// 1. A system call is issued by the user space;\n+    /// 2. A CPU exception is triggered by the user space;\n+    /// 3. A kernel event is pending, as indicated by the given closure.\n     ///\n-    /// After handling the user event and updating the user-mode CPU context,\n+    /// After handling whatever user or kernel events that\n+    /// cause the method to return\n+    /// and updating the user-mode CPU context,\n     /// this method can be invoked again to go back to the user space.\n-    pub fn execute(&mut self) -> UserEvent {\n+    pub fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         self.user_space.vm_space().activate();\n         debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n-        self.context.execute()\n+        self.context.execute(has_kernel_event)\n     }\n \n     /// Returns an immutable reference the user-mode CPU context.\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -143,14 +150,13 @@ impl<'a> UserMode<'a> {\n }\n \n #[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n-/// A user event is what brings back the control of the CPU back from\n-/// the user space to the kernel space.\n-///\n-/// Note that hardware interrupts are not considered user events as they\n-/// are triggered by devices and not visible to user programs.\n-/// To handle interrupts, one should register callback funtions for\n-/// IRQ lines (`IrqLine`).\n-pub enum UserEvent {\n-    Syscall,\n-    Exception,\n+/// A reason as to why the control of the CPU is returned from\n+/// the user space to the kernel.\n+pub enum ReturnReason {\n+    /// A system call is issued by the user space.\n+    UserSyscall,\n+    /// A CPU exception is triggered by the user space.\n+    UserException,\n+    /// A kernel event is pending\n+    KernelEvent,\n }\ndiff --git a/kernel/aster-nix/src/thread/kernel_thread.rs b/kernel/aster-nix/src/thread/kernel_thread.rs\n--- a/kernel/aster-nix/src/thread/kernel_thread.rs\n+++ b/kernel/aster-nix/src/thread/kernel_thread.rs\n@@ -44,6 +44,8 @@ impl KernelThreadExt for Thread {\n             let weal_thread = thread_ref.clone();\n             let task = TaskOptions::new(thread_fn)\n                 .data(weal_thread)\n+                .priority(thread_options.priority)\n+                .cpu_affinity(thread_options.cpu_affinity)\n                 .build()\n                 .unwrap();\n             let status = ThreadStatus::Init;\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -1,20 +1,27 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_frame::{\n-    cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n-    user::{UserContextApi, UserEvent, UserMode, UserSpace},\n+    user::{ReturnReason, UserContextApi, UserMode, UserSpace},\n };\n \n use super::Thread;\n use crate::{\n-    cpu::LinuxAbi, prelude::*, process::signal::handle_pending_signal, syscall::handle_syscall,\n+    cpu::LinuxAbi,\n+    prelude::*,\n+    process::{posix_thread::PosixThreadExt, signal::handle_pending_signal},\n+    syscall::handle_syscall,\n     thread::exception::handle_exception,\n };\n \n /// create new task with userspace and parent process\n pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n     fn user_task_entry() {\n+        fn has_pending_signal(current_thread: &Arc<Thread>) -> bool {\n+            let posix_thread = current_thread.as_posix_thread().unwrap();\n+            posix_thread.has_pending_signal()\n+        }\n+\n         let current_thread = current_thread!();\n         let current_task = current_thread.task();\n         let user_space = current_task\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -34,11 +41,17 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             user_mode.context().syscall_ret()\n         );\n \n+        #[allow(clippy::redundant_closure)]\n+        let has_kernel_event_fn = || has_pending_signal(&current_thread);\n         loop {\n-            let user_event = user_mode.execute();\n+            let return_reason = user_mode.execute(has_kernel_event_fn);\n             let context = user_mode.context_mut();\n             // handle user event:\n-            handle_user_event(user_event, context);\n+            match return_reason {\n+                ReturnReason::UserException => handle_exception(context),\n+                ReturnReason::UserSyscall => handle_syscall(context),\n+                ReturnReason::KernelEvent => {}\n+            };\n             // should be do this comparison before handle signal?\n             if current_thread.status().is_exited() {\n                 break;\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -68,10 +81,3 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         .build()\n         .expect(\"spawn task failed\")\n }\n-\n-fn handle_user_event(user_event: UserEvent, context: &mut UserContext) {\n-    match user_event {\n-        UserEvent::Syscall => handle_syscall(context),\n-        UserEvent::Exception => handle_exception(context),\n-    }\n-}\ndiff --git /dev/null b/regression/apps/alarm/alarm.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/alarm/alarm.c\n@@ -0,0 +1,11 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#include <unistd.h>\n+\n+int main()\n+{\n+\talarm(3);\n+\twhile (1) {\n+\t}\n+\treturn 0;\n+}\n",
        "test_patch": "",
        "problem_statement": "Deliver POSIX signals for busy-loop user code\n## Problem\r\n\r\nCurrently, the POSIX signals are handled in the main loop of user tasks, after `UserMode::execute` returns.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            \r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n            \r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            // POSIX signals are handled here!\r\n            handle_pending_signal(context).unwrap();\r\n            \r\n            // ...\r\n        }\r\n    }\r\n    \r\n    TaskOptions::new(user_task_entry)\r\n        .data(thread_ref)\r\n        .user_space(Some(user_space))\r\n        .build()\r\n        .expect(\"spawn task failed\")\r\n}\r\n```\r\n\r\nThis means that if `UserMode::execute` does not returns, then the kernel has no chance to handle signals. Consider the following simple user program in C.\r\n\r\n```rust\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\n\r\nOf course. The `SIGALRM` shall never be delivered to the process by Asterinas as the kernel can only handles POSIX signals when the user code requests system calls.\r\n\r\n## Analysis\r\n\r\nTo figure out a solution, let's dig into the `UserMode::execute` function, which calls `UserContext::execute` to do the real job.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n    \r\n    loop {\r\n        self.user_context.run();\r\n        match CpuException::to_cpu_exception(self.user_context.trap_num as u16) {\r\n            Some(exception) => {\r\n                if exception.typ == CpuExceptionType::FaultOrTrap\r\n                    || exception.typ == CpuExceptionType::Fault\r\n                    || exception.typ == CpuExceptionType::Trap\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            None => {\r\n                if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        call_irq_callback_functions(&self.as_trap_frame());\r\n    }\r\n\r\n    if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\r\n        // ...\r\n        \r\n        UserEvent::Exception\r\n    } else {\r\n        UserEvent::Syscall\r\n    }\r\n}\r\n```\r\n\r\nIf the periodic timer interrupt is triggered while the CPU is running in the user mode, then `self.user_context.run()` returns and the interrupt is handled by the `call_irq_callback_functions` function.\r\n\r\nSo the control of the CPU does return to the kernel at regular intervals. However, a significant issue arises with the `UserContext::execute` method from the Asterinas Framework\u2014it lacks awareness and handling of POSIX signals, and appropriately so.\r\n\r\n## Solution\r\n\r\n### Major changes to `aster-frame`\r\n\r\nSo this issue proposes to extend the API of the `UserMode::execute` method as well as that of `UserContext::execute` so that the two methods would return the control of the CPU to its caller (e.g., the `aster-nix` crate) if there are pending events (e.g., POSIX signals).\r\n\r\nThe new interface is as shown below.\r\n\r\n```rust\r\nimpl<'a> UserMode<'a> {\r\n    /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\r\n    ///\r\n    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\r\n    /// 1. A system call is issued by the user space;\r\n    /// 2. A CPU exception is triggered by the user space;\r\n    /// 3. A kernel event is pending, as indicated by the given closure.\r\n    ///\r\n    /// After handling whatever user or kernel events that \r\n    /// cause the method to return\r\n    /// and updating the user-mode CPU context,\r\n    /// this method can be invoked again to go back to the user space.\r\n    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason \r\n    where\r\n        F: FnMut() -> bool,\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nThe new `ReturnReason` replaces the old `UserEvent`.\r\n\r\n```rust\r\n/// A reason as to why the control of the CPU is returned from\r\n/// the user space to the kernel.\r\n#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\r\npub enum ReturnReason {\r\n    /// A system call is issued by the user space.\r\n    UserSyscall,\r\n    /// A CPU exception is triggered by the user space.\r\n    UserException,\r\n    /// A kernel event is pending \r\n    KernelEvent,\r\n}\r\n```\r\n\r\n### Major changes to `aster-nix`\r\n\r\nThe main loop of a user task is modifed to utilize the extended interface of `UserMode::execute`.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n\r\n    fn user_task_entry() {\r\n        let has_kernel_events_fn = {\r\n            let current = current!();\r\n            let current_thread = current_thread!();\r\n            || {\r\n                current.has_pending_signals()\r\n            }\r\n        };\r\n        \r\n        loop {\r\n            let return_reason = user_mode.execute(has_kernel_events_fn);\r\n            let context = user_mode.context_mut();\r\n            match user_event {\r\n                ReturnReason::UserSyscall => handle_syscall(context),\r\n                ReturnReason::UserException => handle_exception(context),\r\n                _ =>,\r\n            }\r\n\r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            handle_pending_signal(context).unwrap();\r\n            // ...\r\n        }\r\n    }\r\n\r\n    // ...\r\n}\r\n```\r\n\n`ThreadOptions` is not fully used while creating new kernel thread\nHere is the `aster-nix::thread::kernel_thread::ThreadOptions`.\r\n```rust\r\n/// Options to create or spawn a new thread.\r\npub struct ThreadOptions {\r\n    func: Option<Box<dyn Fn() + Send + Sync>>,\r\n    priority: Priority,\r\n    cpu_affinity: CpuSet,\r\n}\r\n```\r\nIt has fields representing priority and cpu affinity. But when we create new kernel thread in the code below,\r\n```rust\r\nfn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\r\n        let task_fn = thread_options.take_func();\r\n        let thread_fn = move || {\r\n            task_fn();\r\n            let current_thread = current_thread!();\r\n            // ensure the thread is exit\r\n            current_thread.exit();\r\n        };\r\n        let tid = allocate_tid();\r\n        let thread = Arc::new_cyclic(|thread_ref| {\r\n            let weal_thread = thread_ref.clone();\r\n            let task = TaskOptions::new(thread_fn)\r\n                .data(weal_thread)\r\n                .build()\r\n                .unwrap();\r\n            let status = ThreadStatus::Init;\r\n            let kernel_thread = KernelThread;\r\n            Thread::new(tid, task, kernel_thread, status)\r\n        });\r\n        thread_table::add_thread(thread.clone());\r\n        thread\r\n    }\r\n```\r\nwe never use this two fields to construct `TaskOptions`, therefore the bound task is always of default configuration. \r\n\r\nOne problem caused by this issue is that all `Worker`s in `WORKERPOOL_HIGH_PRI` are of normal priority instead of real-time priority, which is incorrect and can cause starvation in some specific cases.\n",
        "hints_text": "I made some modification in #782 to enable timely delivery of POSIX signals based on the solution you proposed. But as to this specific MRE that you mentioned,\r\n```c\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\nI'm afraid that's not enough. \r\n\r\nUnder current implementation of alarm syscall, the actual callback, in which we enqueue the `SIGALRM` to corresponding `posix_thread`'s `sig_queues`, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed. \n> Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted to the work queue? \r\n\r\nBut I'm not sure whether we need to trigger preemtion before handling irq or after handling irq.\n> > Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n> \r\n> @jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted the the work queue?\r\n\r\nWill the `Usermode::execute` in `user_task_entry` ever return once we enter the `while(1)` busy-looping?\r\n\r\n\n> Will the Usermode::execute in user_task_entry ever return once we enter the while(1) busy-looping?\r\n\r\nCurrently, it won't. Maybe the `has_kernel_events_fn` should also check whether there are any pending workitems, and if any, `Usermode.execute` should also return to `aster-nix` to enable workqueue thread run. \r\n\r\nI'm not sure whether it's suitable to do so. \n> However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420 The following small change should be enough to address the issue you raised.\r\n\r\n### The change\r\n\r\nThe `aster_frame::task::preempt` function should be made private and called internally in `UserMode::execute`. This way, the Framework ensures that the user-kernel switching is always a preemption point.\r\n\r\n### The rationale\r\n\r\nPreemptive scheduling, as opposite to cooperative scheduling, is by definition transparent to the tasks that are subject to scheduling. In other words, Asterinas Framework must enforce preemption, without cooperation from the users of Asterinas Framework.\r\n\r\nBut in our current implementation, the `preempt` method from `aster-frame` is explicitly called by its user.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n\r\n            // ...\r\n\r\n            // a preemption point after handling user event.\r\n            preempt();\r\n        }\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\nThe proposed change can address this problem.\r\n\nThanks for your advice.\r\n\r\nI have some question about how the `WorkQueue` mechanism works after we submit some `WorkItem`s. If I understood  correctly, the `Monitor` of `WorkerPool` should be scheduled to run first and the `Monitor` will `wake_worker` or `add_worker`, then we should wait for the running worker to be scheduled and the `Worker` will pick a  `WorkItem` to run if there is any. \r\n\r\nIf that is the case, how can a `Monitor` of `normal` priority `preempt` a running thread in current `PriorityScheduler`? Calling `schedule` instead of `preempt` may be a workaround, though logically incorrect (because the user loop should not explicitly give up cpu).\nUpdate:\r\n\r\nWhen I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nAfter fixing that issue, the `SIGALRM` signal can finally be correctly enqueued. I expected that the `while(1)` thread would be rescheduled to run and the signal would be handled in next timer interrupt. The `while(1)` did get on the cpu. However, this time the `UserContext::run` never returned. I'm not that familiar with this part and need to dig in more to find out what happened.\n> When I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nGood point \ud83d\udc4d \n@jellllly420 Good job on spotting the bug. Could you try to fix it?",
        "created_at": "2024-04-23T16:18:28Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 665,
        "instance_id": "asterinas__asterinas-665",
        "issue_numbers": [
            "657"
        ],
        "base_commit": "132d36bf2082acafa14edf665e98463f681d6363",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -169,7 +173,7 @@ check: $(CARGO_OSDK)\n \t\t(cd $$dir && cargo clippy -- -D warnings) || exit 1; \\\n \tdone\n \t@for dir in $(OSDK_CRATES); do \\\n-\t\t(cd $$dir && cargo osdk clippy) || exit 1; \\\n+\t\t(cd $$dir && cargo osdk clippy -- -- -D warnings) || exit 1; \\\n \tdone\n \n .PHONY: clean\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -309,7 +309,7 @@ impl UserContextApiInternal for UserContext {\n     }\n }\n \n-/// As Osdev Wiki defines(https://wiki.osdev.org/Exceptions):\n+/// As Osdev Wiki defines(<https://wiki.osdev.org/Exceptions>):\n /// CPU exceptions are classified as:\n ///\n /// Faults: These can be corrected and the program may continue as if nothing happened.\ndiff --git a/framework/aster-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\n--- a/framework/aster-frame/src/arch/x86/device/serial.rs\n+++ b/framework/aster-frame/src/arch/x86/device/serial.rs\n@@ -7,7 +7,7 @@ use crate::arch::x86::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess\n /// A serial port.\n ///\n /// Serial ports are a legacy communications port common on IBM-PC compatible computers.\n-/// Ref: https://wiki.osdev.org/Serial_Ports\n+/// Ref: <https://wiki.osdev.org/Serial_Ports>\n pub struct SerialPort {\n     pub data: IoPort<u8, ReadWriteAccess>,\n     pub int_en: IoPort<u8, WriteOnlyAccess>,\ndiff --git a/framework/aster-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\n--- a/framework/aster-frame/src/arch/x86/timer/pit.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/pit.rs\n@@ -4,7 +4,7 @@\n //! a prescaler and 3 independent frequency dividers. Each frequency divider has an output, which is\n //! used to allow the timer to control external circuitry (for example, IRQ 0).\n //!\n-//! Reference: https://wiki.osdev.org/Programmable_Interval_Timer\n+//! Reference: <https://wiki.osdev.org/Programmable_Interval_Timer>\n //!\n \n use crate::{\ndiff --git a/framework/aster-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/aster-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -5,7 +5,7 @@\n //! The format of the Asterinas command line string conforms\n //! to the Linux kernel command line rules:\n //!\n-//! https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html\n+//! <https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html>\n //!\n \n use alloc::{\ndiff --git a/framework/aster-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\n--- a/framework/aster-frame/src/bus/pci/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/mod.rs\n@@ -9,7 +9,7 @@\n //!\n //! Use case:\n //!\n-//! ```rust norun\n+//! ```rust no_run\n //! #[derive(Debug)]\n //! pub struct PciDeviceA {\n //!     common_device: PciCommonDevice,\ndiff --git a/framework/aster-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/aster-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -103,7 +103,7 @@ impl Drop for IrqLine {\n ///\n /// # Example\n ///\n-/// ``rust\n+/// ```rust\n /// use aster_frame::irq;\n ///\n /// {\ndiff --git a/framework/libs/linux-bzimage/builder/src/pe_header.rs b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/framework/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -3,10 +3,10 @@\n //! Big zImage PE/COFF header generation.\n //!\n //! The definition of the PE/COFF header is in the Microsoft PE/COFF specification:\n-//! https://learn.microsoft.com/en-us/windows/win32/debug/pe-format\n+//! <https://learn.microsoft.com/en-us/windows/win32/debug/pe-format>\n //!\n //! The reference to the Linux PE header definition:\n-//! https://github.com/torvalds/linux/blob/master/include/linux/pe.h\n+//! <https://github.com/torvalds/linux/blob/master/include/linux/pe.h>\n \n use std::{mem::size_of, ops::Range};\n \ndiff --git a/kernel/aster-nix/src/console.rs b/kernel/aster-nix/src/console.rs\n--- a/kernel/aster-nix/src/console.rs\n+++ b/kernel/aster-nix/src/console.rs\n@@ -22,7 +22,7 @@ pub fn _print(args: Arguments) {\n     VirtioConsolesPrinter.write_fmt(args).unwrap();\n }\n \n-/// Copy from Rust std: https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs\n+/// Copied from Rust std: <https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs>\n #[macro_export]\n macro_rules! print {\n     ($($arg:tt)*) => {{\ndiff --git a/kernel/aster-nix/src/console.rs b/kernel/aster-nix/src/console.rs\n--- a/kernel/aster-nix/src/console.rs\n+++ b/kernel/aster-nix/src/console.rs\n@@ -30,7 +30,7 @@ macro_rules! print {\n     }};\n }\n \n-/// Copy from Rust std: https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs\n+/// Copied from Rust std: <https://github.com/rust-lang/rust/blob/master/library/std/src/macros.rs>\n #[macro_export]\n macro_rules! println {\n     () => {\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -39,7 +39,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n     /// Bind a socket to the iface. So the packet for this socket will be dealt with by the interface.\n     /// If port is None, the iface will pick up an empheral port for the socket.\n     /// FIXME: The reason for binding socket and interface together is because there are limitations inside smoltcp.\n-    /// See discussion at https://github.com/smoltcp-rs/smoltcp/issues/779.\n+    /// See discussion at <https://github.com/smoltcp-rs/smoltcp/issues/779>.\n     fn bind_socket(\n         &self,\n         socket: Box<AnyUnboundSocket>,\ndiff --git a/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs b/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n--- a/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n+++ b/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\n@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n /// Shutdown types\n-/// From https://elixir.bootlin.com/linux/v6.0.9/source/include/linux/net.h\n+/// From <https://elixir.bootlin.com/linux/v6.0.9/source/include/linux/net.h>\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq, TryFromInt)]\n #[allow(non_camel_case_types)]\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -2,7 +2,7 @@\n \n //! This module defines the process initial stack.\n //! The process initial stack, contains arguments, environmental variables and auxiliary vectors\n-//! The data layout of init stack can be seen in Figure 3.9 in https://uclibc.org/docs/psABI-x86_64.pdf\n+//! The data layout of init stack can be seen in Figure 3.9 in <https://uclibc.org/docs/psABI-x86_64.pdf>\n \n use core::mem;\n \ndiff --git a/kernel/aster-nix/src/util/net/options/mod.rs b/kernel/aster-nix/src/util/net/options/mod.rs\n--- a/kernel/aster-nix/src/util/net/options/mod.rs\n+++ b/kernel/aster-nix/src/util/net/options/mod.rs\n@@ -24,7 +24,7 @@\n //!\n //! First, the option should be added in the net module for the TCP socket.\n //!  \n-//! ```rust norun\n+//! ```rust no_run\n //! impl_socket_option!(TcpNodelay(bool));\n //! ```\n //!\ndiff --git a/kernel/aster-nix/src/util/net/options/mod.rs b/kernel/aster-nix/src/util/net/options/mod.rs\n--- a/kernel/aster-nix/src/util/net/options/mod.rs\n+++ b/kernel/aster-nix/src/util/net/options/mod.rs\n@@ -32,15 +32,19 @@\n //! in the utils module. These util functions can be shared if multiple options have the value\n //! of same type.\n //!\n-//! ```rust norun\n-//! impl ReadFromUser for bool { // content omitted here }\n-//! impl WriteFromUser for bool { // content omitted here }\n+//! ```rust compile_fail\n+//! impl ReadFromUser for bool {\n+//!     // content omitted here\n+//! }\n+//! impl WriteFromUser for bool {\n+//!     // content omitted here\n+//! }\n //! ```\n //!\n //! At last, we can implement `RawSocketOption` for `TcpNodelay` so that it can be read/from\n //! user space.\n //!\n-//! ```rust norun\n+//! ```rust no_run\n //! impl_raw_socket_option!(TcpNodeley);\n //! ```\n //!\ndiff --git a/kernel/comps/virtio/src/device/input/mod.rs b/kernel/comps/virtio/src/device/input/mod.rs\n--- a/kernel/comps/virtio/src/device/input/mod.rs\n+++ b/kernel/comps/virtio/src/device/input/mod.rs\n@@ -35,7 +35,7 @@ use crate::transport::VirtioTransport;\n \n pub static DEVICE_NAME: &str = \"Virtio-Input\";\n \n-/// Select value used for [`VirtIOInput::query_config_select()`].\n+/// Select value used for [`device::InputDevice::query_config_select()`].\n #[repr(u8)]\n #[derive(Debug, Clone, Copy)]\n pub enum InputConfigSelect {\ndiff --git a/kernel/libs/aster-rights-proc/src/lib.rs b/kernel/libs/aster-rights-proc/src/lib.rs\n--- a/kernel/libs/aster-rights-proc/src/lib.rs\n+++ b/kernel/libs/aster-rights-proc/src/lib.rs\n@@ -4,11 +4,11 @@\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\n //! The require macro are used to ensure that an object has the enough capability to call the function.\n-//! The **require** macro can accept constraint [SomeRightSet] > [SomeRight],\n-//! which means the SomeRightSet should **contain** the SomeRight.\n-//! The **require** macro can also accept constraint [SomeRightSet] > [AnotherRightSet],\n-//! which means the SomeRightSet should **include** the AnotherRightSet. In this case, AnotherRightSet should be a **generic parameter**.\n-//! i.e., AnotherRightSet should occur the the generic param list of the function.\n+//! The **require** macro can accept constraint `SomeRightSet` > `SomeRight`,\n+//! which means the `SomeRightSet` should **contain** the `SomeRight`.\n+//! The **require** macro can also accept constraint `SomeRightSet` > `AnotherRightSet`,\n+//! which means the `SomeRightSet` should **include** the `AnotherRightSet`. In this case, `AnotherRightSet` should be a **generic parameter**.\n+//! i.e., `AnotherRightSet` should occur the the generic param list of the function.\n //!\n //! If there are multiple constraits, they can be seperated with `|`, which means all constraits should be satisfied.\n //!\ndiff --git a/kernel/libs/aster-rights/src/lib.rs b/kernel/libs/aster-rights/src/lib.rs\n--- a/kernel/libs/aster-rights/src/lib.rs\n+++ b/kernel/libs/aster-rights/src/lib.rs\n@@ -55,7 +55,7 @@ pub type WriteOp = TRights![Write];\n pub type FullOp = TRights![Read, Write, Dup];\n \n /// Wrapper for TRights, used to bypass an error message from the Rust compiler,\n-/// the relevant issue is: https://github.com/rust-lang/rfcs/issues/2758\n+/// the relevant issue is: <https://github.com/rust-lang/rfcs/issues/2758>\n ///\n /// Example:\n ///\ndiff --git a/osdk/src/commands/check.rs /dev/null\n--- a/osdk/src/commands/check.rs\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use std::process;\n-\n-use super::util::{cargo, COMMON_CARGO_ARGS};\n-use crate::{error::Errno, error_msg};\n-\n-pub fn execute_check_command() {\n-    let mut command = cargo();\n-    command\n-        .arg(\"check\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\");\n-    command.args(COMMON_CARGO_ARGS);\n-    let status = command.status().unwrap();\n-    if !status.success() {\n-        error_msg!(\"Check failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-}\ndiff --git a/osdk/src/commands/clippy.rs /dev/null\n--- a/osdk/src/commands/clippy.rs\n+++ /dev/null\n@@ -1,38 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use std::process;\n-\n-use super::util::{cargo, COMMON_CARGO_ARGS};\n-use crate::{error::Errno, error_msg};\n-\n-pub fn execute_clippy_command() {\n-    let mut command = cargo();\n-    command\n-        .arg(\"clippy\")\n-        .arg(\"-h\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\")\n-        .args(COMMON_CARGO_ARGS);\n-    info!(\"Running `cargo clippy -h`\");\n-    let output = command.output().unwrap();\n-    if !output.status.success() {\n-        let stderr = String::from_utf8_lossy(&output.stderr);\n-        eprintln!(\"{}\", &stderr);\n-        error_msg!(\"Cargo clippy failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-\n-    let mut command = cargo();\n-    command\n-        .arg(\"clippy\")\n-        .arg(\"--target\")\n-        .arg(\"x86_64-unknown-none\")\n-        .args(COMMON_CARGO_ARGS);\n-    // TODO: Add support for custom clippy args using OSDK commandline rather than hardcode it.\n-    command.args([\"--\", \"-D\", \"warnings\"]);\n-    let status = command.status().unwrap();\n-    if !status.success() {\n-        error_msg!(\"Cargo clippy failed\");\n-        process::exit(Errno::ExecuteCommand as _);\n-    }\n-}\n",
        "test_patch": "",
        "problem_statement": "[BUG] `cargo doc` reports error and fails\n# Problem\r\n`cargo doc` is used in `make docs` to generate API documentations. However, the command will fail currently. The problem seems to exist for a long time.\r\n\r\nBefore introducing OSDK, the `inventory` crate will report error. Since this crate is forked under Asterinas, we shoube be able to fix the error. \r\n\r\n![iwEcAqNwbmcDAQTRCfIF0QJ2BrCwmeF5_LlFWwXOjUHN7ecAB9MAAAAAuoBoxQgACaJpbQoAC9IABSn4 png_720x720q90](https://github.com/asterinas/asterinas/assets/27764680/f2ccc7b8-a924-402b-b67b-76c3b5a5496f)\r\n\r\nAfter indroducing OSDK, new problem occurs. The `linux-bzimage-setup` panics when running `cargo doc`. \r\n\r\n<img width=\"1458\" alt=\"\u622a\u5c4f2024-02-29 15 30 54\" src=\"https://github.com/asterinas/asterinas/assets/27764680/97c6f89c-419d-46d6-9045-ea515fe80b3c\">\r\n\r\nIf running `cargo doc --target x86_64-unknown-none` to avoid panic in `linux-bzimage-setup` , more error occurs.\r\n\r\n# Possible solution\r\n\r\n1. Fix the error in `inventory`\r\n2. Make `linux-bzimage-setup` can also build under other target, like `x86_64-unknown-linux-gnu`, but should we allow this behavior? \n",
        "hints_text": "This will work.\r\n\r\n```bash\r\ncargo doc --target x86_64-unknown-none -Zbuild-std=core,alloc,compiler_builtins -Zbuild-std-features=compiler-builtins-mem\r\n```",
        "created_at": "2024-03-06T09:10:55Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 630,
        "instance_id": "asterinas__asterinas-630",
        "issue_numbers": [
            "625"
        ],
        "base_commit": "b450eef1660c0362ba65de07a3bd03c8199c3265",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,6 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n+use aster_frame::sync::WaitQueue;\n use keyable_arc::KeyableWeak;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -22,9 +23,11 @@ pub struct IfaceCommon {\n     interface: SpinLock<smoltcp::iface::Interface>,\n     sockets: SpinLock<SocketSet<'static>>,\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n-    /// The time should do next poll. We stores the total microseconds since system boots up.\n+    /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n     bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    /// The wait queue that background polling thread will sleep on\n+    polling_wait_queue: WaitQueue,\n }\n \n impl IfaceCommon {\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -37,6 +40,7 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -60,6 +64,10 @@ impl IfaceCommon {\n         })\n     }\n \n+    pub(super) fn polling_wait_queue(&self) -> &WaitQueue {\n+        &self.polling_wait_queue\n+    }\n+\n     /// Alloc an unused port range from 49152 ~ 65535 (According to smoltcp docs)\n     fn alloc_ephemeral_port(&self) -> Result<u16> {\n         let mut used_ports = self.used_ports.write();\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -155,10 +163,16 @@ impl IfaceCommon {\n \n         let sockets = self.sockets.lock_irq_disabled();\n         if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+            let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms\n-                .store(instant.total_millis() as u64, Ordering::SeqCst);\n+                .store(instant.total_millis() as u64, Ordering::Relaxed);\n+\n+            if new_instant < old_instant {\n+                self.polling_wait_queue.wake_all();\n+            }\n         } else {\n-            self.next_poll_at_ms.store(0, Ordering::SeqCst);\n+            self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -1,5 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use aster_frame::sync::WaitQueue;\n use smoltcp::iface::SocketSet;\n \n use self::common::IfaceCommon;\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -60,6 +61,11 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n     fn netmask(&self) -> Option<Ipv4Address> {\n         self.common().netmask()\n     }\n+\n+    /// The waitqueue used to background polling thread\n+    fn polling_wait_queue(&self) -> &WaitQueue {\n+        self.common().polling_wait_queue()\n+    }\n }\n \n mod internal {\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -1,6 +1,8 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use aster_frame::timer::read_monotonic_milli_seconds;\n+use core::time::Duration;\n+\n+use aster_frame::{task::Priority, timer::read_monotonic_milli_seconds};\n \n use super::Iface;\n use crate::{\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -46,30 +48,40 @@ impl BindPortConfig {\n }\n \n pub fn spawn_background_poll_thread(iface: Arc<dyn Iface>) {\n-    // FIXME: use timer or wait_timeout when timer is enable.\n     let task_fn = move || {\n-        debug!(\"spawn background poll thread\");\n+        trace!(\"spawn background poll thread for {}\", iface.name());\n+        let wait_queue = iface.polling_wait_queue();\n         loop {\n-            let next_poll_time = if let Some(next_poll_time) = iface.next_poll_at_ms() {\n-                next_poll_time\n+            let next_poll_at_ms = if let Some(next_poll_at_ms) = iface.next_poll_at_ms() {\n+                next_poll_at_ms\n             } else {\n-                Thread::yield_now();\n-                continue;\n+                wait_queue.wait_until(|| iface.next_poll_at_ms())\n             };\n-            let now = read_monotonic_milli_seconds();\n-            if now > next_poll_time {\n-                // FIXME: now is later than next poll time. This may cause problem.\n+\n+            let now_as_ms = read_monotonic_milli_seconds();\n+\n+            // FIXME: Ideally, we should perform the `poll` just before `next_poll_at_ms`.\n+            // However, this approach may result in a spinning busy loop\n+            // if the `poll` operation yields no results.\n+            // To mitigate this issue,\n+            // we have opted to assign a high priority to the polling thread,\n+            // ensuring that the `poll` runs as soon as possible.\n+            // For a more in-depth discussion, please refer to the following link:\n+            // <https://github.com/asterinas/asterinas/pull/630#discussion_r1496817030>.\n+            if now_as_ms >= next_poll_at_ms {\n                 iface.poll();\n                 continue;\n             }\n-            let duration = next_poll_time - now;\n-            // FIXME: choose a suitable time interval\n-            if duration < 10 {\n-                iface.poll();\n-            } else {\n-                Thread::yield_now();\n-            }\n+\n+            let duration = Duration::from_millis(next_poll_at_ms - now_as_ms);\n+            wait_queue.wait_until_or_timeout(\n+                // If `iface.next_poll_at_ms()` changes to an earlier time, we will end the waiting.\n+                || (iface.next_poll_at_ms()? < next_poll_at_ms).then_some(()),\n+                &duration,\n+            );\n         }\n     };\n-    Thread::spawn_kernel_thread(ThreadOptions::new(task_fn));\n+\n+    let options = ThreadOptions::new(task_fn).priority(Priority::high());\n+    Thread::spawn_kernel_thread(options);\n }\n",
        "test_patch": "",
        "problem_statement": "Support for in-kernel sleep\nCurrently sleep function we provide seems to be the only `pauser.pause_until_or_timeout()` for the POSIX threads from users, as in the `clock_nanosleep` syscall. However, some functionalities within kernel also need sleep like\r\nhttps://github.com/asterinas/asterinas/blob/bd6f65667df494f6fb88fc60eb4ed18a106bed71/services/libs/aster-std/src/net/iface/util.rs#L49-L76\r\nWithout the support for kernel-level sleep, the polling would consume all the CPU cycles just to busy polling, while there is already hint for how long it should wait.\n",
        "hints_text": "In-kernel sleep is supported. A kernel thread can sleep using the `WaitQueue` API provided by the Framework. `Pauser` is in fact based on `WaitQueue`.\r\n\r\nIn theory, the specific code snippet you show can and should be refactored using `WaitQueue` to avoid busy looping. But it is written that way. Why? My guess is that at the time when this busy loop is written, the timer API of the Framework is not ready.\r\n\r\n```rust\r\n// FIXME: use timer or wait_timeout when timer is enable. \r\n```\r\n\r\n@StevenJiang1110 is the original author so his answer is the most wanted. \r\n\nYes, the origin code is added when `WaitQueue` cannot accept a `timeout` parameter.  Since timeout is supported now, we can avoid using busy loop here. #630 provides a fix for this problem.",
        "created_at": "2024-01-29T03:53:41Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 327,
        "instance_id": "asterinas__asterinas-327",
        "issue_numbers": [
            "340"
        ],
        "base_commit": "dbfb2e1a62a9981a67cc01ff7310981744ec2ac5",
        "patch": "diff --git /dev/null b/tools/docker/.gitignore\nnew file mode 100644\n--- /dev/null\n+++ b/tools/docker/.gitignore\n@@ -0,0 +1,1 @@\n+bom/\n",
        "test_patch": "",
        "problem_statement": "Precompile syscall tests in the dev docker image to accelerate CI\nCurrently the syscall tests are compiled every-time when CI triggers, which is at a cost of around 12 minutes on Github runners.\n",
        "hints_text": "",
        "created_at": "2023-07-27T07:11:21Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 183,
        "instance_id": "asterinas__asterinas-183",
        "issue_numbers": [
            "115"
        ],
        "base_commit": "888853a6de752e97c6f94fff83c00594be42929f",
        "patch": "diff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -13,8 +13,8 @@ target/\n **/.DS_Store\n \n # Ramdisk file\n-src/ramdisk/initramfs/\n-src/ramdisk/build/\n+regression/ramdisk/initramfs/\n+regression/ramdisk/build/\n \n # qemu log file\n qemu.log\ndiff --git a/src/Cargo.toml b/Cargo.toml\n--- a/src/Cargo.toml\n+++ b/Cargo.toml\n@@ -3,11 +3,15 @@ name = \"jinux\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n+[[bin]]\n+name = \"jinux\"\n+path = \"kernel/main.rs\"\n+\n [dependencies]\n limine = \"0.1.10\"\n jinux-frame = { path = \"framework/jinux-frame\" }\n jinux-std = { path = \"services/libs/jinux-std\" }\n-component = { path = \"services/comp-sys/component\" }\n+component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\ndiff --git a/src/Cargo.toml b/Cargo.toml\n--- a/src/Cargo.toml\n+++ b/Cargo.toml\n@@ -33,4 +37,4 @@ members = [\n     \"services/libs/cpio-decoder\",\n ]\n \n-exclude = [\"services/comp-sys/controlled\", \"services/comp-sys/cargo-component\"]\n+exclude = [\"services/libs/comp-sys/controlled\", \"services/libs/comp-sys/cargo-component\"]\ndiff --git a/src/boot/limine/scripts/limine-build.sh b/boot/limine/scripts/limine-build.sh\n--- a/src/boot/limine/scripts/limine-build.sh\n+++ b/boot/limine/scripts/limine-build.sh\n@@ -25,7 +25,7 @@ cp target/limine/limine-cd.bin target/iso_root\n cp target/limine/limine-cd-efi.bin target/iso_root\n \n # Copy ramdisk\n-cp ramdisk/build/ramdisk.cpio target/iso_root\n+cp regression/ramdisk/build/ramdisk.cpio target/iso_root\n \n xorriso -as mkisofs                                             \\\n     -b limine-cd.bin                                            \\\ndiff --git a/src/framework/jinux-frame/Cargo.toml b/framework/jinux-frame/Cargo.toml\n--- a/src/framework/jinux-frame/Cargo.toml\n+++ b/framework/jinux-frame/Cargo.toml\n@@ -12,7 +12,7 @@ spin = \"0.9.4\"\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n buddy_system_allocator = \"0.9.0\"\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-align_ext = { path = \"../align_ext\" }\n+align_ext = { path = \"../libs/align_ext\" }\n intrusive-collections = \"0.9.5\"\n log = \"0.4\"\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\ndiff --git /dev/null b/regression/apps/hello_c/hello\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/hello_c/hello\n@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:dda5a7d6081cc2252056375d0550731ef2fd24789aa5f17da189a36bf78c588d\n+size 871896\ndiff --git a/src/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/src/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\n--- a/src/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n font8x8 = { version = \"0.2.5\", default-features = false, features = [\ndiff --git a/src/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/src/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\n \ndiff --git a/src/services/comps/pci/Cargo.toml b/services/comps/pci/Cargo.toml\n--- a/src/services/comps/pci/Cargo.toml\n+++ b/services/comps/pci/Cargo.toml\n@@ -11,7 +11,7 @@ spin = \"0.9.4\"\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [dependencies.lazy_static]\ndiff --git a/src/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\n--- a/src/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n \ndiff --git a/src/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/src/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/libs/jinux-std/Cargo.toml b/services/libs/jinux-std/Cargo.toml\n--- a/src/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/jinux-std/Cargo.toml\n@@ -7,12 +7,12 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-align_ext = { path = \"../../../framework/align_ext\" }\n+align_ext = { path = \"../../../framework/libs/align_ext\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n jinux-input = { path = \"../../comps/input\" }\n jinux-block = { path = \"../../comps/block\" }\n jinux-time = { path = \"../../comps/time\" }\n-controlled = { path = \"../../comp-sys/controlled\" }\n+controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n jinux-rights-proc = { path = \"../jinux-rights-proc\" }\ndiff --git a/src/services/libs/jinux-std/src/lib.rs b/services/libs/jinux-std/src/lib.rs\n--- a/src/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/jinux-std/src/lib.rs\n@@ -79,7 +79,7 @@ fn init_thread() {\n }\n \n fn read_ramdisk_content() -> &'static [u8] {\n-    include_bytes!(\"../../../../ramdisk/build/ramdisk.cpio\")\n+    include_bytes!(\"../../../../regression/ramdisk/build/ramdisk.cpio\")\n }\n \n /// first process never return\n",
        "test_patch": "",
        "problem_statement": "Reorganize the codebase for cleanness\nTo make the codebase more clean and understandable, I propose to do the following changes:\r\n\r\n* Rename `tests` to `test`, which indicates that the directory contains various types of testing code, including unit tests, user programs, and possibly LTP tests\r\n  * Rename `apps` to `test/apps`\r\n  * In the future, add LTP tests to `test`\r\n  * Put `ramdisk` under `test` because its content is only intended for testing\r\n* Create a `framework/libs` and move every dir (except `jinux-frame`) to the new dir\r\n* Rename `jinux-boot` to `boot` to make the name consistent with other dirs like `services` and `framework`\r\n* Move `services/comp-sys` to `services/libs/comp-sys`\r\n* Move `src/*` to the project root dir\r\n* [Optional] Rename `src/src` to `src/kernel`\n",
        "hints_text": "",
        "created_at": "2023-04-10T03:22:03Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 679,
        "instance_id": "asterinas__asterinas-679",
        "issue_numbers": [
            "666"
        ],
        "base_commit": "dede22843a99f6d19c8a2dddcfc7ef0ad45ce815",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -15,8 +15,7 @@ use crate::{\n         memory_region::{non_overlapping_regions_from, MemoryRegion, MemoryRegionType},\n         BootloaderAcpiArg, BootloaderFramebufferArg,\n     },\n-    config::PHYS_OFFSET,\n-    vm::paddr_to_vaddr,\n+    vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR},\n };\n \n static BOOT_PARAMS: Once<BootParams> = Once::new();\ndiff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -71,7 +70,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n     let hdr = &BOOT_PARAMS.get().unwrap().hdr;\n     let ptr = hdr.ramdisk_image as usize;\n     // We must return a slice composed by VA since kernel should read everything in VA.\n-    let base_va = if ptr < PHYS_OFFSET {\n+    let base_va = if ptr < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(ptr)\n     } else {\n         ptr\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -12,8 +12,7 @@ use crate::{\n         memory_region::{non_overlapping_regions_from, MemoryRegion, MemoryRegionType},\n         BootloaderAcpiArg, BootloaderFramebufferArg,\n     },\n-    config::PHYS_OFFSET,\n-    vm::paddr_to_vaddr,\n+    vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR},\n };\n \n global_asm!(include_str!(\"header.S\"));\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -77,7 +76,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n         )\n     };\n     // We must return a slice composed by VA since kernel should read every in VA.\n-    let base_va = if start < PHYS_OFFSET {\n+    let base_va = if start < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(start)\n     } else {\n         start\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -17,7 +17,7 @@ use crate::boot::{\n \n global_asm!(include_str!(\"header.S\"));\n \n-use crate::{config::PHYS_OFFSET, vm::paddr_to_vaddr};\n+use crate::vm::{paddr_to_vaddr, PHYS_MEM_BASE_VADDR};\n \n pub(super) const MULTIBOOT2_ENTRY_MAGIC: u32 = 0x36d76289;\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -58,7 +58,7 @@ fn init_initramfs(initramfs: &'static Once<&'static [u8]>) {\n         .expect(\"No Multiboot2 modules found!\");\n     let base_addr = mb2_module_tag.start_address() as usize;\n     // We must return a slice composed by VA since kernel should read every in VA.\n-    let base_va = if base_addr < PHYS_OFFSET {\n+    let base_va = if base_addr < PHYS_MEM_BASE_VADDR {\n         paddr_to_vaddr(base_addr)\n     } else {\n         base_addr\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -3,7 +3,7 @@\n use pod::Pod;\n \n use crate::{\n-    config::ENTRY_COUNT,\n+    arch::x86::mm::NR_ENTRIES_PER_PAGE,\n     vm::page_table::{PageTableEntryTrait, PageTableFlagsTrait},\n };\n \ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -153,6 +153,6 @@ impl PageTableEntryTrait for PageTableEntry {\n \n     fn page_index(va: crate::vm::Vaddr, level: usize) -> usize {\n         debug_assert!((1..=5).contains(&level));\n-        va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+        va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     }\n }\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -6,7 +6,6 @@ use pod::Pod;\n use x86_64::{instructions::tlb, structures::paging::PhysFrame, VirtAddr};\n \n use crate::{\n-    config::ENTRY_COUNT,\n     sync::Mutex,\n     vm::{\n         page_table::{table_of, PageTableEntryTrait, PageTableFlagsTrait},\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -14,6 +13,8 @@ use crate::{\n     },\n };\n \n+pub(crate) const NR_ENTRIES_PER_PAGE: usize = 512;\n+\n bitflags::bitflags! {\n     #[derive(Pod)]\n     #[repr(C)]\ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -210,7 +211,7 @@ impl PageTableEntryTrait for PageTableEntry {\n \n     fn page_index(va: crate::vm::Vaddr, level: usize) -> usize {\n         debug_assert!((1..=5).contains(&level));\n-        va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+        va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     }\n }\n \ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -12,11 +12,11 @@ use tdx_guest::{\n \n use crate::{\n     arch::mm::{is_kernel_vaddr, PageTableFlags},\n-    config::PAGE_SIZE,\n     vm::{\n         paddr_to_vaddr,\n         page_table::{PageTableError, KERNEL_PAGE_TABLE},\n     },\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\ndiff --git a/framework/aster-frame/src/config.rs /dev/null\n--- a/framework/aster-frame/src/config.rs\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-#![allow(unused)]\n-\n-use log::Level;\n-\n-pub const USER_STACK_SIZE: usize = PAGE_SIZE * 4;\n-pub const KERNEL_STACK_SIZE: usize = PAGE_SIZE * 64;\n-pub const KERNEL_HEAP_SIZE: usize = PAGE_SIZE * 256;\n-\n-pub const KERNEL_OFFSET: usize = 0xffffffff80000000;\n-\n-pub const PHYS_OFFSET: usize = 0xFFFF800000000000;\n-pub const ENTRY_COUNT: usize = 512;\n-\n-pub const PAGE_SIZE: usize = 0x1000;\n-pub const PAGE_SIZE_BITS: usize = 0xc;\n-\n-pub const KVA_START: usize = (usize::MAX) << PAGE_SIZE_BITS;\n-\n-pub const DEFAULT_LOG_LEVEL: Level = Level::Error;\n-\n-pub const REAL_TIME_TASK_PRI: u16 = 100;\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -28,7 +28,6 @@ extern crate static_assertions;\n pub mod arch;\n pub mod boot;\n pub mod bus;\n-pub mod config;\n pub mod console;\n pub mod cpu;\n mod error;\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -1,16 +1,20 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use log::{Metadata, Record};\n+use log::{Level, Metadata, Record};\n \n-use crate::{config::DEFAULT_LOG_LEVEL, early_println};\n+use crate::early_println;\n \n const LOGGER: Logger = Logger {};\n \n+/// FIXME: The logs should be able to be read from files in the userspace,\n+/// and the log level should be configurable.\n+pub const INIT_LOG_LEVEL: Level = Level::Error;\n+\n struct Logger {}\n \n impl log::Log for Logger {\n     fn enabled(&self, metadata: &Metadata) -> bool {\n-        metadata.level() <= DEFAULT_LOG_LEVEL\n+        metadata.level() <= INIT_LOG_LEVEL\n     }\n \n     fn log(&self, record: &Record) {\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -24,6 +28,6 @@ impl log::Log for Logger {\n \n pub(crate) fn init() {\n     log::set_logger(&LOGGER)\n-        .map(|()| log::set_max_level(DEFAULT_LOG_LEVEL.to_level_filter()))\n+        .map(|()| log::set_max_level(INIT_LOG_LEVEL.to_level_filter()))\n         .unwrap();\n }\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use crate::config::REAL_TIME_TASK_PRI;\n+pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n \n /// The priority of a task.\n /// Similar to Linux, a larger value represents a lower priority,\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -44,6 +44,6 @@ impl Priority {\n     }\n \n     pub const fn is_real_time(&self) -> bool {\n-        self.0 < REAL_TIME_TASK_PRI\n+        self.0 < REAL_TIME_TASK_PRIORITY\n     }\n }\ndiff --git a/framework/aster-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\n--- a/framework/aster-frame/src/task/task.rs\n+++ b/framework/aster-frame/src/task/task.rs\n@@ -9,14 +9,15 @@ use super::{\n };\n use crate::{\n     arch::mm::PageTableFlags,\n-    config::{KERNEL_STACK_SIZE, PAGE_SIZE},\n     cpu::CpuSet,\n     prelude::*,\n     sync::{Mutex, MutexGuard},\n     user::UserSpace,\n-    vm::{page_table::KERNEL_PAGE_TABLE, VmAllocOptions, VmSegment},\n+    vm::{page_table::KERNEL_PAGE_TABLE, VmAllocOptions, VmSegment, PAGE_SIZE},\n };\n \n+pub const KERNEL_STACK_SIZE: usize = PAGE_SIZE * 64;\n+\n core::arch::global_asm!(include_str!(\"switch.S\"));\n \n #[derive(Debug, Default, Clone, Copy)]\ndiff --git a/framework/aster-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\n--- a/framework/aster-frame/src/vm/dma/mod.rs\n+++ b/framework/aster-frame/src/vm/dma/mod.rs\n@@ -10,7 +10,7 @@ pub use dma_stream::{DmaDirection, DmaStream};\n use spin::Once;\n \n use super::Paddr;\n-use crate::{arch::iommu::has_iommu, config::PAGE_SIZE, sync::SpinLock};\n+use crate::{arch::iommu::has_iommu, sync::SpinLock, vm::PAGE_SIZE};\n \n /// If a device performs DMA to read or write system\n /// memory, the addresses used by the device are device addresses.\ndiff --git a/framework/aster-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\n--- a/framework/aster-frame/src/vm/frame.rs\n+++ b/framework/aster-frame/src/vm/frame.rs\n@@ -9,7 +9,7 @@ use core::{\n use pod::Pod;\n \n use super::{frame_allocator, HasPaddr, VmIo};\n-use crate::{config::PAGE_SIZE, prelude::*, Error};\n+use crate::{prelude::*, vm::PAGE_SIZE, Error};\n \n /// A collection of page frames (physical memory pages).\n ///\ndiff --git a/framework/aster-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\n--- a/framework/aster-frame/src/vm/frame_allocator.rs\n+++ b/framework/aster-frame/src/vm/frame_allocator.rs\n@@ -10,8 +10,8 @@ use spin::Once;\n use super::{frame::VmFrameFlags, VmFrame, VmFrameVec, VmSegment};\n use crate::{\n     boot::memory_region::{MemoryRegion, MemoryRegionType},\n-    config::PAGE_SIZE,\n     sync::SpinLock,\n+    vm::PAGE_SIZE,\n };\n \n pub(super) static FRAME_ALLOCATOR: Once<SpinLock<FrameAllocator>> = Once::new();\ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -11,11 +11,10 @@ use log::debug;\n \n use super::paddr_to_vaddr;\n use crate::{\n-    config::{KERNEL_HEAP_SIZE, PAGE_SIZE},\n     prelude::*,\n     sync::SpinLock,\n     trap::disable_local,\n-    vm::frame_allocator::FRAME_ALLOCATOR,\n+    vm::{frame_allocator::FRAME_ALLOCATOR, PAGE_SIZE},\n     Error,\n };\n \ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -27,12 +26,14 @@ pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {\n     panic!(\"Heap allocation error, layout = {:?}\", layout);\n }\n \n-static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];\n+const INIT_KERNEL_HEAP_SIZE: usize = PAGE_SIZE * 256;\n+\n+static mut HEAP_SPACE: [u8; INIT_KERNEL_HEAP_SIZE] = [0; INIT_KERNEL_HEAP_SIZE];\n \n pub fn init() {\n     // Safety: The HEAP_SPACE is a static memory range, so it's always valid.\n     unsafe {\n-        HEAP_ALLOCATOR.init(HEAP_SPACE.as_ptr(), KERNEL_HEAP_SIZE);\n+        HEAP_ALLOCATOR.init(HEAP_SPACE.as_ptr(), INIT_KERNEL_HEAP_SIZE);\n     }\n }\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -6,9 +6,11 @@ use core::fmt;\n use super::page_table::{PageTable, PageTableConfig, UserMode};\n use crate::{\n     arch::mm::{PageTableEntry, PageTableFlags},\n-    config::{PAGE_SIZE, PHYS_OFFSET},\n     prelude::*,\n-    vm::{is_page_aligned, VmAllocOptions, VmFrame, VmFrameVec, VmReader, VmWriter},\n+    vm::{\n+        is_page_aligned, VmAllocOptions, VmFrame, VmFrameVec, VmReader, VmWriter,\n+        PHYS_MEM_BASE_VADDR, PAGE_SIZE,\n+    },\n     Error,\n };\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -148,7 +150,7 @@ impl MemorySet {\n             if let Entry::Vacant(e) = self.areas.entry(area.start_va) {\n                 let area = e.insert(area);\n                 for (va, frame) in area.mapper.iter() {\n-                    debug_assert!(frame.start_paddr() < PHYS_OFFSET);\n+                    debug_assert!(frame.start_paddr() < PHYS_MEM_BASE_VADDR);\n                     self.pt.map(*va, frame, area.flags).unwrap();\n                 }\n             } else {\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -32,10 +32,38 @@ pub use self::{\n     page_table::PageTable,\n     space::{VmMapOptions, VmPerm, VmSpace},\n };\n-use crate::{\n-    boot::memory_region::{MemoryRegion, MemoryRegionType},\n-    config::{KERNEL_OFFSET, PAGE_SIZE, PHYS_OFFSET},\n-};\n+use crate::boot::memory_region::{MemoryRegion, MemoryRegionType};\n+\n+pub const PAGE_SIZE: usize = 0x1000;\n+\n+/// The maximum virtual address of user space (non inclusive).\n+/// \n+/// Typicall 64-bit systems have at least 48-bit virtual address space.\n+/// A typical way to reserve half of the address space for the kernel is\n+/// to use the highest 48-bit virtual address space.\n+///\n+/// Also, the top page is not regarded as usable since it's a workaround\n+/// for some x86_64 CPUs' bugs. See\n+/// <https://github.com/torvalds/linux/blob/480e035fc4c714fb5536e64ab9db04fedc89e910/arch/x86/include/asm/page_64.h#L68-L78>\n+/// for the rationale.\n+pub const MAX_USERSPACE_VADDR: Vaddr = 0x0000_8000_0000_0000 - PAGE_SIZE;\n+\n+/// Start of the kernel address space.\n+/// \n+/// This is the _lowest_ address of the x86-64's _high_ canonical addresses.\n+///\n+/// This is also the base address of the direct mapping of all physical\n+/// memory in the kernel address space.\n+pub(crate) const PHYS_MEM_BASE_VADDR: Vaddr = 0xffff_8000_0000_0000;\n+\n+/// The kernel code is linear mapped to this address.\n+///\n+/// FIXME: This offset should be randomly chosen by the loader or the\n+/// boot compatibility layer. But we disabled it because the framework\n+/// doesn't support relocatable kernel yet.\n+pub fn kernel_loaded_offset() -> usize {\n+    0xffff_ffff_8000_0000\n+}\n \n /// Get physical address trait\n pub trait HasPaddr {\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -43,9 +71,9 @@ pub trait HasPaddr {\n }\n \n pub fn vaddr_to_paddr(va: Vaddr) -> Option<Paddr> {\n-    if (PHYS_OFFSET..=KERNEL_OFFSET).contains(&va) {\n+    if (PHYS_MEM_BASE_VADDR..=kernel_loaded_offset()).contains(&va) {\n         // can use offset to get the physical address\n-        Some(va - PHYS_OFFSET)\n+        Some(va - PHYS_MEM_BASE_VADDR)\n     } else {\n         page_table::vaddr_to_paddr(va)\n     }\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -57,7 +85,7 @@ pub const fn is_page_aligned(p: usize) -> bool {\n \n /// Convert physical address to virtual address using offset, only available inside aster-frame\n pub(crate) fn paddr_to_vaddr(pa: usize) -> usize {\n-    pa + PHYS_OFFSET\n+    pa + PHYS_MEM_BASE_VADDR\n }\n \n /// Only available inside aster-frame\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -9,10 +9,9 @@ use spin::Once;\n \n use super::{paddr_to_vaddr, Paddr, Vaddr, VmAllocOptions};\n use crate::{\n-    arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry},\n-    config::{ENTRY_COUNT, PAGE_SIZE},\n+    arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry, NR_ENTRIES_PER_PAGE},\n     sync::SpinLock,\n-    vm::VmFrame,\n+    vm::{VmFrame, PAGE_SIZE},\n };\n \n pub trait PageTableFlagsTrait: Clone + Copy + Sized + Pod + Debug {\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -77,9 +76,9 @@ pub trait PageTableEntryTrait: Clone + Copy + Sized + Pod + Debug {\n \n     /// The index of the next PTE is determined based on the virtual address and the current level, and the level range is [1,5].\n     ///\n-    /// For example, in x86 we use the following expression to get the index (ENTRY_COUNT is 512):\n+    /// For example, in x86 we use the following expression to get the index (NR_ENTRIES_PER_PAGE is 512):\n     /// ```\n-    /// va >> (12 + 9 * (level - 1)) & (ENTRY_COUNT - 1)\n+    /// va >> (12 + 9 * (level - 1)) & (NR_ENTRIES_PER_PAGE - 1)\n     /// ```\n     ///\n     fn page_index(va: Vaddr, level: usize) -> usize;\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -395,7 +394,7 @@ impl<T: PageTableEntryTrait, M> PageTable<T, M> {\n     }\n }\n \n-/// Read `ENTRY_COUNT` of PageTableEntry from an address\n+/// Read `NR_ENTRIES_PER_PAGE` of PageTableEntry from an address\n ///\n /// # Safety\n ///\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -406,7 +405,7 @@ pub unsafe fn table_of<'a, T: PageTableEntryTrait>(pa: Paddr) -> Option<&'a mut\n         return None;\n     }\n     let ptr = super::paddr_to_vaddr(pa) as *mut _;\n-    Some(core::slice::from_raw_parts_mut(ptr, ENTRY_COUNT))\n+    Some(core::slice::from_raw_parts_mut(ptr, NR_ENTRIES_PER_PAGE))\n }\n \n /// translate a virtual address to physical address which cannot use offset to get physical address\ndiff --git a/framework/aster-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\n--- a/framework/aster-frame/src/vm/space.rs\n+++ b/framework/aster-frame/src/vm/space.rs\n@@ -5,7 +5,7 @@ use core::ops::Range;\n use bitflags::bitflags;\n \n use super::{is_page_aligned, MapArea, MemorySet, VmFrameVec, VmIo};\n-use crate::{arch::mm::PageTableFlags, config::PAGE_SIZE, prelude::*, sync::Mutex, Error};\n+use crate::{arch::mm::PageTableFlags, prelude::*, sync::Mutex, vm::PAGE_SIZE, Error};\n \n /// Virtual memory space.\n ///\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -14,9 +14,8 @@ pub(crate) use alloc::{\n pub(crate) use core::{any::Any, ffi::CStr, fmt::Debug};\n \n pub(crate) use aster_frame::{\n-    config::PAGE_SIZE,\n     sync::{Mutex, MutexGuard, RwLock, RwMutex, SpinLock, SpinLockGuard},\n-    vm::Vaddr,\n+    vm::{Vaddr, PAGE_SIZE},\n };\n pub(crate) use bitflags::bitflags;\n pub(crate) use int_to_c_enum::TryFromInt;\ndiff --git a/kernel/aster-nix/src/process/process_vm/mod.rs b/kernel/aster-nix/src/process/process_vm/mod.rs\n--- a/kernel/aster-nix/src/process/process_vm/mod.rs\n+++ b/kernel/aster-nix/src/process/process_vm/mod.rs\n@@ -14,30 +14,40 @@ use user_heap::UserHeap;\n use crate::vm::vmar::Vmar;\n \n /*\n-* The user vm space layout is look like below.\n-* |-----------------------|-------The highest user vm address\n-* |                       |\n-* |       Mmap Areas      |\n-* |                       |\n-* |                       |\n-* --------------------------------The init stack base\n-* |                       |\n-* | User Stack(Init Stack)|\n-* |                       |\n-* |         ||            |\n-* ----------||----------------------The user stack top, grows down\n-* |         \\/            |\n-* |                       |\n-* |     Unmapped Areas    |\n-* |                       |\n-* |         /\\            |\n-* ----------||---------------------The user heap top, grows up\n-* |         ||            |\n-* |                       |\n-* |        User Heap      |\n-* |                       |\n-* ----------------------------------The user heap base\n-*/\n+ * The user's virtual memory space layout looks like below.\n+ * TODO: The layout of the userheap does not match the current implementation,\n+ * And currently the initial program break is a fixed value.\n+ *\n+ *  (high address)\n+ *  +---------------------+ <------+ The top of Vmar, which is the highest address usable\n+ *  |                     |          Randomly padded pages\n+ *  +---------------------+ <------+ The base of the initial user stack\n+ *  | User stack          |\n+ *  |                     |\n+ *  +---------||----------+ <------+ The user stack limit, can be extended lower\n+ *  |         \\/          |\n+ *  | ...                 |\n+ *  |                     |\n+ *  | MMAP Spaces         |\n+ *  |                     |\n+ *  | ...                 |\n+ *  |         /\\          |\n+ *  +---------||----------+ <------+ The current program break\n+ *  | User heap           |\n+ *  |                     |\n+ *  +---------------------+ <------+ The original program break\n+ *  |                     |          Randomly padded pages\n+ *  +---------------------+ <------+ The end of the program's last segment\n+ *  |                     |\n+ *  | Loaded segments     |\n+ *  | .text, .data, .bss  |\n+ *  | , etc.              |\n+ *  |                     |\n+ *  +---------------------+ <------+ The bottom of Vmar at 0x1_0000\n+ *  |                     |          64 KiB unusable space\n+ *  +---------------------+\n+ *  (low address)\n+ */\n \n /// The virtual space usage.\n /// This struct is used to control brk and mmap now.\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -7,7 +7,7 @@\n use core::mem;\n \n use align_ext::AlignExt;\n-use aster_frame::vm::{VmIo, VmPerm};\n+use aster_frame::vm::{VmIo, VmPerm, MAX_USERSPACE_VADDR};\n use aster_rights::{Full, Rights};\n \n use super::{\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -20,15 +20,16 @@ use crate::{\n     vm::{perms::VmPerms, vmar::Vmar, vmo::VmoOptions},\n };\n \n-pub const INIT_STACK_BASE: Vaddr = 0x0000_0000_2000_0000;\n-pub const INIT_STACK_SIZE: usize = 0x1000 * 16; // 64KB\n+pub const INIT_STACK_SIZE: usize = 64 * 1024; // 64 KiB\n \n /*\n- * The initial stack of a process looks like below(This figure is from occlum):\n+ * Illustration of the virtual memory space containing the processes' init stack:\n  *\n- *\n- *  +---------------------+ <------+ Top of stack\n- *  |                     |          (high address)\n+ *  (high address)\n+ *  +---------------------+ <------+ Highest address\n+ *  |                     |          Random stack paddings\n+ *  +---------------------+ <------+ The base of stack (stack grows down)\n+ *  |                     |\n  *  | Null-terminated     |\n  *  | strings referenced  |\n  *  | by variables below  |\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -62,8 +63,10 @@ pub const INIT_STACK_SIZE: usize = 0x1000 * 16; // 64KB\n  *  +---------------------+\n  *  |                     |\n  *  |                     |\n- *  +                     +\n- *\n+ *  +---------------------+\n+ *  |                     |\n+ *  +---------------------+ <------+ User stack default rlimit\n+ *  (low address)\n  */\n pub struct InitStack {\n     /// The high address of init stack\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n--- a/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n+++ b/kernel/aster-nix/src/process/program_loader/elf/init_stack.rs\n@@ -93,9 +96,13 @@ impl InitStack {\n         }\n     }\n \n-    /// This function only work for first process\n     pub fn new_default_config(argv: Vec<CString>, envp: Vec<CString>) -> Self {\n-        let init_stack_top = INIT_STACK_BASE - PAGE_SIZE;\n+        let nr_pages_padding = {\n+            let mut random_nr_pages_padding: u8 = 0;\n+            getrandom::getrandom(random_nr_pages_padding.as_bytes_mut()).unwrap();\n+            random_nr_pages_padding as usize\n+        };\n+        let init_stack_top = MAX_USERSPACE_VADDR - PAGE_SIZE * nr_pages_padding;\n         let init_stack_size = INIT_STACK_SIZE;\n         InitStack::new(init_stack_top, init_stack_size, argv, envp)\n     }\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/aster-nix/src/vdso.rs\n--- a/kernel/aster-nix/src/vdso.rs\n+++ b/kernel/aster-nix/src/vdso.rs\n@@ -13,7 +13,10 @@\n \n use alloc::{boxed::Box, sync::Arc};\n \n-use aster_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n+use aster_frame::{\n+    sync::Mutex,\n+    vm::{VmIo, PAGE_SIZE},\n+};\n use aster_rights::Rights;\n use aster_time::Instant;\n use aster_util::coeff::Coeff;\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -11,7 +11,7 @@ pub mod vm_mapping;\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use aster_frame::vm::VmSpace;\n+use aster_frame::vm::{VmSpace, MAX_USERSPACE_VADDR};\n use aster_rights::Rights;\n \n use self::{\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -124,11 +124,8 @@ impl VmarInner {\n     }\n }\n \n-// FIXME: How to set the correct root vmar range?\n-// We should not include addr 0 here(is this right?), since the 0 addr means the null pointer.\n-// We should include addr 0x0040_0000, since non-pie executables typically are put on 0x0040_0000.\n-const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x0010_0000;\n-const ROOT_VMAR_HIGHEST_ADDR: Vaddr = 0x1000_0000_0000;\n+const ROOT_VMAR_LOWEST_ADDR: Vaddr = 0x001_0000; // 64 KiB is the Linux configurable default\n+const ROOT_VMAR_CAP_ADDR: Vaddr = MAX_USERSPACE_VADDR;\n \n impl Interval<usize> for Arc<Vmar_> {\n     fn range(&self) -> Range<usize> {\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -161,7 +158,7 @@ impl Vmar_ {\n \n     pub fn new_root() -> Arc<Self> {\n         let mut free_regions = BTreeMap::new();\n-        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_HIGHEST_ADDR);\n+        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\n         let vmar_inner = VmarInner {\n             is_destroyed: false,\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -169,7 +166,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        Vmar_::new(vmar_inner, VmSpace::new(), 0, ROOT_VMAR_HIGHEST_ADDR, None)\n+        Vmar_::new(vmar_inner, VmSpace::new(), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\n \n     fn is_root_vmar(&self) -> bool {\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/aster-nix/src/vm/vmar/mod.rs\n--- a/kernel/aster-nix/src/vm/vmar/mod.rs\n+++ b/kernel/aster-nix/src/vm/vmar/mod.rs\n@@ -279,7 +276,7 @@ impl Vmar_ {\n         inner.child_vmar_s.clear();\n         inner.vm_mappings.clear();\n         inner.free_regions.clear();\n-        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_HIGHEST_ADDR);\n+        let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         inner.free_regions.insert(root_region.start(), root_region);\n         Ok(())\n     }\ndiff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/aster-nix/src/vm/vmar/options.rs\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/aster-nix/src/vm/vmar/options.rs\n@@ -2,7 +2,7 @@\n \n //! Options for allocating child VMARs.\n \n-use aster_frame::{config::PAGE_SIZE, Error, Result};\n+use aster_frame::{vm::PAGE_SIZE, Error, Result};\n \n use super::Vmar;\n \ndiff --git a/kernel/comps/block/src/lib.rs b/kernel/comps/block/src/lib.rs\n--- a/kernel/comps/block/src/lib.rs\n+++ b/kernel/comps/block/src/lib.rs\n@@ -49,7 +49,7 @@ use self::{\n     prelude::*,\n };\n \n-pub const BLOCK_SIZE: usize = aster_frame::config::PAGE_SIZE;\n+pub const BLOCK_SIZE: usize = aster_frame::vm::PAGE_SIZE;\n pub const SECTOR_SIZE: usize = 512;\n \n pub trait BlockDevice: Send + Sync + Any + Debug {\ndiff --git a/kernel/comps/framebuffer/src/lib.rs b/kernel/comps/framebuffer/src/lib.rs\n--- a/kernel/comps/framebuffer/src/lib.rs\n+++ b/kernel/comps/framebuffer/src/lib.rs\n@@ -13,7 +13,12 @@ use core::{\n     ops::{Index, IndexMut},\n };\n \n-use aster_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n+use aster_frame::{\n+    boot,\n+    io_mem::IoMem,\n+    sync::SpinLock,\n+    vm::{VmIo, PAGE_SIZE},\n+};\n use component::{init_component, ComponentInitError};\n use font8x8::UnicodeFonts;\n use spin::Once;\ndiff --git a/kernel/comps/virtio/src/device/console/device.rs b/kernel/comps/virtio/src/device/console/device.rs\n--- a/kernel/comps/virtio/src/device/console/device.rs\n+++ b/kernel/comps/virtio/src/device/console/device.rs\n@@ -4,7 +4,7 @@ use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\n use core::hint::spin_loop;\n \n use aster_console::{AnyConsoleDevice, ConsoleCallback};\n-use aster_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame, vm::PAGE_SIZE};\n use aster_util::safe_ptr::SafePtr;\n use log::debug;\n \ndiff --git a/kernel/comps/virtio/src/transport/mmio/device.rs b/kernel/comps/virtio/src/transport/mmio/device.rs\n--- a/kernel/comps/virtio/src/transport/mmio/device.rs\n+++ b/kernel/comps/virtio/src/transport/mmio/device.rs\n@@ -8,12 +8,11 @@ use aster_frame::{\n         bus::MmioDevice,\n         device::{MmioCommonDevice, VirtioMmioVersion},\n     },\n-    config::PAGE_SIZE,\n     io_mem::IoMem,\n     offset_of,\n     sync::RwLock,\n     trap::IrqCallbackFunction,\n-    vm::DmaCoherent,\n+    vm::{DmaCoherent, PAGE_SIZE},\n };\n use aster_rights::{ReadOp, WriteOp};\n use aster_util::{field_ptr, safe_ptr::SafePtr};\n",
        "test_patch": "",
        "problem_statement": "[BUG] Uncaught panic happened in heap_allocator\nI run 416.gamess , one of spec CPU 2006 test items,  but a pacnic happened:\r\n\r\n```\r\n~ # ./gamess_base.amd64-m64-gcc41-nn < exam29.config \r\n[ERROR]: Uncaught panic!\r\npanicked at framework/aster-frame/src/vm/heap_allocator.rs:24:5:\r\nHeap allocation error, layout = Layout { size: 659468632, align: 1 (1 << 0) }\r\n```\r\nThis pacnic alse happened when I run 434.zeusmp.\r\nthe file of 434.zeusmp and 416.gamess: [https://github.com/skpupil/my_spec_test](url) \n",
        "hints_text": "We currently have only the ability to manage <4G of memory. And the default QEMU boot option gives a 2G memory. Maybe an allocation of 629MiB caused an OOM.\r\n\r\nRelated to #318 \n```rust\r\n    if segment_vmo_size > tail_padding_offset {\r\n        let buffer = vec![0u8; segment_vmo_size - tail_padding_offset];\r\n        segment_vmo.write_bytes(tail_padding_offset, &buffer)?;\r\n    }\r\n```\r\n\r\nThe troublemaker is found: the memsize of that segment is 629MiB. And we should do lazy zero out init rather than doing such a scary memset operation of vmo.\r\n\r\n```\r\n(gdb) bt\r\n#0  alloc::alloc::handle_alloc_error (layout=...) at src/alloc.rs:389\r\n#1  0xffffffff8904ba9e in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::allocate_in<u8, alloc::alloc::Global> (\r\n    capacity=659468632, init=alloc::raw_vec::AllocInit::Zeroed, alloc=...) at src/raw_vec.rs:204\r\n#2  0xffffffff88ed31e8 in alloc::raw_vec::RawVec<u8, alloc::alloc::Global>::with_capacity_zeroed_in<u8, alloc::alloc::Global> (capacity=659468632, alloc=...)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:153\r\n#3  0xffffffff88ece3f4 in alloc::vec::spec_from_elem::{impl#3}::from_elem<alloc::alloc::Global> (elem=0, n=659468632, \r\n    alloc=...)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:52\r\n#4  0xffffffff88ed190f in alloc::vec::from_elem<u8> (elem=0, n=659468632)\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2627\r\n#5  0xffffffff88b11985 in aster_nix::process::program_loader::elf::load_elf::init_segment_vmo (\r\n    program_header=0xffff80000c8d2d18, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:309\r\n#6  0xffffffff88b103cd in aster_nix::process::program_loader::elf::load_elf::map_segment_vmos (elf=0xffff800003dbd6d8, \r\n    root_vmar=0xffff80000c8df010, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:201\r\n#7  0xffffffff88b0faa0 in aster_nix::process::program_loader::elf::load_elf::init_and_map_vmos (\r\n    process_vm=0xffff80000c8df010, ldso=..., elf=0xffff800003dbd6d8, elf_file=0xffff80000c184810, argv=..., envp=..., \r\n    vdso_text_base=1064960) at src/process/program_loader/elf/load_elf.rs:123\r\n#8  0xffffffff88b0eece in aster_nix::process::program_loader::elf::load_elf::load_elf_to_vm (\r\n    process_vm=0xffff80000c8df010, file_header=..., elf_file=..., fs_resolver=0xffff80000c8cf910, argv=..., envp=..., \r\n    vdso_text_base=1064960) at src/process/program_loader/elf/load_elf.rs:55\r\n#9  0xffffffff88b0e212 in aster_nix::process::program_loader::load_program_to_vm (process_vm=0xffff80000c8df010, \r\n    elf_file=..., argv=..., envp=..., fs_resolver=0xffff80000c8cf910, recursion_limit=1)\r\n    at src/process/program_loader/mod.rs:89\r\n#10 0xffffffff88d11dc3 in aster_nix::syscall::execve::do_execve (elf_file=..., argv_ptr_ptr=268442568, \r\n    envp_ptr_ptr=268442632, context=0xffff800003dc09c0) at src/syscall/execve.rs:119\r\n#11 0xffffffff88d107b7 in aster_nix::syscall::execve::sys_execve (filename_ptr=268442504, argv_ptr_ptr=268442568, \r\n    envp_ptr_ptr=268442632, context=0xffff800003dc09c0) at src/syscall/execve.rs:36\r\n#12 0xffffffff88d0cd6e in aster_nix::syscall::syscall_dispatch (syscall_number=59, args=..., context=0xffff800003dc09c0)\r\n    at src/syscall/mod.rs:462\r\n#13 0xffffffff88d0c4dc in aster_nix::syscall::handle_syscall (context=0xffff800003dc09c0) at src/syscall/mod.rs:397\r\n#14 0xffffffff88d09fee in aster_nix::thread::task::handle_user_event (user_event=aster_frame::user::UserEvent::Syscall, \r\n    context=0xffff800003dc09c0) at src/thread/task.rs:71\r\n#15 0xffffffff88d09a6d in aster_nix::thread::task::create_new_user_task::user_task_entry () at src/thread/task.rs:37\r\n#16 0xffffffff88d3f8ce in core::ops::function::Fn::call<fn(), ()> ()\r\n    at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n#17 0xffffffff88fc6ad6 in alloc::boxed::{impl#49}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (self=0xffff80000c8cfe40, args=()) at /root/.rustup/toolchains/nightly-2024-01-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2029\r\n#18 0xffffffff88fac554 in aster_frame::task::task::{impl#3}::build::kernel_task_entry () at src/task/task.rs:259\r\n(gdb) f 6\r\n#6  0xffffffff88b103cd in aster_nix::process::program_loader::elf::load_elf::map_segment_vmos (elf=0xffff800003dbd6d8, \r\n    root_vmar=0xffff80000c8df010, elf_file=0xffff80000c184810) at src/process/program_loader/elf/load_elf.rs:201\r\n201                 let vmo = init_segment_vmo(program_header, elf_file)?;\r\n(gdb) p *program_header\r\n$3 = xmas_elf::program::ProgramHeader64 {type_: xmas_elf::program::Type_ (1), flags: xmas_elf::program::Flags (6), offset: 8596504, virtual_addr: 8600600, physical_addr: 8600600, file_size: 66192, mem_size: 659531104, align: 4096}\r\n```",
        "created_at": "2024-03-13T06:03:51Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 395,
        "instance_id": "asterinas__asterinas-395",
        "issue_numbers": [
            "254"
        ],
        "base_commit": "576578baf4025686ae4c2893c2aafbc8d1e14722",
        "patch": "diff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -12,6 +12,8 @@ pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \n+use self::tty::get_n_tty;\n+\n /// Init the device node in fs, must be called after mounting rootfs.\n pub fn init() -> Result<()> {\n     let null = Arc::new(null::Null);\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -19,7 +21,9 @@ pub fn init() -> Result<()> {\n     let zero = Arc::new(zero::Zero);\n     add_node(zero, \"zero\")?;\n     tty::init();\n-    let tty = tty::get_n_tty().clone();\n+    let console = get_n_tty().clone();\n+    add_node(console, \"console\")?;\n+    let tty = Arc::new(tty::TtyDevice);\n     add_node(tty, \"tty\")?;\n     let random = Arc::new(random::Random);\n     add_node(random, \"random\")?;\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Null;\n \ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -12,7 +15,9 @@ impl Device for Null {\n         // Same value with Linux\n         DeviceId::new(1, 3)\n     }\n+}\n \n+impl FileIo for Null {\n     fn read(&self, _buf: &mut [u8]) -> Result<usize> {\n         Ok(0)\n     }\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -20,4 +25,9 @@ impl Device for Null {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/jinux-std/src/device/pty/mod.rs\n--- a/services/libs/jinux-std/src/device/pty/mod.rs\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -33,7 +33,7 @@ pub fn init() -> Result<()> {\n \n pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n     debug!(\"pty index = {}\", index);\n-    let master = Arc::new(PtyMaster::new(ptmx, index));\n-    let slave = Arc::new(PtySlave::new(master.clone()));\n+    let master = PtyMaster::new(ptmx, index);\n+    let slave = PtySlave::new(&master);\n     Ok((master, slave))\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -2,16 +2,18 @@ use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \n use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::device::tty::new_job_control_and_ldisc;\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n-use crate::fs::file_handle::FileLike;\n+use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::FsPath;\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::{AccessMode, Inode, InodeMode, IoctlCmd};\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n+use crate::process::{JobControl, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n-const PTS_DIR: &str = \"/dev/pts\";\n const BUFFER_CAPACITY: usize = 4096;\n \n /// Pesudo terminal master.\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -23,19 +25,24 @@ pub struct PtyMaster {\n     index: u32,\n     output: Arc<LineDiscipline>,\n     input: SpinLock<HeapRb<u8>>,\n+    job_control: Arc<JobControl>,\n     /// The state of input buffer\n     pollee: Pollee,\n+    weak_self: Weak<Self>,\n }\n \n impl PtyMaster {\n-    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n-        Self {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| PtyMaster {\n             ptmx,\n             index,\n-            output: LineDiscipline::new(),\n+            output: ldisc,\n             input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            job_control,\n             pollee: Pollee::new(IoEvents::OUT),\n-        }\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -46,16 +53,12 @@ impl PtyMaster {\n         &self.ptmx\n     }\n \n-    pub(super) fn slave_push_byte(&self, byte: u8) {\n+    pub(super) fn slave_push_char(&self, ch: u8) {\n         let mut input = self.input.lock_irq_disabled();\n-        input.push_overwrite(byte);\n+        input.push_overwrite(ch);\n         self.update_state(&input);\n     }\n \n-    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.output.read(buf)\n-    }\n-\n     pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         let mut poll_status = IoEvents::empty();\n \ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -87,7 +90,7 @@ impl PtyMaster {\n     }\n }\n \n-impl FileLike for PtyMaster {\n+impl FileIo for PtyMaster {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         // TODO: deal with nonblocking read\n         if buf.is_empty() {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -122,7 +125,6 @@ impl FileLike for PtyMaster {\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut input = self.input.lock();\n-\n         for character in buf {\n             self.output.push_char(*character, |content| {\n                 for byte in content.as_bytes() {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -193,29 +195,35 @@ impl FileLike for PtyMaster {\n                 self.output.set_window_size(winsize);\n                 Ok(0)\n             }\n-            IoctlCmd::TIOCSCTTY => {\n-                // TODO: reimplement when adding session.\n-                let foreground = {\n-                    let current = current!();\n-                    let process_group = current.process_group().unwrap();\n-                    Arc::downgrade(&process_group)\n-                };\n-                self.output.set_fg(foreground);\n-                Ok(0)\n-            }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                let Some(foreground) = self.foreground() else {\n                     return_errno_with_message!(\n                         Errno::ESRCH,\n                         \"the foreground process group does not exist\"\n                     );\n                 };\n+                let fg_pgid = foreground.pgid();\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO: reimplement when adding session.\n-                self.output.set_fg(Weak::new());\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -246,15 +254,47 @@ impl FileLike for PtyMaster {\n     }\n }\n \n-pub struct PtySlave(Arc<PtyMaster>);\n+impl Terminal for PtyMaster {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Drop for PtyMaster {\n+    fn drop(&mut self) {\n+        let fs = self.ptmx.fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.index;\n+        devpts.remove_slave(index);\n+    }\n+}\n+\n+pub struct PtySlave {\n+    master: Weak<PtyMaster>,\n+    job_control: JobControl,\n+    weak_self: Weak<Self>,\n+}\n \n impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Self {\n-        PtySlave(master)\n+    pub fn new(master: &Arc<PtyMaster>) -> Arc<Self> {\n+        Arc::new_cyclic(|weak_ref| PtySlave {\n+            master: Arc::downgrade(master),\n+            job_control: JobControl::new(),\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n-        self.0.index()\n+        self.master().index()\n+    }\n+\n+    fn master(&self) -> Arc<PtyMaster> {\n+        self.master.upgrade().unwrap()\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -266,50 +306,91 @@ impl Device for PtySlave {\n     fn id(&self) -> crate::fs::device::DeviceId {\n         DeviceId::new(88, self.index())\n     }\n+}\n \n+impl Terminal for PtySlave {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl FileIo for PtySlave {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.0.slave_read(buf)\n+        self.job_control.wait_until_in_foreground()?;\n+        self.master().output.read(buf)\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let master = self.master();\n         for ch in buf {\n             // do we need to add '\\r' here?\n             if *ch == b'\\n' {\n-                self.0.slave_push_byte(b'\\r');\n-                self.0.slave_push_byte(b'\\n');\n+                master.slave_push_char(b'\\r');\n+                master.slave_push_char(b'\\n');\n             } else {\n-                self.0.slave_push_byte(*ch);\n+                master.slave_push_char(*ch);\n             }\n         }\n         Ok(buf.len())\n     }\n \n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.master().slave_poll(mask, poller)\n+    }\n+\n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n         match cmd {\n             IoctlCmd::TCGETS\n             | IoctlCmd::TCSETS\n-            | IoctlCmd::TIOCGPGRP\n             | IoctlCmd::TIOCGPTN\n             | IoctlCmd::TIOCGWINSZ\n-            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            | IoctlCmd::TIOCSWINSZ => self.master().ioctl(cmd, arg),\n+            IoctlCmd::TIOCGPGRP => {\n+                if !self.is_controlling_terminal() {\n+                    return_errno_with_message!(Errno::ENOTTY, \"slave is not controlling terminal\");\n+                }\n+\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+\n+                let fg_pgid = foreground.pgid();\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCSCTTY => {\n-                // TODO:\n+                self.set_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO:\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n-                let buffer_len = self.0.slave_buf_len() as i32;\n+                let buffer_len = self.master().slave_buf_len() as i32;\n                 write_val_to_user(arg, &buffer_len)?;\n                 Ok(0)\n             }\n             _ => Ok(0),\n         }\n     }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.slave_poll(mask, poller)\n-    }\n }\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Random;\n \ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -19,7 +22,9 @@ impl Device for Random {\n         // The same value as Linux\n         DeviceId::new(1, 8)\n     }\n+}\n \n+impl FileIo for Random {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -27,6 +32,11 @@ impl Device for Random {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n \n impl From<getrandom::Error> for Error {\ndiff --git /dev/null b/services/libs/jinux-std/src/device/tty/device.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/tty/device.rs\n@@ -0,0 +1,47 @@\n+use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::signal::Poller;\n+\n+/// Corresponds to `/dev/tty` in the file system. This device represents the controlling terminal\n+/// of the session of current process.\n+pub struct TtyDevice;\n+\n+impl Device for TtyDevice {\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let current = current!();\n+        let session = current.session().unwrap();\n+\n+        let Some(terminal) = session.terminal() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the session does not have controlling terminal\"\n+            );\n+        };\n+\n+        Ok(Some(terminal as Arc<dyn FileIo>))\n+    }\n+\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        DeviceId::new(5, 0)\n+    }\n+}\n+\n+impl FileIo for TtyDevice {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read tty device\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write tty device\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -1,13 +1,10 @@\n use crate::events::IoEvents;\n+use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::{Pollee, Poller};\n-use crate::process::ProcessGroup;\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n-use crate::{\n-    prelude::*,\n-    process::{signal::signals::kernel::KernelSignal, Pgid},\n-};\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -19,19 +16,21 @@ use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n const BUFFER_CAPACITY: usize = 4096;\n \n+pub type LdiscSignalSender = Arc<dyn Fn(KernelSignal) + Send + Sync + 'static>;\n+\n pub struct LineDiscipline {\n     /// current line\n     current_line: SpinLock<CurrentLine>,\n     /// The read buffer\n     read_buffer: SpinLock<StaticRb<u8, BUFFER_CAPACITY>>,\n-    /// The foreground process group\n-    foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n     /// Windows size,\n     winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n+    /// Used to send signal for foreground processes, when some char comes.\n+    send_signal: LdiscSignalSender,\n     /// work item\n     work_item: Arc<WorkItem>,\n     /// Parameters used by a work item.\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -76,8 +75,8 @@ impl CurrentLine {\n \n impl LineDiscipline {\n     /// Create a new line discipline\n-    pub fn new() -> Arc<Self> {\n-        Arc::new_cyclic(|line_ref: &Weak<LineDiscipline>| {\n+    pub fn new(send_signal: LdiscSignalSender) -> Arc<Self> {\n+        Arc::new_cyclic(move |line_ref: &Weak<LineDiscipline>| {\n             let line_discipline = line_ref.clone();\n             let work_item = Arc::new(WorkItem::new(Box::new(move || {\n                 if let Some(line_discipline) = line_discipline.upgrade() {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -87,10 +86,10 @@ impl LineDiscipline {\n             Self {\n                 current_line: SpinLock::new(CurrentLine::new()),\n                 read_buffer: SpinLock::new(StaticRb::default()),\n-                foreground: SpinLock::new(Weak::new()),\n                 termios: SpinLock::new(KernelTermios::default()),\n                 winsize: SpinLock::new(WinSize::default()),\n                 pollee: Pollee::new(IoEvents::empty()),\n+                send_signal,\n                 work_item,\n                 work_item_para: Arc::new(SpinLock::new(LineDisciplineWorkPara::new())),\n             }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -98,7 +97,7 @@ impl LineDiscipline {\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char<F: FnMut(&str)>(&self, ch: u8, echo_callback: F) {\n+    pub fn push_char<F2: FnMut(&str)>(&self, ch: u8, echo_callback: F2) {\n         let termios = self.termios.lock_irq_disabled();\n \n         let ch = if termios.contains_icrnl() && ch == b'\\r' {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -107,7 +106,7 @@ impl LineDiscipline {\n             ch\n         };\n \n-        if self.may_send_signal_to_foreground(&termios, ch) {\n+        if self.may_send_signal(&termios, ch) {\n             // The char is already dealt with, so just return\n             return;\n         }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -158,22 +157,14 @@ impl LineDiscipline {\n         self.update_readable_state_deferred();\n     }\n \n-    fn may_send_signal_to_foreground(&self, termios: &KernelTermios, ch: u8) -> bool {\n-        if !termios.contains_isig() {\n+    fn may_send_signal(&self, termios: &KernelTermios, ch: u8) -> bool {\n+        if !termios.is_canonical_mode() || !termios.contains_isig() {\n             return false;\n         }\n \n-        let Some(foreground) = self.foreground.lock().upgrade() else {\n-            return false;\n-        };\n-\n         let signal = match ch {\n-            item if item == *termios.get_special_char(CC_C_CHAR::VINTR) => {\n-                KernelSignal::new(SIGINT)\n-            }\n-            item if item == *termios.get_special_char(CC_C_CHAR::VQUIT) => {\n-                KernelSignal::new(SIGQUIT)\n-            }\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VINTR) => KernelSignal::new(SIGINT),\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VQUIT) => KernelSignal::new(SIGQUIT),\n             _ => return false,\n         };\n         // `kernel_signal()` may cause sleep, so only construct parameters here.\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -182,7 +173,7 @@ impl LineDiscipline {\n         true\n     }\n \n-    fn update_readable_state(&self) {\n+    pub fn update_readable_state(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n         if !buffer.is_empty() {\n             self.pollee.add_events(IoEvents::IN);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -193,7 +184,6 @@ impl LineDiscipline {\n \n     fn update_readable_state_deferred(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n-        let pollee = self.pollee.clone();\n         // add/del events may sleep, so only construct parameters here.\n         if !buffer.is_empty() {\n             self.work_item_para.lock_irq_disabled().pollee_type = Some(PolleeType::Add);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -206,11 +196,7 @@ impl LineDiscipline {\n     /// include all operations that may cause sleep, and processes by a work queue.\n     fn update_readable_state_after(&self) {\n         if let Some(signal) = self.work_item_para.lock_irq_disabled().kernel_signal.take() {\n-            self.foreground\n-                .lock()\n-                .upgrade()\n-                .unwrap()\n-                .kernel_signal(signal)\n+            (self.send_signal)(signal);\n         };\n         if let Some(pollee_type) = self.work_item_para.lock_irq_disabled().pollee_type.take() {\n             match pollee_type {\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -243,42 +229,24 @@ impl LineDiscipline {\n         }\n     }\n \n-    /// read all bytes buffered to dst, return the actual read length.\n-    pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let mut poller = None;\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         loop {\n-            let res = self.try_read(dst);\n+            let res = self.try_read(buf);\n             match res {\n-                Ok(read_len) => {\n-                    return Ok(read_len);\n-                }\n-                Err(e) => {\n-                    if e.error() != Errno::EAGAIN {\n-                        return Err(e);\n+                Ok(len) => return Ok(len),\n+                Err(e) if e.error() != Errno::EAGAIN => return Err(e),\n+                Err(_) => {\n+                    let poller = Some(Poller::new());\n+                    if self.poll(IoEvents::IN, poller.as_ref()).is_empty() {\n+                        poller.as_ref().unwrap().wait()?\n                     }\n                 }\n             }\n-\n-            // Wait for read event\n-            let need_poller = if poller.is_none() {\n-                poller = Some(Poller::new());\n-                poller.as_ref()\n-            } else {\n-                None\n-            };\n-            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n-            if revents.is_empty() {\n-                // FIXME: deal with ldisc read timeout\n-                poller.as_ref().unwrap().wait()?;\n-            }\n         }\n     }\n \n-    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n-        if !self.current_can_read() {\n-            return_errno!(Errno::EAGAIN);\n-        }\n-\n+    /// read all bytes buffered to dst, return the actual read length.\n+    fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n         let (vmin, vtime) = {\n             let termios = self.termios.lock_irq_disabled();\n             let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -326,7 +294,8 @@ impl LineDiscipline {\n                 if termios.is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if is_line_terminator(next_char, &termios) {\n-                        if !should_not_be_read(next_char, &termios) {\n+                        // The eof should not be read\n+                        if !is_eof(next_char, &termios) {\n                             *dst_i = next_char;\n                             read_len += 1;\n                         }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -368,31 +337,6 @@ impl LineDiscipline {\n         todo!()\n     }\n \n-    /// Determine whether current process can read the line discipline. If current belongs to the foreground process group.\n-    /// or the foreground process group is None, returns true.\n-    fn current_can_read(&self) -> bool {\n-        let current = current!();\n-        let Some(foreground) = self.foreground.lock_irq_disabled().upgrade() else {\n-            return true;\n-        };\n-        foreground.contains_process(current.pid())\n-    }\n-\n-    /// set foreground process group\n-    pub fn set_fg(&self, foreground: Weak<ProcessGroup>) {\n-        *self.foreground.lock_irq_disabled() = foreground;\n-        // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n-        self.update_readable_state();\n-    }\n-\n-    /// get foreground process group id\n-    pub fn fg_pgid(&self) -> Option<Pgid> {\n-        self.foreground\n-            .lock_irq_disabled()\n-            .upgrade()\n-            .map(|foreground| foreground.pgid())\n-    }\n-\n     /// whether there is buffered data\n     pub fn is_empty(&self) -> bool {\n         self.read_buffer.lock_irq_disabled().len() == 0\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -439,8 +383,7 @@ fn is_line_terminator(item: u8, termios: &KernelTermios) -> bool {\n     false\n }\n \n-/// The special char should not be read by reading process\n-fn should_not_be_read(ch: u8, termios: &KernelTermios) -> bool {\n+fn is_eof(ch: u8, termios: &KernelTermios) -> bool {\n     ch == *termios.get_special_char(CC_C_CHAR::VEOF)\n }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -467,6 +410,7 @@ enum PolleeType {\n }\n \n struct LineDisciplineWorkPara {\n+    #[allow(clippy::type_complexity)]\n     kernel_signal: Option<KernelSignal>,\n     pollee_type: Option<PolleeType>,\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -2,23 +2,28 @@ use spin::Once;\n \n use self::driver::TtyDriver;\n use self::line_discipline::LineDiscipline;\n-use super::*;\n use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::IoctlCmd;\n use crate::prelude::*;\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::Poller;\n-use crate::process::{process_table, ProcessGroup};\n+use crate::process::{JobControl, Process, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n+mod device;\n pub mod driver;\n pub mod line_discipline;\n pub mod termio;\n \n+pub use device::TtyDevice;\n+\n static N_TTY: Once<Arc<Tty>> = Once::new();\n \n pub(super) fn init() {\n     let name = CString::new(\"console\").unwrap();\n-    let tty = Arc::new(Tty::new(name));\n+    let tty = Tty::new(name);\n     N_TTY.call_once(|| tty);\n     driver::init();\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -28,44 +33,36 @@ pub struct Tty {\n     name: CString,\n     /// line discipline\n     ldisc: Arc<LineDiscipline>,\n+    job_control: Arc<JobControl>,\n     /// driver\n     driver: SpinLock<Weak<TtyDriver>>,\n+    weak_self: Weak<Self>,\n }\n \n impl Tty {\n-    pub fn new(name: CString) -> Self {\n-        Tty {\n+    pub fn new(name: CString) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| Tty {\n             name,\n-            ldisc: LineDiscipline::new(),\n+            ldisc,\n+            job_control,\n             driver: SpinLock::new(Weak::new()),\n-        }\n-    }\n-\n-    /// Set foreground process group\n-    pub fn set_fg(&self, process_group: Weak<ProcessGroup>) {\n-        self.ldisc.set_fg(process_group);\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn set_driver(&self, driver: Weak<TtyDriver>) {\n         *self.driver.lock_irq_disabled() = driver;\n     }\n \n-    pub fn receive_char(&self, item: u8) {\n-        self.ldisc.push_char(item, |content| print!(\"{}\", content));\n+    pub fn receive_char(&self, ch: u8) {\n+        self.ldisc.push_char(ch, |content| print!(\"{}\", content));\n     }\n }\n \n-impl Device for Tty {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        // Same value with Linux\n-        DeviceId::new(5, 0)\n-    }\n-\n+impl FileIo for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.job_control.wait_until_in_foreground()?;\n         self.ldisc.read(buf)\n     }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -92,23 +89,28 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.ldisc.fg_pgid() else {\n-                    return_errno_with_message!(Errno::ENOENT, \"No fg process group\")\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(Errno::ESRCH, \"No fg process group\")\n                 };\n+                let fg_pgid = foreground.pgid();\n                 debug!(\"fg_pgid = {}\", fg_pgid);\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCSPGRP => {\n                 // Set the process group id of fg progress group\n-                let pgid = read_val_from_user::<i32>(arg)?;\n-                if pgid < 0 {\n-                    return_errno_with_message!(Errno::EINVAL, \"invalid pgid\");\n-                }\n-                match process_table::pgid_to_process_group(pgid as u32) {\n-                    None => self.ldisc.set_fg(Weak::new()),\n-                    Some(process_group) => self.ldisc.set_fg(Arc::downgrade(&process_group)),\n-                }\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                // Some background processes may be waiting on the wait queue,\n+                // when set_fg, the background processes may be able to read.\n+                self.ldisc.update_readable_state();\n                 Ok(0)\n             }\n             IoctlCmd::TCSETS => {\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -143,12 +145,73 @@ impl Device for Tty {\n                 self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             _ => todo!(),\n         }\n     }\n }\n \n-/// FIXME: should we maintain a static console?\n+impl Terminal for Tty {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Device for Tty {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        // The same value as /dev/console in linux.\n+        DeviceId::new(88, 0)\n+    }\n+}\n+\n+pub fn new_job_control_and_ldisc() -> (Arc<JobControl>, Arc<LineDiscipline>) {\n+    let job_control = Arc::new(JobControl::new());\n+\n+    let send_signal = {\n+        let cloned_job_control = job_control.clone();\n+        move |signal: KernelSignal| {\n+            let Some(foreground) = cloned_job_control.foreground() else {\n+                return;\n+            };\n+\n+            foreground.broadcast_signal(signal);\n+        }\n+    };\n+\n+    let ldisc = LineDiscipline::new(Arc::new(send_signal));\n+\n+    (job_control, ldisc)\n+}\n+\n pub fn get_n_tty() -> &'static Arc<Tty> {\n     N_TTY.get().unwrap()\n }\n+\n+/// Open `N_TTY` as the controlling terminal for the process. This method should\n+/// only be called when creating the init process.\n+pub fn open_ntty_as_controlling_terminal(process: &Process) -> Result<()> {\n+    let tty = get_n_tty();\n+\n+    let session = &process.session().unwrap();\n+    let process_group = process.process_group().unwrap();\n+\n+    session.set_terminal(|| {\n+        tty.job_control.set_session(session);\n+        Ok(tty.clone())\n+    })?;\n+\n+    tty.job_control.set_foreground(Some(&process_group))?;\n+\n+    Ok(())\n+}\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Urandom;\n \ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -19,7 +22,9 @@ impl Device for Urandom {\n         // The same value as Linux\n         DeviceId::new(1, 9)\n     }\n+}\n \n+impl FileIo for Urandom {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -27,4 +32,9 @@ impl Device for Urandom {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Zero;\n \ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -12,7 +15,9 @@ impl Device for Zero {\n         // Same value with Linux\n         DeviceId::new(1, 5)\n     }\n+}\n \n+impl FileIo for Zero {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         for byte in buf.iter_mut() {\n             *byte = 0;\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -23,4 +28,9 @@ impl Device for Zero {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/device.rs b/services/libs/jinux-std/src/fs/device.rs\n--- a/services/libs/jinux-std/src/fs/device.rs\n+++ b/services/libs/jinux-std/src/fs/device.rs\n@@ -1,33 +1,21 @@\n-use crate::events::IoEvents;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n-use crate::fs::utils::{InodeMode, InodeType, IoctlCmd};\n+use crate::fs::utils::{InodeMode, InodeType};\n use crate::prelude::*;\n-use crate::process::signal::Poller;\n+\n+use super::inode_handle::FileIo;\n \n /// The abstract of device\n-pub trait Device: Sync + Send {\n+pub trait Device: Sync + Send + FileIo {\n     /// Return the device type.\n     fn type_(&self) -> DeviceType;\n \n     /// Return the device ID.\n     fn id(&self) -> DeviceId;\n \n-    /// Read from the device.\n-    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n-\n-    /// Write to the device.\n-    fn write(&self, buf: &[u8]) -> Result<usize>;\n-\n-    /// Poll on the device.\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        let events = IoEvents::IN | IoEvents::OUT;\n-        events & mask\n-    }\n-\n-    /// Ioctl on the device.\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    /// Open a device.\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        Ok(None)\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-use crate::events::IoEvents;\n-use crate::fs::file_handle::FileLike;\n-use crate::prelude::*;\n-use crate::process::signal::Poller;\n-\n-use super::*;\n-\n-use crate::device::PtyMaster;\n-\n-/// Pty master inode for the master device.\n-pub struct PtyMasterInode(Arc<PtyMaster>);\n-\n-impl PtyMasterInode {\n-    pub fn new(device: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self(device))\n-    }\n-}\n-\n-impl Drop for PtyMasterInode {\n-    fn drop(&mut self) {\n-        // Remove the slave from fs.\n-        let fs = self.0.ptmx().fs();\n-        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n-\n-        let index = self.0.index();\n-        devpts.remove_slave(index);\n-    }\n-}\n-\n-impl Inode for PtyMasterInode {\n-    /// Do not cache dentry in DCACHE.\n-    ///\n-    /// Each file descriptor obtained by opening \"/dev/ptmx\" is an independent pty master\n-    /// with its own associated pty slave.\n-    fn is_dentry_cacheable(&self) -> bool {\n-        false\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.0.ptmx().metadata().size\n-    }\n-\n-    fn resize(&self, new_size: usize) {}\n-\n-    fn metadata(&self) -> Metadata {\n-        self.0.ptmx().metadata()\n-    }\n-\n-    fn type_(&self) -> InodeType {\n-        self.0.ptmx().metadata().type_\n-    }\n-\n-    fn mode(&self) -> InodeMode {\n-        self.0.ptmx().metadata().mode\n-    }\n-\n-    fn set_mode(&self, mode: InodeMode) {}\n-\n-    fn atime(&self) -> Duration {\n-        self.0.ptmx().metadata().atime\n-    }\n-\n-    fn set_atime(&self, time: Duration) {}\n-\n-    fn mtime(&self) -> Duration {\n-        self.0.ptmx().metadata().mtime\n-    }\n-\n-    fn set_mtime(&self, time: Duration) {}\n-\n-    fn read_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn write_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_direct_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn write_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_direct_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.0.ioctl(cmd, arg)\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.poll(mask, poller)\n-    }\n-\n-    fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().fs()\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,4 @@\n+use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\n     DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,11 +10,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\n \n-mod master;\n mod ptmx;\n mod slave;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -52,7 +51,7 @@ impl DevPts {\n     }\n \n     /// Create the master and slave pair.\n-    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMasterInode>, Arc<PtySlaveInode>)> {\n+    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMaster>, Arc<PtySlaveInode>)> {\n         let index = self\n             .index_alloc\n             .lock()\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -61,17 +60,16 @@ impl DevPts {\n \n         let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n-        let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\n         self.root.add_slave(index.to_string(), slave_inode.clone());\n \n-        Ok((master_inode, slave_inode))\n+        Ok((master, slave_inode))\n     }\n \n     /// Remove the slave from fs.\n     ///\n     /// This is called when the master is being dropped.\n-    fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n+    pub fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n         let removed_slave = self.root.remove_slave(&index.to_string());\n         if removed_slave.is_some() {\n             self.index_alloc.lock().free(index as usize);\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -241,7 +239,7 @@ impl Inode for RootInode {\n         let inode = match name {\n             \".\" | \"..\" => self.fs().root_inode(),\n             // Call the \"open\" method of ptmx to create a master and slave pair.\n-            \"ptmx\" => self.ptmx.open()?,\n+            \"ptmx\" => self.ptmx.clone(),\n             slave => self\n                 .slaves\n                 .read()\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -1,4 +1,8 @@\n+use crate::device::PtyMaster;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -14,12 +18,14 @@ const PTMX_MINOR_NUM: u32 = 2;\n pub struct Ptmx {\n     inner: Inner,\n     metadata: Metadata,\n-    fs: Weak<DevPts>,\n }\n \n+#[derive(Clone)]\n+struct Inner(Weak<DevPts>);\n+\n impl Ptmx {\n     pub fn new(sb: &SuperBlock, fs: Weak<DevPts>) -> Arc<Self> {\n-        let inner = Inner;\n+        let inner = Inner(fs);\n         Arc::new(Self {\n             metadata: Metadata::new_device(\n                 PTMX_INO,\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -28,20 +34,19 @@ impl Ptmx {\n                 &inner,\n             ),\n             inner,\n-            fs,\n         })\n     }\n \n     /// The open method for ptmx.\n     ///\n     /// Creates a master and slave pair and returns the master inode.\n-    pub fn open(&self) -> Result<Arc<PtyMasterInode>> {\n+    pub fn open(&self) -> Result<Arc<PtyMaster>> {\n         let (master, _) = self.devpts().create_master_slave_pair()?;\n         Ok(master)\n     }\n \n     pub fn devpts(&self) -> Arc<DevPts> {\n-        self.fs.upgrade().unwrap()\n+        self.inner.0.upgrade().unwrap()\n     }\n \n     pub fn device_type(&self) -> DeviceType {\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -119,9 +124,11 @@ impl Inode for Ptmx {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.devpts()\n     }\n-}\n \n-struct Inner;\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(Arc::new(self.inner.clone()))\n+    }\n+}\n \n impl Device for Inner {\n     fn type_(&self) -> DeviceType {\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -132,13 +139,23 @@ impl Device for Inner {\n         DeviceId::new(PTMX_MAJOR_NUM, PTMX_MINOR_NUM)\n     }\n \n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let devpts = self.0.upgrade().unwrap();\n+        let (master, _) = devpts.create_master_slave_pair()?;\n+        Ok(Some(master as _))\n+    }\n+}\n+\n+impl FileIo for Inner {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        // do nothing because it should not be used to read.\n-        Ok(0)\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read ptmx\");\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n-        // do nothing because it should not be used to write.\n-        Ok(buf.len())\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write ptmx\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -1,4 +1,5 @@\n use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -107,4 +108,8 @@ impl Inode for PtySlaveInode {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.fs.upgrade().unwrap()\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(self.device.clone())\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -1,6 +1,7 @@\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\n+use crate::fs::device::Device;\n use crate::fs::utils::{AccessMode, IoctlCmd, Metadata, SeekFrom, StatusFlags};\n use crate::net::socket::Socket;\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -73,6 +74,10 @@ pub trait FileLike: Send + Sync + Any {\n     fn as_socket(&self) -> Option<&dyn Socket> {\n         None\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n }\n \n impl dyn FileLike {\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -27,7 +27,7 @@ impl FileTable {\n     pub fn new_with_stdio() -> Self {\n         let mut table = SlotVec::new();\n         let fs_resolver = FsResolver::new();\n-        let tty_path = FsPath::new(AT_FDCWD, \"/dev/tty\").expect(\"cannot find tty\");\n+        let tty_path = FsPath::new(AT_FDCWD, \"/dev/console\").expect(\"cannot find tty\");\n         let stdin = {\n             let flags = AccessMode::O_RDONLY as u32;\n             let mode = InodeMode::S_IRUSR;\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -21,8 +21,16 @@ impl InodeHandle<Rights> {\n         if access_mode.is_writable() && inode.type_() == InodeType::Dir {\n             return_errno_with_message!(Errno::EISDIR, \"Directory cannot open to write\");\n         }\n+\n+        let file_io = if let Some(device) = inode.as_device() {\n+            device.open()?\n+        } else {\n+            None\n+        };\n+\n         let inner = Arc::new(InodeHandle_ {\n             dentry,\n+            file_io,\n             offset: Mutex::new(0),\n             access_mode,\n             status_flags: AtomicU32::new(status_flags.bits()),\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -42,6 +50,7 @@ impl InodeHandle<Rights> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n         }\n+\n         self.0.read_to_end(buf)\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -75,11 +84,11 @@ impl FileLike for InodeHandle<Rights> {\n     }\n \n     fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.dentry().inode().poll(mask, poller)\n+        self.0.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.dentry().inode().ioctl(cmd, arg)\n+        self.0.ioctl(cmd, arg)\n     }\n \n     fn metadata(&self) -> Metadata {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -107,4 +116,8 @@ impl FileLike for InodeHandle<Rights> {\n         // Close does not guarantee that the data has been successfully saved to disk.\n         Ok(())\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.dentry().inode().as_device()\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -5,11 +5,14 @@ mod static_cap;\n \n use core::sync::atomic::{AtomicU32, Ordering};\n \n+use crate::events::IoEvents;\n+use crate::fs::device::Device;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::{\n     AccessMode, Dentry, DirentVisitor, InodeType, IoctlCmd, Metadata, SeekFrom, StatusFlags,\n };\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n use jinux_rights::Rights;\n \n #[derive(Debug)]\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -17,6 +20,10 @@ pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\n \n struct InodeHandle_ {\n     dentry: Arc<Dentry>,\n+    /// `file_io` is Similar to `file_private` field in `file` structure in linux. If\n+    /// `file_io` is Some, typical file operations including `read`, `write`, `poll`,\n+    /// `ioctl` will be provided by `file_io`, instead of `dentry`.\n+    file_io: Option<Arc<dyn FileIo>>,\n     offset: Mutex<usize>,\n     access_mode: AccessMode,\n     status_flags: AtomicU32,\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -25,6 +32,11 @@ struct InodeHandle_ {\n impl InodeHandle_ {\n     pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.read(buf);\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_at(*offset, buf)?\n         } else {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -37,6 +49,11 @@ impl InodeHandle_ {\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.write(buf);\n+        }\n+\n         if self.status_flags().contains(StatusFlags::O_APPEND) {\n             *offset = self.dentry.inode_len();\n         }\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -51,6 +68,10 @@ impl InodeHandle_ {\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        if self.file_io.is_some() {\n+            return_errno_with_message!(Errno::EINVAL, \"file io does not support read to end\");\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_to_end(buf)?\n         } else {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -117,6 +138,22 @@ impl InodeHandle_ {\n         *offset += read_cnt;\n         Ok(read_cnt)\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.poll(mask, poller);\n+        }\n+\n+        self.dentry.inode().poll(mask, poller)\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.ioctl(cmd, arg);\n+        }\n+\n+        self.dentry.inode().ioctl(cmd, arg)\n+    }\n }\n \n impl Debug for InodeHandle_ {\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -136,3 +173,15 @@ impl<R> InodeHandle<R> {\n         &self.0.dentry\n     }\n }\n+\n+pub trait FileIo: Send + Sync + 'static {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize>;\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents;\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/jinux-std/src/fs/procfs/mod.rs\n--- a/services/libs/jinux-std/src/fs/procfs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/mod.rs\n@@ -91,7 +91,7 @@ impl DirOps for RootDirOps {\n             SelfSymOps::new_inode(this_ptr.clone())\n         } else if let Ok(pid) = name.parse::<Pid>() {\n             let process_ref =\n-                process_table::pid_to_process(pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n+                process_table::get_process(&pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n             PidDirOps::new_inode(process_ref, this_ptr.clone())\n         } else {\n             return_errno!(Errno::ENOENT);\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -574,6 +574,10 @@ impl Inode for RamInode {\n         Ok(device_inode)\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.0.read().inner.as_device().cloned()\n+    }\n+\n     fn create(&self, name: &str, type_: InodeType, mode: InodeMode) -> Result<Arc<dyn Inode>> {\n         if self.0.read().metadata.type_ != InodeType::Dir {\n             return_errno_with_message!(Errno::ENOTDIR, \"self is not dir\");\ndiff --git a/services/libs/jinux-std/src/fs/rootfs.rs b/services/libs/jinux-std/src/fs/rootfs.rs\n--- a/services/libs/jinux-std/src/fs/rootfs.rs\n+++ b/services/libs/jinux-std/src/fs/rootfs.rs\n@@ -84,7 +84,7 @@ pub fn init(initramfs_buf: &[u8]) -> Result<()> {\n \n static ROOT_MOUNT: Once<Arc<MountNode>> = Once::new();\n \n-fn init_root_mount() {\n+pub fn init_root_mount() {\n     ROOT_MOUNT.call_once(|| -> Arc<MountNode> {\n         let rootfs = RamFS::new();\n         MountNode::new_root(rootfs)\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -285,6 +285,10 @@ pub trait Inode: Any + Sync + Send {\n         Err(Error::new(Errno::ENOTDIR))\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n+\n     fn readdir_at(&self, offset: usize, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         Err(Error::new(Errno::ENOTDIR))\n     }\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -1,26 +1,20 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace, vm::VmIo};\n-\n+use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n+use super::process_vm::ProcessVm;\n+use super::signal::sig_disposition::SigDispositions;\n+use super::{process_table, Process, ProcessBuilder};\n+use crate::current_thread;\n+use crate::fs::file_table::FileTable;\n+use crate::fs::fs_resolver::FsResolver;\n+use crate::fs::utils::FileCreationMask;\n+use crate::prelude::*;\n+use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n+use crate::util::write_val_to_user;\n+use crate::vm::vmar::Vmar;\n+use jinux_frame::cpu::UserContext;\n+use jinux_frame::user::UserSpace;\n+use jinux_frame::vm::VmIo;\n use jinux_rights::Full;\n \n-use crate::{\n-    current_thread,\n-    fs::file_table::FileTable,\n-    fs::{fs_resolver::FsResolver, utils::FileCreationMask},\n-    prelude::*,\n-    process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt, ThreadName},\n-        process_table,\n-    },\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n-    util::write_val_to_user,\n-    vm::vmar::Vmar,\n-};\n-\n-use super::{\n-    posix_thread::PosixThread, process_vm::ProcessVm, signal::sig_disposition::SigDispositions,\n-    Process, ProcessBuilder,\n-};\n-\n bitflags! {\n     pub struct CloneFlags: u32 {\n         const CLONE_VM      = 0x00000100;       /* Set if VM shared between processes.  */\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -275,16 +269,13 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n             .file_table(child_file_table)\n             .fs(child_fs)\n             .umask(child_umask)\n-            .sig_dispositions(child_sig_dispositions)\n-            .process_group(current.process_group().unwrap());\n+            .sig_dispositions(child_sig_dispositions);\n \n         process_builder.build()?\n     };\n \n-    current!().add_child(child.clone());\n-    process_table::add_process(child.clone());\n-\n-    let child_thread = thread_table::tid_to_thread(child_tid).unwrap();\n+    // Deals with clone flags\n+    let child_thread = thread_table::get_thread(child_tid).unwrap();\n     let child_posix_thread = child_thread.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -296,6 +287,10 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n         clone_args.child_tidptr,\n         clone_flags,\n     )?;\n+\n+    // Sets parent process and group for child process.\n+    set_parent_and_group(&current, &child);\n+\n     Ok(child)\n }\n \ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -414,3 +409,19 @@ fn clone_sysvsem(clone_flags: CloneFlags) -> Result<()> {\n     }\n     Ok(())\n }\n+\n+fn set_parent_and_group(parent: &Arc<Process>, child: &Arc<Process>) {\n+    let process_group = parent.process_group().unwrap();\n+\n+    let mut process_table_mut = process_table::process_table_mut();\n+    let mut group_inner = process_group.inner.lock();\n+    let mut child_group_mut = child.process_group.lock();\n+    let mut children_mut = parent.children().lock();\n+\n+    children_mut.insert(child.pid(), child.clone());\n+\n+    group_inner.processes.insert(child.pid(), child.clone());\n+    *child_group_mut = Arc::downgrade(&process_group);\n+\n+    process_table_mut.insert(child.pid(), child.clone());\n+}\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -37,9 +37,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     // Move children to the init process\n     if !is_init_process(&current) {\n         if let Some(init_process) = get_init_process() {\n+            let mut init_children = init_process.children().lock();\n             for (_, child_process) in current.children().lock().extract_if(|_, _| true) {\n-                child_process.set_parent(Arc::downgrade(&init_process));\n-                init_process.add_child(child_process);\n+                let mut parent = child_process.parent.lock();\n+                init_children.insert(child_process.pid(), child_process.clone());\n+                *parent = Arc::downgrade(&init_process);\n             }\n         }\n     }\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -56,7 +58,7 @@ const INIT_PROCESS_PID: Pid = 1;\n \n /// Get the init process\n fn get_init_process() -> Option<Arc<Process>> {\n-    process_table::pid_to_process(INIT_PROCESS_PID)\n+    process_table::get_process(&INIT_PROCESS_PID)\n }\n \n fn is_init_process(process: &Process) -> bool {\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -4,7 +4,6 @@ pub mod posix_thread;\n #[allow(clippy::module_inception)]\n mod process;\n mod process_filter;\n-mod process_group;\n pub mod process_table;\n mod process_vm;\n mod program_loader;\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -17,9 +16,10 @@ mod wait;\n pub use clone::{clone_child, CloneArgs, CloneFlags};\n pub use exit::do_exit_group;\n pub use process::ProcessBuilder;\n-pub use process::{current, ExitCode, Pgid, Pid, Process};\n+pub use process::{\n+    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessGroup, Session, Sid, Terminal,\n+};\n pub use process_filter::ProcessFilter;\n-pub use process_group::ProcessGroup;\n pub use program_loader::{check_executable_file, load_program_to_vm};\n pub use rlimit::ResourceType;\n pub use term_status::TermStatus;\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -1,12 +1,10 @@\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\n-use crate::process::posix_thread::PosixThreadBuilder;\n-use crate::process::process_group::ProcessGroup;\n-use crate::process::process_table;\n+use crate::process::posix_thread::{PosixThreadBuilder, PosixThreadExt};\n use crate::process::process_vm::ProcessVm;\n use crate::process::rlimit::ResourceLimits;\n-use crate::process::{posix_thread::PosixThreadExt, signal::sig_disposition::SigDispositions};\n+use crate::process::signal::sig_disposition::SigDispositions;\n use crate::thread::Thread;\n \n use super::{Pid, Process};\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -23,7 +21,6 @@ pub struct ProcessBuilder<'a> {\n     argv: Option<Vec<CString>>,\n     envp: Option<Vec<CString>>,\n     process_vm: Option<ProcessVm>,\n-    process_group: Option<Arc<ProcessGroup>>,\n     file_table: Option<Arc<Mutex<FileTable>>>,\n     fs: Option<Arc<RwLock<FsResolver>>>,\n     umask: Option<Arc<RwLock<FileCreationMask>>>,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -41,7 +38,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv: None,\n             envp: None,\n             process_vm: None,\n-            process_group: None,\n             file_table: None,\n             fs: None,\n             umask: None,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -60,11 +56,6 @@ impl<'a> ProcessBuilder<'a> {\n         self\n     }\n \n-    pub fn process_group(&mut self, process_group: Arc<ProcessGroup>) -> &mut Self {\n-        self.process_group = Some(process_group);\n-        self\n-    }\n-\n     pub fn file_table(&mut self, file_table: Arc<Mutex<FileTable>>) -> &mut Self {\n         self.file_table = Some(file_table);\n         self\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -126,7 +117,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv,\n             envp,\n             process_vm,\n-            process_group,\n             file_table,\n             fs,\n             umask,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -136,10 +126,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         let process_vm = process_vm.or_else(|| Some(ProcessVm::alloc())).unwrap();\n \n-        let process_group_ref = process_group\n-            .as_ref()\n-            .map_or_else(Weak::new, Arc::downgrade);\n-\n         let file_table = file_table\n             .or_else(|| Some(Arc::new(Mutex::new(FileTable::new_with_stdio()))))\n             .unwrap();\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -168,7 +154,6 @@ impl<'a> ProcessBuilder<'a> {\n                 threads,\n                 executable_path.to_string(),\n                 process_vm,\n-                process_group_ref,\n                 file_table,\n                 fs,\n                 umask,\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -194,15 +179,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         process.threads().lock().push(thread);\n \n-        if let Some(process_group) = process_group {\n-            process_group.add_process(process.clone());\n-        } else {\n-            let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-            let pgid = new_process_group.pgid();\n-            process.set_process_group(Arc::downgrade(&new_process_group));\n-            process_table::add_process_group(new_process_group);\n-        }\n-\n         process.set_runnable();\n \n         Ok(process)\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/job_control.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/job_control.rs\n@@ -0,0 +1,161 @@\n+use crate::prelude::*;\n+use crate::process::signal::constants::{SIGCONT, SIGHUP};\n+use crate::process::signal::signals::kernel::KernelSignal;\n+use crate::process::signal::Pauser;\n+use crate::process::{ProcessGroup, Session};\n+\n+/// The job control for terminals like tty and pty.\n+///\n+/// This struct is used to support shell job control, which allows users to\n+/// run commands in the foreground or in the background. This struct manages\n+/// the session and foreground process group for a terminal.\n+pub struct JobControl {\n+    foreground: SpinLock<Weak<ProcessGroup>>,\n+    session: SpinLock<Weak<Session>>,\n+    pauser: Arc<Pauser>,\n+}\n+\n+impl JobControl {\n+    /// Creates a new `TtyJobControl`\n+    pub fn new() -> Self {\n+        Self {\n+            foreground: SpinLock::new(Weak::new()),\n+            session: SpinLock::new(Weak::new()),\n+            pauser: Pauser::new(),\n+        }\n+    }\n+\n+    // *************** Session ***************\n+\n+    /// Returns the session whose controlling terminal is the terminal.\n+    fn session(&self) -> Option<Arc<Session>> {\n+        self.session.lock().upgrade()\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the `session`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This terminal should not belong to any session.\n+    pub fn set_session(&self, session: &Arc<Session>) {\n+        debug_assert!(self.session().is_none());\n+        *self.session.lock() = Arc::downgrade(session);\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn set_current_session(&self) -> Result<()> {\n+        if self.session().is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal is already controlling terminal of another session\"\n+            );\n+        }\n+\n+        let current = current!();\n+\n+        let process_group = current.process_group().unwrap();\n+        *self.foreground.lock() = Arc::downgrade(&process_group);\n+\n+        let session = current.session().unwrap();\n+        *self.session.lock() = Arc::downgrade(&session);\n+\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Releases the current session from this terminal.\n+    pub fn release_current_session(&self) -> Result<()> {\n+        let Some(session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the terminal is not controlling terminal now\"\n+            );\n+        };\n+\n+        if let Some(foreground) = self.foreground() {\n+            foreground.broadcast_signal(KernelSignal::new(SIGHUP));\n+            foreground.broadcast_signal(KernelSignal::new(SIGCONT));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // *************** Foreground process group ***************\n+\n+    /// Returns the foreground process group\n+    pub fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.foreground.lock().upgrade()\n+    }\n+\n+    /// Sets the foreground process group.\n+    ///\n+    /// # Panic\n+    ///\n+    /// The process group should belong to one session.\n+    pub fn set_foreground(&self, process_group: Option<&Arc<ProcessGroup>>) -> Result<()> {\n+        let Some(process_group) = process_group else {\n+            // FIXME: should we allow this branch?\n+            *self.foreground.lock() = Weak::new();\n+            return Ok(());\n+        };\n+\n+        let session = process_group.session().unwrap();\n+        let Some(terminal_session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal does not become controlling terminal of one session.\"\n+            );\n+        };\n+\n+        if !Arc::ptr_eq(&terminal_session, &session) {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the process proup belongs to different session\"\n+            );\n+        }\n+\n+        *self.foreground.lock() = Arc::downgrade(process_group);\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Wait until the current process is the foreground process group. If\n+    /// the foreground process group is None, returns true.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn wait_until_in_foreground(&self) -> Result<()> {\n+        // Fast path\n+        if self.current_belongs_to_foreground() {\n+            return Ok(());\n+        }\n+\n+        // Slow path\n+        self.pauser.pause_until(|| {\n+            if self.current_belongs_to_foreground() {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn current_belongs_to_foreground(&self) -> bool {\n+        let Some(foreground) = self.foreground() else {\n+            return true;\n+        };\n+\n+        foreground.contains_process(current!().pid())\n+    }\n+}\n+\n+impl Default for JobControl {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -1,7 +1,4 @@\n-mod builder;\n-\n use super::posix_thread::PosixThreadExt;\n-use super::process_group::ProcessGroup;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\n use super::rlimit::ResourceLimits;\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -13,7 +10,7 @@ use super::signal::signals::Signal;\n use super::signal::{Pauser, SigEvents, SigEventsFilter};\n use super::status::ProcessStatus;\n use super::{process_table, TermStatus};\n-use crate::device::tty::get_n_tty;\n+use crate::device::tty::open_ntty_as_controlling_terminal;\n use crate::events::Observer;\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -23,10 +20,25 @@ use crate::thread::{allocate_tid, Thread};\n use crate::vm::vmar::Vmar;\n use jinux_rights::Full;\n \n+mod builder;\n+mod job_control;\n+mod process_group;\n+mod session;\n+mod terminal;\n+\n pub use builder::ProcessBuilder;\n+pub use job_control::JobControl;\n+pub use process_group::ProcessGroup;\n+pub use session::Session;\n+pub use terminal::Terminal;\n \n+/// Process id.\n pub type Pid = u32;\n+/// Process group id.\n pub type Pgid = u32;\n+/// Session Id.\n+pub type Sid = u32;\n+\n pub type ExitCode = i32;\n \n /// Process stands for a set of threads that shares the same userspace.\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -46,11 +58,11 @@ pub struct Process {\n     /// Process status\n     status: Mutex<ProcessStatus>,\n     /// Parent process\n-    parent: Mutex<Weak<Process>>,\n+    pub(super) parent: Mutex<Weak<Process>>,\n     /// Children processes\n     children: Mutex<BTreeMap<Pid, Arc<Process>>>,\n     /// Process group\n-    process_group: Mutex<Weak<ProcessGroup>>,\n+    pub(super) process_group: Mutex<Weak<ProcessGroup>>,\n     /// File table\n     file_table: Arc<Mutex<FileTable>>,\n     /// FsResolver\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -75,7 +87,6 @@ impl Process {\n         threads: Vec<Arc<Thread>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n-        process_group: Weak<ProcessGroup>,\n         file_table: Arc<Mutex<FileTable>>,\n         fs: Arc<RwLock<FsResolver>>,\n         umask: Arc<RwLock<FileCreationMask>>,\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -99,7 +110,7 @@ impl Process {\n             status: Mutex::new(ProcessStatus::Uninit),\n             parent: Mutex::new(parent),\n             children: Mutex::new(BTreeMap::new()),\n-            process_group: Mutex::new(process_group),\n+            process_group: Mutex::new(Weak::new()),\n             file_table,\n             fs,\n             umask,\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -118,11 +129,9 @@ impl Process {\n         // spawn user process should give an absolute path\n         debug_assert!(executable_path.starts_with('/'));\n         let process = Process::create_user_process(executable_path, argv, envp)?;\n-        // FIXME: How to determine the fg process group?\n-        let process_group = Weak::clone(&process.process_group.lock());\n-        // FIXME: tty should be a parameter?\n-        let tty = get_n_tty();\n-        tty.set_fg(process_group);\n+\n+        open_ntty_as_controlling_terminal(&process)?;\n+\n         process.run();\n         Ok(process)\n     }\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -141,7 +150,25 @@ impl Process {\n         };\n \n         let process = process_builder.build()?;\n-        process_table::add_process(process.clone());\n+\n+        // Lock order: session table -> group table -> process table -> group of process\n+        // -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut process_table_mut = process_table::process_table_mut();\n+\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+        group_table_mut.insert(group.pgid(), group.clone());\n+\n+        // Creates new session\n+        let session = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&session);\n+        session.inner.lock().leader = Some(process.clone());\n+        session_table_mut.insert(session.sid(), session);\n+\n+        process_table_mut.insert(process.pid(), process.clone());\n         Ok(process)\n     }\n \ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -180,30 +207,25 @@ impl Process {\n     }\n \n     // *********** Parent and child ***********\n-\n-    pub fn add_child(&self, child: Arc<Process>) {\n-        let child_pid = child.pid();\n-        self.children.lock().insert(child_pid, child);\n-    }\n-\n-    pub fn set_parent(&self, parent: Weak<Process>) {\n-        *self.parent.lock() = parent;\n-    }\n-\n     pub fn parent(&self) -> Option<Arc<Process>> {\n         self.parent.lock().upgrade()\n     }\n \n-    pub fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n+    pub(super) fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n         &self.children\n     }\n \n+    pub fn has_child(&self, pid: &Pid) -> bool {\n+        self.children.lock().contains_key(pid)\n+    }\n+\n     pub fn children_pauser(&self) -> &Arc<Pauser> {\n         &self.children_pauser\n     }\n \n-    // *********** Process group ***********\n+    // *********** Process group & Session***********\n \n+    /// Returns the process group id of the process.\n     pub fn pgid(&self) -> Pgid {\n         if let Some(process_group) = self.process_group.lock().upgrade() {\n             process_group.pgid()\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -212,17 +234,237 @@ impl Process {\n         }\n     }\n \n-    /// Set process group for current process. If old process group exists,\n-    /// remove current process from old process group.\n-    pub fn set_process_group(&self, process_group: Weak<ProcessGroup>) {\n-        if let Some(old_process_group) = self.process_group() {\n-            old_process_group.remove_process(self.pid());\n+    /// Returns the process group which the process belongs to.\n+    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n+        self.process_group.lock().upgrade()\n+    }\n+\n+    /// Returns whether `self` is the leader of process group.\n+    fn is_group_leader(self: &Arc<Self>) -> bool {\n+        let Some(process_group) = self.process_group() else {\n+            return false;\n+        };\n+\n+        let Some(leader) = process_group.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leader)\n+    }\n+\n+    /// Returns the session which the process belongs to.\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        let process_group = self.process_group()?;\n+        process_group.session()\n+    }\n+\n+    /// Returns whether the process is session leader.\n+    pub fn is_session_leader(self: &Arc<Self>) -> bool {\n+        let session = self.session().unwrap();\n+\n+        let Some(leading_process) = session.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leading_process)\n+    }\n+\n+    /// Moves the process to the new session.\n+    ///\n+    /// If the process is already session leader, this method does nothing.\n+    ///\n+    /// Otherwise, this method creates a new process group in a new session\n+    /// and moves the process to the session, returning the new session.\n+    ///\n+    /// This method may return the following errors:\n+    /// * `EPERM`, if the process is a process group leader, or some existing session\n+    /// or process group has the same id as the process.\n+    pub fn to_new_session(self: &Arc<Self>) -> Result<Arc<Session>> {\n+        if self.is_session_leader() {\n+            return Ok(self.session().unwrap());\n+        }\n+\n+        if self.is_group_leader() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"process group leader cannot be moved to new session.\"\n+            );\n+        }\n+\n+        let session = self.session().unwrap();\n+\n+        // Lock order: session table -> group table -> group of process -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        if session_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create new session\");\n+        }\n+\n+        if group_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create process group\");\n+        }\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                session_inner.process_groups.remove(&old_group.pgid());\n+\n+                if session_inner.is_empty() {\n+                    session_table_mut.remove(&session.sid());\n+                }\n+            }\n         }\n-        *self.process_group.lock() = process_group;\n+\n+        // Creates a new process group\n+        let new_group = ProcessGroup::new(self.clone());\n+        *self_group_mut = Arc::downgrade(&new_group);\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        // Creates a new session\n+        let new_session = Session::new(new_group.clone());\n+        let mut new_group_inner = new_group.inner.lock();\n+        new_group_inner.session = Arc::downgrade(&new_session);\n+        new_session.inner.lock().leader = Some(self.clone());\n+        session_table_mut.insert(new_session.sid(), new_session.clone());\n+\n+        // Removes the process from session.\n+        let mut session_inner = session.inner.lock();\n+        session_inner.remove_process(self);\n+\n+        Ok(new_session)\n+    }\n+\n+    /// Moves the process to other process group.\n+    ///\n+    /// * If the group already exists, the process and the group should belong to the same session.\n+    /// * If the group does not exist, this method creates a new group for the process and move the\n+    /// process to the group. The group is added to the session of the process.\n+    ///\n+    /// This method may return `EPERM` in following cases:\n+    /// * The process is session leader;\n+    /// * The group already exists, but the group does not belong to the same session as the process;\n+    /// * The group does not exist, but `pgid` is not equal to `pid` of the process.\n+    pub fn to_other_group(self: &Arc<Self>, pgid: Pgid) -> Result<()> {\n+        // if the process already belongs to the process group\n+        if self.pgid() == pgid {\n+            return Ok(());\n+        }\n+\n+        if self.is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"the process cannot be a session leader\");\n+        }\n+\n+        if let Some(process_group) = process_table::get_process_group(&pgid) {\n+            let session = self.session().unwrap();\n+            if !session.contains_process_group(&process_group) {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the group and process does not belong to same session\"\n+                );\n+            }\n+            self.to_specified_group(&process_group)?;\n+        } else {\n+            if pgid != self.pid() {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the new process group should have the same id as the process.\"\n+                );\n+            }\n+\n+            self.to_new_group()?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Creates a new process group and moves the process to the group.\n+    ///\n+    /// The new group will be added to the same session as the process.\n+    fn to_new_group(self: &Arc<Self>) -> Result<()> {\n+        let session = self.session().unwrap();\n+        // Lock order: group table -> group of process -> group inner -> session inner\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                // The old session won't be empty, since we will add a new group to the session.\n+                session_inner.process_groups.remove(&old_group.pgid());\n+            }\n+        }\n+\n+        // Creates a new process group. Adds the new group to group table and session.\n+        let new_group = ProcessGroup::new(self.clone());\n+\n+        let mut new_group_inner = new_group.inner.lock();\n+        let mut session_inner = session.inner.lock();\n+\n+        *self_group_mut = Arc::downgrade(&new_group);\n+\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        new_group_inner.session = Arc::downgrade(&session);\n+        session_inner\n+            .process_groups\n+            .insert(new_group.pgid(), new_group.clone());\n+\n+        Ok(())\n     }\n \n-    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n-        self.process_group.lock().upgrade()\n+    /// Moves the process to a specified group.\n+    ///\n+    /// The caller needs to ensure that the process and the group belongs to the same session.\n+    fn to_specified_group(self: &Arc<Process>, group: &Arc<ProcessGroup>) -> Result<()> {\n+        // Lock order: group table -> group of process -> group inner (small pgid -> big pgid)\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        let mut group_inner = if let Some(old_group) = self_group_mut.upgrade() {\n+            // Lock order: group with smaller pgid first\n+            let (mut old_group_inner, group_inner) = match old_group.pgid().cmp(&group.pgid()) {\n+                core::cmp::Ordering::Equal => return Ok(()),\n+                core::cmp::Ordering::Less => (old_group.inner.lock(), group.inner.lock()),\n+                core::cmp::Ordering::Greater => {\n+                    let group_inner = group.inner.lock();\n+                    let old_group_inner = old_group.inner.lock();\n+                    (old_group_inner, group_inner)\n+                }\n+            };\n+            old_group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if old_group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+            }\n+\n+            group_inner\n+        } else {\n+            group.inner.lock()\n+        };\n+\n+        // Adds the process to the specified group\n+        group_inner.processes.insert(self.pid, self.clone());\n+        *self_group_mut = Arc::downgrade(group);\n+\n+        Ok(())\n     }\n \n     // ************** Virtual Memory *************\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/process_group.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/process_group.rs\n@@ -0,0 +1,84 @@\n+use super::{Pgid, Pid, Process, Session};\n+use crate::prelude::*;\n+use crate::process::signal::signals::Signal;\n+\n+/// `ProcessGroup` represents a set of processes. Each `ProcessGroup` has a unique\n+/// identifier `pgid`.\n+pub struct ProcessGroup {\n+    pgid: Pgid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) processes: BTreeMap<Pid, Arc<Process>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) session: Weak<Session>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn remove_process(&mut self, pid: &Pid) {\n+        let Some(process) = self.processes.remove(pid) else {\n+            return;\n+        };\n+\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, &process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.processes.is_empty()\n+    }\n+}\n+\n+impl ProcessGroup {\n+    /// Creates a new process group with one process. The pgid is the same as the process\n+    /// id. The process will become the leading process of the new process group.\n+    ///\n+    /// The caller needs to ensure that the process does not belong to any group.\n+    pub(in crate::process) fn new(process: Arc<Process>) -> Arc<Self> {\n+        let pid = process.pid();\n+\n+        let inner = {\n+            let mut processes = BTreeMap::new();\n+            processes.insert(pid, process.clone());\n+            Inner {\n+                processes,\n+                leader: Some(process.clone()),\n+                session: Weak::new(),\n+            }\n+        };\n+\n+        Arc::new(ProcessGroup {\n+            pgid: pid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns whether self contains a process with `pid`.\n+    pub(in crate::process) fn contains_process(&self, pid: Pid) -> bool {\n+        self.inner.lock().processes.contains_key(&pid)\n+    }\n+\n+    /// Returns the process group identifier\n+    pub fn pgid(&self) -> Pgid {\n+        self.pgid\n+    }\n+\n+    /// Broadcasts signal to all processes in the group.\n+    pub fn broadcast_signal(&self, signal: impl Signal + Clone + 'static) {\n+        for process in self.inner.lock().processes.values() {\n+            process.enqueue_signal(Box::new(signal.clone()));\n+        }\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns the session which the group belongs to\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        self.inner.lock().session.upgrade()\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/session.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/session.rs\n@@ -0,0 +1,133 @@\n+use crate::prelude::*;\n+\n+use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\n+\n+/// A `Session` is a collection of related process groups. Each session has a\n+/// unique identifier `sid`. Process groups and sessions form a two-level\n+/// hierarchical relationship between processes.\n+///\n+/// **Leader**: A *session leader* is the process that creates a new session and whose process\n+/// ID becomes the session ID.\n+///\n+/// **Controlling terminal**: The terminal can be used to manage all processes in the session. The\n+/// controlling terminal is established when the session leader first opens a terminal.\n+pub struct Session {\n+    sid: Sid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) process_groups: BTreeMap<Pgid, Arc<ProcessGroup>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) terminal: Option<Arc<dyn Terminal>>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.process_groups.is_empty()\n+    }\n+\n+    pub(in crate::process) fn remove_process(&mut self, process: &Arc<Process>) {\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn remove_process_group(&mut self, pgid: &Pgid) {\n+        self.process_groups.remove(pgid);\n+    }\n+}\n+\n+impl Session {\n+    /// Creates a new session for the process group. The process group becomes the member of\n+    /// the new session.\n+    ///\n+    /// The caller needs to ensure that the group does not belong to any session, and the caller\n+    /// should set the leader process after creating the session.\n+    pub(in crate::process) fn new(group: Arc<ProcessGroup>) -> Arc<Self> {\n+        let sid = group.pgid();\n+        let inner = {\n+            let mut process_groups = BTreeMap::new();\n+            process_groups.insert(group.pgid(), group);\n+\n+            Inner {\n+                process_groups,\n+                leader: None,\n+                terminal: None,\n+            }\n+        };\n+        Arc::new(Self {\n+            sid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns the session id\n+    pub fn sid(&self) -> Sid {\n+        self.sid\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns whether `self` contains the `process_group`\n+    pub(in crate::process) fn contains_process_group(\n+        self: &Arc<Self>,\n+        process_group: &Arc<ProcessGroup>,\n+    ) -> bool {\n+        self.inner\n+            .lock()\n+            .process_groups\n+            .contains_key(&process_group.pgid())\n+    }\n+\n+    /// Sets terminal as the controlling terminal of the session. The `get_terminal` method\n+    /// should set the session for the terminal and returns the session.\n+    ///\n+    /// If the session already has controlling terminal, this method will return `Err(EPERM)`.\n+    pub fn set_terminal<F>(&self, get_terminal: F) -> Result<()>\n+    where\n+        F: Fn() -> Result<Arc<dyn Terminal>>,\n+    {\n+        let mut inner = self.inner.lock();\n+\n+        if inner.terminal.is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"current session already has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = get_terminal()?;\n+        inner.terminal = Some(terminal);\n+        Ok(())\n+    }\n+\n+    /// Releases the controlling terminal of the session.\n+    ///\n+    /// If the session does not have controlling terminal, this method will return `ENOTTY`.\n+    pub fn release_terminal<F>(&self, release_session: F) -> Result<()>\n+    where\n+        F: Fn(&Arc<dyn Terminal>) -> Result<()>,\n+    {\n+        let mut inner = self.inner.lock();\n+        if inner.terminal.is_none() {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"current session does not has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = inner.terminal.as_ref().unwrap();\n+        release_session(terminal)?;\n+        inner.terminal = None;\n+        Ok(())\n+    }\n+\n+    /// Returns the controlling terminal of `self`.\n+    pub fn terminal(&self) -> Option<Arc<dyn Terminal>> {\n+        self.inner.lock().terminal.clone()\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/terminal.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/terminal.rs\n@@ -0,0 +1,104 @@\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, ProcessGroup};\n+\n+use super::JobControl;\n+\n+/// A termial is used to interact with system. A terminal can support the shell\n+/// job control.\n+///\n+/// We currently support two kinds of terminal, the tty and pty.\n+pub trait Terminal: Send + Sync + FileIo {\n+    // *************** Foreground ***************\n+\n+    /// Returns the foreground process group\n+    fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.job_control().foreground()\n+    }\n+\n+    /// Sets the foreground process group of this terminal.\n+    ///\n+    /// If the terminal is not controlling terminal, this method returns `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn set_foreground(&self, pgid: &Pgid) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"self is not controlling terminal\");\n+        }\n+\n+        let foreground = process_table::get_process_group(pgid);\n+\n+        self.job_control().set_foreground(foreground.as_ref())\n+    }\n+\n+    // *************** Session and controlling terminal ***************\n+\n+    /// Returns whether the terminal is the controlling terminal of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn is_controlling_terminal(&self) -> bool {\n+        let session = current!().session().unwrap();\n+        let Some(terminal) = session.terminal() else {\n+            return false;\n+        };\n+\n+        let arc_self = self.arc_self();\n+        Arc::ptr_eq(&terminal, &arc_self)\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// If self is not session leader, or the terminal is controlling terminal of other session,\n+    /// or the session already has controlling terminal, this method returns `EPERM`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn set_current_session(&self) -> Result<()> {\n+        if !current!().is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"current process is not session leader\");\n+        }\n+\n+        let get_terminal = || {\n+            self.job_control().set_current_session()?;\n+            Ok(self.arc_self())\n+        };\n+\n+        let session = current!().session().unwrap();\n+        session.set_terminal(get_terminal)\n+    }\n+\n+    /// Releases the terminal from the session of current process if the terminal is the controlling\n+    /// terminal of the session.\n+    ///\n+    /// If the terminal is not the controlling terminal of the session, this method will return `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn release_current_session(&self) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"release wrong tty\");\n+        }\n+\n+        let current = current!();\n+        if !current.is_session_leader() {\n+            warn!(\"TODO: release tty for process that is not session leader\");\n+            return Ok(());\n+        }\n+\n+        let release_session = |_: &Arc<dyn Terminal>| self.job_control().release_current_session();\n+\n+        let session = current.session().unwrap();\n+        session.release_terminal(release_session)\n+    }\n+\n+    /// Returns the job control of the terminal.\n+    fn job_control(&self) -> &JobControl;\n+\n+    fn arc_self(&self) -> Arc<dyn Terminal>;\n+}\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs /dev/null\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ /dev/null\n@@ -1,85 +0,0 @@\n-use super::{\n-    process_table,\n-    signal::signals::{kernel::KernelSignal, user::UserSignal},\n-    Pgid, Pid, Process,\n-};\n-use crate::prelude::*;\n-\n-pub struct ProcessGroup {\n-    inner: Mutex<ProcessGroupInner>,\n-}\n-\n-struct ProcessGroupInner {\n-    pgid: Pgid,\n-    processes: BTreeMap<Pid, Arc<Process>>,\n-    leader_process: Option<Arc<Process>>,\n-}\n-\n-impl ProcessGroup {\n-    fn default() -> Self {\n-        ProcessGroup {\n-            inner: Mutex::new(ProcessGroupInner {\n-                pgid: 0,\n-                processes: BTreeMap::new(),\n-                leader_process: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new(process: Arc<Process>) -> Self {\n-        let process_group = ProcessGroup::default();\n-        let pid = process.pid();\n-        process_group.set_pgid(pid);\n-        process_group.add_process(process.clone());\n-        process_group.set_leader_process(process);\n-        process_group\n-    }\n-\n-    pub fn set_pgid(&self, pgid: Pgid) {\n-        self.inner.lock().pgid = pgid;\n-    }\n-\n-    pub fn set_leader_process(&self, leader_process: Arc<Process>) {\n-        self.inner.lock().leader_process = Some(leader_process);\n-    }\n-\n-    pub fn add_process(&self, process: Arc<Process>) {\n-        self.inner.lock().processes.insert(process.pid(), process);\n-    }\n-\n-    pub fn contains_process(&self, pid: Pid) -> bool {\n-        self.inner.lock().processes.contains_key(&pid)\n-    }\n-\n-    /// remove a process from this process group.\n-    /// If this group contains no processes now, the group itself will be deleted from global table.\n-    pub fn remove_process(&self, pid: Pid) {\n-        let mut inner_lock = self.inner.lock();\n-        inner_lock.processes.remove(&pid);\n-        let len = inner_lock.processes.len();\n-        let pgid = inner_lock.pgid;\n-        // if self contains no process, remove self from table\n-        if len == 0 {\n-            // this must be the last statement\n-            process_table::remove_process_group(pgid);\n-        }\n-    }\n-\n-    pub fn pgid(&self) -> Pgid {\n-        self.inner.lock().pgid\n-    }\n-\n-    /// send kernel signal to all processes in the group\n-    pub fn kernel_signal(&self, signal: KernelSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-\n-    /// send user signal to all processes in the group\n-    pub fn user_signal(&self, signal: UserSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -5,35 +5,25 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n-use super::{process_group::ProcessGroup, Pgid, Pid, Process};\n+use super::{Pgid, Pid, Process, ProcessGroup, Session, Sid};\n \n-lazy_static! {\n-    static ref PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n-    static ref PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> =\n-        Mutex::new(BTreeMap::new());\n-    static ref PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n-}\n-\n-/// add a process to global table\n-pub fn add_process(process: Arc<Process>) {\n-    let pid = process.pid();\n-    PROCESS_TABLE.lock().insert(pid, process);\n-}\n+static PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n+static SESSION_TABLE: Mutex<BTreeMap<Sid, Arc<Session>>> = Mutex::new(BTreeMap::new());\n \n-/// remove a process from global table\n-pub fn remove_process(pid: Pid) {\n-    PROCESS_TABLE.lock().remove(&pid);\n+// ************ Process *************\n \n-    let events = PidEvent::Exit(pid);\n-    PROCESS_TABLE_SUBJECT.notify_observers(&events);\n+/// Gets a process with pid\n+pub fn get_process(pid: &Pid) -> Option<Arc<Process>> {\n+    PROCESS_TABLE.lock().get(pid).cloned()\n }\n \n-/// get a process with pid\n-pub fn pid_to_process(pid: Pid) -> Option<Arc<Process>> {\n-    PROCESS_TABLE.lock().get(&pid).cloned()\n+pub(super) fn process_table_mut() -> MutexGuard<'static, BTreeMap<Pid, Arc<Process>>> {\n+    PROCESS_TABLE.lock()\n }\n \n-/// get all processes\n+/// Gets all processes\n pub fn get_all_processes() -> Vec<Arc<Process>> {\n     PROCESS_TABLE\n         .lock()\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -42,26 +32,41 @@ pub fn get_all_processes() -> Vec<Arc<Process>> {\n         .collect()\n }\n \n-/// add process group to global table\n-pub fn add_process_group(process_group: Arc<ProcessGroup>) {\n-    let pgid = process_group.pgid();\n-    PROCESS_GROUP_TABLE.lock().insert(pgid, process_group);\n+// ************ Process Group *************\n+\n+/// Gets a process group with `pgid`\n+pub fn get_process_group(pgid: &Pgid) -> Option<Arc<ProcessGroup>> {\n+    PROCESS_GROUP_TABLE.lock().get(pgid).cloned()\n+}\n+\n+/// Returns whether process table contains process group with pgid\n+pub fn contain_process_group(pgid: &Pgid) -> bool {\n+    PROCESS_GROUP_TABLE.lock().contains_key(pgid)\n }\n \n-/// remove process group from global table\n-pub fn remove_process_group(pgid: Pgid) {\n-    PROCESS_GROUP_TABLE.lock().remove(&pgid);\n+pub(super) fn group_table_mut() -> MutexGuard<'static, BTreeMap<Pgid, Arc<ProcessGroup>>> {\n+    PROCESS_GROUP_TABLE.lock()\n }\n \n-/// get a process group with pgid\n-pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n-    PROCESS_GROUP_TABLE.lock().get(&pgid).cloned()\n+// ************ Session *************\n+\n+/// Gets a session with `sid`.\n+pub fn get_session(sid: &Sid) -> Option<Arc<Session>> {\n+    SESSION_TABLE.lock().get(sid).map(Arc::clone)\n }\n \n+pub(super) fn session_table_mut() -> MutexGuard<'static, BTreeMap<Sid, Arc<Session>>> {\n+    SESSION_TABLE.lock()\n+}\n+\n+// ************ Observer *************\n+\n+/// Registers an observer which watches `PidEvent`.\n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n+/// Unregisters an observer which watches `PidEvent`.\n pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\ndiff --git a/services/libs/jinux-std/src/process/wait.rs b/services/libs/jinux-std/src/process/wait.rs\n--- a/services/libs/jinux-std/src/process/wait.rs\n+++ b/services/libs/jinux-std/src/process/wait.rs\n@@ -80,9 +80,33 @@ fn reap_zombie_child(process: &Process, pid: Pid) -> u32 {\n     for thread in &*child_process.threads().lock() {\n         thread_table::remove_thread(thread.tid());\n     }\n-    process_table::remove_process(child_process.pid());\n-    if let Some(process_group) = child_process.process_group() {\n-        process_group.remove_process(child_process.pid());\n+\n+    // Lock order: session table -> group table -> process table -> group of process\n+    // -> group inner -> session inner\n+    let mut session_table_mut = process_table::session_table_mut();\n+    let mut group_table_mut = process_table::group_table_mut();\n+    let mut process_table_mut = process_table::process_table_mut();\n+\n+    let mut child_group_mut = child_process.process_group.lock();\n+\n+    let process_group = child_group_mut.upgrade().unwrap();\n+    let mut group_inner = process_group.inner.lock();\n+    let session = group_inner.session.upgrade().unwrap();\n+    let mut session_inner = session.inner.lock();\n+\n+    group_inner.remove_process(&child_process.pid());\n+    session_inner.remove_process(&child_process);\n+    *child_group_mut = Weak::new();\n+\n+    if group_inner.is_empty() {\n+        group_table_mut.remove(&process_group.pgid());\n+        session_inner.remove_process_group(&process_group.pgid());\n+\n+        if session_inner.is_empty() {\n+            session_table_mut.remove(&session.sid());\n+        }\n     }\n+\n+    process_table_mut.remove(&child_process.pid());\n     child_process.exit_code().unwrap()\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/getsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/getsid.rs\n@@ -0,0 +1,30 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pid};\n+\n+use super::{SyscallReturn, SYS_GETSID};\n+\n+pub fn sys_getsid(pid: Pid) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_GETSID);\n+    debug!(\"pid = {}\", pid);\n+\n+    let session = current!().session().unwrap();\n+    let sid = session.sid();\n+\n+    if pid == 0 {\n+        return Ok(SyscallReturn::Return(sid as _));\n+    }\n+\n+    let Some(process) = process_table::get_process(&pid) else {\n+        return_errno_with_message!(Errno::ESRCH, \"the process does not exist\")\n+    };\n+\n+    if !Arc::ptr_eq(&session, &process.session().unwrap()) {\n+        return_errno_with_message!(\n+            Errno::EPERM,\n+            \"the process and current process does not belong to the same session\"\n+        );\n+    }\n+\n+    Ok(SyscallReturn::Return(sid as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/jinux-std/src/syscall/kill.rs\n--- a/services/libs/jinux-std/src/syscall/kill.rs\n+++ b/services/libs/jinux-std/src/syscall/kill.rs\n@@ -34,15 +34,15 @@ pub fn do_sys_kill(filter: ProcessFilter, sig_num: SigNum) -> Result<()> {\n             }\n         }\n         ProcessFilter::WithPid(pid) => {\n-            if let Some(process) = process_table::pid_to_process(pid) {\n+            if let Some(process) = process_table::get_process(&pid) {\n                 process.enqueue_signal(Box::new(signal));\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process in process table\");\n             }\n         }\n         ProcessFilter::WithPgid(pgid) => {\n-            if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-                process_group.user_signal(signal);\n+            if let Some(process_group) = process_table::get_process_group(&pgid) {\n+                process_group.broadcast_signal(signal);\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process group in process table\");\n             }\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -77,12 +77,14 @@ use self::connect::sys_connect;\n use self::execve::sys_execveat;\n use self::getpeername::sys_getpeername;\n use self::getrandom::sys_getrandom;\n+use self::getsid::sys_getsid;\n use self::getsockname::sys_getsockname;\n use self::getsockopt::sys_getsockopt;\n use self::listen::sys_listen;\n use self::pread64::sys_pread64;\n use self::recvfrom::sys_recvfrom;\n use self::sendto::sys_sendto;\n+use self::setsid::sys_setsid;\n use self::setsockopt::sys_setsockopt;\n use self::shutdown::sys_shutdown;\n use self::socket::sys_socket;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -119,6 +121,7 @@ mod getpgrp;\n mod getpid;\n mod getppid;\n mod getrandom;\n+mod getsid;\n mod getsockname;\n mod getsockopt;\n mod gettid;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -155,6 +158,7 @@ mod sendto;\n mod set_robust_list;\n mod set_tid_address;\n mod setpgid;\n+mod setsid;\n mod setsockopt;\n mod shutdown;\n mod socket;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -274,6 +278,8 @@ define_syscall_nums!(\n     SYS_SETPGID = 109,\n     SYS_GETPPID = 110,\n     SYS_GETPGRP = 111,\n+    SYS_SETSID = 112,\n+    SYS_GETSID = 124,\n     SYS_STATFS = 137,\n     SYS_FSTATFS = 138,\n     SYS_PRCTL = 157,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -435,6 +441,8 @@ pub fn syscall_dispatch(\n         SYS_SETPGID => syscall_handler!(2, sys_setpgid, args),\n         SYS_GETPPID => syscall_handler!(0, sys_getppid),\n         SYS_GETPGRP => syscall_handler!(0, sys_getpgrp),\n+        SYS_SETSID => syscall_handler!(0, sys_setsid),\n+        SYS_GETSID => syscall_handler!(1, sys_getsid, args),\n         SYS_STATFS => syscall_handler!(2, sys_statfs, args),\n         SYS_FSTATFS => syscall_handler!(2, sys_fstatfs, args),\n         SYS_PRCTL => syscall_handler!(5, sys_prctl, args),\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -1,8 +1,6 @@\n-use crate::{\n-    log_syscall_entry,\n-    prelude::*,\n-    process::{process_table, Pgid, Pid, ProcessGroup},\n-};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, Pid};\n \n use super::{SyscallReturn, SYS_SETPGID};\n \ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -15,7 +13,7 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     let pgid = if pgid == 0 { pid } else { pgid };\n     debug!(\"pid = {}, pgid = {}\", pid, pgid);\n \n-    if pid != current.pid() && !current.children().lock().contains_key(&pid) {\n+    if pid != current.pid() && !current.has_child(&pid) {\n         return_errno_with_message!(\n             Errno::ESRCH,\n             \"cannot set pgid for process other than current or children of current\"\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -25,27 +23,14 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     // How can we determine a child process has called execve?\n \n     // only can move process to an existing group or self\n-    if pgid != pid && process_table::pgid_to_process_group(pgid).is_none() {\n+    if pgid != pid && !process_table::contain_process_group(&pgid) {\n         return_errno_with_message!(Errno::EPERM, \"process group must exist\");\n     }\n \n-    let process = process_table::pid_to_process(pid)\n+    let process = process_table::get_process(&pid)\n         .ok_or(Error::with_message(Errno::ESRCH, \"process does not exist\"))?;\n \n-    // if the process already belongs to the process group\n-    if process.pgid() == pgid {\n-        return Ok(SyscallReturn::Return(0));\n-    }\n-\n-    if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-        process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&process_group));\n-    } else {\n-        let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-        // new_process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&new_process_group));\n-        process_table::add_process_group(new_process_group);\n-    }\n+    process.to_other_group(pgid)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/setsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/setsid.rs\n@@ -0,0 +1,13 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+\n+use super::{SyscallReturn, SYS_SETSID};\n+\n+pub fn sys_setsid() -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_SETSID);\n+\n+    let current = current!();\n+    let session = current.to_new_session()?;\n+\n+    Ok(SyscallReturn::Return(session.sid() as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/jinux-std/src/syscall/tgkill.rs\n--- a/services/libs/jinux-std/src/syscall/tgkill.rs\n+++ b/services/libs/jinux-std/src/syscall/tgkill.rs\n@@ -16,8 +16,8 @@ pub fn sys_tgkill(tgid: Pid, tid: Tid, sig_num: u8) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_TGKILL);\n     let sig_num = SigNum::from_u8(sig_num);\n     info!(\"tgid = {}, pid = {}, sig_num = {:?}\", tgid, tid, sig_num);\n-    let target_thread = thread_table::tid_to_thread(tid)\n-        .ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n+    let target_thread =\n+        thread_table::get_thread(tid).ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n     let posix_thread = target_thread.as_posix_thread().unwrap();\n     let pid = posix_thread.process().pid();\n     if pid != tgid {\ndiff --git a/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/jinux-std/src/thread/thread_table.rs\n--- a/services/libs/jinux-std/src/thread/thread_table.rs\n+++ b/services/libs/jinux-std/src/thread/thread_table.rs\n@@ -15,6 +15,6 @@ pub fn remove_thread(tid: Tid) {\n     THREAD_TABLE.lock().remove(&tid);\n }\n \n-pub fn tid_to_thread(tid: Tid) -> Option<Arc<Thread>> {\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n     THREAD_TABLE.lock().get(&tid).cloned()\n }\n",
        "test_patch": "",
        "problem_statement": "Implement session for shell job control\nProcess groups and sessions form a two-level hierarchical relationship between processes. A session is a collection of process groups. A process\u2019s session membership is determined by its session identifier (SID). All of the processes in a session share a single controlling terminal. \r\n\r\nThe related syscalls are getsid and setsid\n",
        "hints_text": "",
        "created_at": "2023-08-30T11:25:32Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 334,
        "instance_id": "asterinas__asterinas-334",
        "issue_numbers": [
            "214"
        ],
        "base_commit": "25c4f0f2bcaa0bc8c650b0f4ee7b0d78e2a836b2",
        "patch": "diff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -3,7 +3,7 @@ MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n-TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve \n+TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve pty\n \n .PHONY: all\n \ndiff --git /dev/null b/regression/apps/pty/open_pty.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/pty/open_pty.c\n@@ -0,0 +1,51 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <termios.h>\n+#include <pty.h>\n+\n+int main() {\n+    int master, slave;\n+    char name[256];\n+    struct termios term;\n+\n+    if (openpty(&master, &slave, name, NULL, NULL) == -1) {\n+        perror(\"openpty\");\n+        exit(EXIT_FAILURE);\n+    }\n+\n+    printf(\"slave name: %s\\n\", name);\n+\n+    // Set pty slave terminal attributes\n+    tcgetattr(slave, &term);\n+    term.c_lflag &= ~(ICANON | ECHO);\n+    term.c_cc[VMIN] = 1;\n+    term.c_cc[VTIME] = 0;\n+    tcsetattr(slave, TCSANOW, &term);\n+\n+    // Print to pty slave\n+    dprintf(slave, \"Hello world!\\n\");\n+\n+    // Read from pty slave\n+    char buf[256];\n+    ssize_t n = read(master, buf, sizeof(buf));\n+    if (n > 0) {\n+        printf(\"read %ld bytes from slave: %.*s\", n, (int)n, buf);\n+    }\n+\n+    // Write to pty master\n+    dprintf(master, \"hello world from master\\n\");\n+\n+    // Read from pty master\n+    char nbuf[256];\n+    ssize_t nn = read(slave, nbuf, sizeof(nbuf));\n+    if (nn > 0) {\n+        printf(\"read %ld bytes from master: %.*s\", nn, (int)nn, nbuf);\n+    }\n+\n+    close(master);\n+    close(slave);\n+\n+    return 0;\n+}\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -7,6 +7,8 @@ mod zero;\n \n use crate::fs::device::{add_node, Device, DeviceId, DeviceType};\n use crate::prelude::*;\n+pub use pty::new_pty_pair;\n+pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \ndiff --git a/services/libs/jinux-std/src/device/pty.rs /dev/null\n--- a/services/libs/jinux-std/src/device/pty.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-use crate::fs::{\n-    devpts::DevPts,\n-    fs_resolver::{FsPath, FsResolver},\n-    utils::{InodeMode, InodeType},\n-};\n-use crate::prelude::*;\n-\n-pub fn init() -> Result<()> {\n-    let fs = FsResolver::new();\n-\n-    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n-    // Create the \"pts\" directory and mount devpts on it.\n-    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n-    devpts.mount(DevPts::new())?;\n-\n-    // Create the \"ptmx\" symlink.\n-    let ptmx = dev.create(\n-        \"ptmx\",\n-        InodeType::SymLink,\n-        InodeMode::from_bits_truncate(0o777),\n-    )?;\n-    ptmx.write_link(\"pts/ptmx\")?;\n-    Ok(())\n-}\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -0,0 +1,38 @@\n+use crate::fs::devpts::DevPts;\n+use crate::fs::fs_resolver::{FsPath, FsResolver};\n+use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\n+use crate::prelude::*;\n+\n+mod pty;\n+\n+pub use pty::{PtyMaster, PtySlave};\n+use spin::Once;\n+\n+static DEV_PTS: Once<Arc<Dentry>> = Once::new();\n+\n+pub fn init() -> Result<()> {\n+    let fs = FsResolver::new();\n+\n+    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n+    // Create the \"pts\" directory and mount devpts on it.\n+    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n+    devpts.mount(DevPts::new())?;\n+\n+    DEV_PTS.call_once(|| devpts);\n+\n+    // Create the \"ptmx\" symlink.\n+    let ptmx = dev.create(\n+        \"ptmx\",\n+        InodeType::SymLink,\n+        InodeMode::from_bits_truncate(0o777),\n+    )?;\n+    ptmx.write_link(\"pts/ptmx\")?;\n+    Ok(())\n+}\n+\n+pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n+    debug!(\"pty index = {}\", index);\n+    let master = Arc::new(PtyMaster::new(ptmx, index));\n+    let slave = Arc::new(PtySlave::new(master.clone()));\n+    Ok((master, slave))\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/pty.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -0,0 +1,312 @@\n+use alloc::format;\n+use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n+\n+use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::fs_resolver::FsPath;\n+use crate::fs::utils::{AccessMode, Inode, InodeMode, IoEvents, IoctlCmd, Pollee, Poller};\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+const PTS_DIR: &str = \"/dev/pts\";\n+const BUFFER_CAPACITY: usize = 4096;\n+\n+/// Pesudo terminal master.\n+/// Internally, it has two buffers.\n+/// One is inside ldisc, which is written by master and read by slave,\n+/// the other is a ring buffer, which is written by slave and read by master.\n+pub struct PtyMaster {\n+    ptmx: Arc<dyn Inode>,\n+    index: u32,\n+    output: LineDiscipline,\n+    input: SpinLock<HeapRb<u8>>,\n+    /// The state of input buffer\n+    pollee: Pollee,\n+}\n+\n+impl PtyMaster {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n+        Self {\n+            ptmx,\n+            index,\n+            output: LineDiscipline::new(),\n+            input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            pollee: Pollee::new(IoEvents::OUT),\n+        }\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.index\n+    }\n+\n+    pub fn ptmx(&self) -> &Arc<dyn Inode> {\n+        &self.ptmx\n+    }\n+\n+    pub(super) fn slave_push_byte(&self, byte: u8) {\n+        let mut input = self.input.lock_irq_disabled();\n+        input.push_overwrite(byte);\n+        self.update_state(&input);\n+    }\n+\n+    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.output.read(buf)\n+    }\n+\n+    pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.output.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.pollee.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+\n+    pub(super) fn slave_buf_len(&self) -> usize {\n+        self.output.buffer_len()\n+    }\n+\n+    fn update_state(&self, buf: &HeapRb<u8>) {\n+        if buf.is_empty() {\n+            self.pollee.del_events(IoEvents::IN)\n+        } else {\n+            self.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+}\n+\n+impl FileLike for PtyMaster {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        // TODO: deal with nonblocking read\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let poller = Poller::new();\n+        loop {\n+            let mut input = self.input.lock_irq_disabled();\n+\n+            if input.is_empty() {\n+                let events = self.pollee.poll(IoEvents::IN, Some(&poller));\n+\n+                if events.contains(IoEvents::ERR) {\n+                    return_errno_with_message!(Errno::EACCES, \"unexpected err\");\n+                }\n+\n+                if events.is_empty() {\n+                    drop(input);\n+                    poller.wait();\n+                }\n+                continue;\n+            }\n+\n+            let read_len = input.len().min(buf.len());\n+            input.pop_slice(&mut buf[..read_len]);\n+            self.update_state(&input);\n+            return Ok(read_len);\n+        }\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let mut input = self.input.lock();\n+\n+        for character in buf {\n+            self.output.push_char(*character, |content| {\n+                for byte in content.as_bytes() {\n+                    input.push_overwrite(*byte);\n+                }\n+            });\n+        }\n+\n+        self.update_state(&input);\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                let termios = self.output.termios();\n+                write_val_to_user(arg, &termios)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TCSETS => {\n+                let termios = read_val_from_user(arg)?;\n+                self.output.set_termios(termios);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPTLCK => {\n+                // TODO: lock/unlock pty\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTN => {\n+                let idx = self.index();\n+                write_val_to_user(arg, &idx)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTPEER => {\n+                let current = current!();\n+\n+                // TODO: deal with open options\n+                let slave = {\n+                    let slave_name = {\n+                        let devpts_path = super::DEV_PTS.get().unwrap().abs_path();\n+                        format!(\"{}/{}\", devpts_path, self.index())\n+                    };\n+\n+                    let fs_path = FsPath::try_from(slave_name.as_str())?;\n+\n+                    let inode_handle = {\n+                        let fs = current.fs().read();\n+                        let flags = AccessMode::O_RDWR as u32;\n+                        let mode = (InodeMode::S_IRUSR | InodeMode::S_IWUSR).bits();\n+                        fs.open(&fs_path, flags, mode)?\n+                    };\n+                    Arc::new(inode_handle)\n+                };\n+\n+                let fd = {\n+                    let mut file_table = current.file_table().lock();\n+                    file_table.insert(slave)\n+                };\n+                Ok(fd)\n+            }\n+            IoctlCmd::TIOCGWINSZ => {\n+                let winsize = self.output.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.output.set_window_size(winsize);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO: reimplement when adding session.\n+                let foreground = {\n+                    let current = current!();\n+                    let process_group = current.process_group().lock();\n+                    process_group.clone()\n+                };\n+                self.output.set_fg(foreground);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPGRP => {\n+                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO: reimplement when adding session.\n+                self.output.set_fg(Weak::new());\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let len = self.input.lock().len() as i32;\n+                write_val_to_user(arg, &len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.pollee.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.output.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+}\n+\n+pub struct PtySlave(Arc<PtyMaster>);\n+\n+impl PtySlave {\n+    pub fn new(master: Arc<PtyMaster>) -> Self {\n+        PtySlave(master)\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.0.index()\n+    }\n+}\n+\n+impl Device for PtySlave {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> crate::fs::device::DeviceId {\n+        DeviceId::new(88, self.index() as u32)\n+    }\n+\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.slave_read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        for ch in buf {\n+            // do we need to add '\\r' here?\n+            if *ch == b'\\n' {\n+                self.0.slave_push_byte(b'\\r');\n+                self.0.slave_push_byte(b'\\n');\n+            } else {\n+                self.0.slave_push_byte(*ch);\n+            }\n+        }\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS\n+            | IoctlCmd::TCSETS\n+            | IoctlCmd::TIOCGPGRP\n+            | IoctlCmd::TIOCGPTN\n+            | IoctlCmd::TIOCGWINSZ\n+            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let buffer_len = self.0.slave_buf_len() as i32;\n+                write_val_to_user(arg, &buffer_len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.0.slave_poll(mask, poller)\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -25,6 +25,8 @@ pub struct LineDiscipline {\n     foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n+    /// Windows size,\n+    winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -72,12 +74,13 @@ impl LineDiscipline {\n             read_buffer: SpinLock::new(StaticRb::default()),\n             foreground: SpinLock::new(Weak::new()),\n             termios: SpinLock::new(KernelTermios::default()),\n+            winsize: SpinLock::new(WinSize::default()),\n             pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char(&self, mut item: u8, echo_callback: fn(&str)) {\n+    pub fn push_char<F: FnMut(&str)>(&self, mut item: u8, echo_callback: F) {\n         let termios = self.termios.lock_irq_disabled();\n         if termios.contains_icrnl() && item == b'\\r' {\n             item = b'\\n'\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -162,7 +165,7 @@ impl LineDiscipline {\n     }\n \n     // TODO: respect output flags\n-    fn output_char(&self, item: u8, termios: &KernelTermios, echo_callback: fn(&str)) {\n+    fn output_char<F: FnMut(&str)>(&self, item: u8, termios: &KernelTermios, mut echo_callback: F) {\n         match item {\n             b'\\n' => echo_callback(\"\\n\"),\n             b'\\r' => echo_callback(\"\\r\\n\"),\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -350,6 +353,18 @@ impl LineDiscipline {\n         self.current_line.lock().drain();\n         let _: Vec<_> = self.read_buffer.lock().pop_iter().collect();\n     }\n+\n+    pub fn buffer_len(&self) -> usize {\n+        self.read_buffer.lock().len()\n+    }\n+\n+    pub fn window_size(&self) -> WinSize {\n+        self.winsize.lock().clone()\n+    }\n+\n+    pub fn set_window_size(&self, winsize: WinSize) {\n+        *self.winsize.lock() = winsize;\n+    }\n }\n \n fn meet_new_line(item: u8, termios: &KernelTermios) -> bool {\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -6,7 +6,7 @@ use super::*;\n use crate::fs::utils::{IoEvents, IoctlCmd, Poller};\n use crate::prelude::*;\n use crate::process::process_group::ProcessGroup;\n-use crate::process::{process_table, Pgid};\n+use crate::process::process_table;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod driver;\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -130,7 +130,13 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGWINSZ => {\n-                // TODO:get window size\n+                let winsize = self.ldisc.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n             _ => todo!(),\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -14,22 +14,28 @@ bitflags! {\n     #[repr(C)]\n     pub struct C_IFLAGS: u32 {\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits-common.h\n-        const IGNBRK\t= 0x001;\t\t\t/* Ignore break condition */\n-        const BRKINT\t= 0x002;\t\t\t/* Signal interrupt on break */\n-        const IGNPAR\t= 0x004;\t\t\t/* Ignore characters with parity errors */\n-        const PARMRK\t= 0x008;\t\t\t/* Mark parity and framing errors */\n-        const INPCK\t    = 0x010;\t\t\t/* Enable input parity check */\n-        const ISTRIP\t= 0x020;\t\t\t/* Strip 8th bit off characters */\n-        const INLCR\t    = 0x040;\t\t\t/* Map NL to CR on input */\n-        const IGNCR\t    = 0x080;\t\t\t/* Ignore CR */\n-        const ICRNL\t    = 0x100;\t\t\t/* Map CR to NL on input */\n-        const IXANY\t    = 0x800;\t\t\t/* Any character will restart after stop */\n+        const IGNBRK  = 0x001;\t\t\t/* Ignore break condition */\n+        const BRKINT  = 0x002;\t\t\t/* Signal interrupt on break */\n+        const IGNPAR  = 0x004;\t\t\t/* Ignore characters with parity errors */\n+        const PARMRK  = 0x008;\t\t\t/* Mark parity and framing errors */\n+        const INPCK   = 0x010;\t\t\t/* Enable input parity check */\n+        const ISTRIP  = 0x020;\t\t\t/* Strip 8th bit off characters */\n+        const INLCR   = 0x040;\t\t\t/* Map NL to CR on input */\n+        const IGNCR   = 0x080;\t\t\t/* Ignore CR */\n+        const ICRNL   = 0x100;\t\t\t/* Map CR to NL on input */\n+        const IXANY   = 0x800;\t\t\t/* Any character will restart after stop */\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits.h\n-        const IUCLC\t    = 0x0200;\n-        const IXON\t    = 0x0400;\n-        const IXOFF\t    = 0x1000;\n-        const IMAXBEL\t= 0x2000;\n-        const IUTF8\t    = 0x4000;\n+        const IUCLC   = 0x0200;\n+        const IXON    = 0x0400;\n+        const IXOFF   = 0x1000;\n+        const IMAXBEL = 0x2000;\n+        const IUTF8   = 0x4000;\n+    }\n+}\n+\n+impl Default for C_IFLAGS {\n+    fn default() -> Self {\n+        C_IFLAGS::ICRNL | C_IFLAGS::IXON\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -37,18 +43,68 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_OFLAGS: u32 {\n-        const OPOST\t= 0x01;\t\t\t/* Perform output processing */\n-        const OCRNL\t= 0x08;\n-        const ONOCR\t= 0x10;\n-        const ONLRET= 0x20;\n-        const OFILL\t= 0x40;\n-        const OFDEL\t= 0x80;\n+        const OPOST  = 1 << 0;\t\t\t/* Perform output processing */\n+        const OLCUC  = 1 << 1;\n+        const ONLCR  = 1 << 2;\n+        const OCRNL  = 1 << 3;\n+        const ONOCR  = 1 << 4;\n+        const ONLRET = 1 << 5;\n+        const OFILL  = 1 << 6;\n+        const OFDEL  = 1 << 7;\n     }\n }\n \n-#[repr(u32)]\n+impl Default for C_OFLAGS {\n+    fn default() -> Self {\n+        C_OFLAGS::OPOST | C_OFLAGS::ONLCR\n+    }\n+}\n+\n+#[repr(C)]\n #[derive(Debug, Clone, Copy, Pod)]\n-pub enum C_CFLAGS {\n+pub struct C_CFLAGS(u32);\n+\n+impl Default for C_CFLAGS {\n+    fn default() -> Self {\n+        let cbaud = C_CFLAGS_BAUD::B38400 as u32;\n+        let csize = C_CFLAGS_CSIZE::CS8 as u32;\n+        let c_cflags = cbaud | csize | CREAD;\n+        Self(c_cflags)\n+    }\n+}\n+\n+impl C_CFLAGS {\n+    pub fn cbaud(&self) -> Result<C_CFLAGS_BAUD> {\n+        let cbaud = self.0 & CBAUD_MASK;\n+        Ok(C_CFLAGS_BAUD::try_from(cbaud)?)\n+    }\n+\n+    pub fn csize(&self) -> Result<C_CFLAGS_CSIZE> {\n+        let csize = self.0 & CSIZE_MASK;\n+        Ok(C_CFLAGS_CSIZE::try_from(csize)?)\n+    }\n+\n+    pub fn cread(&self) -> bool {\n+        self.0 & CREAD != 0\n+    }\n+}\n+\n+const CREAD: u32 = 0x00000080;\n+const CBAUD_MASK: u32 = 0x0000100f;\n+const CSIZE_MASK: u32 = 0x00000030;\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_CSIZE {\n+    CS5 = 0x00000000,\n+    CS6 = 0x00000010,\n+    CS7 = 0x00000020,\n+    CS8 = 0x00000030,\n+}\n+\n+#[repr(u32)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_BAUD {\n     B0 = 0x00000000, /* hang up */\n     B50 = 0x00000001,\n     B75 = 0x00000002,\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -71,28 +127,41 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_LFLAGS: u32 {\n-        const ISIG\t=   0x00001;\n-        const ICANON=   0x00002;\n-        const XCASE\t=   0x00004;\n-        const ECHO\t=   0x00008;\n-        const ECHOE\t=   0x00010;\n-        const ECHOK\t=   0x00020;\n-        const ECHONL=\t0x00040;\n-        const NOFLSH=\t0x00080;\n-        const TOSTOP=\t0x00100;\n-        const ECHOCTL=\t0x00200;\n-        const ECHOPRT=\t0x00400;\n-        const ECHOKE=   0x00800;\n-        const FLUSHO=\t0x01000;\n-        const PENDIN=\t0x04000;\n-        const IEXTEN=\t0x08000;\n-        const EXTPROC=\t0x10000;\n+        const ISIG    = 0x00001;\n+        const ICANON  = 0x00002;\n+        const XCASE   = 0x00004;\n+        const ECHO    = 0x00008;\n+        const ECHOE   = 0x00010;\n+        const ECHOK   = 0x00020;\n+        const ECHONL  = 0x00040;\n+        const NOFLSH  = 0x00080;\n+        const TOSTOP  = 0x00100;\n+        const ECHOCTL = 0x00200;\n+        const ECHOPRT = 0x00400;\n+        const ECHOKE  = 0x00800;\n+        const FLUSHO  = 0x01000;\n+        const PENDIN  = 0x04000;\n+        const IEXTEN  = 0x08000;\n+        const EXTPROC = 0x10000;\n+    }\n+}\n+\n+impl Default for C_LFLAGS {\n+    fn default() -> Self {\n+        C_LFLAGS::ICANON\n+            | C_LFLAGS::ECHO\n+            | C_LFLAGS::ISIG\n+            | C_LFLAGS::ECHOE\n+            | C_LFLAGS::ECHOK\n+            | C_LFLAGS::ECHOCTL\n+            | C_LFLAGS::ECHOKE\n+            | C_LFLAGS::IEXTEN\n     }\n }\n \n /* c_cc characters index*/\n #[repr(u32)]\n-#[derive(Debug, Clone, Copy, Pod)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum CC_C_CHAR {\n     VINTR = 0,\n     VQUIT = 1,\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -114,61 +183,28 @@ pub enum CC_C_CHAR {\n }\n \n impl CC_C_CHAR {\n-    // The special char is the same as ubuntu\n-    pub fn char(&self) -> u8 {\n+    // The special char is from gvisor\n+    pub fn default_char(&self) -> u8 {\n         match self {\n-            CC_C_CHAR::VINTR => 3,\n-            CC_C_CHAR::VQUIT => 28,\n-            CC_C_CHAR::VERASE => 127,\n-            CC_C_CHAR::VKILL => 21,\n-            CC_C_CHAR::VEOF => 4,\n-            CC_C_CHAR::VTIME => 0,\n+            CC_C_CHAR::VINTR => control_character('C'),\n+            CC_C_CHAR::VQUIT => control_character('\\\\'),\n+            CC_C_CHAR::VERASE => '\\x7f' as u8,\n+            CC_C_CHAR::VKILL => control_character('U'),\n+            CC_C_CHAR::VEOF => control_character('D'),\n+            CC_C_CHAR::VTIME => '\\0' as u8,\n             CC_C_CHAR::VMIN => 1,\n-            CC_C_CHAR::VSWTC => 0,\n-            CC_C_CHAR::VSTART => 17,\n-            CC_C_CHAR::VSTOP => 19,\n-            CC_C_CHAR::VSUSP => 26,\n-            CC_C_CHAR::VEOL => 255,\n-            CC_C_CHAR::VREPRINT => 18,\n-            CC_C_CHAR::VDISCARD => 15,\n-            CC_C_CHAR::VWERASE => 23,\n-            CC_C_CHAR::VLNEXT => 22,\n-            CC_C_CHAR::VEOL2 => 255,\n+            CC_C_CHAR::VSWTC => '\\0' as u8,\n+            CC_C_CHAR::VSTART => control_character('Q'),\n+            CC_C_CHAR::VSTOP => control_character('S'),\n+            CC_C_CHAR::VSUSP => control_character('Z'),\n+            CC_C_CHAR::VEOL => '\\0' as u8,\n+            CC_C_CHAR::VREPRINT => control_character('R'),\n+            CC_C_CHAR::VDISCARD => control_character('O'),\n+            CC_C_CHAR::VWERASE => control_character('W'),\n+            CC_C_CHAR::VLNEXT => control_character('V'),\n+            CC_C_CHAR::VEOL2 => '\\0' as u8,\n         }\n     }\n-\n-    pub fn as_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    pub fn from_char(item: u8) -> Result<Self> {\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VQUIT.char() {\n-            return Ok(Self::VQUIT);\n-        }\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VERASE.char() {\n-            return Ok(Self::VERASE);\n-        }\n-        if item == Self::VEOF.char() {\n-            return Ok(Self::VEOF);\n-        }\n-        if item == Self::VSTART.char() {\n-            return Ok(Self::VSTART);\n-        }\n-        if item == Self::VSTOP.char() {\n-            return Ok(Self::VSTOP);\n-        }\n-        if item == Self::VSUSP.char() {\n-            return Ok(Self::VSUSP);\n-        }\n-\n-        return_errno_with_message!(Errno::EINVAL, \"Not a valid cc_char\");\n-    }\n }\n \n #[derive(Debug, Clone, Copy, Pod)]\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -185,50 +221,39 @@ pub struct KernelTermios {\n impl KernelTermios {\n     pub fn default() -> Self {\n         let mut termios = Self {\n-            c_iflags: C_IFLAGS::ICRNL,\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::ICANON | C_LFLAGS::ECHO,\n+            c_iflags: C_IFLAGS::default(),\n+            c_oflags: C_OFLAGS::default(),\n+            c_cflags: C_CFLAGS::default(),\n+            c_lflags: C_LFLAGS::default(),\n             c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n+            c_cc: [CcT::default(); KERNEL_NCCS],\n         };\n-        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.default_char();\n         termios\n     }\n \n-    fn new() -> Self {\n-        KernelTermios {\n-            c_iflags: C_IFLAGS::empty(),\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::empty(),\n-            c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n-        }\n-    }\n-\n     pub fn get_special_char(&self, cc_c_char: CC_C_CHAR) -> &CcT {\n-        &self.c_cc[cc_c_char.as_usize()]\n+        &self.c_cc[cc_c_char as usize]\n     }\n \n     pub fn get_special_char_mut(&mut self, cc_c_char: CC_C_CHAR) -> &mut CcT {\n-        &mut self.c_cc[cc_c_char.as_usize()]\n+        &mut self.c_cc[cc_c_char as usize]\n     }\n \n     /// Canonical mode means we will handle input by lines, not by single character\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -265,3 +290,17 @@ impl KernelTermios {\n         self.c_lflags.contains(C_LFLAGS::IEXTEN)\n     }\n }\n+\n+const fn control_character(c: char) -> u8 {\n+    debug_assert!(c as u8 >= 'A' as u8);\n+    c as u8 - 'A' as u8 + 1u8\n+}\n+\n+#[derive(Debug, Clone, Copy, Default, Pod)]\n+#[repr(C)]\n+pub struct WinSize {\n+    ws_row: u16,\n+    ws_col: u16,\n+    ws_xpixel: u16,\n+    ws_ypixel: u16,\n+}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -1,7 +1,9 @@\n-use crate::prelude::*;\n+use crate::{fs::file_handle::FileLike, prelude::*};\n \n use super::*;\n \n+use crate::device::PtyMaster;\n+\n /// Pty master inode for the master device.\n pub struct PtyMasterInode(Arc<PtyMaster>);\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -14,8 +16,11 @@ impl PtyMasterInode {\n impl Drop for PtyMasterInode {\n     fn drop(&mut self) {\n         // Remove the slave from fs.\n-        let index = self.0.slave_index();\n-        let _ = self.0.ptmx().devpts().remove_slave(index);\n+        let fs = self.0.ptmx().fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.0.index();\n+        devpts.remove_slave(index);\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -77,52 +82,6 @@ impl Inode for PtyMasterInode {\n     }\n \n     fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().devpts()\n-    }\n-}\n-\n-// TODO: implement real pty master.\n-pub struct PtyMaster {\n-    slave_index: u32,\n-    ptmx: Arc<Ptmx>,\n-}\n-\n-impl PtyMaster {\n-    pub fn new(slave_index: u32, ptmx: Arc<Ptmx>) -> Arc<Self> {\n-        Arc::new(Self { slave_index, ptmx })\n-    }\n-\n-    pub fn slave_index(&self) -> u32 {\n-        self.slave_index\n-    }\n-\n-    fn ptmx(&self) -> &Ptmx {\n-        &self.ptmx\n-    }\n-}\n-\n-impl Device for PtyMaster {\n-    fn type_(&self) -> DeviceType {\n-        self.ptmx.device_type()\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        self.ptmx.device_id()\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n+        self.0.ptmx().fs()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,9 +9,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::{PtyMaster, PtyMasterInode};\n+use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n-use self::slave::{PtySlave, PtySlaveInode};\n+use self::slave::PtySlaveInode;\n \n mod master;\n mod ptmx;\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -60,8 +60,7 @@ impl DevPts {\n             .alloc()\n             .ok_or_else(|| Error::with_message(Errno::EIO, \"cannot alloc index\"))?;\n \n-        let master = PtyMaster::new(index as u32, self.root.ptmx.clone());\n-        let slave = PtySlave::new(master.clone());\n+        let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n         let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -2,6 +2,8 @@ use crate::prelude::*;\n \n use super::*;\n \n+use crate::device::PtySlave;\n+\n /// Same major number with Linux, the minor number is the index of slave.\n const SLAVE_MAJOR_NUM: u32 = 3;\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -88,44 +90,3 @@ impl Inode for PtySlaveInode {\n         self.fs.upgrade().unwrap()\n     }\n }\n-\n-// TODO: implement real pty slave.\n-pub struct PtySlave {\n-    master: Arc<PtyMaster>,\n-}\n-\n-impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self { master })\n-    }\n-\n-    pub fn index(&self) -> u32 {\n-        self.master.slave_index()\n-    }\n-}\n-\n-impl Device for PtySlave {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        DeviceId::new(SLAVE_MAJOR_NUM, self.index())\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n--- a/services/libs/jinux-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n@@ -3,18 +3,30 @@ use crate::prelude::*;\n #[repr(u32)]\n #[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum IoctlCmd {\n-    // Get terminal attributes\n+    /// Get terminal attributes\n     TCGETS = 0x5401,\n     TCSETS = 0x5402,\n-    // Drain the output buffer and set attributes\n+    /// Drain the output buffer and set attributes\n     TCSETSW = 0x5403,\n-    // Drain the output buffer, and discard pending input, and set attributes\n+    /// Drain the output buffer, and discard pending input, and set attributes\n     TCSETSF = 0x5404,\n-    // Get the process group ID of the foreground process group on this terminal\n+    /// Make the given terminal the controlling terminal of the calling process.\n+    TIOCSCTTY = 0x540e,\n+    /// Get the process group ID of the foreground process group on this terminal\n     TIOCGPGRP = 0x540f,\n-    // Set the foreground process group ID of this terminal.\n+    /// Set the foreground process group ID of this terminal.\n     TIOCSPGRP = 0x5410,\n-    // Set window size\n+    /// Get the number of bytes in the input buffer.\n+    FIONREAD = 0x541B,\n+    /// Set window size\n     TIOCGWINSZ = 0x5413,\n     TIOCSWINSZ = 0x5414,\n+    /// the calling process gives up this controlling terminal\n+    TIOCNOTTY = 0x5422,\n+    /// Get Pty Number\n+    TIOCGPTN = 0x80045430,\n+    /// Lock/unlock Pty\n+    TIOCSPTLCK = 0x40045431,\n+    /// Safely open the slave\n+    TIOCGPTPEER = 0x40045441,\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -146,6 +146,7 @@ impl Vnode {\n         if let Some(page_cache) = &inner.page_cache {\n             page_cache.evict_range(0..file_len);\n         }\n+\n         inner.inode.read_at(0, &mut buf[..file_len])\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -196,11 +197,13 @@ impl Vnode {\n     }\n \n     pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.inner.read().inode.poll(mask, poller)\n+        let inode = self.inner.read().inode.clone();\n+        inode.poll(mask, poller)\n     }\n \n     pub fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.inner.read().inode.ioctl(cmd, arg)\n+        let inode = self.inner.read().inode.clone();\n+        inode.ioctl(cmd, arg)\n     }\n \n     pub fn fs(&self) -> Arc<dyn FileSystem> {\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -150,12 +150,27 @@ impl VmMapping {\n     }\n     pub fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         let vmo_read_offset = self.vmo_offset() + offset;\n+\n+        // TODO: the current logic is vulnerable to TOCTTOU attack, since the permission may change after check.\n+        let page_idx_range = get_page_idx_range(&(vmo_read_offset..vmo_read_offset + buf.len()));\n+        let read_perm = VmPerm::R;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &read_perm)?;\n+        }\n+\n         self.vmo.read_bytes(vmo_read_offset, buf)?;\n         Ok(())\n     }\n \n     pub fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         let vmo_write_offset = self.vmo_offset() + offset;\n+\n+        let page_idx_range = get_page_idx_range(&(vmo_write_offset..vmo_write_offset + buf.len()));\n+        let write_perm = VmPerm::W;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &write_perm)?;\n+        }\n+\n         self.vmo.write_bytes(vmo_write_offset, buf)?;\n         Ok(())\n     }\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -198,7 +213,9 @@ impl VmMapping {\n         } else {\n             self.vmo.check_rights(Rights::READ)?;\n         }\n-        self.check_perm(&page_idx, write)?;\n+\n+        let required_perm = if write { VmPerm::W } else { VmPerm::R };\n+        self.check_perm(&page_idx, &required_perm)?;\n \n         let frame = self.vmo.get_committed_frame(page_idx, write)?;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -300,8 +317,8 @@ impl VmMapping {\n         self.inner.lock().trim_right(vm_space, vaddr)\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n-        self.inner.lock().check_perm(page_idx, write)\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n+        self.inner.lock().check_perm(page_idx, perm)\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -457,16 +474,14 @@ impl VmMappingInner {\n         self.map_to_addr..self.map_to_addr + self.map_size\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n         let page_perm = self\n             .page_perms\n             .get(&page_idx)\n             .ok_or(Error::with_message(Errno::EINVAL, \"invalid page idx\"))?;\n-        if !page_perm.contains(VmPerm::R) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should at least contain read\");\n-        }\n-        if write && !page_perm.contains(VmPerm::W) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should contain write for write access\");\n+\n+        if !page_perm.contains(*perm) {\n+            return_errno_with_message!(Errno::EACCES, \"perm check fails\");\n         }\n \n         Ok(())\n",
        "test_patch": "",
        "problem_statement": "Implement pseudo terminals\nMaybe we need #209 for pty, since each pty will be a device under devfs.\n",
        "hints_text": "",
        "created_at": "2023-08-01T06:37:18Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 561,
        "instance_id": "asterinas__asterinas-561",
        "issue_numbers": [
            "551"
        ],
        "base_commit": "6dbf5d560deafea0dcec228e4cb2d5e53c756174",
        "patch": "diff --git a/.cargo/config.toml b/.cargo/config.toml\n--- a/.cargo/config.toml\n+++ b/.cargo/config.toml\n@@ -1,6 +1,6 @@\n \n [target.'cfg(target_os = \"none\")']\n-runner = \"cargo run --package jinux-runner --\"\n+runner = \"cargo run --package aster-runner --\"\n \n [alias]\n kcheck = \"check --target x86_64-custom.json -Zbuild-std=core,alloc,compiler_builtins -Zbuild-std-features=compiler-builtins-mem\"\ndiff --git a/.github/workflows/docker_build.yml b/.github/workflows/docker_build.yml\n--- a/.github/workflows/docker_build.yml\n+++ b/.github/workflows/docker_build.yml\n@@ -26,7 +26,7 @@ jobs:\n       - name: Fetch versions in the repo\n         id: fetch-versions\n         run: |\n-          echo \"jinux_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n+          echo \"aster_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n           echo \"rust_version=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' rust-toolchain.toml )\" >> \"$GITHUB_OUTPUT\"\n \n       - name: Build and push\ndiff --git a/.github/workflows/docker_build.yml b/.github/workflows/docker_build.yml\n--- a/.github/workflows/docker_build.yml\n+++ b/.github/workflows/docker_build.yml\n@@ -36,6 +36,6 @@ jobs:\n           file: ./tools/docker/Dockerfile.ubuntu22.04\n           platforms: linux/amd64\n           push: true\n-          tags: jinuxdev/jinux:${{ steps.fetch-versions.outputs.jinux_version }}\n+          tags: asterinas/asterinas:${{ steps.fetch-versions.outputs.aster_version }}\n           build-args: |\n-            \"JINUX_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\n+            \"ASTER_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\ndiff --git a/COPYRIGHT b/COPYRIGHT\n--- a/COPYRIGHT\n+++ b/COPYRIGHT\n@@ -1,9 +1,9 @@\n-The Jinux project licensed under the GNU General Public License version 2.\n+The Asterinas project licensed under the GNU General Public License version 2.\n \n-Copyrights in the Jinux project are retained by their contributors. No\n-copyright assignment is required to contribute to the Jinux project.\n+Copyrights in the Asterinas project are retained by their contributors. No\n+copyright assignment is required to contribute to the Asterinas project.\n For full authorship information, see the version control history.\n \n-Please note that certain files or directories within the Jinux project may \n+Please note that certain files or directories within the Asterinas project may \n contain explicit copyright notices and/or license notices differ\n from the project's general license terms.\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -552,7 +796,7 @@ dependencies = [\n [[package]]\n name = \"inherit-methods-macro\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n+source = \"git+https://github.com/asterinas/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n dependencies = [\n  \"darling\",\n  \"proc-macro2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -918,7 +918,7 @@ checksum = \"b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3\"\n [[package]]\n name = \"libflate\"\n version = \"1.4.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"adler32\",\n  \"core2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -929,7 +929,7 @@ dependencies = [\n [[package]]\n name = \"libflate_lz77\"\n version = \"1.2.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"core2\",\n  \"hashbrown 0.13.2\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1059,7 +1059,7 @@ checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n [[package]]\n name = \"pod\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"pod-derive\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1067,7 +1067,7 @@ dependencies = [\n [[package]]\n name = \"pod-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1428,7 +1428,7 @@ dependencies = [\n [[package]]\n name = \"trapframe\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/jinzhao-dev/trapframe-rs?rev=9758a83#9758a83f769c8f4df35413c7ad28ef42c270187e\"\n+source = \"git+https://github.com/asterinas/trapframe-rs?rev=2f37590#2f375901398508edb554deb2f84749153a59bb4a\"\n dependencies = [\n  \"log\",\n  \"pod\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,21 +1,21 @@\n [package]\n-name = \"jinux\"\n+name = \"asterinas\"\n version = \"0.2.2\"\n edition = \"2021\"\n \n [[bin]]\n-name = \"jinux\"\n+name = \"asterinas\"\n path = \"kernel/main.rs\"\n \n [dependencies]\n-jinux-frame = { path = \"framework/jinux-frame\" }\n-jinux-std = { path = \"services/libs/jinux-std\" }\n+aster-frame = { path = \"framework/aster-frame\" }\n+aster-std = { path = \"services/libs/aster-std\" }\n component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\n-jinux-time = { path = \"services/comps/time\" }\n-jinux-framebuffer = { path = \"services/comps/framebuffer\" }\n+aster-time = { path = \"services/comps/time\" }\n+aster-framebuffer = { path = \"services/comps/framebuffer\" }\n \n [profile.dev]\n opt-level = 0\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -48,10 +48,10 @@ members = [\n     \"services/libs/cpio-decoder\",\n     \"services/libs/int-to-c-enum\",\n     \"services/libs/int-to-c-enum/derive\",\n-    \"services/libs/jinux-rights\",\n-    \"services/libs/jinux-rights-proc\",\n-    \"services/libs/jinux-std\",\n-    \"services/libs/jinux-util\",\n+    \"services/libs/aster-rights\",\n+    \"services/libs/aster-rights-proc\",\n+    \"services/libs/aster-std\",\n+    \"services/libs/aster-util\",\n     \"services/libs/keyable-arc\",\n     \"services/libs/typeflags\",\n     \"services/libs/typeflags-util\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -65,4 +65,4 @@ exclude = [\n ]\n \n [features]\n-intel_tdx = [\"jinux-frame/intel_tdx\", \"jinux-std/intel_tdx\"]\n+intel_tdx = [\"aster-frame/intel_tdx\", \"aster-std/intel_tdx\"]\ndiff --git a/Components.toml b/Components.toml\n--- a/Components.toml\n+++ b/Components.toml\n@@ -1,14 +1,14 @@\n # template\n [components]\n-std = { name = \"jinux-std\" }\n-virtio = { name = \"jinux-virtio\" }\n-input = { name = \"jinux-input\" }\n-block = { name = \"jinux-block\" }\n-console = { name = \"jinux-console\" }\n-time = { name = \"jinux-time\" }\n-framebuffer = { name = \"jinux-framebuffer\" }\n-network = { name = \"jinux-network\" }\n-main = { name = \"jinux\" }\n+std = { name = \"aster-std\" }\n+virtio = { name = \"aster-virtio\" }\n+input = { name = \"aster-input\" }\n+block = { name = \"aster-block\" }\n+console = { name = \"aster-console\" }\n+time = { name = \"aster-time\" }\n+framebuffer = { name = \"aster-framebuffer\" }\n+network = { name = \"aster-network\" }\n+main = { name = \"asterinas\" }\n \n [whitelist]\n [whitelist.std.run_first_process]\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,4 +1,4 @@\n-# Make varaiables and defaults, you should refer to jinux-runner for more details\n+# Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\n BOOT_PROTOCOL ?= multiboot2\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -92,8 +92,8 @@ USERMODE_TESTABLE := \\\n     services/libs/cpio-decoder \\\n     services/libs/int-to-c-enum \\\n     services/libs/int-to-c-enum/derive \\\n-    services/libs/jinux-rights \\\n-    services/libs/jinux-rights-proc \\\n+    services/libs/aster-rights \\\n+    services/libs/aster-rights-proc \\\n     services/libs/keyable-arc \\\n     services/libs/typeflags \\\n     services/libs/typeflags-util\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -231,6 +231,6 @@ Jinux is under active development. The list below summarizes the progress of imp\n \n ## License\n \n-The Jinux project is proudly released as a free software\n+The Asterinas project is proudly released as a free software\n under the license of [GNU General Public License version 2](LICENSE-GPL).\n See [COPYRIGHT](COPYRIGHT) for details.\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -5,7 +5,7 @@ fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n     let linker_script_path = if target == \"x86_64\" {\n         PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap())\n             .join(\"framework\")\n-            .join(\"jinux-frame\")\n+            .join(\"aster-frame\")\n             .join(\"src\")\n             .join(\"arch\")\n             .join(\"x86\")\ndiff --git a/docs/README.md b/docs/README.md\n--- a/docs/README.md\n+++ b/docs/README.md\n@@ -1,4 +1,4 @@\n-# Jinux Documentation\n+# Asterinas Documentation\n \n The documentation is rendered as a book with [mdBook](https://rust-lang.github.io/mdBook/),\n which can be installed with `cargo`.\ndiff --git a/docs/book.toml b/docs/book.toml\n--- a/docs/book.toml\n+++ b/docs/book.toml\n@@ -3,7 +3,7 @@ authors = [\"Tate, Hongliang Tian\"]\n language = \"en\"\n multilingual = false\n src = \"src\"\n-title = \"Jinux: A Secure, Fast, and Modern OS in Rust\"\n+title = \"Asterinas: A Secure, Fast, and Modern OS in Rust\"\n \n [rust]\n edition = \"2021\"\ndiff --git a/docs/src/README.md b/docs/src/README.md\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -14,7 +14,7 @@\n \n # Introduction\n \n-This document describes Jinux, a secure, fast, and modern OS written in Rust.\n+This document describes Asterinas, a secure, fast, and modern OS written in Rust.\n \n As the project is a work in progress, this document is by no means complete.\n Despite the incompleteness, this evolving document serves several important purposes:\ndiff --git a/docs/src/README.md b/docs/src/README.md\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -50,7 +50,7 @@ OSes, e.g., [Kerla](https://github.com/nuta/kerla),\n and [zCore](https://github.com/rcore-os/zCore). Despite their varying degrees of\n success, none of them are general-purpose, industrial-strength OSes that are or\n will ever be competitive with Linux. Eventually, a winner will emerge out of this\n-market of Rust OSes, and Jinux is our bet for this competition.\n+market of Rust OSes, and Asterinas is our bet for this competition.\n \n Second, Rust OSes are a perfect fit for\n [Trusted Execution Environments (TEEs)](https://en.wikipedia.org/wiki/Trusted_execution_environment).\ndiff --git a/docs/src/capabilities/README.md b/docs/src/capabilities/README.md\n--- a/docs/src/capabilities/README.md\n+++ b/docs/src/capabilities/README.md\n@@ -20,12 +20,12 @@ capabilities in a limited fashion, mostly as a means to limit the access from\n external users (e.g., via syscall), rather than a mechanism to enforce advanced\n security policies internally (e.g., module-level isolation).\n \n-So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Jinux to enhance the security and robustness of the\n+So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Asterinas to enhance the security and robustness of the\n OS? Specifically, we propose a new principle called \"_everything is a capability_\".\n Here, \"everything\" refers to any type of OS resource, internal or external alike.\n In traditional OSes, treating everything as a capability is unrewarding \n because (1) capabilities themselves are unreliable due to memory safety problems\n-, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Jinux.\n+, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Asterinas.\n Because the odds of memory safety bugs are minimized and \n advanced Rust features like type-level programming allow us to implement\n capabilities as a zero-cost abstraction.\ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -1,6 +1,6 @@\n # Zero-Cost Capabilities\n \n-To strengthen the security of Jinux, we aim to implement all kinds of OS resources\n+To strengthen the security of Asterinas, we aim to implement all kinds of OS resources\n as capabilities. As the capabilities are going to be used throughout the OS,\n it is highly desirable to minimize their costs. For this purpose,\n we want to implement capabilities as a _zero-cost abstraction_.\ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -376,7 +376,7 @@ typeflags! {\n }\n ```\n \n-The `Jinux-rights-proc/lib.rs` file implements the `require` procedural macro.\n+The `aster-rights-proc/lib.rs` file implements the `require` procedural macro.\n See the channel capability example later for how `require` is used.\n \n ```rust\ndiff --git a/docs/src/privilege_separation/README.md b/docs/src/privilege_separation/README.md\n--- a/docs/src/privilege_separation/README.md\n+++ b/docs/src/privilege_separation/README.md\n@@ -1,15 +1,15 @@\n # Privilege Separation\n \n-One fundamental design goal of Jinux is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Jinux can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n+One fundamental design goal of Asterinas is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Asterinas can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n \n To put privilege separation into perspective, let's compare the architectures\n-of the monolithic kernels, microkernels, and Jinux.\n+of the monolithic kernels, microkernels, and Asterinas.\n \n ![Arch comparison](../images/arch_comparison.png)\n \n The diagram above highlights the characteristics of different OS architectures \n in terms of communication overheads and the TCB for memory safety.\n-Thanks to privilege separation, Jinux promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n+Thanks to privilege separation, Asterinas promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n \n Privilege separation is an interesting research problem, prompting us to \n answer a series of technical questions.\ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -22,7 +22,7 @@ Here are some of the elements in PCI-based Virtio devices that may involve `unsa\n ### Privileged part\n \n ```rust\n-// file: jinux-core-libs/pci-io-port/lib.rs\n+// file: aster-core-libs/pci-io-port/lib.rs\n use x86::IoPort;\n \n /// The I/O port to write an address in the PCI \ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -49,7 +49,7 @@ pub const PCI_DATA_PORT: IoPort<u32> = {\n ### Unprivileged part\n \n ```rust\n-// file: jinux-comps/pci/lib.rs\n+// file: aster-comps/pci/lib.rs\n use pci_io_port::{PCI_ADDR_PORT, PCI_DATA_PORT};\n \n /// The PCI configuration space, which enables the discovery,\ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -128,7 +128,7 @@ pub struct PciCapabilities {\n Most code of Virtio drivers can be unprivileged thanks to the abstractions of `VmPager` and `VmCell` provided by the OS core.\n \n ```rust\n-// file: jinux-comp-libs/virtio/transport.rs\n+// file: aster-comp-libs/virtio/transport.rs\n \n /// The transport layer for configuring a Virtio device.\n pub struct VirtioTransport {\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -138,7 +138,7 @@ impl<T, P: Write> UserPtr<T, P> {\n }\n ```\n \n-The examples reveal two important considerations in designing Jinux:\n+The examples reveal two important considerations in designing Asterinas:\n 1. Exposing _truly_ safe APIs. The privileged OS core must expose _truly safe_ APIs: however buggy or silly the unprivileged OS components may be written, they must _not_ cause undefined behaviors.\n 2. Handling _arbitrary_ pointers safely. The safe API of the OS core must provide a safe way to deal with arbitrary pointers.\n \ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -146,15 +146,15 @@ With the two points in mind, let's get back to our main goal of privilege separa\n \n ## Code organization with privilege separation\n \n-Our first step is to separate privileged and unprivileged code in the codebase of Jinux. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n+Our first step is to separate privileged and unprivileged code in the codebase of Asterinas. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n \n ```text\n .\n-\u251c\u2500\u2500 jinux\n+\u251c\u2500\u2500 asterinas\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core\n+\u251c\u2500\u2500 aster-core\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 lib.rs\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 syscall_handler.rs\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -162,7 +162,7 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502   \u2502       \u251c\u2500\u2500 vmo.rs\n \u2502   \u2502       \u2514\u2500\u2500 vmar.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core-libs\n+\u251c\u2500\u2500 aster-core-libs\n \u2502   \u251c\u2500\u2500 linux-abi-types\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 lib.rs\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -171,34 +171,34 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502      \u00a0\u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-comps\n+\u251c\u2500\u2500 aster-comps\n \u2502 \u00a0 \u2514\u2500\u2500 linux-syscall\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502     \u00a0\u00a0\u2514\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 jinux-comp-libs\n+\u2514\u2500\u2500 aster-comp-libs\n  \u00a0\u00a0 \u2514\u2500\u2500 linux-abi\n         \u251c\u2500\u2500 src\n       \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n      \u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml \n ```\n \n-The ultimate build target of the codebase is the `jinux` crate, which is an OS kernel that consists of a privileged OS core (crate `jinux-core`) and multiple OS components (the crates under `jinux-comps/`).\n+The ultimate build target of the codebase is the `asterinas` crate, which is an OS kernel that consists of a privileged OS core (crate `aster-core`) and multiple OS components (the crates under `aster-comps/`).\n \n-For the sake of privilege separation, only crate `jinux` and `jinux-core` along with the crates under `jinux-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `jinux-comps/` along with their dependent crates under `jinux-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `jinux-core` or the crates under `jinux-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `jinux` and `jinux-core` crate plus the crates under `jinux-core-libs/`.\n+For the sake of privilege separation, only crate `asterinas` and `aster-core` along with the crates under `aster-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `aster-comps/` along with their dependent crates under `aster-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `aster-core` or the crates under `aster-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `asterinas` and `aster-core` crate plus the crates under `aster-core-libs/`.\n \n-Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `jinux-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n+Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `aster-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n \n-## Crate `jinux-core`\n+## Crate `aster-core`\n \n-For our purposes here, the two most relevant APIs provided by `jinux-core` is the abstraction for syscall handlers and virtual memory (VM).\n+For our purposes here, the two most relevant APIs provided by `aster-core` is the abstraction for syscall handlers and virtual memory (VM).\n \n ### Syscall handlers\n \n The `SyscallHandler` abstraction enables the OS core to hide the low-level, architectural-dependent aspects of syscall handling workflow (e.g., user-kernel switching and CPU register manipulation) and allow the unprivileged OS components to implement system calls.\n \n ```rust\n-// file: jinux-core/src/syscall_handler.rs\n+// file: aster-core/src/syscall_handler.rs\n \n pub trait SyscallHandler {\n     fn handle_syscall(&self, ctx: &mut SyscallContext);\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -243,8 +243,8 @@ an important concept that we will elaborate on later. Basically, they are capabi\n Here we demonstrate how to leverage the APIs of `ksos-core` to implement system calls with safe Rust code in crate `linux-syscall`.\n \n ```rust\n-// file: jinux-comps/linux-syscall/src/lib.rs\n-use jinux_core::{SyscallContext, SyscallHandler, Vmar};\n+// file: aster-comps/linux-syscall/src/lib.rs\n+use aster_core::{SyscallContext, SyscallHandler, Vmar};\n use linux_abi::{SyscallNum::*, UserPtr, RawFd, RawTimeVal, RawTimeZone};\n \n pub struct SampleHandler;\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -315,7 +315,7 @@ impl SampleHandler {\n This crate defines a marker trait `Pod`, which represents plain-old data.\n \n ```rust\n-/// file: jinux-core-libs/pod/src/lib.rs\n+/// file: aster-core-libs/pod/src/lib.rs\n \n /// A marker trait for plain old data (POD).\n ///\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -388,7 +388,7 @@ unsafe impl<T: Pod, const N> [T; N] for Pod {}\n ## Crate `linux-abi-type`\n \n ```rust\n-// file: jinux-core-libs/linux-abi-types\n+// file: aster-core-libs/linux-abi-types\n use pod::Pod;\n \n pub type RawFd = i32;\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -404,7 +404,7 @@ unsafe impl Pod for RawTimeVal {}\n ## Crate `linux-abi`\n \n ```rust\n-// file: jinux-comp-libs/linux-abi\n+// file: aster-comp-libs/linux-abi\n pub use linux_abi_types::*;\n \n pub enum SyscallNum {\ndiff --git a/framework/jinux-frame/Cargo.toml b/framework/aster-frame/Cargo.toml\n--- a/framework/jinux-frame/Cargo.toml\n+++ b/framework/aster-frame/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame\"\n+name = \"aster-frame\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/framework/jinux-frame/build.rs b/framework/aster-frame/build.rs\n--- a/framework/jinux-frame/build.rs\n+++ b/framework/aster-frame/build.rs\n@@ -32,7 +32,7 @@ fn build_linux_setup_header(\n \n     let cargo = std::env::var(\"CARGO\").unwrap();\n     let mut cmd = std::process::Command::new(cargo);\n-    cmd.arg(\"install\").arg(\"jinux-frame-x86-boot-linux-setup\");\n+    cmd.arg(\"install\").arg(\"aster-frame-x86-boot-linux-setup\");\n     cmd.arg(\"--debug\");\n     cmd.arg(\"--locked\");\n     cmd.arg(\"--path\").arg(setup_crate_dir.to_str().unwrap());\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n@@ -3,7 +3,7 @@\n //! The bootloader will deliver the address of the `BootParams` struct\n //! as the argument of the kernel entrypoint. So we must define a Linux\n //! ABI compatible struct in Rust, despite that most of the fields are\n-//! currently not needed by Jinux.\n+//! currently not needed by Asterinas.\n //!\n \n #[derive(Copy, Clone, Debug)]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -152,5 +152,5 @@ unsafe extern \"sysv64\" fn __linux64_boot(params_ptr: *const boot_params::BootPar\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame-x86-boot-linux-setup\"\n+name = \"aster-frame-x86-boot-linux-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n@@ -9,8 +9,8 @@\n // Some of the fields filled with a 0xab* values should be filled\n // by the runner, which is the only tool after building and can\n // access the info of the payload.\n-// Jinux will use only a few of these fields, and some of them\n-// are filled by the loader and will be read by Jinux.\n+// Asterinas will use only a few of these fields, and some of them\n+// are filled by the loader and will be read by Asterinas.\n \n CODE32_START = 0x100000\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n@@ -24,6 +24,6 @@ pub fn load_elf(file: &[u8]) -> u32 {\n         }\n     }\n \n-    // Return the Linux 32-bit Boot Protocol entry point defined by Jinux.\n+    // Return the Linux 32-bit Boot Protocol entry point defined by Asterinas.\n     0x8001000\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n@@ -9,7 +9,7 @@ use core::arch::{asm, global_asm};\n \n global_asm!(include_str!(\"header.S\"));\n \n-unsafe fn call_jinux_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n+unsafe fn call_aster_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n     asm!(\"mov esi, {}\", in(reg) boot_params_ptr);\n     asm!(\"mov eax, {}\", in(reg) entrypoint);\n     asm!(\"jmp eax\");\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n@@ -34,7 +34,7 @@ pub extern \"cdecl\" fn _rust_setup_entry(boot_params_ptr: u32) -> ! {\n     println!(\"[setup] entrypoint: {:#x}\", entrypoint);\n \n     // Safety: the entrypoint and the ptr is valid.\n-    unsafe { call_jinux_entrypoint(entrypoint, boot_params_ptr) };\n+    unsafe { call_aster_entrypoint(entrypoint, boot_params_ptr) };\n }\n \n #[panic_handler]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,4 +1,4 @@\n-//! The x86 boot module defines the entrypoints of Jinux and\n+//! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\n //! We directly support\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -9,7 +9,7 @@\n //!\n //! without any additional configurations.\n //!\n-//! Jinux diffrentiates the boot protocol by the entry point\n+//! Asterinas diffrentiates the boot protocol by the entry point\n //! chosen by the boot loader. In each entry point function,\n //! the universal callback registeration method from\n //! `crate::boot` will be called. Thus the initialization of\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -339,5 +339,5 @@ unsafe extern \"sysv64\" fn __multiboot_entry(boot_magic: u32, boot_params: u64) -\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -172,5 +172,5 @@ unsafe extern \"sysv64\" fn __multiboot2_entry(boot_magic: u32, boot_params: u64)\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/jinux-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,6 +1,6 @@\n //! The module to parse kernel command-line arguments.\n //!\n-//! The format of the Jinux command line string conforms\n+//! The format of the Asterinas command line string conforms\n //! to the Linux kernel command line rules:\n //!\n //! https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html\ndiff --git a/framework/jinux-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\n--- a/framework/jinux-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -60,7 +60,7 @@ macro_rules! define_global_static_boot_arguments {\n         ///\n         /// For the introduction of a new boot protocol, the entry point could be a novel\n         /// one. The entry point function should register all the boot initialization\n-        /// methods before `jinux_main` is called. A boot initialization method takes a\n+        /// methods before `aster_main` is called. A boot initialization method takes a\n         /// reference of the global static boot information variable and initialize it,\n         /// so that the boot information it represents could be accessed in the kernel\n         /// anywhere.\ndiff --git a/framework/jinux-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/jinux-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framework part of Jinux.\n+//! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_maybe_uninit_zeroed)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/jinux-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\n--- a/framework/jinux-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -57,7 +57,7 @@ use crate::trap::DisabledLocalIrqGuard;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwLock;\n+/// use aster_frame::sync::RwLock;\n ///\n /// let lock = RwLock::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\n--- a/framework/jinux-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -46,7 +46,7 @@ use super::WaitQueue;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwMutex;\n+/// use aster_frame::sync::RwMutex;\n ///\n /// let mutex = RwMutex::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/jinux-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -98,7 +98,7 @@ impl Drop for IrqLine {\n /// # Example\n ///\n /// ``rust\n-/// use jinux_frame::irq;\n+/// use aster_frame::irq;\n ///\n /// {\n ///     let _ = irq::disable_local();\ndiff --git a/framework/jinux-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/jinux-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -48,7 +48,7 @@ impl UserSpace {\n \n /// Specific architectures need to implement this trait. This should only used in `UserMode`\n ///\n-/// Only visible in jinux-frame\n+/// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n     fn execute(&mut self) -> UserEvent;\ndiff --git a/framework/jinux-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/jinux-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -98,7 +98,7 @@ pub trait UserContextApi {\n /// Here is a sample code on how to use `UserMode`.\n ///  \n /// ```no_run\n-/// use jinux_frame::task::Task;\n+/// use aster_frame::task::Task;\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\ndiff --git a/framework/jinux-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/jinux-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -54,12 +54,12 @@ pub const fn is_page_aligned(p: usize) -> bool {\n     (p & (PAGE_SIZE - 1)) == 0\n }\n \n-/// Convert physical address to virtual address using offset, only available inside jinux-frame\n+/// Convert physical address to virtual address using offset, only available inside aster-frame\n pub(crate) fn paddr_to_vaddr(pa: usize) -> usize {\n     pa + PHYS_OFFSET\n }\n \n-/// Only available inside jinux-frame\n+/// Only available inside aster-frame\n pub(crate) static MEMORY_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\n \n pub static FRAMEBUFFER_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,17 +1,17 @@\n #![no_std]\n #![no_main]\n-// The `export_name` attribute for the `jinux_main` entrypoint requires the removal of safety check.\n+// The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\n // Please be aware that the kernel is not allowed to introduce any other unsafe operations.\n // #![forbid(unsafe_code)]\n-extern crate jinux_frame;\n+extern crate aster_frame;\n \n-use jinux_frame::early_println;\n+use aster_frame::early_println;\n \n-#[export_name = \"jinux_main\"]\n+#[export_name = \"aster_main\"]\n pub fn main() -> ! {\n-    jinux_frame::init();\n-    early_println!(\"[kernel] finish init jinux_frame\");\n+    aster_frame::init();\n+    early_println!(\"[kernel] finish init aster_frame\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    jinux_std::init();\n-    jinux_std::run_first_process();\n+    aster_std::init();\n+    aster_std::run_first_process();\n }\ndiff --git a/regression/Makefile b/regression/Makefile\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -39,7 +39,7 @@ $(INITRAMFS)/lib/x86_64-linux-gnu:\n \t@cp -L /lib/x86_64-linux-gnu/libz.so.1 $@\n \t@cp -L /usr/local/benchmark/iperf/lib/libiperf.so.0 $@\n \t@# TODO: use a custom compiled vdso.so file in the future.\n-\t@git clone https://github.com/jinzhao-dev/linux_vdso.git\n+\t@git clone https://github.com/asterinas/linux_vdso.git\n \t@cd ./linux_vdso && git checkout 2a6d2db 2>/dev/null\n \t@cp -L ./linux_vdso/vdso64.so $@\n \t@rm -rf ./linux_vdso \ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -31,7 +31,7 @@ find . -name \"*shell_cmd*\"\n mkdir foo\n rmdir foo \n \n-echo \"Hello world from jinux\" > hello.txt\n+echo \"Hello world from asterinas\" > hello.txt\n rm hello.txt\n \n cd ..\ndiff --git a/runner/Cargo.toml b/runner/Cargo.toml\n--- a/runner/Cargo.toml\n+++ b/runner/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-runner\"\n+name = \"aster-runner\"\n version = \"0.1.0\"\n edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\ndiff --git a/runner/grub/grub.cfg.template b/runner/grub/grub.cfg.template\n--- a/runner/grub/grub.cfg.template\n+++ b/runner/grub/grub.cfg.template\n@@ -7,7 +7,7 @@\n set timeout_style=#GRUB_TIMEOUT_STYLE#\n set timeout=#GRUB_TIMEOUT#\n \n-menuentry 'jinux' {\n+menuentry 'asterinas' {\n     #GRUB_CMD_KERNEL# #KERNEL# #KERNEL_COMMAND_LINE#\n     #GRUB_CMD_INITRAMFS# /boot/initramfs.cpio.gz\n     boot\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -21,7 +21,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n     let mut gdb_cmd = Command::new(\"gdb\");\n     // Set the architecture, otherwise GDB will complain about.\n     gdb_cmd.arg(\"-ex\").arg(\"set arch i386:x86-64:intel\");\n-    let grub_script = \"/tmp/jinux-gdb-grub-script\";\n+    let grub_script = \"/tmp/aster-gdb-grub-script\";\n     if gdb_grub {\n         let grub_dir = PathBuf::from(qemu_grub_efi::GRUB_PREFIX)\n             .join(\"lib\")\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -41,7 +41,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         for line in lines {\n             if line.contains(\"target remote :1234\") {\n                 // Connect to the GDB server.\n-                writeln!(f, \"target remote /tmp/jinux-gdb-socket\").unwrap();\n+                writeln!(f, \"target remote /tmp/aster-gdb-socket\").unwrap();\n             } else {\n                 writeln!(f, \"{}\", line).unwrap();\n             }\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -53,7 +53,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         // Connect to the GDB server.\n         gdb_cmd\n             .arg(\"-ex\")\n-            .arg(\"target remote /tmp/jinux-gdb-socket\");\n+            .arg(\"target remote /tmp/aster-gdb-socket\");\n     }\n     // Connect to the GDB server and run.\n     println!(\"running:{:#?}\", gdb_cmd);\ndiff --git a/runner/src/machine/qemu_grub_efi/linux_boot.rs b/runner/src/machine/qemu_grub_efi/linux_boot.rs\n--- a/runner/src/machine/qemu_grub_efi/linux_boot.rs\n+++ b/runner/src/machine/qemu_grub_efi/linux_boot.rs\n@@ -47,7 +47,7 @@ fn header_to_raw_binary(elf_file: &[u8]) -> Vec<u8> {\n /// This function sould be used when generating the Linux x86 Boot setup header.\n /// Some fields in the Linux x86 Boot setup header should be filled after assembled.\n /// And the filled fields must have the bytes with values of 0xAB. See\n-/// `framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n+/// `framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n /// info on this mechanism.\n fn fill_header_field(header: &mut [u8], offset: usize, value: &[u8]) {\n     let size = value.len();\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -70,13 +70,13 @@ pub const GRUB_PREFIX: &str = \"/usr/local/grub\";\n pub const GRUB_VERSION: &str = \"x86_64-efi\";\n \n pub fn create_bootdev_image(\n-    jinux_path: PathBuf,\n+    atser_path: PathBuf,\n     initramfs_path: PathBuf,\n     grub_cfg: String,\n     protocol: BootProtocol,\n     release_mode: bool,\n ) -> PathBuf {\n-    let target_dir = jinux_path.parent().unwrap();\n+    let target_dir = atser_path.parent().unwrap();\n     let iso_root = target_dir.join(\"iso_root\");\n \n     // Clear or make the iso dir.\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -96,24 +96,24 @@ pub fn create_bootdev_image(\n         BootProtocol::Linux => {\n             // Find the setup header in the build script output directory.\n             let bs_out_dir = if release_mode {\n-                glob(\"target/x86_64-custom/release/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/release/build/aster-frame-*\").unwrap()\n             } else {\n-                glob(\"target/x86_64-custom/debug/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/debug/build/aster-frame-*\").unwrap()\n             };\n             let header_path = Path::new(bs_out_dir.into_iter().next().unwrap().unwrap().as_path())\n                 .join(\"out\")\n                 .join(\"bin\")\n-                .join(\"jinux-frame-x86-boot-linux-setup\");\n+                .join(\"aster-frame-x86-boot-linux-setup\");\n             // Make the `bzImage`-compatible kernel image and place it in the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinuz\");\n-            linux_boot::make_bzimage(&target_path, &jinux_path.as_path(), &header_path.as_path())\n+            let target_path = iso_root.join(\"boot\").join(\"asterinaz\");\n+            linux_boot::make_bzimage(&target_path, &atser_path.as_path(), &header_path.as_path())\n                 .unwrap();\n             target_path\n         }\n         BootProtocol::Multiboot | BootProtocol::Multiboot2 => {\n             // Copy the kernel image to the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinux\");\n-            fs::copy(&jinux_path, &target_path).unwrap();\n+            let target_path = iso_root.join(\"boot\").join(\"atserinas\");\n+            fs::copy(&atser_path, &target_path).unwrap();\n             target_path\n         }\n     };\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -164,15 +164,15 @@ pub fn generate_grub_cfg(\n     let buffer = match protocol {\n         BootProtocol::Multiboot => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module --nounzip\"),\n         BootProtocol::Multiboot2 => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot2\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module2 --nounzip\"),\n         BootProtocol::Linux => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"linux\")\n-            .replace(\"#KERNEL#\", \"/boot/jinuz\")\n+            .replace(\"#KERNEL#\", \"/boot/asterinaz\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"initrd\"),\n     };\n \ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -40,7 +40,7 @@ pub enum BootProtocol {\n #[command(author, version, about, long_about = None)]\n struct Args {\n     // Positional arguments.\n-    /// The Jinux binary path.\n+    /// The Asterinas binary path.\n     path: PathBuf,\n \n     /// Provide the kernel commandline, which specifies\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -117,7 +117,7 @@ pub fn random_hostfwd_ports() -> (u16, u16) {\n \n pub const GDB_ARGS: &[&str] = &[\n     \"-chardev\",\n-    \"socket,path=/tmp/jinux-gdb-socket,server=on,wait=off,id=gdb0\",\n+    \"socket,path=/tmp/aster-gdb-socket,server=on,wait=off,id=gdb0\",\n     \"-gdb\",\n     \"chardev:gdb0\",\n     \"-S\",\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -145,13 +145,13 @@ fn main() {\n         port1, port2\n     ));\n     println!(\n-        \"[jinux-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n+        \"[aster-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n         port1, 22, port2, 8080\n     );\n \n     if args.halt_for_gdb {\n         if args.enable_kvm {\n-            println!(\"[jinux-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n+            println!(\"[aster-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n             return;\n         }\n         qemu_cmd.args(GDB_ARGS);\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -206,17 +206,18 @@ fn main() {\n         qemu_cmd.arg(bootdev_image.as_os_str());\n     }\n \n-    println!(\"[jinux-runner] Running: {:#?}\", qemu_cmd);\n+    println!(\"[aster-runner] Running: {:#?}\", qemu_cmd);\n \n     let exit_status = qemu_cmd.status().unwrap();\n-\n-    // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n-    let qemu_exit_code = exit_status.code().unwrap();\n-    let kernel_exit_code = qemu_exit_code >> 1;\n-    match kernel_exit_code {\n-        0x10 /* jinux_frame::QemuExitCode::Success */ => { std::process::exit(0); },\n-        0x20 /* jinux_frame::QemuExitCode::Failed */ => { std::process::exit(1); },\n-        _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+    if !exit_status.success() {\n+        // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n+        let qemu_exit_code = exit_status.code().unwrap();\n+        let kernel_exit_code = qemu_exit_code >> 1;\n+        match kernel_exit_code {\n+            0x10 /*aster_frame::QemuExitCode::Success*/ => { std::process::exit(0); },\n+            0x20 /*aster_frame::QemuExitCode::Failed*/ => { std::process::exit(1); },\n+            _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+        }\n     }\n }\n \ndiff --git a/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-block\"\n+name = \"aster-block\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\n--- a/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The block devices of jinux\n+//! The block devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n use component::init_component;\n use component::ComponentInitError;\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub const BLK_SIZE: usize = 512;\ndiff --git a/services/comps/console/Cargo.toml b/services/comps/console/Cargo.toml\n--- a/services/comps/console/Cargo.toml\n+++ b/services/comps/console/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-console\"\n+name = \"aster-console\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/console/Cargo.toml b/services/comps/console/Cargo.toml\n--- a/services/comps/console/Cargo.toml\n+++ b/services/comps/console/Cargo.toml\n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The console device of jinux\n+//! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -8,8 +8,8 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, fmt::Debug, string::String, sync::Arc, vec::Vec};\n use core::any::Any;\n \n+use aster_frame::sync::SpinLock;\n use component::{init_component, ComponentInitError};\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub type ConsoleCallback = dyn Fn(&[u8]) + Send + Sync;\ndiff --git a/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\n--- a/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -1,12 +1,12 @@\n [package]\n-name = \"jinux-framebuffer\"\n+name = \"aster-framebuffer\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framebuffer of jinux\n+//! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(strict_provenance)]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -6,13 +6,13 @@\n extern crate alloc;\n \n use alloc::vec::Vec;\n+use aster_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use component::{init_component, ComponentInitError};\n use core::{\n     fmt,\n     ops::{Index, IndexMut},\n };\n use font8x8::UnicodeFonts;\n-use jinux_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use spin::Once;\n \n #[init_component]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -28,7 +28,7 @@ pub(crate) fn init() {\n         let framebuffer = boot::framebuffer_arg();\n         let mut writer = None;\n         let mut size = 0;\n-        for i in jinux_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n+        for i in aster_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n             size = i.len() as usize;\n         }\n \ndiff --git a/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-input\"\n+name = \"aster-input\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\n--- a/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -8,9 +8,9 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The input devices of jinux\n+//! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -14,7 +14,7 @@ use alloc::vec::Vec;\n use component::init_component;\n use component::ComponentInitError;\n \n-use jinux_frame::sync::SpinLock;\n+use aster_frame::sync::SpinLock;\n use spin::Once;\n use virtio_input_decoder::DecodeType;\n \ndiff --git a/services/comps/network/Cargo.toml b/services/comps/network/Cargo.toml\n--- a/services/comps/network/Cargo.toml\n+++ b/services/comps/network/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-network\"\n+name = \"aster-network\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/network/Cargo.toml b/services/comps/network/Cargo.toml\n--- a/services/comps/network/Cargo.toml\n+++ b/services/comps/network/Cargo.toml\n@@ -7,13 +7,13 @@ edition = \"2021\"\n \n [dependencies]\n component = { path = \"../../libs/comp-sys/component\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n bytes = { version = \"1.4.0\", default-features = false }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -13,14 +13,14 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n+use aster_util::safe_ptr::Pod;\n use buffer::RxBuffer;\n use buffer::TxBuffer;\n use component::init_component;\n use component::ComponentInitError;\n use core::any::Any;\n use core::fmt::Debug;\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::safe_ptr::Pod;\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\n--- a/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -1,13 +1,13 @@\n [package]\n-name = \"jinux-time\"\n+name = \"aster-time\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -6,9 +6,9 @@\n //! It can be integrated into larger systems to provide timing capabilities, or used standalone for time tracking and elapsed time measurements.\n \n use alloc::sync::Arc;\n+use aster_frame::sync::SpinLock;\n+use aster_util::coeff::Coeff;\n use core::{cmp::max, ops::Add, time::Duration};\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::coeff::Coeff;\n \n use crate::NANOS_PER_SECOND;\n \ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,13 +1,13 @@\n-//! The system time of jinux\n+//! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \n extern crate alloc;\n \n use alloc::sync::Arc;\n+use aster_frame::sync::Mutex;\n use component::{init_component, ComponentInitError};\n use core::{sync::atomic::Ordering::Relaxed, time::Duration};\n-use jinux_frame::sync::Mutex;\n use spin::Once;\n \n use clocksource::ClockSource;\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\n-use jinux_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n \n pub(crate) static CENTURY_REGISTER: AtomicU8 = AtomicU8::new(0);\n \ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -2,9 +2,9 @@\n //!\n //! Use `init` to initialize this module.\n use alloc::sync::Arc;\n+use aster_frame::arch::{read_tsc, x86::tsc_freq};\n+use aster_frame::timer::Timer;\n use core::time::Duration;\n-use jinux_frame::arch::{read_tsc, x86::tsc_freq};\n-use jinux_frame::timer::Timer;\n use spin::Once;\n \n use crate::clocksource::{ClockSource, Instant};\ndiff --git a/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-virtio\"\n+name = \"aster-virtio\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\n--- a/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -11,15 +11,15 @@ spin = \"0.9.4\"\n virtio-input-decoder = \"0.1.4\"\n bytes = { version = \"1.4.0\", default-features = false }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-jinux-input = { path = \"../input\" }\n-jinux-block = { path = \"../block\" }\n-jinux-network = { path = \"../network\" }\n-jinux-console = { path = \"../console\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-input = { path = \"../input\" }\n+aster-block = { path = \"../block\" }\n+aster-network = { path = \"../network\" }\n+aster-console = { path = \"../console\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,8 +1,8 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, string::ToString, sync::Arc};\n-use jinux_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::info;\n use pod::Pod;\n \ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -97,7 +97,7 @@ impl BlockDevice {\n             .unwrap();\n \n         fn handle_block_device(_: &TrapFrame) {\n-            jinux_block::get_device(super::DEVICE_NAME)\n+            aster_block::get_device(super::DEVICE_NAME)\n                 .unwrap()\n                 .handle_irq();\n         }\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -107,7 +107,7 @@ impl BlockDevice {\n         }\n         device.transport.finish_init();\n \n-        jinux_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -120,7 +120,7 @@ impl BlockDevice {\n     }\n }\n \n-impl jinux_block::BlockDevice for BlockDevice {\n+impl aster_block::BlockDevice for BlockDevice {\n     fn read_block(&self, block_id: usize, buf: &mut [u8]) {\n         self.read(block_id, buf);\n     }\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,9 +1,9 @@\n pub mod device;\n \n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,9 +1,9 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\n-use jinux_console::{AnyConsoleDevice, ConsoleCallback};\n-use jinux_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_console::{AnyConsoleDevice, ConsoleCallback};\n+use aster_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::debug;\n \n use crate::{\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -130,14 +130,14 @@ impl ConsoleDevice {\n             .unwrap();\n         device.transport.finish_init();\n \n-        jinux_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\n }\n \n fn handle_console_input(_: &TrapFrame) {\n-    jinux_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n+    aster_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n }\n \n fn config_space_change(_: &TrapFrame) {\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -7,9 +7,9 @@ use alloc::{\n     sync::Arc,\n     vec::Vec,\n };\n+use aster_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n-use jinux_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{debug, info};\n use pod::Pod;\n use virtio_input_decoder::{DecodeType, Decoder};\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -112,7 +112,7 @@ impl InputDevice {\n \n         fn handle_input(_: &TrapFrame) {\n             debug!(\"Handle Virtio input interrupt\");\n-            let device = jinux_input::get_device(super::DEVICE_NAME).unwrap();\n+            let device = aster_input::get_device(super::DEVICE_NAME).unwrap();\n             device.handle_irq().unwrap();\n         }\n \ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -131,7 +131,7 @@ impl InputDevice {\n \n         device.transport.finish_init();\n \n-        jinux_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -183,7 +183,7 @@ impl InputDevice {\n     }\n }\n \n-impl jinux_input::InputDevice for InputDevice {\n+impl aster_input::InputDevice for InputDevice {\n     fn handle_irq(&self) -> Option<()> {\n         // one interrupt may contains serval input, so it should loop\n         loop {\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -26,8 +26,8 @@\n \n pub mod device;\n use crate::transport::VirtioTransport;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n pub static DEVICE_NAME: &str = \"Virtio-Input\";\ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::io_mem::IoMem;\n+use aster_network::EthernetAddr;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_network::EthernetAddr;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,12 +1,12 @@\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\n-use jinux_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_network::{\n+use aster_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_network::{\n     buffer::{RxBuffer, TxBuffer},\n     AnyNetworkDevice, EthernetAddr, NetDeviceIrqHandler, VirtioNetError,\n };\n-use jinux_util::{field_ptr, slot_vec::SlotVec};\n+use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n use pod::Pod;\n use smoltcp::phy::{DeviceCapabilities, Medium};\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -87,7 +87,7 @@ impl NetworkDevice {\n \n         /// Interrupt handler if network device receives some packet\n         fn handle_network_event(_: &TrapFrame) {\n-            jinux_network::handle_recv_irq(super::DEVICE_NAME);\n+            aster_network::handle_recv_irq(super::DEVICE_NAME);\n         }\n \n         device\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -99,7 +99,7 @@ impl NetworkDevice {\n             .register_queue_callback(QUEUE_RECV, Box::new(handle_network_event), false)\n             .unwrap();\n \n-        jinux_network::register_device(\n+        aster_network::register_device(\n             super::DEVICE_NAME.to_string(),\n             Arc::new(SpinLock::new(Box::new(device))),\n         );\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The virtio of jinux\n+//! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -3,18 +3,18 @@\n use crate::transport::VirtioTransport;\n \n use alloc::vec::Vec;\n+use aster_frame::{\n+    io_mem::IoMem,\n+    offset_of,\n+    vm::{DmaCoherent, VmAllocOptions},\n+};\n+use aster_rights::{Dup, TRightSet, TRights, Write};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n use core::{\n     mem::size_of,\n     sync::atomic::{fence, Ordering},\n };\n-use jinux_frame::{\n-    io_mem::IoMem,\n-    offset_of,\n-    vm::{DmaCoherent, VmAllocOptions},\n-};\n-use jinux_rights::{Dup, TRightSet, TRights, Write};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::debug;\n use pod::Pod;\n \ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -372,7 +372,7 @@ fn set_buf(ptr: &SafePtr<Descriptor, &DmaCoherent, TRightSet<TRights![Dup, Write\n     // FIXME: use `DmaSteam` for buf. Now because the upper device driver lacks the\n     // ability to safely construct DmaStream from slice, slice is still used here.\n     let va = buf.as_ptr() as usize;\n-    let pa = jinux_frame::vm::vaddr_to_paddr(va).unwrap();\n+    let pa = aster_frame::vm::vaddr_to_paddr(va).unwrap();\n     field_ptr!(ptr, Descriptor, addr)\n         .write(&(pa as u64))\n         .unwrap();\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,6 +1,5 @@\n use alloc::{boxed::Box, sync::Arc};\n-use core::mem::size_of;\n-use jinux_frame::{\n+use aster_frame::{\n     bus::mmio::{\n         bus::MmioDevice,\n         device::{MmioCommonDevice, VirtioMmioVersion},\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -12,8 +11,9 @@ use jinux_frame::{\n     trap::IrqCallbackFunction,\n     vm::DmaCoherent,\n };\n-use jinux_rights::{ReadOp, WriteOp};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n+use aster_rights::{ReadOp, WriteOp};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n+use core::mem::size_of;\n use log::warn;\n \n use crate::{\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -33,7 +33,7 @@ pub struct VirtioMmioDevice {\n pub struct VirtioMmioTransport {\n     layout: SafePtr<VirtioMmioLayout, IoMem>,\n     device: Arc<VirtioMmioDevice>,\n-    common_device: jinux_frame::bus::mmio::device::MmioCommonDevice,\n+    common_device: aster_frame::bus::mmio::device::MmioCommonDevice,\n     multiplex: Arc<RwLock<MultiplexIrq>>,\n }\n \ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         mmio::{\n             bus::{MmioDevice, MmioDriver},\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::mmio::MMIO_BUS;\n+use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\n \n use self::driver::VirtioMmioDriver;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,13 +1,13 @@\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     io_mem::IoMem,\n     sync::RwLock,\n     trap::{IrqCallbackFunction, IrqLine, TrapFrame},\n };\n-use jinux_rights::{ReadOp, TRightSet, WriteOp};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_rights::{ReadOp, TRightSet, WriteOp};\n+use aster_util::safe_ptr::SafePtr;\n \n /// Multiplexing Irqs. The two interrupt types (configuration space change and queue interrupt)\n /// of the virtio-mmio device share the same IRQ, so `MultiplexIrq` are used to distinguish them.\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,8 +1,8 @@\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\n-use jinux_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n+use aster_util::safe_ptr::SafePtr;\n \n use crate::{\n     queue::{AvailRing, Descriptor, UsedRing},\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::{\n+use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\n     cfg_space::{Bar, IoBar, MemoryBar},\n     common_device::BarManager,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::PciDevice, capability::CapabilityData, common_device::PciCommonDevice, PciDeviceId,\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -12,8 +12,8 @@ use jinux_frame::{\n };\n \n use alloc::{boxed::Box, sync::Arc};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use core::fmt::Debug;\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{info, warn};\n \n use super::{common_cfg::VirtioPciCommonCfg, msix::VirtioMsixManager};\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::{PciDevice, PciDriver},\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -5,7 +5,7 @@ pub mod driver;\n pub(super) mod msix;\n \n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::PCI_BUS;\n+use aster_frame::bus::pci::PCI_BUS;\n use spin::Once;\n \n use self::driver::VirtioPciDriver;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,5 +1,5 @@\n use alloc::vec::Vec;\n-use jinux_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n+use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \n pub struct VirtioMsixManager {\n     config_msix_vector: u16,\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -17,7 +17,7 @@ impl VirtioMsixManager {\n     pub fn new(mut msix: CapabilityMsixData) -> Self {\n         let mut msix_vector_list: Vec<u16> = (0..msix.table_size()).collect();\n         for i in msix_vector_list.iter() {\n-            let irq = jinux_frame::trap::IrqLine::alloc().unwrap();\n+            let irq = aster_frame::trap::IrqLine::alloc().unwrap();\n             msix.set_interrupt_vector(irq, *i);\n         }\n         let config_msix_vector = msix_vector_list.pop().unwrap();\ndiff --git a/services/libs/jinux-rights-proc/Cargo.toml b/services/libs/aster-rights-proc/Cargo.toml\n--- a/services/libs/jinux-rights-proc/Cargo.toml\n+++ b/services/libs/aster-rights-proc/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights-proc\"\n+name = \"aster-rights-proc\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/libs/jinux-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\n--- a/services/libs/jinux-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the require procedural macros to implement capability for jinux.\n+//\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\n //! The require macro are used to ensure that an object has the enough capability to call the function.\ndiff --git a/services/libs/jinux-rights/Cargo.toml b/services/libs/aster-rights/Cargo.toml\n--- a/services/libs/jinux-rights/Cargo.toml\n+++ b/services/libs/aster-rights/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights\"\n+name = \"aster-rights\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/libs/jinux-rights/Cargo.toml b/services/libs/aster-rights/Cargo.toml\n--- a/services/libs/jinux-rights/Cargo.toml\n+++ b/services/libs/aster-rights/Cargo.toml\n@@ -9,6 +9,6 @@ edition = \"2021\"\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n bitflags = \"1.3\"\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n \n [features]\ndiff --git a/services/libs/jinux-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\n--- a/services/libs/jinux-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -58,7 +58,7 @@ pub type FullOp = TRights![Read, Write, Dup];\n /// Example:\n ///\n /// ```rust\n-/// use jinux_rights::{Rights, TRights, TRightSet};\n+/// use aster_rights::{Rights, TRights, TRightSet};\n ///\n /// pub struct Vmo<R=Rights>(R);\n ///\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/aster-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/aster-std/Cargo.toml\n@@ -1,26 +1,26 @@\n [package]\n-name = \"jinux-std\"\n+name = \"aster-std\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n-jinux-input = { path = \"../../comps/input\" }\n-jinux-block = { path = \"../../comps/block\" }\n-jinux-network = { path = \"../../comps/network\" }\n-jinux-console = { path = \"../../comps/console\" }\n-jinux-time = { path = \"../../comps/time\" }\n-jinux-virtio = { path = \"../../comps/virtio\" }\n-jinux-rights = { path = \"../jinux-rights\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n+aster-input = { path = \"../../comps/input\" }\n+aster-block = { path = \"../../comps/block\" }\n+aster-network = { path = \"../../comps/network\" }\n+aster-console = { path = \"../../comps/console\" }\n+aster-time = { path = \"../../comps/time\" }\n+aster-virtio = { path = \"../../comps/virtio\" }\n+aster-rights = { path = \"../aster-rights\" }\n controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n-jinux-util = { path = \"../jinux-util\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n+aster-util = { path = \"../aster-util\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n cpio-decoder = { path = \"../cpio-decoder\" }\n virtio-input-decoder = \"0.1.4\"\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/aster-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/aster-std/Cargo.toml\n@@ -52,7 +52,7 @@ bitflags = \"1.3\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n keyable-arc = { path = \"../keyable-arc\" }\n # unzip initramfs\n-libflate = { git = \"https://github.com/jinzhao-dev/libflate\", rev = \"b781da6\", features = [\n+libflate = { git = \"https://github.com/asterinas/libflate\", rev = \"b781da6\", features = [\n     \"no_std\",\n ] }\n core2 = { version = \"0.4\", default_features = false, features = [\"alloc\"] }\ndiff --git a/services/libs/jinux-std/src/console.rs b/services/libs/aster-std/src/console.rs\n--- a/services/libs/jinux-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -9,7 +9,7 @@ struct VirtioConsolesPrinter;\n \n impl Write for VirtioConsolesPrinter {\n     fn write_str(&mut self, s: &str) -> core::fmt::Result {\n-        for (_, device) in jinux_console::all_devices() {\n+        for (_, device) in aster_console::all_devices() {\n             device.send(s.as_bytes());\n         }\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/jinux-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,4 +1,4 @@\n-pub use jinux_frame::arch::console::register_console_input_callback;\n+pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \n use crate::{\ndiff --git a/services/libs/jinux-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/jinux-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -9,7 +9,7 @@ use crate::{\n pub static TTY_DRIVER: Once<Arc<TtyDriver>> = Once::new();\n \n pub(super) fn init() {\n-    for (_, device) in jinux_console::all_devices() {\n+    for (_, device) in aster_console::all_devices() {\n         device.register_callback(&console_input_callback)\n     }\n     let tty_driver = Arc::new(TtyDriver::new());\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -6,7 +6,7 @@ use crate::process::signal::{Pollee, Poller};\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n use alloc::format;\n-use jinux_frame::trap::disable_local;\n+use aster_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\ndiff --git a/services/libs/jinux-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/jinux-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -178,15 +178,15 @@ impl From<Errno> for Error {\n     }\n }\n \n-impl From<jinux_frame::Error> for Error {\n-    fn from(frame_error: jinux_frame::Error) -> Self {\n+impl From<aster_frame::Error> for Error {\n+    fn from(frame_error: aster_frame::Error) -> Self {\n         match frame_error {\n-            jinux_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n-            jinux_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n-            jinux_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n-            jinux_frame::Error::IoError => Error::new(Errno::EIO),\n-            jinux_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n-            jinux_frame::Error::PageFault => Error::new(Errno::EFAULT),\n+            aster_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n+            aster_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n+            aster_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n+            aster_frame::Error::IoError => Error::new(Errno::EIO),\n+            aster_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n+            aster_frame::Error::PageFault => Error::new(Errno::EFAULT),\n         }\n     }\n }\ndiff --git a/services/libs/jinux-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/jinux-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -237,16 +237,16 @@ impl From<cpio_decoder::error::Error> for Error {\n     }\n }\n \n-impl From<Error> for jinux_frame::Error {\n+impl From<Error> for aster_frame::Error {\n     fn from(error: Error) -> Self {\n         match error.errno {\n-            Errno::EACCES => jinux_frame::Error::AccessDenied,\n-            Errno::EIO => jinux_frame::Error::IoError,\n-            Errno::ENOMEM => jinux_frame::Error::NoMemory,\n-            Errno::EFAULT => jinux_frame::Error::PageFault,\n-            Errno::EINVAL => jinux_frame::Error::InvalidArgs,\n-            Errno::EBUSY => jinux_frame::Error::NotEnoughResources,\n-            _ => jinux_frame::Error::InvalidArgs,\n+            Errno::EACCES => aster_frame::Error::AccessDenied,\n+            Errno::EIO => aster_frame::Error::IoError,\n+            Errno::ENOMEM => aster_frame::Error::NoMemory,\n+            Errno::EFAULT => aster_frame::Error::PageFault,\n+            Errno::EINVAL => aster_frame::Error::InvalidArgs,\n+            Errno::EBUSY => aster_frame::Error::NotEnoughResources,\n+            _ => aster_frame::Error::InvalidArgs,\n         }\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -6,9 +6,9 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n \n+use aster_frame::vm::VmFrame;\n+use aster_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n-use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -2,8 +2,8 @@ use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\n \n+use aster_util::slot_vec::SlotVec;\n use core::cell::Cell;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::file_handle::FileLike;\n use super::fs_resolver::{FsPath, FsResolver, AT_FDCWD};\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,7 +1,7 @@\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -13,7 +13,7 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[derive(Debug)]\n pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n-use jinux_rights::{Read, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_rights::{Read, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,5 +1,5 @@\n+use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n-use jinux_util::slot_vec::SlotVec;\n \n use crate::fs::device::Device;\n use crate::fs::utils::{DirentVisitor, FileSystem, Inode, InodeMode, InodeType, Metadata};\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,10 +1,10 @@\n use alloc::str;\n+use aster_frame::sync::{RwLock, RwLockWriteGuard};\n+use aster_frame::vm::{VmFrame, VmIo};\n+use aster_rights::Full;\n+use aster_util::slot_vec::SlotVec;\n use core::sync::atomic::{AtomicUsize, Ordering};\n use core::time::Duration;\n-use jinux_frame::sync::{RwLock, RwLockWriteGuard};\n-use jinux_frame::vm::{VmFrame, VmIo};\n-use jinux_rights::Full;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::*;\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\n--- a/services/libs/jinux-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[allow(non_camel_case_types)]\n #[derive(Clone, Copy, Debug)]\ndiff --git a/services/libs/jinux-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\n--- a/services/libs/jinux-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,12 +1,12 @@\n+use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n-use jinux_rights_proc::require;\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\n \n use crate::events::IoEvents;\n use crate::events::Observer;\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n-use jinux_rights::{Read, ReadOp, TRights, Write, WriteOp};\n+use aster_rights::{Read, ReadOp, TRights, Write, WriteOp};\n \n use super::StatusFlags;\n \ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,7 +1,7 @@\n use super::Inode;\n use crate::prelude::*;\n \n-use jinux_util::slot_vec::SlotVec;\n+use aster_util::slot_vec::SlotVec;\n \n pub trait DirEntryVecExt {\n     /// If the entry is not found by `name`, use `f` to get the inode, then put the entry into vec.\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::vm::VmFrame;\n+use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\n-use jinux_frame::vm::VmFrame;\n-use jinux_rights::Full;\n \n use super::{DirentVisitor, FileSystem, IoctlCmd, SuperBlock};\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\n--- a/services/libs/jinux-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,10 +1,10 @@\n use super::Inode;\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n-use jinux_rights::Full;\n+use aster_rights::Full;\n \n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n use core::ops::Range;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n use lru::LruCache;\n \n pub struct PageCache {\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The std library of jinux\n+//! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -28,7 +28,7 @@ use crate::{\n         Thread,\n     },\n };\n-use jinux_frame::{\n+use aster_frame::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n     boot,\n };\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -82,7 +82,7 @@ fn init_thread() {\n     }));\n     thread.join();\n     info!(\n-        \"[jinux-std/lib.rs] spawn kernel thread, tid = {}\",\n+        \"[aster-std/lib.rs] spawn kernel thread, tid = {}\",\n         thread.tid()\n     );\n     thread::work_queue::init();\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -125,12 +125,10 @@ fn print_banner() {\n     println!(\"\\x1B[36m\");\n     println!(\n         r\"\n-       __   __  .__   __.  __    __  ___   ___ \n-      |  | |  | |  \\ |  | |  |  |  | \\  \\ /  / \n-      |  | |  | |   \\|  | |  |  |  |  \\  V  /  \n-.--.  |  | |  | |  . `  | |  |  |  |   >   <   \n-|  `--'  | |  | |  |\\   | |  `--'  |  /  .  \\  \n- \\______/  |__| |__| \\__|  \\______/  /__/ \\__\\                                                                                            \n+   _   ___ _____ ___ ___ ___ _  _   _   ___ \n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/                                                                                                                                    \n \"\n     );\n     println!(\"\\x1B[0m\");\ndiff --git a/services/libs/jinux-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\n--- a/services/libs/jinux-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\n     let millis = read_monotonic_milli_seconds();\ndiff --git a/services/libs/jinux-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\n--- a/services/libs/jinux-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/jinux-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n-use jinux_frame::sync::SpinLock;\n-use jinux_network::AnyNetworkDevice;\n-use jinux_virtio::device::network::DEVICE_NAME;\n+use aster_frame::sync::SpinLock;\n+use aster_network::AnyNetworkDevice;\n+use aster_virtio::device::network::DEVICE_NAME;\n use smoltcp::{\n     iface::{Config, Routes, SocketHandle, SocketSet},\n     socket::dhcpv4,\ndiff --git a/services/libs/jinux-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/jinux-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -19,7 +19,7 @@ pub struct IfaceVirtio {\n \n impl IfaceVirtio {\n     pub fn new() -> Arc<Self> {\n-        let virtio_net = jinux_network::get_device(DEVICE_NAME).unwrap();\n+        let virtio_net = aster_network::get_device(DEVICE_NAME).unwrap();\n         let interface = {\n             let mac_addr = virtio_net.lock().mac_addr();\n             let ip_addr = IpCidr::new(wire::IpAddress::Ipv4(wire::Ipv4Address::UNSPECIFIED), 0);\ndiff --git a/services/libs/jinux-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\n--- a/services/libs/jinux-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -18,8 +18,8 @@ pub fn init() {\n         vec![iface_virtio, iface_loopback]\n     });\n \n-    for (name, _) in jinux_network::all_devices() {\n-        jinux_network::register_recv_callback(&name, || {\n+    for (name, _) in aster_network::all_devices() {\n+        aster_network::register_recv_callback(&name, || {\n             // TODO: further check that the irq num is the same as iface's irq num\n             let iface_virtio = &IFACES.get().unwrap()[0];\n             iface_virtio.poll();\ndiff --git a/services/libs/jinux-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\n--- a/services/libs/jinux-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -12,14 +12,14 @@ pub(crate) use alloc::sync::Arc;\n pub(crate) use alloc::sync::Weak;\n pub(crate) use alloc::vec;\n pub(crate) use alloc::vec::Vec;\n+pub(crate) use aster_frame::config::PAGE_SIZE;\n+pub(crate) use aster_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n+pub(crate) use aster_frame::vm::Vaddr;\n pub(crate) use bitflags::bitflags;\n pub(crate) use core::any::Any;\n pub(crate) use core::ffi::CStr;\n pub(crate) use core::fmt::Debug;\n pub(crate) use int_to_c_enum::TryFromInt;\n-pub(crate) use jinux_frame::config::PAGE_SIZE;\n-pub(crate) use jinux_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n-pub(crate) use jinux_frame::vm::Vaddr;\n pub(crate) use log::{debug, error, info, trace, warn};\n pub(crate) use pod::Pod;\n \ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -10,10 +10,10 @@ use crate::prelude::*;\n use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n use crate::util::write_val_to_user;\n use crate::vm::vmar::Vmar;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::user::UserSpace;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::Full;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::user::UserSpace;\n+use aster_frame::vm::VmIo;\n+use aster_rights::Full;\n \n bitflags! {\n     pub struct CloneFlags: u32 {\ndiff --git a/services/libs/jinux-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\n--- a/services/libs/jinux-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -2,7 +2,7 @@ use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n \n #[derive(Debug)]\n pub(super) struct Credentials_ {\ndiff --git a/services/libs/jinux-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\n--- a/services/libs/jinux-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -4,8 +4,8 @@ mod static_cap;\n mod user;\n \n use crate::prelude::*;\n+use aster_rights::{FullOp, ReadOp, WriteOp};\n use credentials_::Credentials_;\n-use jinux_rights::{FullOp, ReadOp, WriteOp};\n \n pub use group::Gid;\n pub use user::Uid;\ndiff --git a/services/libs/jinux-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\n--- a/services/libs/jinux-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,9 +1,9 @@\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n-use jinux_rights::{Dup, Read, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_rights::{Dup, Read, TRights, Write};\n+use aster_rights_proc::require;\n \n impl<R: TRights> Credentials<R> {\n     /// Creates a root `Credentials`. This method can only be used when creating the first process\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::user::UserSpace;\n+use aster_frame::user::UserSpace;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,6 +1,6 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n \n-use jinux_frame::cpu::num_cpus;\n+use aster_frame::cpu::num_cpus;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -10,8 +10,8 @@ use crate::prelude::*;\n use crate::process::signal::constants::SIGCONT;\n use crate::thread::{thread_table, Tid};\n use crate::util::write_val_to_user;\n+use aster_rights::{ReadOp, WriteOp};\n use futex::futex_wake;\n-use jinux_rights::{ReadOp, WriteOp};\n use robust_list::wake_robust_futex;\n \n mod builder;\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n--- a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace};\n+use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\n     fs::fs_resolver::{FsPath, FsResolver, AT_FDCWD},\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -23,8 +23,8 @@ mod process_group;\n mod session;\n mod terminal;\n \n+use aster_rights::Full;\n pub use builder::ProcessBuilder;\n-use jinux_rights::Full;\n pub use job_control::JobControl;\n pub use process_group::ProcessGroup;\n pub use session::Session;\ndiff --git a/services/libs/jinux-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\n--- a/services/libs/jinux-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -6,7 +6,7 @@\n \n pub mod user_heap;\n \n-use jinux_rights::Full;\n+use aster_rights::Full;\n use user_heap::UserHeap;\n \n use crate::vm::vmar::Vmar;\ndiff --git a/services/libs/jinux-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n--- a/services/libs/jinux-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -7,7 +7,7 @@ use crate::{\n     vm::vmo::{VmoFlags, VmoOptions},\n };\n use align_ext::AlignExt;\n-use jinux_rights::{Full, Rights};\n+use aster_rights::{Full, Rights};\n \n pub const USER_HEAP_BASE: Vaddr = 0x0000_0000_1000_0000;\n pub const USER_HEAP_SIZE_LIMIT: usize = PAGE_SIZE * 1000;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n--- a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -8,9 +8,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::VmoOptions},\n };\n use align_ext::AlignExt;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use core::mem;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n \n use super::aux_vec::{AuxKey, AuxVec};\n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n--- a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -13,9 +13,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::Vmo},\n };\n use align_ext::AlignExt;\n-use jinux_frame::task::Task;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n+use aster_frame::task::Task;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use xmas_elf::program::{self, ProgramHeader64};\n \n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\n--- a/services/libs/jinux-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,8 +1,8 @@\n #![allow(non_camel_case_types)]\n use core::mem;\n \n-use jinux_frame::cpu::GeneralRegs;\n-use jinux_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n+use aster_frame::cpu::GeneralRegs;\n+use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\n--- a/services/libs/jinux-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -17,9 +17,9 @@ pub use poll::{Pollee, Poller};\n pub use sig_stack::{SigStack, SigStackFlags, SigStackStatus};\n \n use align_ext::AlignExt;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::task::Task;\n use core::mem;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::task::Task;\n \n use super::posix_thread::{PosixThread, PosixThreadExt};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\n--- a/services/libs/jinux-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,7 +1,7 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \n-use jinux_frame::sync::WaitQueue;\n+use aster_frame::sync::WaitQueue;\n \n use crate::events::Observer;\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\n--- a/services/libs/jinux-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::{CpuException, CpuExceptionInfo};\n-use jinux_frame::cpu::{\n+use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n+use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\n     INVALID_OPCODE, PAGE_FAULT, SIMD_FLOATING_POINT_EXCEPTION, X87_FLOATING_POINT_EXCEPTION,\n };\ndiff --git a/services/libs/jinux-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\n--- a/services/libs/jinux-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n+use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\n-use jinux_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n \n pub fn init() {\n     let preempt_scheduler = Box::new(PreemptScheduler::new());\ndiff --git a/services/libs/jinux-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\n--- a/services/libs/jinux-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/jinux-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\n--- a/services/libs/jinux-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\n use crate::process::{clone_child, CloneArgs, CloneFlags};\ndiff --git a/services/libs/jinux-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\n--- a/services/libs/jinux-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::UserContext;\n-use jinux_rights::WriteOp;\n+use aster_frame::cpu::UserContext;\n+use aster_rights::WriteOp;\n \n use super::{constants::*, SyscallReturn};\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/jinux-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\n--- a/services/libs/jinux-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -3,7 +3,7 @@ use crate::{\n     prelude::*,\n     process::{clone_child, CloneArgs},\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_FORK;\n \ndiff --git a/services/libs/jinux-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\n--- a/services/libs/jinux-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -5,8 +5,8 @@ use crate::vm::perms::VmPerms;\n use crate::vm::vmo::{VmoChildOptions, VmoOptions, VmoRightsOp};\n use crate::{log_syscall_entry, prelude::*};\n use align_ext::AlignExt;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n \n use crate::syscall::SYS_MMAP;\n \ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -69,7 +69,7 @@ use crate::syscall::wait4::sys_wait4;\n use crate::syscall::waitid::sys_waitid;\n use crate::syscall::write::sys_write;\n use crate::syscall::writev::sys_writev;\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use self::accept::sys_accept;\n use self::bind::sys_bind;\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n--- a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -4,7 +4,7 @@ use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::constants::{SIGKILL, SIGSTOP};\n use crate::process::signal::sig_mask::SigMask;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n pub fn sys_rt_sigprocmask(\n     how: u32,\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n--- a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -4,7 +4,7 @@ use crate::{\n     process::{posix_thread::PosixThreadExt, signal::c_types::ucontext_t},\n     util::read_val_from_user,\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use super::{SyscallReturn, SYS_RT_SIGRETRUN};\n \ndiff --git a/services/libs/jinux-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\n--- a/services/libs/jinux-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,8 +1,8 @@\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\n-use jinux_frame::cpu::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::cpu::*;\n+use aster_frame::vm::VmIo;\n \n /// We can't handle most exceptions, just send self a fault signal before return to user space.\n pub fn handle_exception(context: &UserContext) {\ndiff --git a/services/libs/jinux-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\n--- a/services/libs/jinux-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::{Priority, TaskOptions};\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::{Priority, TaskOptions};\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\n--- a/services/libs/jinux-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -5,7 +5,7 @@ use core::{\n     sync::atomic::{AtomicU32, Ordering},\n };\n \n-use jinux_frame::task::Task;\n+use aster_frame::task::Task;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\n--- a/services/libs/jinux-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n     user::{UserContextApi, UserEvent, UserMode, UserSpace},\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::cpu::CpuSet;\n+use aster_frame::cpu::CpuSet;\n use spin::Once;\n use work_item::WorkItem;\n use worker_pool::WorkerPool;\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -60,7 +60,7 @@ static WORKQUEUE_GLOBAL_HIGH_PRI: Once<Arc<WorkQueue>> = Once::new();\n /// Certainly, users can also create a dedicated WorkQueue and WorkerPool.\n ///\n /// ```rust\n-/// use jinux_frame::cpu::CpuSet;\n+/// use aster_frame::cpu::CpuSet;\n /// use crate::thread::work_queue::{WorkQueue, WorkerPool, WorkItem};\n ///\n /// fn deferred_task(){\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\n use core::sync::atomic::Ordering;\n-use jinux_frame::cpu::CpuSet;\n \n /// A task to be executed by a worker thread.\n pub struct WorkItem {\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -2,8 +2,8 @@ use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::Priority;\n \n /// A worker thread. A `Worker` will attempt to retrieve unfinished\n /// work items from its corresponding `WorkerPool`. If there are none,\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n--- a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -4,9 +4,9 @@ use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPri\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::sync::WaitQueue;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::sync::WaitQueue;\n+use aster_frame::task::Priority;\n \n /// A pool of workers.\n ///\ndiff --git a/services/libs/jinux-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\n--- a/services/libs/jinux-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -3,7 +3,7 @@ use core::time::Duration;\n \n use crate::prelude::*;\n \n-use jinux_time::read_monotonic_time;\n+use aster_time::read_monotonic_time;\n \n mod system_time;\n \ndiff --git a/services/libs/jinux-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/jinux-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,5 +1,5 @@\n+use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n-use jinux_time::{read_monotonic_time, read_start_time};\n use time::{Date, Month, PrimitiveDateTime, Time};\n \n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/jinux-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -68,8 +68,8 @@ impl SystemTime {\n     }\n }\n \n-/// convert jinux_frame::time::Time to System time\n-fn convert_system_time(system_time: jinux_time::SystemTime) -> Result<SystemTime> {\n+/// convert aster_frame::time::Time to System time\n+fn convert_system_time(system_time: aster_time::SystemTime) -> Result<SystemTime> {\n     let month = match Month::try_from(system_time.month) {\n         Ok(month) => month,\n         Err(_) => return_errno_with_message!(Errno::EINVAL, \"unknown month in system time\"),\ndiff --git a/services/libs/jinux-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\n--- a/services/libs/jinux-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n pub mod net;\n \n /// copy bytes from user space of current process. The bytes len is the len of dest.\ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -11,10 +11,10 @@\n \n use alloc::boxed::Box;\n use alloc::sync::Arc;\n-use jinux_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n-use jinux_rights::Rights;\n-use jinux_time::Instant;\n-use jinux_util::coeff::Coeff;\n+use aster_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n+use aster_rights::Rights;\n+use aster_time::Instant;\n+use aster_util::coeff::Coeff;\n use pod::Pod;\n use spin::Once;\n \ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -108,7 +108,7 @@ impl VdsoData {\n \n     /// Init vdso data based on the default clocksource.\n     fn init(&mut self) {\n-        let clocksource = jinux_time::default_clocksource();\n+        let clocksource = aster_time::default_clocksource();\n         let coeff = clocksource.coeff();\n         self.set_clock_mode(DEFAULT_CLOCK_MODE);\n         self.set_coeff(coeff);\ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -249,7 +249,7 @@ fn init_vdso() {\n pub(super) fn init() {\n     init_start_secs_count();\n     init_vdso();\n-    jinux_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n+    aster_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n }\n \n /// Return the vdso vmo.\ndiff --git a/services/libs/jinux-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\n--- a/services/libs/jinux-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -10,8 +10,8 @@\n //! [Zircon](https://fuchsia.dev/fuchsia-src/reference/kernel_objects/vm_object).\n //! As capabilities, the two abstractions are aligned with our goal\n //! of everything-is-a-capability, although their specifications and\n-//! implementations in C/C++ cannot apply directly to Jinux.\n-//! In Jinux, VMARs and VMOs, as well as other capabilities, are implemented\n+//! implementations in C/C++ cannot apply directly to Asterinas.\n+//! In Asterinas, VMARs and VMOs, as well as other capabilities, are implemented\n //! as zero-cost capabilities.\n \n pub mod page_fault_handler;\ndiff --git a/services/libs/jinux-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\n--- a/services/libs/jinux-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n use bitflags::bitflags;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n \n bitflags! {\n     /// The memory access permissions of memory mappings.\ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::{Vaddr, VmIo};\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::{Vaddr, VmIo};\n-use jinux_rights::Rights;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -23,8 +23,8 @@ impl Vmar<Rights> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -156,13 +156,13 @@ impl Vmar<Rights> {\n }\n \n impl VmIo for Vmar<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::sync::Arc;\n use alloc::sync::Weak;\n use alloc::vec::Vec;\n+use aster_frame::vm::VmSpace;\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::VmSpace;\n-use jinux_rights::Rights;\n \n use self::vm_mapping::VmMapping;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,7 +1,7 @@\n //! Options for allocating child VMARs.\n \n-use jinux_frame::config::PAGE_SIZE;\n-use jinux_frame::{Error, Result};\n+use aster_frame::config::PAGE_SIZE;\n+use aster_frame::{Error, Result};\n \n use super::Vmar;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -13,7 +13,7 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -28,8 +28,8 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar: Vmar<Full> = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,9 +1,9 @@\n use core::ops::Range;\n \n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::{Dup, Rights, TRightSet, TRights};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::VmIo;\n+use aster_rights::{Dup, Rights, TRightSet, TRights};\n+use aster_rights_proc::require;\n \n use crate::vm::{page_fault_handler::PageFaultHandler, vmo::Vmo};\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -28,8 +28,8 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::<RightsWrapper<Full>>::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -177,13 +177,13 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmar<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::sync::Mutex;\n+use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n use core::ops::Range;\n-use jinux_frame::sync::Mutex;\n-use jinux_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n \n use crate::vm::{\n     vmo::get_page_idx_range,\ndiff --git a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -2,9 +2,9 @@ use core::ops::Range;\n \n use crate::prelude::*;\n \n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::VmoRightsOp;\n use super::{\ndiff --git a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -150,13 +150,13 @@ impl Vmo<Rights> {\n }\n \n impl VmIo for Vmo<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -3,8 +3,8 @@\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n-use jinux_rights::Rights;\n+use aster_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n+use aster_rights::Rights;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/jinux-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -66,7 +66,7 @@ pub use pager::Pager;\n /// # Implementation\n ///\n /// `Vmo` provides high-level APIs for address space management by wrapping\n-/// around its low-level counterpart `jinux_frame::vm::VmFrames`.\n+/// around its low-level counterpart `aster_frame::vm::VmFrames`.\n /// Compared with `VmFrames`,\n /// `Vmo` is easier to use (by offering more powerful APIs) and\n /// harder to misuse (thanks to its nature of being capability).\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -4,15 +4,15 @@ use core::marker::PhantomData;\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n+use aster_rights_proc::require;\n use typeflags_util::{SetExtend, SetExtendOp};\n \n use crate::prelude::*;\n \n use crate::vm::vmo::get_inherited_frames_from_parent;\n use crate::vm::vmo::{VmoInner, Vmo_};\n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{Pager, Vmo, VmoFlags};\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -23,7 +23,7 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _dynamic_ capability with full access rights:\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -32,8 +32,8 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _static_ capability with all access rights:\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::<Full>::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -44,7 +44,7 @@ use super::{Pager, Vmo, VmoFlags};\n /// physically contiguous:\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n ///\n /// let vmo = VmoOptions::new(10 * PAGE_SIZE)\n ///     .flags(VmoFlags::RESIZABLE)\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -164,7 +164,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -178,8 +178,8 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo: Vmo<Full> = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -196,7 +196,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// right regardless of whether the parent is writable or not.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -211,7 +211,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// The above rule for COW VMO children also applies to static capabilities.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::<TRights![Read, Dup]>::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -227,7 +227,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// Note that a slice VMO child and its parent cannot not be resizable.\n ///\n /// ```rust\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\ndiff --git a/services/libs/jinux-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\n--- a/services/libs/jinux-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmFrame;\n+use aster_frame::vm::VmFrame;\n \n /// Pagers provide frame to a VMO.\n ///\ndiff --git a/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,9 +1,9 @@\n use crate::prelude::*;\n+use aster_frame::vm::VmIo;\n+use aster_rights_proc::require;\n use core::ops::Range;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights_proc::require;\n \n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{\ndiff --git a/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/jinux-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -145,13 +145,13 @@ impl<R: TRights> Vmo<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmo<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\n--- a/services/libs/jinux-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -9,5 +9,5 @@\n /// _exclusively_ to one another. In other words, a type should not implement\n /// both traits.\n pub trait Dup: Sized {\n-    fn dup(&self) -> jinux_frame::Result<Self>;\n+    fn dup(&self) -> aster_frame::Result<Self>;\n }\ndiff --git a/services/libs/jinux-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\n--- a/services/libs/jinux-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The util of jinux\n+//! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \ndiff --git a/services/libs/jinux-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/jinux-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,10 +1,10 @@\n+use aster_frame::vm::Paddr;\n+use aster_frame::vm::{HasPaddr, VmIo};\n+use aster_frame::Result;\n+use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n use core::fmt::Debug;\n use core::marker::PhantomData;\n-use jinux_frame::vm::Paddr;\n-use jinux_frame::vm::{HasPaddr, VmIo};\n-use jinux_frame::Result;\n-use jinux_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \ndiff --git a/services/libs/jinux-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/jinux-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -358,14 +358,14 @@ impl<T, M: Debug, R> Debug for SafePtr<T, M, R> {\n #[macro_export]\n macro_rules! field_ptr {\n     ($ptr:expr, $type:ty, $($field:tt)+) => {{\n-        use jinux_frame::offset_of;\n-        use jinux_frame::vm::VmIo;\n-        use jinux_rights::Dup;\n-        use jinux_rights::TRightSet;\n-        use jinux_rights::TRights;\n-        use jinux_util::safe_ptr::Pod;\n-        use jinux_util::safe_ptr::SetContain;\n-        use jinux_util::safe_ptr::SafePtr;\n+        use aster_frame::offset_of;\n+        use aster_frame::vm::VmIo;\n+        use aster_rights::Dup;\n+        use aster_rights::TRightSet;\n+        use aster_rights::TRights;\n+        use aster_util::safe_ptr::Pod;\n+        use aster_util::safe_ptr::SetContain;\n+        use aster_util::safe_ptr::SafePtr;\n \n         #[inline]\n         fn new_field_ptr<T, M, R, U>(\ndiff --git a/services/libs/jinux-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\n--- a/services/libs/jinux-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -35,7 +35,7 @@ macro_rules! read_union_fields {\n         union_read_ptr.read_at(offset)\n     });\n     ($container:ident.$($field:ident).*) => ({\n-        let field_offset = jinux_frame::value_offset!($container.$($field).*);\n+        let field_offset = aster_frame::value_offset!($container.$($field).*);\n         let union_read_ptr = UnionReadPtr::new(&*$container);\n         union_read_ptr.read_at(field_offset)\n     });\ndiff --git a/services/libs/comp-sys/cargo-component/README.md b/services/libs/comp-sys/cargo-component/README.md\n--- a/services/libs/comp-sys/cargo-component/README.md\n+++ b/services/libs/comp-sys/cargo-component/README.md\n@@ -1,15 +1,15 @@\n ## Overview\n-The crate contains cargo-component, a cargo subcommand to enable component-level access control in Jinux. For more info about Jinux component system, see the [RFC](https://github.com/jinzhao-dev/jinux/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n+The crate contains cargo-component, a cargo subcommand to enable component-level access control in Asterinas. For more info about Asterinas component system, see the [RFC](https://github.com/asterinas/Asterinas/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n \n ## install\n-After running `make setup` for jinux, this crate can be created with cargo.\n+After running `make setup` for Asterinas, this crate can be created with cargo.\n ```shell\n cargo install --path .\n ```\n This will install two binaries `cargo-component` and `component-driver` at `$HOME/.cargo/bin`(by default, it depends on the cargo config).\n \n ## Usage\n-Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For jinux, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n+Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For Asterinas, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n \n ### Two notes:\n - The directory **where you run the command** should contains a `Components.toml` config file, where defines all components and whitelist. \ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,7 +1,7 @@\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\n-//! When use jinux-typeflags or jinux-rights-poc, this crate should also be added as a dependency.\n+//! When use typeflags or aster-rights-poc, this crate should also be added as a dependency.\n #![no_std]\n pub mod assert;\n pub mod bool;\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the procedural macro typeflags to implement capability for jinux.\n+//\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\n //! So we leave the common type-level operations and structures defined in typeflags-util.\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,6 +1,6 @@\n #!/bin/bash\n \n-# This script is used to update Jinux version numbers in all relevant files in the repository.\n+# This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \n # Update Cargo style versions (`version = \"{version}\"`) in file $1\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -9,16 +9,16 @@ update_cargo_versions() {\n     sed -i \"s/^version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"$/version = \\\"${new_version}\\\"/g\" $1\n }\n \n-# Update Docker image versions (`jinuxdev/jinux:{version}`) in file $1\n+# Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\n-    sed -i \"s/jinuxdev\\/jinux:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/jinuxdev\\/jinux:${new_version}/g\" $1\n+    sed -i \"s/asterinas\\/asterinas:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/asterinas\\/asterinas:${new_version}/g\" $1\n }\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/..\n-CARGO_TOML_PATH=${JINUX_SRC_DIR}/Cargo.toml\n-VERSION_PATH=${JINUX_SRC_DIR}/VERSION\n+ASTER_SRC_DIR=${SCRIPT_DIR}/..\n+CARGO_TOML_PATH=${ASTER_SRC_DIR}/Cargo.toml\n+VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n # Get and check the new version number\n if [[ $1 =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -32,14 +32,14 @@ fi\n update_cargo_versions ${CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p jinux --precise $new_version\n+cargo update -p asterinas --precise $new_version\n \n # Update Docker image versions in README files\n-update_image_versions ${JINUX_SRC_DIR}/README.md\n+update_image_versions ${ASTER_SRC_DIR}/README.md\n update_image_versions ${SCRIPT_DIR}/docker/README.md\n \n # Update Docker image versions in workflows\n-WORKFLOWS=$(find \"${JINUX_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n+WORKFLOWS=$(find \"${ASTER_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n for workflow in $WORKFLOWS; do\n     update_image_versions $workflow\n done\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -47,4 +47,4 @@ done\n # Create or update VERSION\n echo \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Jinux version to $new_version\"\n+echo \"Bumped Asterinas version to $new_version\"\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -182,15 +182,15 @@ RUN make defconfig \\\n     && sed -i \"s/# CONFIG_FEATURE_SH_STANDALONE is not set/CONFIG_FEATURE_SH_STANDALONE=y/g\" .config \\\n     && make -j\n \n-#= The final stages to produce the Jinux development image ====================\n+#= The final stages to produce the Asterinas development image ====================\n \n FROM build-base as rust\n \n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n-ARG JINUX_RUST_VERSION\n+ARG ASTER_RUST_VERSION\n RUN curl https://sh.rustup.rs -sSf | \\\n-        sh -s -- --default-toolchain ${JINUX_RUST_VERSION} -y \\\n+        sh -s -- --default-toolchain ${ASTER_RUST_VERSION} -y \\\n     && rm -rf /root/.cargo/registry && rm -rf /root/.cargo/git \\\n     && cargo -V \\\n     && rustup component add rust-src rustc-dev llvm-tools-preview\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -202,7 +202,7 @@ RUN cargo install \\\n \n FROM rust\n \n-# Install all Jinux dependent packages\n+# Install all Asterinas dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -249,9 +249,9 @@ COPY --from=busybox /root/busybox/busybox /bin/busybox\n # Install benchmarks built from the previous stages\n COPY --from=build-benchmarks /usr/local/benchmark /usr/local/benchmark\n \n-# Add the path of jinux tools\n-ENV PATH=\"/root/jinux/target/bin:${PATH}\"\n+# Add the path of Asterinas tools\n+ENV PATH=\"/root/asterinas/target/bin:${PATH}\"\n \n-VOLUME [ \"/root/jinux\" ]\n+VOLUME [ \"/root/asterinas\" ]\n \n-WORKDIR /root/jinux\n+WORKDIR /root/asterinas\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -3,9 +3,9 @@\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/../..\n+ASTER_SRC_DIR=${SCRIPT_DIR}/../..\n CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n-VERSION=$( cat ${JINUX_SRC_DIR}/VERSION )\n-IMAGE_NAME=jinuxdev/jinux:${VERSION}\n+VERSION=$( cat ${ASTER_SRC_DIR}/VERSION )\n+IMAGE_NAME=asterinas/asterinas:${VERSION}\n \n-docker run -it --privileged --network=host --device=/dev/kvm -v ${JINUX_SRC_DIR}:/root/jinux ${IMAGE_NAME}\n+docker run -it --privileged --network=host --device=/dev/kvm -v ${ASTER_SRC_DIR}:/root/asterinas ${IMAGE_NAME}\n",
        "test_patch": "",
        "problem_statement": "Rename the project name from Jinux to Asterinas\nThe project's official name will be Asterinas. The renaming process consists of the following steps:\r\n1. The Github repo will be renamed to `asterinas` and moved to the `asterinas` Github org. \r\n2. The DockerHub Image will be moved to `asterinas/asterinas`.\r\n3. All occurrences of `Jinux` in the codebase should be renamed to `Asterinas`.\r\n4. All occurrences of `jinux-` (or `jinux_`) as in the codebase should be renamed to `aster-` (or `aster_`).\r\n5. The ascii-art LOGO should be replaced accordingly.\r\n\r\nWe will make the project open source as long as we are given the green light by the management. Renaming will be done the first day when the project is open sourced.\r\n\n",
        "hints_text": "",
        "created_at": "2023-12-25T03:34:33Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 193,
        "instance_id": "asterinas__asterinas-193",
        "issue_numbers": [
            "124"
        ],
        "base_commit": "7e1584fca9b0bb818ea8f115ab471bc21613b7bd",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -145,6 +145,15 @@ dependencies = [\n name = \"cpio-decoder\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n [[package]]\n name = \"ctor\"\n version = \"0.1.25\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -359,11 +368,12 @@ dependencies = [\n  \"jinux-rights-proc\",\n  \"jinux-time\",\n  \"jinux-util\",\n+ \"keyable-arc\",\n  \"lazy_static\",\n  \"log\",\n  \"lru\",\n  \"pod\",\n- \"ringbuffer\",\n+ \"ringbuf\",\n  \"spin 0.9.4\",\n  \"time\",\n  \"typeflags\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -411,6 +421,10 @@ version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n \n+[[package]]\n+name = \"keyable-arc\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -536,10 +550,13 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"ringbuffer\"\n-version = \"0.10.0\"\n+name = \"ringbuf\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"310a2514cb46bb500a2f2ad70c79c51c5a475cc23faa245d2c675faabe889370\"\n+checksum = \"93ca10b9c9e53ac855a2d6953bce34cef6edbac32c4b13047a4d59d67299420a\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n \n [[package]]\n name = \"rsdp\"\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/jinux-std/Cargo.toml\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/jinux-std/Cargo.toml\n@@ -28,7 +28,8 @@ xmas-elf = \"0.8.0\"\n # goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n # data-structures\n bitflags = \"1.3\"\n-ringbuffer = \"0.10.0\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"../keyable-arc\" }\n \n spin = \"0.9.4\"\n vte = \"0.10\"\ndiff --git a/services/libs/jinux-std/src/events/events.rs b/services/libs/jinux-std/src/events/events.rs\n--- a/services/libs/jinux-std/src/events/events.rs\n+++ b/services/libs/jinux-std/src/events/events.rs\n@@ -1,2 +1,34 @@\n /// A trait to represent any events.\n pub trait Events: Copy + Clone + Send + Sync + 'static {}\n+\n+/// A trait to filter events.\n+///\n+/// # The no-op event filter\n+///\n+/// The unit type `()` can serve as a no-op event filter.\n+/// It implements `EventsFilter<E>` for any events type `E`,\n+/// with a `filter` method that always returns `true`.\n+/// If the `F` type of `Subject<E, F>` is not specified explicitly,\n+/// then the unit type `()` is chosen as the event filter.\n+///\n+/// # Per-object event filter\n+///\n+/// Any `Option<F: EventsFilter>` is also an event filter thanks to\n+/// the blanket implementations the `EventsFilter` trait.\n+/// By using `Option<F: EventsFilter>`, we can decide, on a per-observer basis,\n+/// if an observer needs an event filter.\n+pub trait EventsFilter<E: Events>: Send + Sync + 'static {\n+    fn filter(&self, event: &E) -> bool;\n+}\n+\n+impl<E: Events> EventsFilter<E> for () {\n+    fn filter(&self, _events: &E) -> bool {\n+        true\n+    }\n+}\n+\n+impl<E: Events, F: EventsFilter<E>> EventsFilter<E> for Option<F> {\n+    fn filter(&self, events: &E) -> bool {\n+        self.as_ref().map_or(true, |f| f.filter(events))\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/events/mod.rs b/services/libs/jinux-std/src/events/mod.rs\n--- a/services/libs/jinux-std/src/events/mod.rs\n+++ b/services/libs/jinux-std/src/events/mod.rs\n@@ -2,6 +2,6 @@ mod events;\n mod observer;\n mod subject;\n \n-pub use self::events::Events;\n+pub use self::events::{Events, EventsFilter};\n pub use self::observer::Observer;\n pub use self::subject::Subject;\ndiff --git a/services/libs/jinux-std/src/events/subject.rs b/services/libs/jinux-std/src/events/subject.rs\n--- a/services/libs/jinux-std/src/events/subject.rs\n+++ b/services/libs/jinux-std/src/events/subject.rs\n@@ -1,43 +1,86 @@\n use crate::prelude::*;\n \n-use super::{Events, Observer};\n+use core::sync::atomic::{AtomicUsize, Ordering};\n+use keyable_arc::KeyableWeak;\n \n-/// A Subject notify interesting events to registered observers.\n-pub struct Subject<E: Events> {\n-    observers: Mutex<Vec<Weak<dyn Observer<E>>>>,\n+use super::{Events, EventsFilter, Observer};\n+\n+/// A Subject notifies interesting events to registered observers.\n+pub struct Subject<E: Events, F: EventsFilter<E> = ()> {\n+    // A table that maintains all interesting observers.\n+    observers: Mutex<BTreeMap<KeyableWeak<dyn Observer<E>>, F>>,\n+    // To reduce lock contentions, we maintain a counter for the size of the table\n+    num_observers: AtomicUsize,\n }\n \n-impl<E: Events> Subject<E> {\n+impl<E: Events, F: EventsFilter<E>> Subject<E, F> {\n     pub fn new() -> Self {\n         Self {\n-            observers: Mutex::new(Vec::new()),\n+            observers: Mutex::new(BTreeMap::new()),\n+            num_observers: AtomicUsize::new(0),\n         }\n     }\n \n     /// Register an observer.\n-    pub fn register_observer(&self, observer: Weak<dyn Observer<E>>) {\n+    ///\n+    /// A registered observer will get notified through its `on_events` method.\n+    /// If events `filter` is provided, only filtered events will notify the observer.\n+    ///\n+    /// If the given observer has already been registered, then its registered events\n+    /// filter will be updated.\n+    pub fn register_observer(&self, observer: Weak<dyn Observer<E>>, filter: F) {\n         let mut observers = self.observers.lock();\n-        observers.push(observer);\n+        let is_new = {\n+            let observer: KeyableWeak<dyn Observer<E>> = observer.into();\n+            observers.insert(observer, filter).is_none()\n+        };\n+        if is_new {\n+            self.num_observers.fetch_add(1, Ordering::Release);\n+        }\n     }\n \n     /// Unregister an observer.\n-    pub fn unregister_observer(&self, observer: Weak<dyn Observer<E>>) {\n+    ///\n+    /// If such an observer is found, then the registered observer will be\n+    /// removed from the subject and returned as the return value. Otherwise,\n+    /// a `None` will be returned.\n+    pub fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<E>>,\n+    ) -> Option<Weak<dyn Observer<E>>> {\n+        let observer: KeyableWeak<dyn Observer<E>> = observer.clone().into();\n         let mut observers = self.observers.lock();\n-        observers.retain(|e| !Weak::ptr_eq(&e, &observer));\n+        let observer = observers\n+            .remove_entry(&observer)\n+            .map(|(observer, _)| observer.into());\n+        if observer.is_some() {\n+            self.num_observers.fetch_sub(1, Ordering::Relaxed);\n+        }\n+        observer\n     }\n \n     /// Notify events to all registered observers.\n+    ///\n     /// It will remove the observers which have been freed.\n     pub fn notify_observers(&self, events: &E) {\n+        // Fast path.\n+        if self.num_observers.load(Ordering::Relaxed) == 0 {\n+            return;\n+        }\n+\n+        // Slow path: broadcast the new events to all observers.\n         let mut observers = self.observers.lock();\n-        let mut idx = 0;\n-        while idx < observers.len() {\n-            if let Some(observer) = observers[idx].upgrade() {\n+        observers.retain(|observer, filter| {\n+            if let Some(observer) = observer.upgrade() {\n+                if !filter.filter(events) {\n+                    return true;\n+                }\n                 observer.on_events(events);\n-                idx += 1;\n+                true\n             } else {\n-                observers.remove(idx);\n+                self.num_observers.fetch_sub(1, Ordering::Relaxed);\n+                false\n             }\n-        }\n+        });\n     }\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/epoll/epoll_file.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/epoll/epoll_file.rs\n@@ -0,0 +1,490 @@\n+use crate::events::Observer;\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::file_table::{FdEvents, FileDescripter};\n+use crate::fs::utils::{IoEvents, IoctlCmd, Pollee, Poller};\n+\n+use core::sync::atomic::{AtomicBool, Ordering};\n+use core::time::Duration;\n+\n+use super::*;\n+\n+/// A file-like object that provides epoll API.\n+///\n+/// Conceptually, we maintain two lists: one consists of all interesting files,\n+/// which can be managed by the epoll ctl commands; the other are for ready files,\n+/// which are files that have some events. A epoll wait only needs to iterate the\n+/// ready list and poll each file to see if the file is ready for the interesting\n+/// I/O.\n+///\n+/// To maintain the ready list, we need to monitor interesting events that happen\n+/// on the files. To do so, the `EpollFile` registers itself as an `Observer` to\n+/// the monotored files. Thus, we can add a file to the ready list when an interesting\n+/// event happens on the file.\n+pub struct EpollFile {\n+    // All interesting entries.\n+    interest: Mutex<BTreeMap<FileDescripter, Arc<EpollEntry>>>,\n+    // Entries that are probably ready (having events happened).\n+    ready: Mutex<VecDeque<Arc<EpollEntry>>>,\n+    // EpollFile itself is also pollable\n+    pollee: Pollee,\n+    // Any EpollFile is wrapped with Arc when created.\n+    weak_self: Weak<Self>,\n+}\n+\n+impl EpollFile {\n+    /// Creates a new epoll file.\n+    pub fn new() -> Arc<Self> {\n+        Arc::new_cyclic(|me| Self {\n+            interest: Mutex::new(BTreeMap::new()),\n+            ready: Mutex::new(VecDeque::new()),\n+            pollee: Pollee::new(IoEvents::empty()),\n+            weak_self: me.clone(),\n+        })\n+    }\n+\n+    /// Control the interest list of the epoll file.\n+    pub fn control(&self, cmd: &EpollCtl) -> Result<()> {\n+        match *cmd {\n+            EpollCtl::Add(fd, ep_event, ep_flags) => self.add_interest(fd, ep_event, ep_flags),\n+            EpollCtl::Del(fd) => {\n+                self.del_interest(fd)?;\n+                self.unregister_from_file_table_entry(fd);\n+                Ok(())\n+            }\n+            EpollCtl::Mod(fd, ep_event, ep_flags) => self.mod_interest(fd, ep_event, ep_flags),\n+        }\n+    }\n+\n+    fn add_interest(\n+        &self,\n+        fd: FileDescripter,\n+        ep_event: EpollEvent,\n+        ep_flags: EpollFlags,\n+    ) -> Result<()> {\n+        self.warn_unsupported_flags(&ep_flags);\n+\n+        let current = current!();\n+        let file_table = current.file_table().lock();\n+        let file_table_entry = file_table.get_entry(fd)?;\n+        let file = file_table_entry.file();\n+        let weak_file = Arc::downgrade(file);\n+        let mask = ep_event.events;\n+        let entry = EpollEntry::new(fd, weak_file, ep_event, ep_flags, self.weak_self.clone());\n+\n+        // Add the new entry to the interest list and start monitering its events\n+        let mut interest = self.interest.lock();\n+        if interest.contains_key(&fd) {\n+            return_errno_with_message!(Errno::EEXIST, \"the fd has been added\");\n+        }\n+        file.register_observer(entry.self_weak() as _, IoEvents::all())?;\n+        interest.insert(fd, entry.clone());\n+        // Register self to the file table entry\n+        file_table_entry.register_observer(self.weak_self.clone() as _);\n+        let file = file.clone();\n+        drop(file_table);\n+        drop(interest);\n+\n+        // Add the new entry to the ready list if the file is ready\n+        let events = file.poll(mask, None);\n+        if !events.is_empty() {\n+            self.push_ready(entry);\n+        }\n+        Ok(())\n+    }\n+\n+    fn del_interest(&self, fd: FileDescripter) -> Result<()> {\n+        let mut interest = self.interest.lock();\n+        let entry = interest\n+            .remove(&fd)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"fd is not in the interest list\"))?;\n+\n+        // If this epoll entry is in the ready list, then we should delete it.\n+        // But unfortunately, deleting an entry from the ready list has a\n+        // complexity of O(N).\n+        //\n+        // To optimize the performance, we only mark the epoll entry as\n+        // deleted at this moment. The real deletion happens when the ready list\n+        // is scanned in EpolFile::wait.\n+        entry.set_deleted();\n+\n+        let file = match entry.file() {\n+            Some(file) => file,\n+            // TODO: should we warn about it?\n+            None => return Ok(()),\n+        };\n+\n+        file.unregister_observer(&(entry.self_weak() as _)).unwrap();\n+        Ok(())\n+    }\n+\n+    fn mod_interest(\n+        &self,\n+        fd: FileDescripter,\n+        new_ep_event: EpollEvent,\n+        new_ep_flags: EpollFlags,\n+    ) -> Result<()> {\n+        self.warn_unsupported_flags(&new_ep_flags);\n+\n+        // Update the epoll entry\n+        let interest = self.interest.lock();\n+        let entry = interest\n+            .get(&fd)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"fd is not in the interest list\"))?;\n+        if entry.is_deleted() {\n+            return_errno_with_message!(Errno::ENOENT, \"fd is not in the interest list\");\n+        }\n+        let new_mask = new_ep_event.events;\n+        entry.update(new_ep_event, new_ep_flags);\n+        let entry = entry.clone();\n+        drop(interest);\n+\n+        // Add the updated entry to the ready list if the file is ready\n+        let file = match entry.file() {\n+            Some(file) => file,\n+            None => return Ok(()),\n+        };\n+        let events = file.poll(new_mask, None);\n+        if !events.is_empty() {\n+            self.push_ready(entry);\n+        }\n+        Ok(())\n+    }\n+\n+    fn unregister_from_file_table_entry(&self, fd: FileDescripter) {\n+        let current = current!();\n+        let file_table = current.file_table().lock();\n+        if let Ok(entry) = file_table.get_entry(fd) {\n+            entry.unregister_observer(&(self.weak_self.clone() as _));\n+        }\n+    }\n+\n+    /// Wait for interesting events happen on the files in the interest list\n+    /// of the epoll file.\n+    ///\n+    /// This method blocks until either some interesting events happen or\n+    /// the timeout expires or a signal arrives. The first case returns\n+    /// `Ok(events)`, where `events` is a `Vec` containing at most `max_events`\n+    /// number of `EpollEvent`s. The second and third case returns errors.\n+    ///\n+    /// When `max_events` equals to zero, the method returns when the timeout\n+    /// expires or a signal arrives.\n+    pub fn wait(&self, max_events: usize, timeout: Option<&Duration>) -> Result<Vec<EpollEvent>> {\n+        let mut ep_events = Vec::new();\n+        let mut poller = None;\n+        loop {\n+            // Try to pop some ready entries\n+            if self.pop_ready(max_events, &mut ep_events) > 0 {\n+                return Ok(ep_events);\n+            }\n+\n+            // Return immediately if specifying a timeout of zero\n+            if timeout.is_some() && timeout.as_ref().unwrap().is_zero() {\n+                return Ok(ep_events);\n+            }\n+\n+            // If no ready entries for now, wait for them\n+            if poller.is_none() {\n+                poller = Some(Poller::new());\n+                let events = self.pollee.poll(IoEvents::IN, poller.as_ref());\n+                if !events.is_empty() {\n+                    continue;\n+                }\n+            }\n+\n+            // FIXME: respect timeout parameter\n+            poller.as_ref().unwrap().wait();\n+        }\n+    }\n+\n+    fn push_ready(&self, entry: Arc<EpollEntry>) {\n+        let mut ready = self.ready.lock();\n+        if entry.is_deleted() {\n+            return;\n+        }\n+\n+        if !entry.is_ready() {\n+            entry.set_ready();\n+            ready.push_back(entry);\n+        }\n+\n+        // Even if the entry is already set to ready, there might be new events that we are interested in.\n+        // Wake the poller anyway.\n+        self.pollee.add_events(IoEvents::IN);\n+    }\n+\n+    fn pop_ready(&self, max_events: usize, ep_events: &mut Vec<EpollEvent>) -> usize {\n+        let mut count_events = 0;\n+        let mut ready = self.ready.lock();\n+        let mut pop_quota = ready.len();\n+        loop {\n+            // Pop some ready entries per round.\n+            //\n+            // Since the popped ready entries may contain \"false positive\" and\n+            // we want to return as many results as possible, this has to\n+            // be done in a loop.\n+            let pop_count = (max_events - count_events).min(pop_quota);\n+            if pop_count == 0 {\n+                break;\n+            }\n+            let ready_entries: Vec<Arc<EpollEntry>> = ready\n+                .drain(..pop_count)\n+                .filter(|entry| !entry.is_deleted())\n+                .collect();\n+            pop_quota -= pop_count;\n+\n+            // Examine these ready entries, which are candidates for the results\n+            // to be returned.\n+            for entry in ready_entries {\n+                let (ep_event, ep_flags) = entry.event_and_flags();\n+                // If this entry's file is ready, save it in the output array.\n+                // EPOLLHUP and EPOLLERR should always be reported.\n+                let ready_events = entry.poll() & (ep_event.events | IoEvents::HUP | IoEvents::ERR);\n+                if !ready_events.is_empty() {\n+                    ep_events.push(EpollEvent::new(ready_events, ep_event.user_data));\n+                    count_events += 1;\n+                }\n+\n+                // If the epoll entry is neither edge-triggered or one-shot, then we should\n+                // keep the entry in the ready list.\n+                if !ep_flags.intersects(EpollFlags::ONE_SHOT | EpollFlags::EDGE_TRIGGER) {\n+                    ready.push_back(entry);\n+                }\n+                // Otherwise, the entry is indeed removed the ready list and we should reset\n+                // its ready flag.\n+                else {\n+                    entry.reset_ready();\n+                    // For EPOLLONESHOT flag, this entry should also be removed from the interest list\n+                    if ep_flags.intersects(EpollFlags::ONE_SHOT) {\n+                        self.del_interest(entry.fd())\n+                            .expect(\"this entry should be in the interest list\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Clear the epoll file's events if no ready entries\n+        if ready.len() == 0 {\n+            self.pollee.del_events(IoEvents::IN);\n+        }\n+        count_events\n+    }\n+\n+    fn warn_unsupported_flags(&self, flags: &EpollFlags) {\n+        if flags.intersects(EpollFlags::EXCLUSIVE | EpollFlags::WAKE_UP) {\n+            warn!(\"{:?} contains unsupported flags\", flags);\n+        }\n+    }\n+}\n+\n+impl Observer<FdEvents> for EpollFile {\n+    fn on_events(&self, events: &FdEvents) {\n+        // Delete the file from the interest list if it is closed.\n+        if let FdEvents::Close(fd) = events {\n+            let _ = self.del_interest(*fd);\n+        }\n+    }\n+}\n+\n+impl Drop for EpollFile {\n+    fn drop(&mut self) {\n+        trace!(\"EpollFile Drop\");\n+        let mut interest = self.interest.lock();\n+        let fds: Vec<_> = interest\n+            .drain_filter(|_, _| true)\n+            .map(|(fd, entry)| {\n+                entry.set_deleted();\n+                if let Some(file) = entry.file() {\n+                    let _ = file.unregister_observer(&(entry.self_weak() as _));\n+                }\n+                fd\n+            })\n+            .collect();\n+        drop(interest);\n+\n+        fds.iter()\n+            .for_each(|&fd| self.unregister_from_file_table_entry(fd));\n+    }\n+}\n+\n+// Implement the common methods required by FileHandle\n+impl FileLike for EpollFile {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support read\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support write\");\n+    }\n+\n+    fn ioctl(&self, _cmd: IoctlCmd, _arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"epoll files do not support ioctl\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.pollee.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.pollee.register_observer(observer, mask);\n+        Ok(())\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.pollee\n+            .unregister_observer(observer)\n+            .ok_or_else(|| Error::with_message(Errno::ENOENT, \"observer is not registered\"))\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+/// An epoll entry contained in an epoll file. Each epoll entry is added, modified,\n+/// or deleted by the `EpollCtl` command.\n+pub struct EpollEntry {\n+    fd: FileDescripter,\n+    file: Weak<dyn FileLike>,\n+    inner: Mutex<Inner>,\n+    // Whether the entry is in the ready list\n+    is_ready: AtomicBool,\n+    // Whether the entry has been deleted from the interest list\n+    is_deleted: AtomicBool,\n+    // Refers to the epoll file containing this epoll entry\n+    weak_epoll: Weak<EpollFile>,\n+    // An EpollEntry is always contained inside Arc\n+    weak_self: Weak<Self>,\n+}\n+\n+struct Inner {\n+    event: EpollEvent,\n+    flags: EpollFlags,\n+}\n+\n+impl EpollEntry {\n+    /// Creates a new epoll entry associated with the given epoll file.\n+    pub fn new(\n+        fd: FileDescripter,\n+        file: Weak<dyn FileLike>,\n+        event: EpollEvent,\n+        flags: EpollFlags,\n+        weak_epoll: Weak<EpollFile>,\n+    ) -> Arc<Self> {\n+        Arc::new_cyclic(|me| Self {\n+            fd,\n+            file,\n+            inner: Mutex::new(Inner { event, flags }),\n+            is_ready: AtomicBool::new(false),\n+            is_deleted: AtomicBool::new(false),\n+            weak_epoll,\n+            weak_self: me.clone(),\n+        })\n+    }\n+\n+    /// Get the epoll file associated with this epoll entry.\n+    pub fn epoll_file(&self) -> Option<Arc<EpollFile>> {\n+        self.weak_epoll.upgrade()\n+    }\n+\n+    /// Get an instance of `Arc` that refers to this epoll entry.\n+    pub fn self_arc(&self) -> Arc<Self> {\n+        self.weak_self.upgrade().unwrap()\n+    }\n+\n+    /// Get an instance of `Weak` that refers to this epoll entry.\n+    pub fn self_weak(&self) -> Weak<Self> {\n+        self.weak_self.clone()\n+    }\n+\n+    /// Get the file associated with this epoll entry.\n+    ///\n+    /// Since an epoll entry only holds a weak reference to the file,\n+    /// it is possible (albeit unlikely) that the file has been dropped.\n+    pub fn file(&self) -> Option<Arc<dyn FileLike>> {\n+        self.file.upgrade()\n+    }\n+\n+    /// Get the epoll event associated with the epoll entry.\n+    pub fn event(&self) -> EpollEvent {\n+        let inner = self.inner.lock();\n+        inner.event\n+    }\n+\n+    /// Get the epoll flags associated with the epoll entry.\n+    pub fn flags(&self) -> EpollFlags {\n+        let inner = self.inner.lock();\n+        inner.flags\n+    }\n+\n+    /// Get the epoll event and flags that are associated with this epoll entry.\n+    pub fn event_and_flags(&self) -> (EpollEvent, EpollFlags) {\n+        let inner = self.inner.lock();\n+        (inner.event, inner.flags)\n+    }\n+\n+    /// Poll the events of the file associated with this epoll entry.\n+    ///\n+    /// If the returned events is not empty, then the file is considered ready.\n+    pub fn poll(&self) -> IoEvents {\n+        match self.file.upgrade() {\n+            Some(file) => file.poll(IoEvents::all(), None),\n+            None => IoEvents::empty(),\n+        }\n+    }\n+\n+    /// Update the epoll entry, most likely to be triggered via `EpollCtl::Mod`.\n+    pub fn update(&self, event: EpollEvent, flags: EpollFlags) {\n+        let mut inner = self.inner.lock();\n+        *inner = Inner { event, flags }\n+    }\n+\n+    /// Returns whether the epoll entry is in the ready list.\n+    pub fn is_ready(&self) -> bool {\n+        self.is_ready.load(Ordering::Relaxed)\n+    }\n+\n+    /// Mark the epoll entry as being in the ready list.\n+    pub fn set_ready(&self) {\n+        self.is_ready.store(true, Ordering::Relaxed);\n+    }\n+\n+    /// Mark the epoll entry as not being in the ready list.\n+    pub fn reset_ready(&self) {\n+        self.is_ready.store(false, Ordering::Relaxed)\n+    }\n+\n+    /// Returns whether the epoll entry has been deleted from the interest list.\n+    pub fn is_deleted(&self) -> bool {\n+        self.is_deleted.load(Ordering::Relaxed)\n+    }\n+\n+    /// Mark the epoll entry as having been deleted from the interest list.\n+    pub fn set_deleted(&self) {\n+        self.is_deleted.store(true, Ordering::Relaxed);\n+    }\n+\n+    /// Get the file descriptor associated with the epoll entry.\n+    pub fn fd(&self) -> FileDescripter {\n+        self.fd\n+    }\n+}\n+\n+impl Observer<IoEvents> for EpollEntry {\n+    fn on_events(&self, _events: &IoEvents) {\n+        // Fast path\n+        if self.is_deleted() {\n+            return;\n+        }\n+\n+        if let Some(epoll_file) = self.epoll_file() {\n+            epoll_file.push_ready(self.self_arc());\n+        }\n+    }\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/epoll/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/epoll/mod.rs\n@@ -0,0 +1,72 @@\n+use super::file_table::FileDescripter;\n+use super::utils::IoEvents;\n+use crate::prelude::*;\n+\n+mod epoll_file;\n+\n+pub use self::epoll_file::EpollFile;\n+\n+/// An epoll control command.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum EpollCtl {\n+    Add(FileDescripter, EpollEvent, EpollFlags),\n+    Del(FileDescripter),\n+    Mod(FileDescripter, EpollEvent, EpollFlags),\n+}\n+\n+bitflags! {\n+    /// Linux's epoll flags.\n+    pub struct EpollFlags: u32 {\n+        const EXCLUSIVE      = (1 << 28);\n+        const WAKE_UP        = (1 << 29);\n+        const ONE_SHOT       = (1 << 30);\n+        const EDGE_TRIGGER   = (1 << 31);\n+    }\n+}\n+\n+/// An epoll event.\n+///\n+/// This could be used as either an input of epoll ctl or an output of epoll wait.\n+/// The memory layout is compatible with that of C's struct epoll_event.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct EpollEvent {\n+    /// I/O events.\n+    ///\n+    /// When `EpollEvent` is used as inputs, this is treated as a mask of events.\n+    /// When `EpollEvent` is used as outputs, this is the active events.\n+    pub events: IoEvents,\n+    /// A 64-bit, user-given data.\n+    pub user_data: u64,\n+}\n+\n+impl EpollEvent {\n+    /// Create a new epoll event.\n+    pub fn new(events: IoEvents, user_data: u64) -> Self {\n+        Self { events, user_data }\n+    }\n+}\n+\n+impl From<&c_epoll_event> for EpollEvent {\n+    fn from(c_event: &c_epoll_event) -> Self {\n+        Self {\n+            events: IoEvents::from_bits_truncate(c_event.events as u32),\n+            user_data: c_event.data,\n+        }\n+    }\n+}\n+\n+impl From<&EpollEvent> for c_epoll_event {\n+    fn from(ep_event: &EpollEvent) -> Self {\n+        Self {\n+            events: ep_event.events.bits() as u32,\n+            data: ep_event.user_data,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+pub struct c_epoll_event {\n+    pub events: u32,\n+    pub data: u64,\n+}\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/file_handle.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -0,0 +1,74 @@\n+//! Opend File Handle\n+\n+use crate::events::Observer;\n+use crate::fs::utils::{IoEvents, IoctlCmd, Metadata, Poller, SeekFrom};\n+use crate::prelude::*;\n+use crate::tty::get_n_tty;\n+\n+use core::any::Any;\n+\n+/// The basic operations defined on a file\n+pub trait FileLike: Send + Sync + Any {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"read is not supported\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"write is not supported\");\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                // FIXME: only a work around\n+                let tty = get_n_tty();\n+                tty.ioctl(cmd, arg)\n+            }\n+            _ => panic!(\"Ioctl unsupported\"),\n+        }\n+    }\n+\n+    fn poll(&self, _mask: IoEvents, _poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+\n+    fn flush(&self) -> Result<()> {\n+        Ok(())\n+    }\n+\n+    fn metadata(&self) -> Metadata {\n+        panic!(\"metadata unsupported\");\n+    }\n+\n+    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"seek is not supported\");\n+    }\n+\n+    fn clean_for_close(&self) -> Result<()> {\n+        self.flush()?;\n+        Ok(())\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        return_errno_with_message!(Errno::EINVAL, \"register_observer is not supported\")\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        return_errno_with_message!(Errno::EINVAL, \"unregister_observer is not supported\")\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any;\n+}\n+\n+impl dyn FileLike {\n+    pub fn downcast_ref<T: FileLike>(&self) -> Option<&T> {\n+        self.as_any_ref().downcast_ref::<T>()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/file.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/file_handle/file.rs\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-use crate::fs::utils::{IoEvents, IoctlCmd, Metadata, SeekFrom};\n-use crate::prelude::*;\n-use crate::tty::get_n_tty;\n-\n-use core::any::Any;\n-\n-/// The basic operations defined on a file\n-pub trait File: Send + Sync + Any {\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        panic!(\"read unsupported\");\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        panic!(\"write unsupported\");\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        match cmd {\n-            IoctlCmd::TCGETS => {\n-                // FIXME: only a work around\n-                let tty = get_n_tty();\n-                tty.ioctl(cmd, arg)\n-            }\n-            _ => panic!(\"Ioctl unsupported\"),\n-        }\n-    }\n-\n-    fn poll(&self) -> IoEvents {\n-        IoEvents::empty()\n-    }\n-\n-    fn flush(&self) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn metadata(&self) -> Metadata {\n-        panic!(\"metadata unsupported\");\n-    }\n-\n-    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n-        panic!(\"seek unsupported\");\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/mod.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/file_handle/mod.rs\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-//! Opend File Handle\n-\n-mod file;\n-mod inode_handle;\n-\n-use crate::fs::utils::{Metadata, SeekFrom};\n-use crate::prelude::*;\n-use crate::rights::{ReadOp, WriteOp};\n-use alloc::sync::Arc;\n-\n-pub use self::file::File;\n-pub use self::inode_handle::InodeHandle;\n-\n-#[derive(Clone)]\n-pub struct FileHandle {\n-    inner: Inner,\n-}\n-\n-#[derive(Clone)]\n-enum Inner {\n-    File(Arc<dyn File>),\n-    Inode(InodeHandle),\n-}\n-\n-impl FileHandle {\n-    pub fn new_file(file: Arc<dyn File>) -> Self {\n-        let inner = Inner::File(file);\n-        Self { inner }\n-    }\n-\n-    pub fn new_inode_handle(inode_handle: InodeHandle) -> Self {\n-        let inner = Inner::Inode(inode_handle);\n-        Self { inner }\n-    }\n-\n-    pub fn as_file(&self) -> Option<&Arc<dyn File>> {\n-        match &self.inner {\n-            Inner::File(file) => Some(file),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_inode_handle(&self) -> Option<&InodeHandle> {\n-        match &self.inner {\n-            Inner::Inode(inode_handle) => Some(inode_handle),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.read(buf),\n-            Inner::Inode(inode_handle) => {\n-                let static_handle = inode_handle.clone().to_static::<ReadOp>()?;\n-                static_handle.read(buf)\n-            }\n-        }\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.write(buf),\n-            Inner::Inode(inode_handle) => {\n-                let static_handle = inode_handle.clone().to_static::<WriteOp>()?;\n-                static_handle.write(buf)\n-            }\n-        }\n-    }\n-\n-    pub fn metadata(&self) -> Metadata {\n-        match &self.inner {\n-            Inner::File(file) => file.metadata(),\n-            Inner::Inode(inode_handle) => inode_handle.dentry().vnode().metadata(),\n-        }\n-    }\n-\n-    pub fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n-        match &self.inner {\n-            Inner::File(file) => file.seek(seek_from),\n-            Inner::Inode(inode_handle) => inode_handle.seek(seek_from),\n-        }\n-    }\n-\n-    pub fn clean_for_close(&self) -> Result<()> {\n-        match &self.inner {\n-            Inner::Inode(_) => {\n-                // Close does not guarantee that the data has been successfully saved to disk.\n-            }\n-            Inner::File(file) => file.flush()?,\n-        }\n-        Ok(())\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -1,105 +1,128 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n+use core::cell::Cell;\n+use jinux_util::slot_vec::SlotVec;\n+\n use super::{\n-    file_handle::FileHandle,\n-    stdio::{Stderr, Stdin, Stdout, FD_STDERR, FD_STDIN, FD_STDOUT},\n+    file_handle::FileLike,\n+    stdio::{Stderr, Stdin, Stdout},\n };\n \n pub type FileDescripter = i32;\n \n pub struct FileTable {\n-    table: BTreeMap<FileDescripter, FileHandle>,\n+    table: SlotVec<FileTableEntry>,\n     subject: Subject<FdEvents>,\n }\n \n impl FileTable {\n     pub fn new() -> Self {\n         Self {\n-            table: BTreeMap::new(),\n+            table: SlotVec::new(),\n             subject: Subject::new(),\n         }\n     }\n \n     pub fn new_with_stdio() -> Self {\n-        let mut table = BTreeMap::new();\n+        let mut table = SlotVec::new();\n         let stdin = Stdin::new_with_default_console();\n         let stdout = Stdout::new_with_default_console();\n         let stderr = Stderr::new_with_default_console();\n-        table.insert(FD_STDIN, FileHandle::new_file(Arc::new(stdin)));\n-        table.insert(FD_STDOUT, FileHandle::new_file(Arc::new(stdout)));\n-        table.insert(FD_STDERR, FileHandle::new_file(Arc::new(stderr)));\n+        table.put(FileTableEntry::new(Arc::new(stdin), false));\n+        table.put(FileTableEntry::new(Arc::new(stdout), false));\n+        table.put(FileTableEntry::new(Arc::new(stderr), false));\n         Self {\n             table,\n             subject: Subject::new(),\n         }\n     }\n \n-    pub fn dup(&mut self, fd: FileDescripter, new_fd: Option<FileDescripter>) -> Result<()> {\n-        let file = self.table.get(&fd).map_or_else(\n+    pub fn dup(&mut self, fd: FileDescripter, new_fd: FileDescripter) -> Result<FileDescripter> {\n+        let entry = self.table.get(fd as usize).map_or_else(\n             || return_errno_with_message!(Errno::ENOENT, \"No such file\"),\n-            |f| Ok(f.clone()),\n+            |e| Ok(e.clone()),\n         )?;\n-        let new_fd = if let Some(new_fd) = new_fd {\n-            new_fd\n-        } else {\n-            self.max_fd() + 1\n+\n+        // Get the lowest-numbered available fd equal to or greater than `new_fd`.\n+        let get_min_free_fd = || -> usize {\n+            let new_fd = new_fd as usize;\n+            if self.table.get(new_fd).is_none() {\n+                return new_fd;\n+            }\n+\n+            for idx in new_fd + 1..self.table.slots_len() {\n+                if self.table.get(idx).is_none() {\n+                    return idx;\n+                }\n+            }\n+            self.table.slots_len()\n         };\n-        if self.table.contains_key(&new_fd) {\n-            return_errno_with_message!(Errno::EBADF, \"Fd exists\");\n-        }\n-        self.table.insert(new_fd, file);\n \n-        Ok(())\n+        let min_free_fd = get_min_free_fd();\n+        self.table.put_at(min_free_fd, entry);\n+        Ok(min_free_fd as FileDescripter)\n     }\n \n-    fn max_fd(&self) -> FileDescripter {\n-        self.table.iter().map(|(fd, _)| fd.clone()).max().unwrap()\n+    pub fn insert(&mut self, item: Arc<dyn FileLike>) -> FileDescripter {\n+        let entry = FileTableEntry::new(item, false);\n+        self.table.put(entry) as FileDescripter\n     }\n \n-    pub fn insert(&mut self, item: FileHandle) -> FileDescripter {\n-        let fd = self.max_fd() + 1;\n-        self.table.insert(fd, item);\n-        fd\n+    pub fn insert_at(\n+        &mut self,\n+        fd: FileDescripter,\n+        item: Arc<dyn FileLike>,\n+    ) -> Option<Arc<dyn FileLike>> {\n+        let entry = FileTableEntry::new(item, false);\n+        let entry = self.table.put_at(fd as usize, entry);\n+        if entry.is_some() {\n+            let events = FdEvents::Close(fd);\n+            self.notify_fd_events(&events);\n+            entry.as_ref().unwrap().notify_fd_events(&events);\n+        }\n+        entry.map(|e| e.file)\n     }\n \n-    pub fn insert_at(&mut self, fd: FileDescripter, item: FileHandle) -> Option<FileHandle> {\n-        let file = self.table.insert(fd, item);\n-        if file.is_some() {\n-            self.notify_close_fd_event(fd);\n+    pub fn close_file(&mut self, fd: FileDescripter) -> Option<Arc<dyn FileLike>> {\n+        let entry = self.table.remove(fd as usize);\n+        if entry.is_some() {\n+            let events = FdEvents::Close(fd);\n+            self.notify_fd_events(&events);\n+            entry.as_ref().unwrap().notify_fd_events(&events);\n         }\n-        file\n+        entry.map(|e| e.file)\n     }\n \n-    pub fn close_file(&mut self, fd: FileDescripter) -> Option<FileHandle> {\n-        let file = self.table.remove(&fd);\n-        if file.is_some() {\n-            self.notify_close_fd_event(fd);\n-        }\n-        file\n+    pub fn get_file(&self, fd: FileDescripter) -> Result<&Arc<dyn FileLike>> {\n+        self.table\n+            .get(fd as usize)\n+            .map(|entry| &entry.file)\n+            .ok_or(Error::with_message(Errno::EBADF, \"fd not exits\"))\n     }\n \n-    pub fn get_file(&self, fd: FileDescripter) -> Result<&FileHandle> {\n+    pub fn get_entry(&self, fd: FileDescripter) -> Result<&FileTableEntry> {\n         self.table\n-            .get(&fd)\n+            .get(fd as usize)\n             .ok_or(Error::with_message(Errno::EBADF, \"fd not exits\"))\n     }\n \n-    pub fn fds_and_files(&self) -> impl Iterator<Item = (&'_ FileDescripter, &'_ FileHandle)> {\n-        self.table.iter()\n+    pub fn fds_and_files(&self) -> impl Iterator<Item = (FileDescripter, &'_ Arc<dyn FileLike>)> {\n+        self.table\n+            .idxes_and_items()\n+            .map(|(idx, entry)| (idx as FileDescripter, &entry.file))\n     }\n \n     pub fn register_observer(&self, observer: Weak<dyn Observer<FdEvents>>) {\n-        self.subject.register_observer(observer);\n+        self.subject.register_observer(observer, ());\n     }\n \n-    pub fn unregister_observer(&self, observer: Weak<dyn Observer<FdEvents>>) {\n+    pub fn unregister_observer(&self, observer: &Weak<dyn Observer<FdEvents>>) {\n         self.subject.unregister_observer(observer);\n     }\n \n-    fn notify_close_fd_event(&self, fd: FileDescripter) {\n-        let events = FdEvents::Close(fd);\n-        self.subject.notify_observers(&events);\n+    fn notify_fd_events(&self, events: &FdEvents) {\n+        self.subject.notify_observers(events);\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -126,3 +149,45 @@ pub enum FdEvents {\n }\n \n impl Events for FdEvents {}\n+\n+pub struct FileTableEntry {\n+    file: Arc<dyn FileLike>,\n+    close_on_exec: Cell<bool>,\n+    subject: Subject<FdEvents>,\n+}\n+\n+impl FileTableEntry {\n+    pub fn new(file: Arc<dyn FileLike>, close_on_exec: bool) -> Self {\n+        Self {\n+            file,\n+            close_on_exec: Cell::new(close_on_exec),\n+            subject: Subject::new(),\n+        }\n+    }\n+\n+    pub fn file(&self) -> &Arc<dyn FileLike> {\n+        &self.file\n+    }\n+\n+    pub fn register_observer(&self, epoll: Weak<dyn Observer<FdEvents>>) {\n+        self.subject.register_observer(epoll, ());\n+    }\n+\n+    pub fn unregister_observer(&self, epoll: &Weak<dyn Observer<FdEvents>>) {\n+        self.subject.unregister_observer(epoll);\n+    }\n+\n+    pub fn notify_fd_events(&self, events: &FdEvents) {\n+        self.subject.notify_observers(events);\n+    }\n+}\n+\n+impl Clone for FileTableEntry {\n+    fn clone(&self) -> Self {\n+        Self {\n+            file: self.file.clone(),\n+            close_on_exec: self.close_on_exec.clone(),\n+            subject: Subject::new(),\n+        }\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/jinux-std/src/fs/fs_resolver.rs\n--- a/services/libs/jinux-std/src/fs/fs_resolver.rs\n+++ b/services/libs/jinux-std/src/fs/fs_resolver.rs\n@@ -2,8 +2,8 @@ use crate::prelude::*;\n use alloc::str;\n use alloc::string::String;\n \n-use super::file_handle::InodeHandle;\n use super::file_table::FileDescripter;\n+use super::inode_handle::InodeHandle;\n use super::procfs::ProcFS;\n use super::ramfs::RamFS;\n use super::utils::{\ndiff --git a/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/jinux-std/src/fs/fs_resolver.rs\n--- a/services/libs/jinux-std/src/fs/fs_resolver.rs\n+++ b/services/libs/jinux-std/src/fs/fs_resolver.rs\n@@ -253,7 +253,7 @@ impl FsResolver {\n         let file_table = current.file_table().lock();\n         let inode_handle = file_table\n             .get_file(fd)?\n-            .as_inode_handle()\n+            .downcast_ref::<InodeHandle>()\n             .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n         Ok(inode_handle.dentry().clone())\n     }\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -36,13 +36,6 @@ impl InodeHandle<Rights> {\n         Ok(InodeHandle(self.0, R1::new()))\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        if !self.1.contains(Rights::READ) {\n-            return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n-        }\n-        self.0.read(buf)\n-    }\n-\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -50,13 +43,6 @@ impl InodeHandle<Rights> {\n         self.0.read_to_end(buf)\n     }\n \n-    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n-        if !self.1.contains(Rights::WRITE) {\n-            return_errno_with_message!(Errno::EBADF, \"File is not writable\");\n-        }\n-        self.0.write(buf)\n-    }\n-\n     pub fn readdir(&self, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -70,3 +56,40 @@ impl Clone for InodeHandle<Rights> {\n         Self(self.0.clone(), self.1.clone())\n     }\n }\n+\n+impl FileLike for InodeHandle<Rights> {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        if !self.1.contains(Rights::READ) {\n+            return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n+        }\n+        self.0.read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        if !self.1.contains(Rights::WRITE) {\n+            return_errno_with_message!(Errno::EBADF, \"File is not writable\");\n+        }\n+        self.0.write(buf)\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.dentry().vnode().poll(mask, poller)\n+    }\n+\n+    fn metadata(&self) -> Metadata {\n+        self.dentry().vnode().metadata()\n+    }\n+\n+    fn seek(&self, seek_from: SeekFrom) -> Result<usize> {\n+        self.0.seek(seek_from)\n+    }\n+\n+    fn clean_for_close(&self) -> Result<()> {\n+        // Close does not guarantee that the data has been successfully saved to disk.\n+        Ok(())\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -3,7 +3,10 @@\n mod dyn_cap;\n mod static_cap;\n \n-use crate::fs::utils::{AccessMode, Dentry, DirentVisitor, InodeType, SeekFrom, StatusFlags};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::utils::{\n+    AccessMode, Dentry, DirentVisitor, InodeType, IoEvents, Metadata, Poller, SeekFrom, StatusFlags,\n+};\n use crate::prelude::*;\n use crate::rights::Rights;\n \ndiff --git a/services/libs/jinux-std/src/fs/mod.rs b/services/libs/jinux-std/src/fs/mod.rs\n--- a/services/libs/jinux-std/src/fs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/mod.rs\n@@ -1,7 +1,10 @@\n+pub mod epoll;\n pub mod file_handle;\n pub mod file_table;\n pub mod fs_resolver;\n pub mod initramfs;\n+pub mod inode_handle;\n+pub mod pipe;\n pub mod procfs;\n pub mod ramfs;\n pub mod stdio;\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/pipe.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/pipe.rs\n@@ -0,0 +1,134 @@\n+use crate::events::Observer;\n+use crate::prelude::*;\n+\n+use super::file_handle::FileLike;\n+use super::utils::{Consumer, IoEvents, Poller, Producer};\n+\n+pub struct PipeReader {\n+    consumer: Consumer<u8>,\n+}\n+\n+impl PipeReader {\n+    pub fn new(consumer: Consumer<u8>) -> Self {\n+        Self { consumer }\n+    }\n+}\n+\n+impl FileLike for PipeReader {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        let is_nonblocking = self.consumer.is_nonblocking();\n+\n+        // Fast path\n+        let res = self.consumer.read(buf);\n+        if should_io_return(&res, is_nonblocking) {\n+            return res;\n+        }\n+\n+        // Slow path\n+        let mask = IoEvents::IN;\n+        let poller = Poller::new();\n+        loop {\n+            let res = self.consumer.read(buf);\n+            if should_io_return(&res, is_nonblocking) {\n+                return res;\n+            }\n+            let events = self.poll(mask, Some(&poller));\n+            if events.is_empty() {\n+                poller.wait();\n+            }\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.consumer.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.consumer.register_observer(observer, mask)\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.consumer.unregister_observer(observer)\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+pub struct PipeWriter {\n+    producer: Producer<u8>,\n+}\n+\n+impl PipeWriter {\n+    pub fn new(producer: Producer<u8>) -> Self {\n+        Self { producer }\n+    }\n+}\n+\n+impl FileLike for PipeWriter {\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let is_nonblocking = self.producer.is_nonblocking();\n+\n+        // Fast path\n+        let res = self.producer.write(buf);\n+        if should_io_return(&res, is_nonblocking) {\n+            return res;\n+        }\n+\n+        // Slow path\n+        let mask = IoEvents::OUT;\n+        let poller = Poller::new();\n+        loop {\n+            let res = self.producer.write(buf);\n+            if should_io_return(&res, is_nonblocking) {\n+                return res;\n+            }\n+            let events = self.poll(mask, Some(&poller));\n+            if events.is_empty() {\n+                poller.wait();\n+            }\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.producer.poll(mask, poller)\n+    }\n+\n+    fn register_observer(\n+        &self,\n+        observer: Weak<dyn Observer<IoEvents>>,\n+        mask: IoEvents,\n+    ) -> Result<()> {\n+        self.producer.register_observer(observer, mask)\n+    }\n+\n+    fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+        self.producer.unregister_observer(observer)\n+    }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+fn should_io_return(res: &Result<usize>, is_nonblocking: bool) -> bool {\n+    if is_nonblocking {\n+        return true;\n+    }\n+    match res {\n+        Ok(_) => true,\n+        Err(e) if e.error() == Errno::EAGAIN => false,\n+        Err(_) => true,\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -1,6 +1,7 @@\n use super::*;\n-use crate::fs::file_handle::FileHandle;\n+use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::FileDescripter;\n+use crate::fs::inode_handle::InodeHandle;\n \n /// Represents the inode at `/proc/[pid]/fd`.\n pub struct FdDirOps(Arc<Process>);\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -62,10 +63,10 @@ impl DirOps for FdDirOps {\n }\n \n /// Represents the inode at `/proc/[pid]/fd/N`.\n-struct FileSymOps(FileHandle);\n+struct FileSymOps(Arc<dyn FileLike>);\n \n impl FileSymOps {\n-    pub fn new_inode(file: FileHandle, parent: Weak<dyn Inode>) -> Arc<dyn Inode> {\n+    pub fn new_inode(file: Arc<dyn FileLike>, parent: Weak<dyn Inode>) -> Arc<dyn Inode> {\n         ProcSymBuilder::new(Self(file))\n             .parent(parent)\n             .build()\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\n@@ -75,13 +76,11 @@ impl FileSymOps {\n \n impl SymOps for FileSymOps {\n     fn read_link(&self) -> Result<String> {\n-        let path = if let Some(inode_handle) = self.0.as_inode_handle() {\n+        let path = if let Some(inode_handle) = self.0.downcast_ref::<InodeHandle>() {\n             inode_handle.dentry().abs_path()\n-        } else if let Some(file) = self.0.as_file() {\n-            // TODO: get the real path for stdio\n-            String::from(\"/dev/tty\")\n         } else {\n-            unreachable!()\n+            // TODO: get the real path for other FileLike object\n+            String::from(\"/dev/tty\")\n         };\n         Ok(path)\n     }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -2,9 +2,10 @@ use alloc::string::String;\n use core::any::Any;\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n+use jinux_util::slot_vec::SlotVec;\n \n use crate::fs::utils::{\n-    DirEntryVec, DirentVisitor, FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n+    DirentVisitor, FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n };\n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -14,7 +15,7 @@ pub struct ProcDir<D: DirOps> {\n     inner: D,\n     this: Weak<ProcDir<D>>,\n     parent: Option<Weak<dyn Inode>>,\n-    cached_children: RwLock<DirEntryVec<(String, Arc<dyn Inode>)>>,\n+    cached_children: RwLock<SlotVec<(String, Arc<dyn Inode>)>>,\n     info: ProcInodeInfo,\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -38,7 +39,7 @@ impl<D: DirOps> ProcDir<D> {\n             inner: dir,\n             this: weak_self.clone(),\n             parent,\n-            cached_children: RwLock::new(DirEntryVec::new()),\n+            cached_children: RwLock::new(SlotVec::new()),\n             info,\n         })\n     }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -51,7 +52,7 @@ impl<D: DirOps> ProcDir<D> {\n         self.parent.as_ref().and_then(|p| p.upgrade())\n     }\n \n-    pub fn cached_children(&self) -> &RwLock<DirEntryVec<(String, Arc<dyn Inode>)>> {\n+    pub fn cached_children(&self) -> &RwLock<SlotVec<(String, Arc<dyn Inode>)>> {\n         &self.cached_children\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n@@ -127,7 +128,7 @@ impl<D: DirOps + 'static> Inode for ProcDir<D> {\n             self.inner.populate_children(self.this.clone());\n             let cached_children = self.cached_children.read();\n             for (idx, (name, child)) in cached_children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .map(|(idx, (name, child))| (idx + 2, (name, child)))\n             {\n                 if idx < *offset {\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -5,12 +5,12 @@ use core::any::Any;\n use core::sync::atomic::{AtomicUsize, Ordering};\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n+use jinux_util::slot_vec::SlotVec;\n use spin::{RwLock, RwLockWriteGuard};\n \n use super::*;\n use crate::fs::utils::{\n-    DirEntryVec, DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd,\n-    Metadata, SuperBlock,\n+    DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata, SuperBlock,\n };\n \n pub struct RamFS {\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -164,7 +164,7 @@ impl Inner {\n }\n \n struct DirEntry {\n-    children: DirEntryVec<(Str256, Arc<RamInode>)>,\n+    children: SlotVec<(Str256, Arc<RamInode>)>,\n     this: Weak<RamInode>,\n     parent: Weak<RamInode>,\n }\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -172,7 +172,7 @@ struct DirEntry {\n impl DirEntry {\n     fn new() -> Self {\n         Self {\n-            children: DirEntryVec::new(),\n+            children: SlotVec::new(),\n             this: Weak::default(),\n             parent: Weak::default(),\n         }\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -205,13 +205,13 @@ impl DirEntry {\n             Some((1, self.parent.upgrade().unwrap()))\n         } else {\n             self.children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .find(|(_, (child, _))| child == &Str256::from(name))\n                 .map(|(idx, (_, inode))| (idx + 2, inode.clone()))\n         }\n     }\n \n-    fn append_entry(&mut self, name: &str, inode: Arc<RamInode>) {\n+    fn append_entry(&mut self, name: &str, inode: Arc<RamInode>) -> usize {\n         self.children.put((Str256::from(name), inode))\n     }\n \ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -255,7 +255,7 @@ impl DirEntry {\n             // Read the normal child entries.\n             for (offset, (name, child)) in self\n                 .children\n-                .idxes_and_entries()\n+                .idxes_and_items()\n                 .map(|(offset, (name, child))| (offset + 2, (name, child)))\n             {\n                 if offset < *idx {\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -1,9 +1,9 @@\n use crate::prelude::*;\n use crate::tty::{get_n_tty, Tty};\n \n-use super::file_handle::File;\n+use super::file_handle::FileLike;\n use super::file_table::FileDescripter;\n-use super::utils::{InodeMode, InodeType, IoEvents, Metadata, SeekFrom};\n+use super::utils::{InodeMode, InodeType, IoEvents, Metadata, Poller, SeekFrom};\n \n pub const FD_STDIN: FileDescripter = 0;\n pub const FD_STDOUT: FileDescripter = 1;\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -21,10 +21,10 @@ pub struct Stderr {\n     console: Option<Arc<Tty>>,\n }\n \n-impl File for Stdin {\n-    fn poll(&self) -> IoEvents {\n+impl FileLike for Stdin {\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         if let Some(console) = self.console.as_ref() {\n-            console.poll()\n+            console.poll(mask, poller)\n         } else {\n             todo!()\n         }\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -69,8 +69,12 @@ impl File for Stdin {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n-impl File for Stdout {\n+impl FileLike for Stdout {\n     fn ioctl(&self, cmd: super::utils::IoctlCmd, arg: usize) -> Result<i32> {\n         if let Some(console) = self.console.as_ref() {\n             console.ioctl(cmd, arg)\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -110,9 +114,13 @@ impl File for Stdout {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n-impl File for Stderr {\n+impl FileLike for Stderr {\n     fn ioctl(&self, cmd: super::utils::IoctlCmd, arg: usize) -> Result<i32> {\n         if let Some(console) = self.console.as_ref() {\n             console.ioctl(cmd, arg)\ndiff --git a/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\n--- a/services/libs/jinux-std/src/fs/stdio.rs\n+++ b/services/libs/jinux-std/src/fs/stdio.rs\n@@ -152,6 +160,10 @@ impl File for Stderr {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n impl Stdin {\ndiff --git /dev/null b/services/libs/jinux-std/src/fs/utils/channel.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/fs/utils/channel.rs\n@@ -0,0 +1,347 @@\n+use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n+use jinux_rights_proc::require;\n+use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\n+\n+use crate::events::Observer;\n+use crate::prelude::*;\n+use crate::rights::*;\n+\n+use super::{IoEvents, Pollee, Poller, StatusFlags};\n+\n+/// A unidirectional communication channel, intended to implement IPC, e.g., pipe,\n+/// unix domain sockets, etc.\n+pub struct Channel<T> {\n+    producer: Producer<T>,\n+    consumer: Consumer<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    pub fn with_capacity(capacity: usize) -> Result<Self> {\n+        Self::with_capacity_and_flags(capacity, StatusFlags::empty())\n+    }\n+\n+    pub fn with_capacity_and_flags(capacity: usize, flags: StatusFlags) -> Result<Self> {\n+        let common = Arc::new(Common::with_capacity_and_flags(capacity, flags)?);\n+        let producer = Producer(EndPoint::new(common.clone(), WriteOp::new()));\n+        let consumer = Consumer(EndPoint::new(common, ReadOp::new()));\n+        Ok(Self { producer, consumer })\n+    }\n+\n+    pub fn split(self) -> (Producer<T>, Consumer<T>) {\n+        let Self { producer, consumer } = self;\n+        (producer, consumer)\n+    }\n+\n+    pub fn producer(&self) -> &Producer<T> {\n+        &self.producer\n+    }\n+\n+    pub fn consumer(&self) -> &Consumer<T> {\n+        &self.consumer\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.producer.0.common.capacity()\n+    }\n+}\n+\n+pub struct Producer<T>(EndPoint<T, WriteOp>);\n+\n+pub struct Consumer<T>(EndPoint<T, ReadOp>);\n+\n+macro_rules! impl_common_methods_for_channel {\n+    () => {\n+        pub fn shutdown(&self) {\n+            self.this_end().shutdown()\n+        }\n+\n+        pub fn is_shutdown(&self) -> bool {\n+            self.this_end().is_shutdown()\n+        }\n+\n+        pub fn is_peer_shutdown(&self) -> bool {\n+            self.peer_end().is_shutdown()\n+        }\n+\n+        pub fn status_flags(&self) -> StatusFlags {\n+            self.this_end().status_flags()\n+        }\n+\n+        pub fn set_status_flags(&self, new_flags: StatusFlags) {\n+            self.this_end().set_status_flags(new_flags)\n+        }\n+\n+        pub fn is_nonblocking(&self) -> bool {\n+            self.this_end()\n+                .status_flags()\n+                .contains(StatusFlags::O_NONBLOCK)\n+        }\n+\n+        pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+            self.this_end().pollee.poll(mask, poller)\n+        }\n+\n+        pub fn register_observer(\n+            &self,\n+            observer: Weak<dyn Observer<IoEvents>>,\n+            mask: IoEvents,\n+        ) -> Result<()> {\n+            self.this_end().pollee.register_observer(observer, mask);\n+            Ok(())\n+        }\n+\n+        pub fn unregister_observer(\n+            &self,\n+            observer: &Weak<dyn Observer<IoEvents>>,\n+        ) -> Result<Weak<dyn Observer<IoEvents>>> {\n+            self.this_end()\n+                .pollee\n+                .unregister_observer(observer)\n+                .ok_or_else(|| Error::with_message(Errno::ENOENT, \"the observer is not registered\"))\n+        }\n+    };\n+}\n+\n+impl<T> Producer<T> {\n+    fn this_end(&self) -> &EndPointInner<HeapRbProducer<T>> {\n+        &self.0.common.producer\n+    }\n+\n+    fn peer_end(&self) -> &EndPointInner<HeapRbConsumer<T>> {\n+        &self.0.common.consumer\n+    }\n+\n+    fn update_pollee(&self) {\n+        let this_end = self.this_end();\n+        let peer_end = self.peer_end();\n+\n+        // Update the event of pollee in a critical region so that pollee\n+        // always reflects the _true_ state of the underlying ring buffer\n+        // regardless of any race conditions.\n+        self.0.common.lock_event();\n+\n+        let rb = this_end.rb();\n+        if rb.is_full() {\n+            this_end.pollee.del_events(IoEvents::OUT);\n+        }\n+        if !rb.is_empty() {\n+            peer_end.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+\n+    impl_common_methods_for_channel!();\n+}\n+\n+impl<T: Copy> Producer<T> {\n+    pub fn write(&self, buf: &[T]) -> Result<usize> {\n+        if self.is_shutdown() || self.is_peer_shutdown() {\n+            return_errno!(Errno::EPIPE);\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let written_len = self.0.write(buf);\n+\n+        self.update_pollee();\n+\n+        if written_len > 0 {\n+            Ok(written_len)\n+        } else {\n+            return_errno_with_message!(Errno::EAGAIN, \"try write later\");\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Producer<T> {\n+    fn drop(&mut self) {\n+        self.shutdown();\n+\n+        self.0.common.lock_event();\n+\n+        // When reading from a channel such as a pipe or a stream socket,\n+        // POLLHUP merely indicates that the peer closed its end of the channel.\n+        self.peer_end().pollee.add_events(IoEvents::HUP);\n+    }\n+}\n+\n+impl<T> Consumer<T> {\n+    fn this_end(&self) -> &EndPointInner<HeapRbConsumer<T>> {\n+        &self.0.common.consumer\n+    }\n+\n+    fn peer_end(&self) -> &EndPointInner<HeapRbProducer<T>> {\n+        &self.0.common.producer\n+    }\n+\n+    fn update_pollee(&self) {\n+        let this_end = self.this_end();\n+        let peer_end = self.peer_end();\n+\n+        // Update the event of pollee in a critical region so that pollee\n+        // always reflects the _true_ state of the underlying ring buffer\n+        // regardless of any race conditions.\n+        self.0.common.lock_event();\n+\n+        let rb = this_end.rb();\n+        if rb.is_empty() {\n+            this_end.pollee.del_events(IoEvents::IN);\n+        }\n+        if !rb.is_full() {\n+            peer_end.pollee.add_events(IoEvents::OUT);\n+        }\n+    }\n+\n+    impl_common_methods_for_channel!();\n+}\n+\n+impl<T: Copy> Consumer<T> {\n+    pub fn read(&self, buf: &mut [T]) -> Result<usize> {\n+        if self.is_shutdown() {\n+            return_errno!(Errno::EPIPE);\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let read_len = self.0.read(buf);\n+\n+        self.update_pollee();\n+\n+        if self.is_peer_shutdown() {\n+            return Ok(read_len);\n+        }\n+\n+        if read_len > 0 {\n+            Ok(read_len)\n+        } else {\n+            return_errno_with_message!(Errno::EAGAIN, \"try read later\");\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Consumer<T> {\n+    fn drop(&mut self) {\n+        self.shutdown();\n+\n+        self.0.common.lock_event();\n+\n+        // POLLERR is also set for a file descriptor referring to the write end of a pipe\n+        // when the read end has been closed.\n+        self.peer_end().pollee.add_events(IoEvents::ERR);\n+    }\n+}\n+\n+struct EndPoint<T, R: TRights> {\n+    common: Arc<Common<T>>,\n+    rights: R,\n+}\n+\n+impl<T, R: TRights> EndPoint<T, R> {\n+    pub fn new(common: Arc<Common<T>>, rights: R) -> Self {\n+        Self { common, rights }\n+    }\n+}\n+\n+impl<T: Copy, R: TRights> EndPoint<T, R> {\n+    #[require(R > Read)]\n+    pub fn read(&self, buf: &mut [T]) -> usize {\n+        let mut rb = self.common.consumer.rb();\n+        rb.pop_slice(buf)\n+    }\n+\n+    #[require(R > Write)]\n+    pub fn write(&self, buf: &[T]) -> usize {\n+        let mut rb = self.common.producer.rb();\n+        rb.push_slice(buf)\n+    }\n+}\n+\n+struct Common<T> {\n+    producer: EndPointInner<HeapRbProducer<T>>,\n+    consumer: EndPointInner<HeapRbConsumer<T>>,\n+    event_lock: Mutex<()>,\n+}\n+\n+impl<T> Common<T> {\n+    fn with_capacity_and_flags(capacity: usize, flags: StatusFlags) -> Result<Self> {\n+        check_status_flags(flags)?;\n+\n+        if capacity == 0 {\n+            return_errno_with_message!(Errno::EINVAL, \"capacity cannot be zero\");\n+        }\n+\n+        let rb: HeapRb<T> = HeapRb::new(capacity);\n+        let (rb_producer, rb_consumer) = rb.split();\n+\n+        let producer = EndPointInner::new(rb_producer, IoEvents::OUT, flags);\n+        let consumer = EndPointInner::new(rb_consumer, IoEvents::empty(), flags);\n+        let event_lock = Mutex::new(());\n+\n+        Ok(Self {\n+            producer,\n+            consumer,\n+            event_lock,\n+        })\n+    }\n+\n+    pub fn lock_event(&self) -> MutexGuard<()> {\n+        self.event_lock.lock()\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.producer.rb().capacity()\n+    }\n+}\n+\n+struct EndPointInner<T> {\n+    rb: Mutex<T>,\n+    pollee: Pollee,\n+    is_shutdown: AtomicBool,\n+    status_flags: AtomicU32,\n+}\n+\n+impl<T> EndPointInner<T> {\n+    pub fn new(rb: T, init_events: IoEvents, status_flags: StatusFlags) -> Self {\n+        Self {\n+            rb: Mutex::new(rb),\n+            pollee: Pollee::new(init_events),\n+            is_shutdown: AtomicBool::new(false),\n+            status_flags: AtomicU32::new(status_flags.bits()),\n+        }\n+    }\n+\n+    pub fn rb(&self) -> MutexGuard<T> {\n+        self.rb.lock()\n+    }\n+\n+    pub fn is_shutdown(&self) -> bool {\n+        self.is_shutdown.load(Ordering::Acquire)\n+    }\n+\n+    pub fn shutdown(&self) {\n+        self.is_shutdown.store(true, Ordering::Release)\n+    }\n+\n+    pub fn status_flags(&self) -> StatusFlags {\n+        let bits = self.status_flags.load(Ordering::Relaxed);\n+        StatusFlags::from_bits(bits).unwrap()\n+    }\n+\n+    pub fn set_status_flags(&self, new_flags: StatusFlags) {\n+        self.status_flags.store(new_flags.bits(), Ordering::Relaxed);\n+    }\n+}\n+\n+fn check_status_flags(flags: StatusFlags) -> Result<()> {\n+    let valid_flags: StatusFlags = StatusFlags::O_NONBLOCK | StatusFlags::O_DIRECT;\n+    if !valid_flags.contains(flags) {\n+        return_errno_with_message!(Errno::EINVAL, \"invalid flags\");\n+    }\n+    if flags.contains(StatusFlags::O_DIRECT) {\n+        return_errno_with_message!(Errno::EINVAL, \"O_DIRECT is not supported\");\n+    }\n+    Ok(())\n+}\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -1,87 +1,7 @@\n use super::Inode;\n use crate::prelude::*;\n \n-/// DirEntryVec is used to store the entries of a directory.\n-/// It can guarantee that the index of one dir entry remains unchanged during\n-/// adding or deleting other dir entries of it.\n-pub struct DirEntryVec<T> {\n-    // The slots to store dir entries.\n-    slots: Vec<Option<T>>,\n-    // The number of occupied slots.\n-    // The i-th slot is occupied if `self.slots[i].is_some()`.\n-    num_occupied: usize,\n-}\n-\n-impl<T> DirEntryVec<T> {\n-    /// New an empty vec.\n-    pub fn new() -> Self {\n-        Self {\n-            slots: Vec::new(),\n-            num_occupied: 0,\n-        }\n-    }\n-\n-    /// Returns `true` if the vec contains no entries.\n-    pub fn is_empty(&self) -> bool {\n-        self.num_occupied == 0\n-    }\n-\n-    /// Put a dir entry into the vec.\n-    /// it may be put into an existing empty slot or the back of the vec.\n-    pub fn put(&mut self, entry: T) {\n-        if self.num_occupied == self.slots.len() {\n-            self.slots.push(Some(entry));\n-        } else {\n-            let idx = self.slots.iter().position(|x| x.is_none()).unwrap();\n-            self.slots[idx] = Some(entry);\n-        }\n-        self.num_occupied += 1;\n-    }\n-\n-    /// Removes and returns the entry at position `idx`.\n-    /// Returns `None` if `idx` is out of bounds or the entry has been removed.\n-    pub fn remove(&mut self, idx: usize) -> Option<T> {\n-        if idx >= self.slots.len() {\n-            return None;\n-        }\n-        let mut del_entry = None;\n-        core::mem::swap(&mut del_entry, &mut self.slots[idx]);\n-        if del_entry.is_some() {\n-            debug_assert!(self.num_occupied > 0);\n-            self.num_occupied -= 1;\n-        }\n-        del_entry\n-    }\n-\n-    /// Put and returns the entry at position `idx`.\n-    /// Returns `None` if `idx` is out of bounds or the entry has been removed.\n-    pub fn put_at(&mut self, idx: usize, entry: T) -> Option<T> {\n-        if idx >= self.slots.len() {\n-            return None;\n-        }\n-        let mut sub_entry = Some(entry);\n-        core::mem::swap(&mut sub_entry, &mut self.slots[idx]);\n-        if sub_entry.is_none() {\n-            self.num_occupied += 1;\n-        }\n-        sub_entry\n-    }\n-\n-    /// Creates an iterator which gives both of the index and the dir entry.\n-    /// The index may not be continuous.\n-    pub fn idxes_and_entries(&self) -> impl Iterator<Item = (usize, &'_ T)> {\n-        self.slots\n-            .iter()\n-            .enumerate()\n-            .filter(|(_, x)| x.is_some())\n-            .map(|(idx, x)| (idx, x.as_ref().unwrap()))\n-    }\n-\n-    /// Creates an iterator which gives the dir entry.\n-    pub fn iter(&self) -> impl Iterator<Item = &'_ T> {\n-        self.slots.iter().filter_map(|x| x.as_ref())\n-    }\n-}\n+use jinux_util::slot_vec::SlotVec;\n \n pub trait DirEntryVecExt {\n     /// If the entry is not found by `name`, use `f` to get the inode, then put the entry into vec.\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -92,7 +12,7 @@ pub trait DirEntryVecExt {\n     fn remove_entry_by_name(&mut self, name: &str) -> Option<(String, Arc<dyn Inode>)>;\n }\n \n-impl DirEntryVecExt for DirEntryVec<(String, Arc<dyn Inode>)> {\n+impl DirEntryVecExt for SlotVec<(String, Arc<dyn Inode>)> {\n     fn put_entry_if_not_found(&mut self, name: &str, f: impl Fn() -> Arc<dyn Inode>) {\n         if self\n             .iter()\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n@@ -106,7 +26,7 @@ impl DirEntryVecExt for DirEntryVec<(String, Arc<dyn Inode>)> {\n \n     fn remove_entry_by_name(&mut self, name: &str) -> Option<(String, Arc<dyn Inode>)> {\n         let idx = self\n-            .idxes_and_entries()\n+            .idxes_and_items()\n             .find(|(_, (child_name, _))| child_name == name)\n             .map(|(idx, _)| idx);\n         if let Some(idx) = idx {\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -5,7 +5,7 @@ use core::any::Any;\n use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n \n-use super::{DirentVisitor, FileSystem, IoctlCmd, SuperBlock};\n+use super::{DirentVisitor, FileSystem, IoEvents, IoctlCmd, Poller, SuperBlock};\n use crate::prelude::*;\n \n #[repr(u32)]\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -197,6 +197,11 @@ pub trait Inode: Any + Sync + Send {\n \n     fn sync(&self) -> Result<()>;\n \n+    fn poll(&self, mask: IoEvents, _poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n+\n     fn fs(&self) -> Arc<dyn FileSystem>;\n \n     fn as_any_ref(&self) -> &dyn Any;\ndiff --git a/services/libs/jinux-std/src/fs/utils/io_events.rs b/services/libs/jinux-std/src/fs/utils/io_events.rs\n--- a/services/libs/jinux-std/src/fs/utils/io_events.rs\n+++ b/services/libs/jinux-std/src/fs/utils/io_events.rs\n@@ -1,11 +1,23 @@\n+use crate::events::{Events, EventsFilter};\n+\n crate::bitflags! {\n     pub struct IoEvents: u32 {\n-        const POLLIN    = 0x0001;\n-        const POLLPRI   = 0x0002;\n-        const POLLOUT   = 0x0004;\n-        const POLLERR   = 0x0008;\n-        const POLLHUP   = 0x0010;\n-        const POLLNVAL  = 0x0020;\n-        const POLLRDHUP = 0x2000;\n+        const IN    = 0x0001;\n+        const PRI   = 0x0002;\n+        const OUT   = 0x0004;\n+        const ERR   = 0x0008;\n+        const HUP   = 0x0010;\n+        const NVAL  = 0x0020;\n+        const RDHUP = 0x2000;\n+        /// Events that are always polled even without specifying them.\n+        const ALWAYS_POLL = Self::ERR.bits | Self::HUP.bits;\n+    }\n+}\n+\n+impl Events for IoEvents {}\n+\n+impl EventsFilter<IoEvents> for IoEvents {\n+    fn filter(&self, events: &IoEvents) -> bool {\n+        self.intersects(*events)\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/jinux-std/src/fs/utils/mod.rs\n--- a/services/libs/jinux-std/src/fs/utils/mod.rs\n+++ b/services/libs/jinux-std/src/fs/utils/mod.rs\n@@ -1,10 +1,11 @@\n //! VFS components\n \n pub use access_mode::AccessMode;\n+pub use channel::{Channel, Consumer, Producer};\n pub use creation_flags::CreationFlags;\n pub use dentry_cache::Dentry;\n pub use dirent_visitor::DirentVisitor;\n-pub use direntry_vec::{DirEntryVec, DirEntryVecExt};\n+pub use direntry_vec::DirEntryVecExt;\n pub use fcntl::FcntlCmd;\n pub use file_creation_mask::FileCreationMask;\n pub use fs::{FileSystem, FsFlags, SuperBlock};\ndiff --git a/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/jinux-std/src/fs/utils/mod.rs\n--- a/services/libs/jinux-std/src/fs/utils/mod.rs\n+++ b/services/libs/jinux-std/src/fs/utils/mod.rs\n@@ -12,11 +13,12 @@ pub use inode::{Inode, InodeMode, InodeType, Metadata};\n pub use io_events::IoEvents;\n pub use ioctl::IoctlCmd;\n pub use page_cache::PageCache;\n-pub use poll::{c_nfds, c_pollfd, PollFd};\n+pub use poll::{Pollee, Poller};\n pub use status_flags::StatusFlags;\n pub use vnode::Vnode;\n \n mod access_mode;\n+mod channel;\n mod creation_flags;\n mod dentry_cache;\n mod dirent_visitor;\ndiff --git a/services/libs/jinux-std/src/fs/utils/poll.rs b/services/libs/jinux-std/src/fs/utils/poll.rs\n--- a/services/libs/jinux-std/src/fs/utils/poll.rs\n+++ b/services/libs/jinux-std/src/fs/utils/poll.rs\n@@ -1,46 +1,214 @@\n-#![allow(non_camel_case_types)]\n-\n use super::IoEvents;\n-use crate::fs::file_table::FileDescripter;\n+use crate::events::{Observer, Subject};\n use crate::prelude::*;\n-pub type c_nfds = u64;\n \n-// https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/poll.h\n-#[derive(Debug, Clone, Copy, Pod)]\n-#[repr(C)]\n-pub struct c_pollfd {\n-    fd: FileDescripter,\n-    events: i16,\n-    revents: i16,\n+use core::sync::atomic::{AtomicU32, AtomicUsize, Ordering};\n+use jinux_frame::sync::WaitQueue;\n+use keyable_arc::KeyableWeak;\n+\n+/// A pollee maintains a set of active events, which can be polled with\n+/// pollers or be monitored with observers.\n+pub struct Pollee {\n+    inner: Arc<PolleeInner>,\n+}\n+\n+struct PolleeInner {\n+    // A subject which is monitored with pollers.\n+    subject: Subject<IoEvents, IoEvents>,\n+    // For efficient manipulation, we use AtomicU32 instead of RwLock<IoEvents>.\n+    events: AtomicU32,\n+}\n+\n+impl Pollee {\n+    /// Creates a new instance of pollee.\n+    pub fn new(init_events: IoEvents) -> Self {\n+        let inner = PolleeInner {\n+            subject: Subject::new(),\n+            events: AtomicU32::new(init_events.bits()),\n+        };\n+        Self {\n+            inner: Arc::new(inner),\n+        }\n+    }\n+\n+    /// Returns the current events of the pollee given an event mask.\n+    ///\n+    /// If no interesting events are polled and a poller is provided, then\n+    /// the poller will start monitoring the pollee and receive event\n+    /// notification once the pollee gets any interesting events.\n+    ///\n+    /// This operation is _atomic_ in the sense that either some interesting\n+    /// events are returned or the poller is registered (if a poller is provided).\n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mask = mask | IoEvents::ALWAYS_POLL;\n+\n+        // Fast path: return events immediately\n+        let revents = self.events() & mask;\n+        if !revents.is_empty() || poller.is_none() {\n+            return revents;\n+        }\n+\n+        // Register the provided poller.\n+        self.register_poller(poller.unwrap(), mask);\n+\n+        // It is important to check events again to handle race conditions\n+        let revents = self.events() & mask;\n+        revents\n+    }\n+\n+    fn register_poller(&self, poller: &Poller, mask: IoEvents) {\n+        self.inner\n+            .subject\n+            .register_observer(poller.observer(), mask);\n+        let mut pollees = poller.inner.pollees.lock();\n+        pollees.insert(Arc::downgrade(&self.inner).into(), ());\n+    }\n+\n+    /// Register an IoEvents observer.\n+    ///\n+    /// A registered observer will get notified (through its `on_events` method)\n+    /// every time new events specified by the `mask` argument happen on the\n+    /// pollee (through the `add_events` method).\n+    ///\n+    /// If the given observer has already been registered, then its registered\n+    /// event mask will be updated.\n+    ///\n+    /// Note that the observer will always get notified of the events in\n+    /// `IoEvents::ALWAYS_POLL` regardless of the value of `mask`.\n+    pub fn register_observer(&self, observer: Weak<dyn Observer<IoEvents>>, mask: IoEvents) {\n+        let mask = mask | IoEvents::ALWAYS_POLL;\n+        self.inner.subject.register_observer(observer, mask);\n+    }\n+\n+    /// Unregister an IoEvents observer.\n+    ///\n+    /// If such an observer is found, then the registered observer will be\n+    /// removed from the pollee and returned as the return value. Otherwise,\n+    /// a `None` will be returned.\n+    pub fn unregister_observer(\n+        &self,\n+        observer: &Weak<dyn Observer<IoEvents>>,\n+    ) -> Option<Weak<dyn Observer<IoEvents>>> {\n+        self.inner.subject.unregister_observer(observer)\n+    }\n+\n+    /// Add some events to the pollee's state.\n+    ///\n+    /// This method wakes up all registered pollers that are interested in\n+    /// the added events.\n+    pub fn add_events(&self, events: IoEvents) {\n+        self.inner.events.fetch_or(events.bits(), Ordering::Release);\n+        self.inner.subject.notify_observers(&events);\n+    }\n+\n+    /// Remove some events from the pollee's state.\n+    ///\n+    /// This method will not wake up registered pollers even when\n+    /// the pollee still has some interesting events to the pollers.\n+    pub fn del_events(&self, events: IoEvents) {\n+        self.inner\n+            .events\n+            .fetch_and(!events.bits(), Ordering::Release);\n+    }\n+\n+    /// Reset the pollee's state.\n+    ///\n+    /// Reset means removing all events on the pollee.\n+    pub fn reset_events(&self) {\n+        self.inner\n+            .events\n+            .fetch_and(!IoEvents::all().bits(), Ordering::Release);\n+    }\n+\n+    fn events(&self) -> IoEvents {\n+        let event_bits = self.inner.events.load(Ordering::Acquire);\n+        IoEvents::from_bits(event_bits).unwrap()\n+    }\n }\n \n-#[derive(Debug, Clone, Copy)]\n-pub struct PollFd {\n-    pub fd: FileDescripter,\n-    pub events: IoEvents,\n-    pub revents: IoEvents,\n+/// A poller gets notified when its associated pollees have interesting events.\n+pub struct Poller {\n+    inner: Arc<PollerInner>,\n }\n \n-impl From<c_pollfd> for PollFd {\n-    fn from(raw: c_pollfd) -> Self {\n-        let events = IoEvents::from_bits_truncate(raw.events as _);\n-        let revents = IoEvents::from_bits_truncate(raw.revents as _);\n+struct PollerInner {\n+    // Use event counter to wait or wake up a poller\n+    event_counter: EventCounter,\n+    // All pollees that are interesting to this poller\n+    pollees: Mutex<BTreeMap<KeyableWeak<PolleeInner>, ()>>,\n+}\n+\n+impl Poller {\n+    /// Constructs a new `Poller`.\n+    pub fn new() -> Self {\n+        let inner = PollerInner {\n+            event_counter: EventCounter::new(),\n+            pollees: Mutex::new(BTreeMap::new()),\n+        };\n         Self {\n-            fd: raw.fd,\n-            events,\n-            revents,\n+            inner: Arc::new(inner),\n         }\n     }\n+\n+    /// Wait until there are any interesting events happen since last `wait`.\n+    pub fn wait(&self) {\n+        self.inner.event_counter.read();\n+    }\n+\n+    fn observer(&self) -> Weak<dyn Observer<IoEvents>> {\n+        Arc::downgrade(&self.inner) as _\n+    }\n+}\n+\n+impl Observer<IoEvents> for PollerInner {\n+    fn on_events(&self, _events: &IoEvents) {\n+        self.event_counter.write();\n+    }\n }\n \n-impl From<PollFd> for c_pollfd {\n-    fn from(raw: PollFd) -> Self {\n-        let events = raw.events.bits() as i16;\n-        let revents = raw.revents.bits() as i16;\n+impl Drop for Poller {\n+    fn drop(&mut self) {\n+        let mut pollees = self.inner.pollees.lock();\n+        if pollees.len() == 0 {\n+            return;\n+        }\n+\n+        let self_observer = self.observer();\n+        for (weak_pollee, _) in pollees.drain_filter(|_, _| true) {\n+            if let Some(pollee) = weak_pollee.upgrade() {\n+                pollee.subject.unregister_observer(&self_observer);\n+            }\n+        }\n+    }\n+}\n+\n+/// A counter for wait and wakeup.\n+struct EventCounter {\n+    counter: AtomicUsize,\n+    wait_queue: WaitQueue,\n+}\n+\n+impl EventCounter {\n+    pub fn new() -> Self {\n         Self {\n-            fd: raw.fd,\n-            events,\n-            revents,\n+            counter: AtomicUsize::new(0),\n+            wait_queue: WaitQueue::new(),\n         }\n     }\n+\n+    pub fn read(&self) -> usize {\n+        self.wait_queue.wait_until(|| {\n+            let val = self.counter.swap(0, Ordering::Relaxed);\n+            if val > 0 {\n+                Some(val)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    pub fn write(&self) {\n+        self.counter.fetch_add(1, Ordering::Relaxed);\n+        self.wait_queue.wake_one();\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -1,4 +1,6 @@\n-use super::{DirentVisitor, FsFlags, Inode, InodeMode, InodeType, Metadata, PageCache};\n+use super::{\n+    DirentVisitor, FsFlags, Inode, InodeMode, InodeType, IoEvents, Metadata, PageCache, Poller,\n+};\n use crate::prelude::*;\n use crate::rights::Full;\n use crate::vm::vmo::Vmo;\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -184,6 +186,10 @@ impl Vnode {\n         self.inner.read().inode.readdir_at(offset, visitor)\n     }\n \n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.inner.read().inode.poll(mask, poller)\n+    }\n+\n     pub fn metadata(&self) -> Metadata {\n         self.inner.read().inode.metadata()\n     }\ndiff --git a/services/libs/jinux-std/src/prelude.rs b/services/libs/jinux-std/src/prelude.rs\n--- a/services/libs/jinux-std/src/prelude.rs\n+++ b/services/libs/jinux-std/src/prelude.rs\n@@ -13,6 +13,7 @@ pub(crate) use alloc::sync::Weak;\n pub(crate) use alloc::vec;\n pub(crate) use alloc::vec::Vec;\n pub(crate) use bitflags::bitflags;\n+pub(crate) use core::any::Any;\n pub(crate) use core::ffi::CStr;\n pub(crate) use jinux_frame::config::PAGE_SIZE;\n pub(crate) use jinux_frame::sync::{Mutex, MutexGuard};\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -49,8 +49,6 @@ pub struct Process {\n     root_vmar: Arc<Vmar<Full>>,\n     /// wait for child status changed\n     waiting_children: WaitQueue,\n-    /// wait for io events\n-    poll_queue: WaitQueue,\n \n     // Mutable Part\n     /// The executable path.\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -110,7 +108,6 @@ impl Process {\n     ) -> Self {\n         let children = BTreeMap::new();\n         let waiting_children = WaitQueue::new();\n-        let poll_queue = WaitQueue::new();\n         let resource_limits = ResourceLimits::default();\n         Self {\n             pid,\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -119,7 +116,6 @@ impl Process {\n             user_vm,\n             root_vmar,\n             waiting_children,\n-            poll_queue,\n             exit_code: AtomicI32::new(0),\n             status: Mutex::new(ProcessStatus::Runnable),\n             parent: Mutex::new(parent),\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -138,10 +134,6 @@ impl Process {\n         &self.waiting_children\n     }\n \n-    pub fn poll_queue(&self) -> &WaitQueue {\n-        &self.poll_queue\n-    }\n-\n     /// init a user process and run the process\n     pub fn spawn_user_process(\n         executable_path: &str,\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs b/services/libs/jinux-std/src/process/process_group.rs\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ b/services/libs/jinux-std/src/process/process_group.rs\n@@ -69,14 +69,6 @@ impl ProcessGroup {\n         self.inner.lock().pgid\n     }\n \n-    /// Wake up all processes waiting on polling queue\n-    pub fn wake_all_polling_procs(&self) {\n-        let inner = self.inner.lock();\n-        for (_, process) in &inner.processes {\n-            process.poll_queue().wake_all();\n-        }\n-    }\n-\n     /// send kernel signal to all processes in the group\n     pub fn kernel_signal(&self, signal: KernelSignal) {\n         for (_, process) in &self.inner.lock().processes {\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -65,10 +65,10 @@ pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n }\n \n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n-    PROCESS_TABLE_SUBJECT.register_observer(observer);\n+    PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n-pub fn unregister_observer(observer: Weak<dyn Observer<PidEvent>>) {\n+pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\n \ndiff --git a/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/jinux-std/src/syscall/chdir.rs\n--- a/services/libs/jinux-std/src/syscall/chdir.rs\n+++ b/services/libs/jinux-std/src/syscall/chdir.rs\n@@ -1,4 +1,6 @@\n-use crate::fs::{file_table::FileDescripter, fs_resolver::FsPath, utils::InodeType};\n+use crate::fs::{\n+    file_table::FileDescripter, fs_resolver::FsPath, inode_handle::InodeHandle, utils::InodeType,\n+};\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::syscall::constants::MAX_FILENAME_LEN;\ndiff --git a/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/jinux-std/src/syscall/chdir.rs\n--- a/services/libs/jinux-std/src/syscall/chdir.rs\n+++ b/services/libs/jinux-std/src/syscall/chdir.rs\n@@ -38,7 +40,7 @@ pub fn sys_fchdir(fd: FileDescripter) -> Result<SyscallReturn> {\n         let file_table = current.file_table().lock();\n         let file = file_table.get_file(fd)?;\n         let inode_handle = file\n-            .as_inode_handle()\n+            .downcast_ref::<InodeHandle>()\n             .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n         inode_handle.dentry().clone()\n     };\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/epoll.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/epoll.rs\n@@ -0,0 +1,133 @@\n+use core::time::Duration;\n+\n+use crate::fs::epoll::{c_epoll_event, EpollCtl, EpollEvent, EpollFile, EpollFlags};\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::utils::CreationFlags;\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+use super::SyscallReturn;\n+use super::{SYS_EPOLL_CREATE1, SYS_EPOLL_CTL, SYS_EPOLL_WAIT};\n+\n+pub fn sys_epoll_create(size: i32) -> Result<SyscallReturn> {\n+    if size <= 0 {\n+        return_errno_with_message!(Errno::EINVAL, \"size is not positive\");\n+    }\n+    sys_epoll_create1(0)\n+}\n+\n+pub fn sys_epoll_create1(flags: u32) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_CREATE1);\n+    debug!(\"flags = 0x{:x}\", flags);\n+\n+    let close_on_exec = {\n+        let flags = CreationFlags::from_bits(flags)\n+            .ok_or_else(|| Error::with_message(Errno::EINVAL, \"invalid flags\"))?;\n+        if flags == CreationFlags::empty() {\n+            false\n+        } else if flags == CreationFlags::O_CLOEXEC {\n+            true\n+        } else {\n+            // Only O_CLOEXEC is valid\n+            return_errno_with_message!(Errno::EINVAL, \"invalid flags\");\n+        }\n+    };\n+\n+    let current = current!();\n+    let epoll_file: Arc<EpollFile> = EpollFile::new();\n+    let mut file_table = current.file_table().lock();\n+    let fd = file_table.insert(epoll_file);\n+    Ok(SyscallReturn::Return(fd as _))\n+}\n+\n+pub fn sys_epoll_ctl(\n+    epfd: FileDescripter,\n+    op: i32,\n+    fd: FileDescripter,\n+    event_addr: Vaddr,\n+) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_CTL);\n+    debug!(\n+        \"epfd = {}, op = {}, fd = {}, event_addr = 0x{:x}\",\n+        epfd, op, fd, event_addr\n+    );\n+\n+    const EPOLL_CTL_ADD: i32 = 1;\n+    const EPOLL_CTL_DEL: i32 = 2;\n+    const EPOLL_CTL_MOD: i32 = 3;\n+\n+    let cmd = match op {\n+        EPOLL_CTL_ADD => {\n+            let c_epoll_event = read_val_from_user::<c_epoll_event>(event_addr)?;\n+            let event = EpollEvent::from(&c_epoll_event);\n+            let flags = EpollFlags::from_bits_truncate(c_epoll_event.events);\n+            EpollCtl::Add(fd, event, flags)\n+        }\n+        EPOLL_CTL_DEL => EpollCtl::Del(fd),\n+        EPOLL_CTL_MOD => {\n+            let c_epoll_event = read_val_from_user::<c_epoll_event>(event_addr)?;\n+            let event = EpollEvent::from(&c_epoll_event);\n+            let flags = EpollFlags::from_bits_truncate(c_epoll_event.events);\n+            EpollCtl::Mod(fd, event, flags)\n+        }\n+        _ => return_errno_with_message!(Errno::EINVAL, \"invalid op\"),\n+    };\n+\n+    let current = current!();\n+    let file = {\n+        let file_table = current.file_table().lock();\n+        file_table.get_file(epfd)?.clone()\n+    };\n+    let epoll_file = file\n+        .downcast_ref::<EpollFile>()\n+        .ok_or(Error::with_message(Errno::EINVAL, \"not epoll file\"))?;\n+    epoll_file.control(&cmd)?;\n+\n+    Ok(SyscallReturn::Return(0 as _))\n+}\n+\n+pub fn sys_epoll_wait(\n+    epfd: FileDescripter,\n+    events_addr: Vaddr,\n+    max_events: i32,\n+    timeout: i32,\n+) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_EPOLL_WAIT);\n+\n+    let max_events = {\n+        if max_events <= 0 {\n+            return_errno_with_message!(Errno::EINVAL, \"max_events is not positive\");\n+        }\n+        max_events as usize\n+    };\n+    let timeout = if timeout >= 0 {\n+        Some(Duration::from_millis(timeout as _))\n+    } else {\n+        None\n+    };\n+    debug!(\n+        \"epfd = {}, events_addr = 0x{:x}, max_events = {}, timeout = {:?}\",\n+        epfd, events_addr, max_events, timeout\n+    );\n+\n+    let current = current!();\n+    let file = {\n+        let file_table = current.file_table().lock();\n+        file_table.get_file(epfd)?.clone()\n+    };\n+    let epoll_file = file\n+        .downcast_ref::<EpollFile>()\n+        .ok_or(Error::with_message(Errno::EINVAL, \"not epoll file\"))?;\n+    let epoll_events = epoll_file.wait(max_events, timeout.as_ref())?;\n+\n+    // Write back\n+    let mut write_addr = events_addr;\n+    for epoll_event in epoll_events.iter() {\n+        let c_epoll_event = c_epoll_event::from(epoll_event);\n+        write_val_to_user(write_addr, &c_epoll_event)?;\n+        write_addr += core::mem::size_of::<c_epoll_event>();\n+    }\n+\n+    Ok(SyscallReturn::Return(epoll_events.len() as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/fcntl.rs b/services/libs/jinux-std/src/syscall/fcntl.rs\n--- a/services/libs/jinux-std/src/syscall/fcntl.rs\n+++ b/services/libs/jinux-std/src/syscall/fcntl.rs\n@@ -12,8 +12,7 @@ pub fn sys_fcntl(fd: FileDescripter, cmd: i32, arg: u64) -> Result<SyscallReturn\n             // FIXME: deal with the cloexec flag\n             let current = current!();\n             let mut file_table = current.file_table().lock();\n-            let new_fd = arg as FileDescripter;\n-            file_table.dup(fd, Some(new_fd))?;\n+            let new_fd = file_table.dup(fd, arg as FileDescripter)?;\n             return Ok(SyscallReturn::Return(new_fd as _));\n         }\n         FcntlCmd::F_SETFD => {\ndiff --git a/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/jinux-std/src/syscall/getdents64.rs\n--- a/services/libs/jinux-std/src/syscall/getdents64.rs\n+++ b/services/libs/jinux-std/src/syscall/getdents64.rs\n@@ -1,5 +1,6 @@\n use crate::fs::{\n     file_table::FileDescripter,\n+    inode_handle::InodeHandle,\n     utils::{DirentVisitor, InodeType},\n };\n use crate::log_syscall_entry;\ndiff --git a/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/jinux-std/src/syscall/getdents64.rs\n--- a/services/libs/jinux-std/src/syscall/getdents64.rs\n+++ b/services/libs/jinux-std/src/syscall/getdents64.rs\n@@ -27,7 +28,7 @@ pub fn sys_getdents64(\n         file_table.get_file(fd)?.clone()\n     };\n     let inode_handle = file\n-        .as_inode_handle()\n+        .downcast_ref::<InodeHandle>()\n         .ok_or(Error::with_message(Errno::EBADE, \"not inode\"))?;\n     if inode_handle.dentry().inode_type() != InodeType::Dir {\n         return_errno!(Errno::ENOTDIR);\ndiff --git a/services/libs/jinux-std/src/syscall/ioctl.rs b/services/libs/jinux-std/src/syscall/ioctl.rs\n--- a/services/libs/jinux-std/src/syscall/ioctl.rs\n+++ b/services/libs/jinux-std/src/syscall/ioctl.rs\n@@ -16,6 +16,6 @@ pub fn sys_ioctl(fd: FileDescripter, cmd: u32, arg: Vaddr) -> Result<SyscallRetu\n     let current = current!();\n     let file_table = current.file_table().lock();\n     let file = file_table.get_file(fd)?;\n-    let res = file.as_file().unwrap().ioctl(ioctl_cmd, arg)?;\n+    let res = file.ioctl(ioctl_cmd, arg)?;\n     return Ok(SyscallReturn::Return(res as _));\n }\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -9,6 +9,7 @@ use crate::syscall::clock_nanosleep::sys_clock_nanosleep;\n use crate::syscall::clone::sys_clone;\n use crate::syscall::close::sys_close;\n use crate::syscall::dup::{sys_dup, sys_dup2};\n+use crate::syscall::epoll::{sys_epoll_create, sys_epoll_create1, sys_epoll_ctl, sys_epoll_wait};\n use crate::syscall::execve::sys_execve;\n use crate::syscall::exit::sys_exit;\n use crate::syscall::exit_group::sys_exit_group;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -36,6 +37,7 @@ use crate::syscall::mprotect::sys_mprotect;\n use crate::syscall::munmap::sys_munmap;\n use crate::syscall::open::{sys_open, sys_openat};\n use crate::syscall::pause::sys_pause;\n+use crate::syscall::pipe::{sys_pipe, sys_pipe2};\n use crate::syscall::poll::sys_poll;\n use crate::syscall::prctl::sys_prctl;\n use crate::syscall::prlimit64::sys_prlimit64;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -75,6 +77,7 @@ mod clone;\n mod close;\n mod constants;\n mod dup;\n+mod epoll;\n mod execve;\n mod exit;\n mod exit_group;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -102,6 +105,7 @@ mod mprotect;\n mod munmap;\n mod open;\n mod pause;\n+mod pipe;\n mod poll;\n mod prctl;\n mod pread64;\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -181,6 +185,7 @@ define_syscall_nums!(\n     SYS_PREAD64 = 17,\n     SYS_WRITEV = 20,\n     SYS_ACCESS = 21,\n+    SYS_PIPE = 22,\n     SYS_SCHED_YIELD = 24,\n     SYS_MADVISE = 28,\n     SYS_DUP = 32,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -218,10 +223,13 @@ define_syscall_nums!(\n     SYS_GETTID = 186,\n     SYS_TIME = 201,\n     SYS_FUTEX = 202,\n+    SYS_EPOLL_CREATE = 213,\n     SYS_GETDENTS64 = 217,\n     SYS_SET_TID_ADDRESS = 218,\n     SYS_CLOCK_NANOSLEEP = 230,\n     SYS_EXIT_GROUP = 231,\n+    SYS_EPOLL_WAIT = 232,\n+    SYS_EPOLL_CTL = 233,\n     SYS_TGKILL = 234,\n     SYS_WAITID = 247,\n     SYS_OPENAT = 257,\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -234,6 +242,8 @@ define_syscall_nums!(\n     SYS_READLINKAT = 267,\n     SYS_SET_ROBUST_LIST = 273,\n     SYS_UTIMENSAT = 280,\n+    SYS_EPOLL_CREATE1 = 291,\n+    SYS_PIPE2 = 293,\n     SYS_PRLIMIT64 = 302\n );\n \ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -313,6 +323,7 @@ pub fn syscall_dispatch(\n         SYS_PREAD64 => syscall_handler!(4, sys_pread64, args),\n         SYS_WRITEV => syscall_handler!(3, sys_writev, args),\n         SYS_ACCESS => syscall_handler!(2, sys_access, args),\n+        SYS_PIPE => syscall_handler!(1, sys_pipe, args),\n         SYS_SCHED_YIELD => syscall_handler!(0, sys_sched_yield),\n         SYS_MADVISE => syscall_handler!(3, sys_madvise, args),\n         SYS_DUP => syscall_handler!(1, sys_dup, args),\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -350,10 +361,13 @@ pub fn syscall_dispatch(\n         SYS_GETTID => syscall_handler!(0, sys_gettid),\n         SYS_TIME => syscall_handler!(1, sys_time, args),\n         SYS_FUTEX => syscall_handler!(6, sys_futex, args),\n+        SYS_EPOLL_CREATE => syscall_handler!(1, sys_epoll_create, args),\n         SYS_GETDENTS64 => syscall_handler!(3, sys_getdents64, args),\n         SYS_SET_TID_ADDRESS => syscall_handler!(1, sys_set_tid_address, args),\n         SYS_CLOCK_NANOSLEEP => syscall_handler!(4, sys_clock_nanosleep, args),\n         SYS_EXIT_GROUP => syscall_handler!(1, sys_exit_group, args),\n+        SYS_EPOLL_WAIT => syscall_handler!(4, sys_epoll_wait, args),\n+        SYS_EPOLL_CTL => syscall_handler!(4, sys_epoll_ctl, args),\n         SYS_TGKILL => syscall_handler!(3, sys_tgkill, args),\n         SYS_WAITID => syscall_handler!(5, sys_waitid, args),\n         SYS_OPENAT => syscall_handler!(4, sys_openat, args),\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -366,6 +380,8 @@ pub fn syscall_dispatch(\n         SYS_READLINKAT => syscall_handler!(4, sys_readlinkat, args),\n         SYS_SET_ROBUST_LIST => syscall_handler!(2, sys_set_robust_list, args),\n         SYS_UTIMENSAT => syscall_handler!(4, sys_utimensat, args),\n+        SYS_EPOLL_CREATE1 => syscall_handler!(1, sys_epoll_create1, args),\n+        SYS_PIPE2 => syscall_handler!(2, sys_pipe2, args),\n         SYS_PRLIMIT64 => syscall_handler!(4, sys_prlimit64, args),\n         _ => {\n             error!(\"Unimplemented syscall number: {}\", syscall_number);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -1,5 +1,5 @@\n use crate::fs::{\n-    file_handle::{File, FileHandle},\n+    file_handle::FileLike,\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\n };\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -39,7 +39,7 @@ pub fn sys_openat(\n \n     if dirfd == AT_FDCWD && pathname == CString::new(\"./trace\")? {\n         // Debug use: This file is used for output busybox log\n-        let trace_file = FileHandle::new_file(Arc::new(BusyBoxTraceFile) as Arc<dyn File>);\n+        let trace_file = Arc::new(BusyBoxTraceFile);\n         let current = current!();\n         let mut file_table = current.file_table().lock();\n         let fd = file_table.insert(trace_file);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -47,7 +47,7 @@ pub fn sys_openat(\n     }\n \n     if dirfd == AT_FDCWD && pathname == CString::new(\"/dev/tty\")? {\n-        let tty_file = FileHandle::new_file(get_n_tty().clone() as Arc<dyn File>);\n+        let tty_file = get_n_tty().clone();\n         let current = current!();\n         let mut file_table = current.file_table().lock();\n         let fd = file_table.insert(tty_file);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -60,7 +60,7 @@ pub fn sys_openat(\n         let pathname = pathname.to_string_lossy();\n         let fs_path = FsPath::new(dirfd, pathname.as_ref())?;\n         let inode_handle = current.fs().read().open(&fs_path, flags, mode)?;\n-        FileHandle::new_inode_handle(inode_handle)\n+        Arc::new(inode_handle)\n     };\n     let mut file_table = current.file_table().lock();\n     let fd = file_table.insert(file_handle);\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\n--- a/services/libs/jinux-std/src/syscall/open.rs\n+++ b/services/libs/jinux-std/src/syscall/open.rs\n@@ -74,9 +74,13 @@ pub fn sys_open(pathname_addr: Vaddr, flags: u32, mode: u16) -> Result<SyscallRe\n /// File for output busybox ash log.\n struct BusyBoxTraceFile;\n \n-impl File for BusyBoxTraceFile {\n+impl FileLike for BusyBoxTraceFile {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         debug!(\"ASH TRACE: {}\", core::str::from_utf8(buf)?);\n         Ok(buf.len())\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/pipe.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/pipe.rs\n@@ -0,0 +1,47 @@\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::pipe::{PipeReader, PipeWriter};\n+use crate::fs::utils::{Channel, StatusFlags};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+use super::SyscallReturn;\n+use super::SYS_PIPE2;\n+\n+pub fn sys_pipe2(fds: Vaddr, flags: u32) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_PIPE2);\n+    debug!(\"flags: {:?}\", flags);\n+\n+    let mut pipe_fds = read_val_from_user::<PipeFds>(fds)?;\n+    let (reader, writer) = {\n+        let (producer, consumer) = Channel::with_capacity_and_flags(\n+            PIPE_BUF_SIZE,\n+            StatusFlags::from_bits_truncate(flags),\n+        )?\n+        .split();\n+        (PipeReader::new(consumer), PipeWriter::new(producer))\n+    };\n+    let pipe_reader = Arc::new(reader);\n+    let pipe_writer = Arc::new(writer);\n+\n+    let current = current!();\n+    let mut file_table = current.file_table().lock();\n+    pipe_fds.reader_fd = file_table.insert(pipe_reader);\n+    pipe_fds.writer_fd = file_table.insert(pipe_writer);\n+    write_val_to_user(fds, &pipe_fds)?;\n+\n+    Ok(SyscallReturn::Return(0))\n+}\n+\n+pub fn sys_pipe(fds: Vaddr) -> Result<SyscallReturn> {\n+    self::sys_pipe2(fds, 0)\n+}\n+\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+struct PipeFds {\n+    reader_fd: FileDescripter,\n+    writer_fd: FileDescripter,\n+}\n+\n+const PIPE_BUF_SIZE: usize = 1024 * 1024;\ndiff --git a/services/libs/jinux-std/src/syscall/poll.rs b/services/libs/jinux-std/src/syscall/poll.rs\n--- a/services/libs/jinux-std/src/syscall/poll.rs\n+++ b/services/libs/jinux-std/src/syscall/poll.rs\n@@ -1,65 +1,161 @@\n+use core::cell::Cell;\n use core::time::Duration;\n \n-use crate::fs::utils::{c_pollfd, PollFd};\n+use crate::fs::file_table::FileDescripter;\n+use crate::fs::utils::{IoEvents, Poller};\n use crate::log_syscall_entry;\n+use crate::prelude::*;\n use crate::util::{read_val_from_user, write_val_to_user};\n-use crate::{fs::utils::c_nfds, prelude::*};\n \n use super::SyscallReturn;\n use super::SYS_POLL;\n \n-pub fn sys_poll(fds: Vaddr, nfds: c_nfds, timeout: i32) -> Result<SyscallReturn> {\n+pub fn sys_poll(fds: Vaddr, nfds: u64, timeout: i32) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_POLL);\n \n-    let mut read_addr = fds;\n-    let mut pollfds = Vec::with_capacity(nfds as _);\n-    for _ in 0..nfds {\n-        let c_poll_fd = read_val_from_user::<c_pollfd>(read_addr)?;\n-        let poll_fd = PollFd::from(c_poll_fd);\n-        pollfds.push(poll_fd);\n-        // FIXME: do we need to respect align of c_pollfd here?\n-        read_addr += core::mem::size_of::<c_pollfd>();\n-    }\n-    let timeout = if timeout == 0 {\n-        None\n-    } else {\n+    let poll_fds = {\n+        let mut read_addr = fds;\n+        let mut poll_fds = Vec::with_capacity(nfds as _);\n+        for _ in 0..nfds {\n+            let c_poll_fd = read_val_from_user::<c_pollfd>(read_addr)?;\n+            let poll_fd = PollFd::from(c_poll_fd);\n+            // Always clear the revents fields first\n+            poll_fd.revents().set(IoEvents::empty());\n+            poll_fds.push(poll_fd);\n+            // FIXME: do we need to respect align of c_pollfd here?\n+            read_addr += core::mem::size_of::<c_pollfd>();\n+        }\n+        poll_fds\n+    };\n+    let timeout = if timeout >= 0 {\n         Some(Duration::from_millis(timeout as _))\n+    } else {\n+        None\n     };\n     debug!(\n         \"poll_fds = {:?}, nfds = {}, timeout = {:?}\",\n-        pollfds, nfds, timeout\n+        poll_fds, nfds, timeout\n     );\n-    let current = current!();\n-    // FIXME: respect timeout parameter\n-    let ready_files = current.poll_queue().wait_until(|| {\n-        let mut ready_files = 0;\n-        for pollfd in &mut pollfds {\n-            let file_table = current.file_table().lock();\n-            let file = file_table.get_file(pollfd.fd);\n-            match file {\n-                Err(_) => return Some(Err(Error::new(Errno::EBADF))),\n-                Ok(file) => {\n-                    let file_events = file.as_file().unwrap().poll();\n-                    let polled_events = pollfd.events.intersection(file_events);\n-                    if !polled_events.is_empty() {\n-                        ready_files += 1;\n-                        pollfd.revents |= polled_events;\n-                    }\n-                }\n-            }\n-        }\n-        if ready_files > 0 {\n-            return Some(Ok(ready_files));\n-        } else {\n-            return None;\n-        }\n-    })?;\n+\n+    let num_revents = do_poll(&poll_fds, timeout)?;\n+\n+    // Write back\n     let mut write_addr = fds;\n-    for pollfd in pollfds {\n+    for pollfd in poll_fds {\n         let c_poll_fd = c_pollfd::from(pollfd);\n         write_val_to_user(write_addr, &c_poll_fd)?;\n         // FIXME: do we need to respect align of c_pollfd here?\n         write_addr += core::mem::size_of::<c_pollfd>();\n     }\n-    Ok(SyscallReturn::Return(ready_files))\n+\n+    Ok(SyscallReturn::Return(num_revents as _))\n+}\n+\n+fn do_poll(poll_fds: &[PollFd], timeout: Option<Duration>) -> Result<usize> {\n+    // The main loop of polling\n+    let poller = Poller::new();\n+    loop {\n+        let mut num_revents = 0;\n+\n+        for poll_fd in poll_fds {\n+            // Skip poll_fd if it is not given a fd\n+            let fd = match poll_fd.fd() {\n+                Some(fd) => fd,\n+                None => continue,\n+            };\n+\n+            // Poll the file\n+            let current = current!();\n+            let file = {\n+                let file_table = current.file_table().lock();\n+                file_table.get_file(fd)?.clone()\n+            };\n+            let need_poller = if num_revents == 0 {\n+                Some(&poller)\n+            } else {\n+                None\n+            };\n+            let revents = file.poll(poll_fd.events(), need_poller);\n+            if !revents.is_empty() {\n+                poll_fd.revents().set(revents);\n+                num_revents += 1;\n+            }\n+        }\n+\n+        if num_revents > 0 {\n+            return Ok(num_revents);\n+        }\n+\n+        // Return immediately if specifying a timeout of zero\n+        if timeout.is_some() && timeout.as_ref().unwrap().is_zero() {\n+            return Ok(0);\n+        }\n+\n+        // FIXME: respect timeout parameter\n+        poller.wait();\n+    }\n+}\n+\n+// https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/poll.h\n+#[derive(Debug, Clone, Copy, Pod)]\n+#[repr(C)]\n+pub struct c_pollfd {\n+    fd: i32,\n+    events: i16,\n+    revents: i16,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct PollFd {\n+    fd: Option<FileDescripter>,\n+    events: IoEvents,\n+    revents: Cell<IoEvents>,\n+}\n+\n+impl PollFd {\n+    pub fn fd(&self) -> Option<FileDescripter> {\n+        self.fd\n+    }\n+\n+    pub fn events(&self) -> IoEvents {\n+        self.events\n+    }\n+\n+    pub fn revents(&self) -> &Cell<IoEvents> {\n+        &self.revents\n+    }\n+}\n+\n+impl From<c_pollfd> for PollFd {\n+    fn from(raw: c_pollfd) -> Self {\n+        let fd = if raw.fd >= 0 {\n+            Some(raw.fd as FileDescripter)\n+        } else {\n+            None\n+        };\n+        let events = IoEvents::from_bits_truncate(raw.events as _);\n+        let revents = Cell::new(IoEvents::from_bits_truncate(raw.revents as _));\n+        Self {\n+            fd,\n+            events,\n+            revents,\n+        }\n+    }\n+}\n+\n+impl From<PollFd> for c_pollfd {\n+    fn from(raw: PollFd) -> Self {\n+        let fd = if let Some(fd) = raw.fd() {\n+            fd as i32\n+        } else {\n+            -1\n+        };\n+        let events = raw.events().bits() as i16;\n+        let revents = raw.revents().get().bits() as i16;\n+        Self {\n+            fd,\n+            events,\n+            revents,\n+        }\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -1,11 +1,10 @@\n-use crate::fs::utils::IoEvents;\n+use crate::fs::utils::{IoEvents, Pollee, Poller};\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n use crate::{\n     prelude::*,\n     process::{process_table, signal::signals::kernel::KernelSignal, Pgid},\n };\n-use jinux_frame::sync::WaitQueue;\n-use ringbuffer::{ConstGenericRingBuffer, RingBuffer, RingBufferRead, RingBufferWrite};\n+use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n use super::termio::{KernelTermios, CC_C_CHAR};\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -18,40 +17,39 @@ pub struct LineDiscipline {\n     /// current line\n     current_line: RwLock<CurrentLine>,\n     /// The read buffer\n-    read_buffer: Mutex<ConstGenericRingBuffer<u8, BUFFER_CAPACITY>>,\n+    read_buffer: Mutex<StaticRb<u8, BUFFER_CAPACITY>>,\n     /// The foreground process group\n     foreground: RwLock<Option<Pgid>>,\n     /// termios\n     termios: RwLock<KernelTermios>,\n-    /// wait until self is readable\n-    read_wait_queue: WaitQueue,\n+    /// Pollee\n+    pollee: Pollee,\n }\n \n-#[derive(Debug)]\n pub struct CurrentLine {\n-    buffer: ConstGenericRingBuffer<u8, BUFFER_CAPACITY>,\n+    buffer: StaticRb<u8, BUFFER_CAPACITY>,\n }\n \n impl CurrentLine {\n     pub fn new() -> Self {\n         Self {\n-            buffer: ConstGenericRingBuffer::new(),\n+            buffer: StaticRb::default(),\n         }\n     }\n \n     /// read all bytes inside current line and clear current line\n     pub fn drain(&mut self) -> Vec<u8> {\n-        self.buffer.drain().collect()\n+        self.buffer.pop_iter().collect()\n     }\n \n     pub fn push_char(&mut self, char: u8) {\n         // What should we do if line is full?\n         debug_assert!(!self.is_full());\n-        self.buffer.push(char);\n+        self.buffer.push_overwrite(char);\n     }\n \n     pub fn backspace(&mut self) {\n-        self.buffer.dequeue();\n+        self.buffer.pop();\n     }\n \n     pub fn is_full(&self) -> bool {\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -68,10 +66,10 @@ impl LineDiscipline {\n     pub fn new() -> Self {\n         Self {\n             current_line: RwLock::new(CurrentLine::new()),\n-            read_buffer: Mutex::new(ConstGenericRingBuffer::new()),\n+            read_buffer: Mutex::new(StaticRb::default()),\n             foreground: RwLock::new(None),\n             termios: RwLock::new(KernelTermios::default()),\n-            read_wait_queue: WaitQueue::new(),\n+            pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -118,7 +116,7 @@ impl LineDiscipline {\n                 current_line.push_char(item);\n                 let current_line_chars = current_line.drain();\n                 for char in current_line_chars {\n-                    self.read_buffer.lock().push(char);\n+                    self.read_buffer.lock().push_overwrite(char);\n                 }\n             } else if item >= 0x20 && item < 0x7f {\n                 // printable character\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -126,7 +124,7 @@ impl LineDiscipline {\n             }\n         } else {\n             // raw mode\n-            self.read_buffer.lock().push(item);\n+            self.read_buffer.lock().push_overwrite(item);\n             // debug!(\"push char: {}\", char::from(item))\n         }\n \ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -135,13 +133,13 @@ impl LineDiscipline {\n         }\n \n         if self.is_readable() {\n-            self.read_wait_queue.wake_all();\n+            self.pollee.add_events(IoEvents::IN);\n         }\n     }\n \n     /// whether self is readable\n     fn is_readable(&self) -> bool {\n-        self.read_buffer.lock().len() > 0\n+        !self.read_buffer.lock().is_empty()\n     }\n \n     // TODO: respect output flags\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -170,58 +168,84 @@ impl LineDiscipline {\n \n     /// read all bytes buffered to dst, return the actual read length.\n     pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let termios = self.termios.read();\n-        let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n-        let vtime = *termios.get_special_char(CC_C_CHAR::VTIME);\n-        drop(termios);\n-        let read_len: usize = self.read_wait_queue.wait_until(|| {\n-            // if current process does not belong to foreground process group,\n-            // block until current process become foreground.\n-            if !self.current_belongs_to_foreground() {\n-                warn!(\"current process does not belong to foreground process group\");\n-                return None;\n+        let mut poller = None;\n+        loop {\n+            let res = self.try_read(dst);\n+            match res {\n+                Ok(read_len) => {\n+                    return Ok(read_len);\n+                }\n+                Err(e) => {\n+                    if e.error() != Errno::EAGAIN {\n+                        return Err(e);\n+                    }\n+                }\n+            }\n+\n+            // Wait for read event\n+            let need_poller = if poller.is_none() {\n+                poller = Some(Poller::new());\n+                poller.as_ref()\n+            } else {\n+                None\n+            };\n+            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n+            if revents.is_empty() {\n+                poller.as_ref().unwrap().wait();\n             }\n+        }\n+    }\n+\n+    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n+        if !self.current_belongs_to_foreground() {\n+            return_errno!(Errno::EAGAIN);\n+        }\n+\n+        let (vmin, vtime) = {\n+            let termios = self.termios.read();\n+            let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n+            let vtime = *termios.get_special_char(CC_C_CHAR::VTIME);\n+            (vmin, vtime)\n+        };\n+        let read_len = {\n             let len = self.read_buffer.lock().len();\n             let max_read_len = len.min(dst.len());\n             if vmin == 0 && vtime == 0 {\n                 // poll read\n-                return self.poll_read(dst);\n-            }\n-            if vmin > 0 && vtime == 0 {\n+                self.poll_read(dst)\n+            } else if vmin > 0 && vtime == 0 {\n                 // block read\n-                return self.block_read(dst, vmin);\n-            }\n-            if vmin == 0 && vtime > 0 {\n+                self.block_read(dst, vmin)?\n+            } else if vmin == 0 && vtime > 0 {\n                 todo!()\n-            }\n-            if vmin > 0 && vtime > 0 {\n+            } else if vmin > 0 && vtime > 0 {\n                 todo!()\n+            } else {\n+                unreachable!()\n             }\n-            unreachable!()\n-        });\n+        };\n+        if !self.is_readable() {\n+            self.pollee.del_events(IoEvents::IN);\n+        }\n         Ok(read_len)\n     }\n \n-    pub fn poll(&self) -> IoEvents {\n-        if self.is_empty() {\n-            IoEvents::empty()\n-        } else {\n-            IoEvents::POLLIN\n-        }\n+    pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.pollee.poll(mask, poller)\n     }\n \n     /// returns immediately with the lesser of the number of bytes available or the number of bytes requested.\n     /// If no bytes are available, completes immediately, returning 0.\n-    fn poll_read(&self, dst: &mut [u8]) -> Option<usize> {\n+    fn poll_read(&self, dst: &mut [u8]) -> usize {\n         let mut buffer = self.read_buffer.lock();\n         let len = buffer.len();\n         let max_read_len = len.min(dst.len());\n         if max_read_len == 0 {\n-            return Some(0);\n+            return 0;\n         }\n         let mut read_len = 0;\n         for i in 0..max_read_len {\n-            if let Some(next_char) = buffer.dequeue() {\n+            if let Some(next_char) = buffer.pop() {\n                 if self.termios.read().is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if meet_new_line(next_char, &self.termios.read()) {\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -245,18 +269,18 @@ impl LineDiscipline {\n             }\n         }\n \n-        Some(read_len)\n+        read_len\n     }\n \n     // The read() blocks until the lesser of the number of bytes requested or\n     // MIN bytes are available, and returns the lesser of the two values.\n-    pub fn block_read(&self, dst: &mut [u8], vmin: u8) -> Option<usize> {\n+    pub fn block_read(&self, dst: &mut [u8], vmin: u8) -> Result<usize> {\n         let min_read_len = (vmin as usize).min(dst.len());\n         let buffer_len = self.read_buffer.lock().len();\n         if buffer_len < min_read_len {\n-            return None;\n+            return_errno!(Errno::EAGAIN);\n         }\n-        return self.poll_read(&mut dst[..min_read_len]);\n+        Ok(self.poll_read(&mut dst[..min_read_len]))\n     }\n \n     /// write bytes to buffer, if flush to console, then write the content to console\ndiff --git a/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/tty/line_discipline.rs\n@@ -283,7 +307,7 @@ impl LineDiscipline {\n         *self.foreground.write() = Some(fg_pgid);\n         // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n         if self.is_readable() {\n-            self.read_wait_queue.wake_all();\n+            self.pollee.add_events(IoEvents::IN);\n         }\n     }\n \ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -1,9 +1,12 @@\n use self::line_discipline::LineDiscipline;\n use crate::driver::tty::TtyDriver;\n use crate::fs::utils::{InodeMode, InodeType, IoEvents, Metadata};\n-use crate::fs::{file_handle::File, utils::IoctlCmd};\n+use crate::fs::{\n+    file_handle::FileLike,\n+    utils::{IoctlCmd, Poller},\n+};\n use crate::prelude::*;\n-use crate::process::{process_table, Pgid};\n+use crate::process::Pgid;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod line_discipline;\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -43,23 +46,12 @@ impl Tty {\n         *self.driver.lock() = driver;\n     }\n \n-    /// Wake up foreground process group that wait on IO events.\n-    /// This function should be called when the interrupt handler of IO events is called.\n-    fn wake_fg_proc_grp(&self) {\n-        if let Some(fg_pgid) = self.ldisc.get_fg() {\n-            if let Some(fg_proc_grp) = process_table::pgid_to_process_group(fg_pgid) {\n-                fg_proc_grp.wake_all_polling_procs();\n-            }\n-        }\n-    }\n-\n     pub fn receive_char(&self, item: u8) {\n         self.ldisc.push_char(item);\n-        self.wake_fg_proc_grp();\n     }\n }\n \n-impl File for Tty {\n+impl FileLike for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         self.ldisc.read(buf)\n     }\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -73,8 +65,8 @@ impl File for Tty {\n         Ok(buf.len())\n     }\n \n-    fn poll(&self) -> IoEvents {\n-        self.ldisc.poll()\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.ldisc.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\ndiff --git a/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\n--- a/services/libs/jinux-std/src/tty/mod.rs\n+++ b/services/libs/jinux-std/src/tty/mod.rs\n@@ -137,6 +129,10 @@ impl File for Tty {\n             rdev: 0,\n         }\n     }\n+\n+    fn as_any_ref(&self) -> &dyn Any {\n+        self\n+    }\n }\n \n /// FIXME: should we maintain a static console?\ndiff --git a/services/libs/jinux-util/src/lib.rs b/services/libs/jinux-util/src/lib.rs\n--- a/services/libs/jinux-util/src/lib.rs\n+++ b/services/libs/jinux-util/src/lib.rs\n@@ -2,5 +2,8 @@\n #![no_std]\n #![forbid(unsafe_code)]\n \n+extern crate alloc;\n+\n pub mod frame_ptr;\n+pub mod slot_vec;\n pub mod union_read_ptr;\ndiff --git /dev/null b/services/libs/jinux-util/src/slot_vec.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-util/src/slot_vec.rs\n@@ -0,0 +1,119 @@\n+use alloc::vec::Vec;\n+\n+/// SlotVec is the variant of Vector.\n+/// It guarantees that the index of one item remains unchanged during adding\n+/// or deleting other items of the vector.\n+pub struct SlotVec<T> {\n+    // The slots to store items.\n+    slots: Vec<Option<T>>,\n+    // The number of occupied slots.\n+    // The i-th slot is occupied if `self.slots[i].is_some()`.\n+    num_occupied: usize,\n+}\n+\n+impl<T> SlotVec<T> {\n+    /// New an empty vector.\n+    pub fn new() -> Self {\n+        Self {\n+            slots: Vec::new(),\n+            num_occupied: 0,\n+        }\n+    }\n+\n+    /// Return `true` if the vector contains no items.\n+    pub fn is_empty(&self) -> bool {\n+        self.num_occupied == 0\n+    }\n+\n+    /// Return the number of items.\n+    pub fn len(&self) -> usize {\n+        self.num_occupied\n+    }\n+\n+    /// Return the number of slots.\n+    pub fn slots_len(&self) -> usize {\n+        self.slots.len()\n+    }\n+\n+    /// Get the item at position `idx`.\n+    ///\n+    /// Return `None` if `idx` is out of bounds or the item is not exist.\n+    pub fn get(&self, idx: usize) -> Option<&T> {\n+        if idx >= self.slots.len() {\n+            return None;\n+        }\n+        self.slots[idx].as_ref()\n+    }\n+\n+    /// Put an item into the vector.\n+    /// It may be put into any existing empty slots or the back of the vector.\n+    ///\n+    /// Return the index of the inserted item.\n+    pub fn put(&mut self, entry: T) -> usize {\n+        let idx = if self.num_occupied == self.slots.len() {\n+            self.slots.push(Some(entry));\n+            self.slots.len() - 1\n+        } else {\n+            let idx = self.slots.iter().position(|x| x.is_none()).unwrap();\n+            self.slots[idx] = Some(entry);\n+            idx\n+        };\n+        self.num_occupied += 1;\n+        idx\n+    }\n+\n+    /// Put and return the item at position `idx`.\n+    ///\n+    /// Return `None` if the item is not exist.\n+    pub fn put_at(&mut self, idx: usize, item: T) -> Option<T> {\n+        if idx >= self.slots.len() {\n+            self.slots.resize_with(idx + 1, Default::default);\n+        }\n+        let mut sub_item = Some(item);\n+        core::mem::swap(&mut sub_item, &mut self.slots[idx]);\n+        if sub_item.is_none() {\n+            self.num_occupied += 1;\n+        }\n+        sub_item\n+    }\n+\n+    /// Remove and return the item at position `idx`.\n+    ///\n+    /// Return `None` if `idx` is out of bounds or the item has been removed.\n+    pub fn remove(&mut self, idx: usize) -> Option<T> {\n+        if idx >= self.slots.len() {\n+            return None;\n+        }\n+        let mut del_item = None;\n+        core::mem::swap(&mut del_item, &mut self.slots[idx]);\n+        if del_item.is_some() {\n+            debug_assert!(self.num_occupied > 0);\n+            self.num_occupied -= 1;\n+        }\n+        del_item\n+    }\n+\n+    /// Create an iterator which gives both of the index and the item.\n+    /// The index may not be continuous.\n+    pub fn idxes_and_items(&self) -> impl Iterator<Item = (usize, &'_ T)> {\n+        self.slots\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, x)| x.is_some())\n+            .map(|(idx, x)| (idx, x.as_ref().unwrap()))\n+    }\n+\n+    /// Create an iterator which just gives the item.\n+    pub fn iter(&self) -> impl Iterator<Item = &'_ T> {\n+        self.slots.iter().filter_map(|x| x.as_ref())\n+    }\n+}\n+\n+impl<T: Clone> Clone for SlotVec<T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            slots: self.slots.clone(),\n+            num_occupied: self.num_occupied.clone(),\n+        }\n+    }\n+}\ndiff --git /dev/null b/services/libs/keyable-arc/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/keyable-arc/Cargo.toml\n@@ -0,0 +1,9 @@\n+[package]\n+name = \"keyable-arc\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n",
        "test_patch": "",
        "problem_statement": "Implement the epoll system call\n\n",
        "hints_text": "",
        "created_at": "2023-04-20T03:46:19Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 567,
        "instance_id": "asterinas__asterinas-567",
        "issue_numbers": [
            "555"
        ],
        "base_commit": "5fb8a9f7e558977a8027eec32565a2de6b87636b",
        "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n # Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{error::Error, path::PathBuf};\n \n fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\ndiff --git a/framework/aster-frame/src/arch/mod.rs b/framework/aster-frame/src/arch/mod.rs\n--- a/framework/aster-frame/src/arch/mod.rs\n+++ b/framework/aster-frame/src/arch/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[cfg(target_arch = \"x86_64\")]\n pub mod x86;\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/boot.S b/framework/aster-frame/src/arch/x86/boot/boot.S\n--- a/framework/aster-frame/src/arch/x86/boot/boot.S\n+++ b/framework/aster-frame/src/arch/x86/boot/boot.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The boot header, initial boot setup code, temporary GDT and page tables are\n // in the boot section. The boot section is mapped writable since kernel may\n // modify the initial page table.\ndiff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Linux 64-bit Boot Protocol supporting module.\n //!\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html\n .section \".multiboot_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{string::String, vec::Vec};\n use multiboot2::MemoryAreaType;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot 2 header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot2/html_node/Index.html//Index\n .section \".multiboot2_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{\n     string::{String, ToString},\n     vec::Vec,\ndiff --git a/framework/aster-frame/src/arch/x86/console.rs b/framework/aster-frame/src/arch/x86/console.rs\n--- a/framework/aster-frame/src/arch/x86/console.rs\n+++ b/framework/aster-frame/src/arch/x86/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Write;\n \n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use core::arch::x86_64::{_fxrstor, _fxsave};\ndiff --git a/framework/aster-frame/src/arch/x86/device/cmos.rs b/framework/aster-frame/src/arch/x86/device/cmos.rs\n--- a/framework/aster-frame/src/arch/x86/device/cmos.rs\n+++ b/framework/aster-frame/src/arch/x86/device/cmos.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::{fadt::Fadt, sdt::Signature};\n use x86_64::instructions::port::{ReadOnlyAccess, WriteOnlyAccess};\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/io_port.rs b/framework/aster-frame/src/arch/x86/device/io_port.rs\n--- a/framework/aster-frame/src/arch/x86/device/io_port.rs\n+++ b/framework/aster-frame/src/arch/x86/device/io_port.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n pub use x86_64::instructions::port::{\ndiff --git a/framework/aster-frame/src/arch/x86/device/mod.rs b/framework/aster-frame/src/arch/x86/device/mod.rs\n--- a/framework/aster-frame/src/arch/x86/device/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Device-related APIs.\n //! This module mainly contains the APIs that should exposed to the device driver like PCI, RTC\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\n--- a/framework/aster-frame/src/arch/x86/device/serial.rs\n+++ b/framework/aster-frame/src/arch/x86/device/serial.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A port-mapped UART. Copied from uart_16550.\n \n use crate::arch::x86::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/context_table.rs b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use alloc::collections::BTreeMap;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/fault.rs b/framework/aster-frame/src/arch/x86/iommu/fault.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/fault.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/mod.rs b/framework/aster-frame/src/arch/x86/iommu/mod.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod context_table;\n mod fault;\n mod remapping;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/remapping.rs b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use log::debug;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use pod::Pod;\n \n use crate::{\ndiff --git a/framework/aster-frame/src/arch/x86/irq.rs b/framework/aster-frame/src/arch/x86/irq.rs\n--- a/framework/aster-frame/src/arch/x86/irq.rs\n+++ b/framework/aster-frame/src/arch/x86/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{boxed::Box, fmt::Debug, sync::Arc, vec::Vec};\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, mem::size_of, slice::Iter};\n \n use acpi::{sdt::Signature, AcpiTable};\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod dmar;\n pub mod remapping;\n \ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Remapping structures of DMAR table.\n //! This file defines these structures and provides a \"Debug\" implementation to see the value inside these structures.\n //! Most of the introduction are copied from Intel vt-directed-io-specification.\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::PlatformInfo;\n use alloc::vec;\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::boxed::Box;\n use alloc::sync::Arc;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use x86::msr::{\n     rdmsr, wrmsr, IA32_APIC_BASE, IA32_X2APIC_APICID, IA32_X2APIC_CUR_COUNT, IA32_X2APIC_DIV_CONF,\n     IA32_X2APIC_EOI, IA32_X2APIC_INIT_COUNT, IA32_X2APIC_LVT_TIMER, IA32_X2APIC_SIVR,\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use crate::vm;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/mod.rs b/framework/aster-frame/src/arch/x86/kernel/mod.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) mod acpi;\n pub(super) mod apic;\n pub(super) mod pic;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/pic.rs b/framework/aster-frame/src/arch/x86/kernel/pic.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/pic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/pic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::x86::device::io_port::{IoPort, WriteOnlyAccess};\n use crate::trap::IrqLine;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/tsc.rs b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n--- a/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicU64;\n use x86::cpuid::cpuid;\n \ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{collections::BTreeMap, fmt};\n use pod::Pod;\ndiff --git a/framework/aster-frame/src/arch/x86/mod.rs b/framework/aster-frame/src/arch/x86/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod boot;\n pub mod console;\n pub(crate) mod cpu;\ndiff --git a/framework/aster-frame/src/arch/x86/pci.rs b/framework/aster-frame/src/arch/x86/pci.rs\n--- a/framework/aster-frame/src/arch/x86/pci.rs\n+++ b/framework/aster-frame/src/arch/x86/pci.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus io port\n \n use super::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/qemu.rs b/framework/aster-frame/src/arch/x86/qemu.rs\n--- a/framework/aster-frame/src/arch/x86/qemu.rs\n+++ b/framework/aster-frame/src/arch/x86/qemu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the ability to exit QEMU and return a value as debug result.\n \n /// The exit code of x86 QEMU isa debug device. In `qemu-system-x86_64` the\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use tdx_guest::{\n     tdcall::TdgVeInfo,\n     tdvmcall::{cpuid, hlt, rdmsr, wrmsr, IoSize},\ndiff --git a/framework/aster-frame/src/arch/x86/timer/apic.rs b/framework/aster-frame/src/arch/x86/timer/apic.rs\n--- a/framework/aster-frame/src/arch/x86/timer/apic.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_rdtsc;\n use core::sync::atomic::{AtomicBool, AtomicU64, Ordering};\ndiff --git a/framework/aster-frame/src/arch/x86/timer/hpet.rs b/framework/aster-frame/src/arch/x86/timer/hpet.rs\n--- a/framework/aster-frame/src/arch/x86/timer/hpet.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/hpet.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{trap::IrqLine, vm::paddr_to_vaddr};\n use acpi::{AcpiError, HpetInfo};\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/mod.rs b/framework/aster-frame/src/arch/x86/timer/mod.rs\n--- a/framework/aster-frame/src/arch/x86/timer/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod apic;\n pub mod hpet;\n pub mod pit;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\n--- a/framework/aster-frame/src/arch/x86/timer/pit.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/pit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! used for PIT Timer\n \n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\n--- a/framework/aster-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The module to parse kernel command-line arguments.\n //!\n //! The format of the Asterinas command line string conforms\ndiff --git a/framework/aster-frame/src/boot/memory_region.rs b/framework/aster-frame/src/boot/memory_region.rs\n--- a/framework/aster-frame/src/boot/memory_region.rs\n+++ b/framework/aster-frame/src/boot/memory_region.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Information of memory regions in the boot phase.\n //!\n \ndiff --git a/framework/aster-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\n--- a/framework/aster-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The architecture-independent boot module, which provides a universal interface\n //! from the bootloader to the rest of the framework.\n //!\ndiff --git a/framework/aster-frame/src/bus/mmio/bus.rs b/framework/aster-frame/src/bus/mmio/bus.rs\n--- a/framework/aster-frame/src/bus/mmio/bus.rs\n+++ b/framework/aster-frame/src/bus/mmio/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{collections::VecDeque, fmt::Debug, sync::Arc, vec::Vec};\n use log::{debug, error};\n \ndiff --git a/framework/aster-frame/src/bus/mmio/device.rs b/framework/aster-frame/src/bus/mmio/device.rs\n--- a/framework/aster-frame/src/bus/mmio/device.rs\n+++ b/framework/aster-frame/src/bus/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use int_to_c_enum::TryFromInt;\n use log::info;\n \ndiff --git a/framework/aster-frame/src/bus/mmio/mod.rs b/framework/aster-frame/src/bus/mmio/mod.rs\n--- a/framework/aster-frame/src/bus/mmio/mod.rs\n+++ b/framework/aster-frame/src/bus/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtio over MMIO\n \n pub mod bus;\ndiff --git a/framework/aster-frame/src/bus/mod.rs b/framework/aster-frame/src/bus/mod.rs\n--- a/framework/aster-frame/src/bus/mod.rs\n+++ b/framework/aster-frame/src/bus/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod mmio;\n pub mod pci;\n \ndiff --git a/framework/aster-frame/src/bus/pci/bus.rs b/framework/aster-frame/src/bus/pci/bus.rs\n--- a/framework/aster-frame/src/bus/pci/bus.rs\n+++ b/framework/aster-frame/src/bus/pci/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{collections::VecDeque, sync::Arc, vec::Vec};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/mod.rs b/framework/aster-frame/src/bus/pci/capability/mod.rs\n--- a/framework/aster-frame/src/bus/pci/capability/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use self::{msix::CapabilityMsixData, vendor::CapabilityVndrData};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/msix.rs b/framework/aster-frame/src/bus/pci/capability/msix.rs\n--- a/framework/aster-frame/src/bus/pci/capability/msix.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n \n use crate::{\ndiff --git a/framework/aster-frame/src/bus/pci/capability/vendor.rs b/framework/aster-frame/src/bus/pci/capability/vendor.rs\n--- a/framework/aster-frame/src/bus/pci/capability/vendor.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/vendor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::bus::pci::{common_device::PciCommonDevice, device_info::PciDeviceLocation};\n use crate::{Error, Result};\n \ndiff --git a/framework/aster-frame/src/bus/pci/cfg_space.rs b/framework/aster-frame/src/bus/pci/cfg_space.rs\n--- a/framework/aster-frame/src/bus/pci/cfg_space.rs\n+++ b/framework/aster-frame/src/bus/pci/cfg_space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use bitflags::bitflags;\n \ndiff --git a/framework/aster-frame/src/bus/pci/common_device.rs b/framework/aster-frame/src/bus/pci/common_device.rs\n--- a/framework/aster-frame/src/bus/pci/common_device.rs\n+++ b/framework/aster-frame/src/bus/pci/common_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use super::{\ndiff --git a/framework/aster-frame/src/bus/pci/device_info.rs b/framework/aster-frame/src/bus/pci/device_info.rs\n--- a/framework/aster-frame/src/bus/pci/device_info.rs\n+++ b/framework/aster-frame/src/bus/pci/device_info.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::iter;\n \n use crate::arch::pci::{PCI_ADDRESS_PORT, PCI_DATA_PORT};\ndiff --git a/framework/aster-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\n--- a/framework/aster-frame/src/bus/pci/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus\n //!\n //! Users can implement the bus under the `PciDriver` to the PCI bus to register devices,\ndiff --git a/framework/aster-frame/src/config.rs b/framework/aster-frame/src/config.rs\n--- a/framework/aster-frame/src/config.rs\n+++ b/framework/aster-frame/src/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n use log::Level;\ndiff --git a/framework/aster-frame/src/console.rs b/framework/aster-frame/src/console.rs\n--- a/framework/aster-frame/src/console.rs\n+++ b/framework/aster-frame/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Arguments;\n \n pub fn print(args: Arguments) {\ndiff --git a/framework/aster-frame/src/cpu.rs b/framework/aster-frame/src/cpu.rs\n--- a/framework/aster-frame/src/cpu.rs\n+++ b/framework/aster-frame/src/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use crate::trap::disable_local;\ndiff --git a/framework/aster-frame/src/error.rs b/framework/aster-frame/src/error.rs\n--- a/framework/aster-frame/src/error.rs\n+++ b/framework/aster-frame/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// The error type which is returned from the APIs of this crate.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum Error {\ndiff --git a/framework/aster-frame/src/io_mem.rs b/framework/aster-frame/src/io_mem.rs\n--- a/framework/aster-frame/src/io_mem.rs\n+++ b/framework/aster-frame/src/io_mem.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{mem::size_of, ops::Range};\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{config::DEFAULT_LOG_LEVEL, early_println};\n \n use log::{Metadata, Record};\ndiff --git a/framework/aster-frame/src/panicking.rs b/framework/aster-frame/src/panicking.rs\n--- a/framework/aster-frame/src/panicking.rs\n+++ b/framework/aster-frame/src/panicking.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Panic support.\n \n use alloc::{boxed::Box, string::ToString};\ndiff --git a/framework/aster-frame/src/prelude.rs b/framework/aster-frame/src/prelude.rs\n--- a/framework/aster-frame/src/prelude.rs\n+++ b/framework/aster-frame/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The prelude.\n \n pub type Result<T> = core::result::Result<T, crate::error::Error>;\ndiff --git a/framework/aster-frame/src/sync/atomic_bits.rs b/framework/aster-frame/src/sync/atomic_bits.rs\n--- a/framework/aster-frame/src/sync/atomic_bits.rs\n+++ b/framework/aster-frame/src/sync/atomic_bits.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self};\n use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n \ndiff --git a/framework/aster-frame/src/sync/mod.rs b/framework/aster-frame/src/sync/mod.rs\n--- a/framework/aster-frame/src/sync/mod.rs\n+++ b/framework/aster-frame/src/sync/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod atomic_bits;\n mod mutex;\n // TODO: refactor this rcu implementation\ndiff --git a/framework/aster-frame/src/sync/mutex.rs b/framework/aster-frame/src/sync/mutex.rs\n--- a/framework/aster-frame/src/sync/mutex.rs\n+++ b/framework/aster-frame/src/sync/mutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::WaitQueue;\n use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rcu/mod.rs b/framework/aster-frame/src/sync/rcu/mod.rs\n--- a/framework/aster-frame/src/sync/rcu/mod.rs\n+++ b/framework/aster-frame/src/sync/rcu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read-copy update (RCU).\n \n use core::marker::PhantomData;\ndiff --git a/framework/aster-frame/src/sync/rcu/monitor.rs b/framework/aster-frame/src/sync/rcu/monitor.rs\n--- a/framework/aster-frame/src/sync/rcu/monitor.rs\n+++ b/framework/aster-frame/src/sync/rcu/monitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::collections::VecDeque;\n use core::sync::atomic::{\n     AtomicBool,\ndiff --git a/framework/aster-frame/src/sync/rcu/owner_ptr.rs b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n--- a/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n+++ b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ptr::NonNull;\n \n use crate::prelude::*;\ndiff --git a/framework/aster-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\n--- a/framework/aster-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\n--- a/framework/aster-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/spin.rs b/framework/aster-frame/src/sync/spin.rs\n--- a/framework/aster-frame/src/sync/spin.rs\n+++ b/framework/aster-frame/src/sync/spin.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/wait.rs b/framework/aster-frame/src/sync/wait.rs\n--- a/framework/aster-frame/src/sync/wait.rs\n+++ b/framework/aster-frame/src/sync/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SpinLock;\n use crate::arch::timer::add_timeout_list;\n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/task/mod.rs b/framework/aster-frame/src/task/mod.rs\n--- a/framework/aster-frame/src/task/mod.rs\n+++ b/framework/aster-frame/src/task/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Tasks are the unit of code execution.\n \n mod priority;\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::REAL_TIME_TASK_PRI;\n \n /// The priority of a task.\ndiff --git a/framework/aster-frame/src/task/processor.rs b/framework/aster-frame/src/task/processor.rs\n--- a/framework/aster-frame/src/task/processor.rs\n+++ b/framework/aster-frame/src/task/processor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicUsize;\n \n use crate::cpu_local;\ndiff --git a/framework/aster-frame/src/task/scheduler.rs b/framework/aster-frame/src/task/scheduler.rs\n--- a/framework/aster-frame/src/task/scheduler.rs\n+++ b/framework/aster-frame/src/task/scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::sync::SpinLock;\n use crate::task::Task;\ndiff --git a/framework/aster-frame/src/task/switch.S b/framework/aster-frame/src/task/switch.S\n--- a/framework/aster-frame/src/task/switch.S\n+++ b/framework/aster-frame/src/task/switch.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .text\n .global context_switch\n .code64\ndiff --git a/framework/aster-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\n--- a/framework/aster-frame/src/task/task.rs\n+++ b/framework/aster-frame/src/task/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::{KERNEL_STACK_SIZE, PAGE_SIZE};\n use crate::cpu::CpuSet;\ndiff --git a/framework/aster-frame/src/timer.rs b/framework/aster-frame/src/timer.rs\n--- a/framework/aster-frame/src/timer.rs\n+++ b/framework/aster-frame/src/timer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Timer.\n \n #[cfg(target_arch = \"x86_64\")]\ndiff --git a/framework/aster-frame/src/trap/handler.rs b/framework/aster-frame/src/trap/handler.rs\n--- a/framework/aster-frame/src/trap/handler.rs\n+++ b/framework/aster-frame/src/trap/handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{arch::irq::IRQ_LIST, cpu::CpuException};\n \n #[cfg(feature = \"intel_tdx\")]\ndiff --git a/framework/aster-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\n--- a/framework/aster-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::irq::{self, IrqCallbackHandle, NOT_USING_IRQ};\n use crate::task::{disable_preempt, DisablePreemptGuard};\n use crate::{prelude::*, Error};\ndiff --git a/framework/aster-frame/src/trap/mod.rs b/framework/aster-frame/src/trap/mod.rs\n--- a/framework/aster-frame/src/trap/mod.rs\n+++ b/framework/aster-frame/src/trap/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod handler;\n mod irq;\n \ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! User space.\n \n use crate::cpu::UserContext;\ndiff --git a/framework/aster-frame/src/util/mod.rs b/framework/aster-frame/src/util/mod.rs\n--- a/framework/aster-frame/src/util/mod.rs\n+++ b/framework/aster-frame/src/util/mod.rs\n@@ -1,1 +1,3 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod recycle_allocator;\ndiff --git a/framework/aster-frame/src/util/recycle_allocator.rs b/framework/aster-frame/src/util/recycle_allocator.rs\n--- a/framework/aster-frame/src/util/recycle_allocator.rs\n+++ b/framework/aster-frame/src/util/recycle_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n #[derive(Debug)]\ndiff --git a/framework/aster-frame/src/vm/dma/dma_coherent.rs b/framework/aster-frame/src/vm/dma/dma_coherent.rs\n--- a/framework/aster-frame/src/vm/dma/dma_coherent.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_coherent.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::ops::Deref;\n \ndiff --git a/framework/aster-frame/src/vm/dma/dma_stream.rs b/framework/aster-frame/src/vm/dma/dma_stream.rs\n--- a/framework/aster-frame/src/vm/dma/dma_stream.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_stream.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_mm_clflush;\n use core::ops::Range;\ndiff --git a/framework/aster-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\n--- a/framework/aster-frame/src/vm/dma/mod.rs\n+++ b/framework/aster-frame/src/vm/dma/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod dma_coherent;\n mod dma_stream;\n \ndiff --git a/framework/aster-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\n--- a/framework/aster-frame/src/vm/frame.rs\n+++ b/framework/aster-frame/src/vm/frame.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use core::{\n     iter::Iterator,\ndiff --git a/framework/aster-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\n--- a/framework/aster-frame/src/vm/frame_allocator.rs\n+++ b/framework/aster-frame/src/vm/frame_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n use alloc::vec::Vec;\n use buddy_system_allocator::FrameAllocator;\ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::{KERNEL_HEAP_SIZE, PAGE_SIZE};\n use crate::prelude::*;\n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/vm/io.rs b/framework/aster-frame/src/vm/io.rs\n--- a/framework/aster-frame/src/vm/io.rs\n+++ b/framework/aster-frame/src/vm/io.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::page_table::{PageTable, PageTableConfig, UserMode};\n use crate::{\n     arch::mm::{PageTableEntry, PageTableFlags},\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n \n /// Virtual addresses.\ndiff --git a/framework/aster-frame/src/vm/offset.rs b/framework/aster-frame/src/vm/offset.rs\n--- a/framework/aster-frame/src/vm/offset.rs\n+++ b/framework/aster-frame/src/vm/offset.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Get the offset of a field within a type as a pointer.\n ///\n /// ```rust\ndiff --git a/framework/aster-frame/src/vm/options.rs b/framework/aster-frame/src/vm/options.rs\n--- a/framework/aster-frame/src/vm/options.rs\n+++ b/framework/aster-frame/src/vm/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, Error};\n \n use super::{frame::VmFrameFlags, frame_allocator, VmFrame, VmFrameVec, VmSegment};\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{paddr_to_vaddr, Paddr, Vaddr, VmAllocOptions};\n use crate::{\n     arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry},\ndiff --git a/framework/aster-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\n--- a/framework/aster-frame/src/vm/space.rs\n+++ b/framework/aster-frame/src/vm/space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::PAGE_SIZE;\n use crate::sync::Mutex;\ndiff --git a/framework/libs/linux-bzimage/boot-params/src/lib.rs b/framework/libs/linux-bzimage/boot-params/src/lib.rs\n--- a/framework/libs/linux-bzimage/boot-params/src/lib.rs\n+++ b/framework/libs/linux-bzimage/boot-params/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The definition of Linux Boot Protocol boot_params struct.\n //!\n //! The bootloader will deliver the address of the `BootParams` struct\ndiff --git a/framework/libs/linux-bzimage/builder/src/lib.rs b/framework/libs/linux-bzimage/builder/src/lib.rs\n--- a/framework/libs/linux-bzimage/builder/src/lib.rs\n+++ b/framework/libs/linux-bzimage/builder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage builder.\n //!\n //! This crate is responsible for building the bzImage. It contains methods to build\ndiff --git a/framework/libs/linux-bzimage/builder/src/mapping.rs b/framework/libs/linux-bzimage/builder/src/mapping.rs\n--- a/framework/libs/linux-bzimage/builder/src/mapping.rs\n+++ b/framework/libs/linux-bzimage/builder/src/mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! In the setup, VA - SETUP32_LMA == FileOffset - LEGACY_SETUP_SEC_SIZE.\n //! And the addresses are specified in the ELF file.\n //!\ndiff --git a/framework/libs/linux-bzimage/builder/src/pe_header.rs b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n--- a/framework/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Big zImage PE/COFF header generation.\n //!\n //! The definition of the PE/COFF header is in the Microsoft PE/COFF specification:\ndiff --git a/framework/libs/linux-bzimage/setup/build.rs b/framework/libs/linux-bzimage/setup/build.rs\n--- a/framework/libs/linux-bzimage/setup/build.rs\n+++ b/framework/libs/linux-bzimage/setup/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::path::PathBuf;\n \n fn main() {\ndiff --git a/framework/libs/linux-bzimage/setup/src/console.rs b/framework/libs/linux-bzimage/setup/src/console.rs\n--- a/framework/libs/linux-bzimage/setup/src/console.rs\n+++ b/framework/libs/linux-bzimage/setup/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self, Write};\n \n use uart_16550::SerialPort;\ndiff --git a/framework/libs/linux-bzimage/setup/src/loader.rs b/framework/libs/linux-bzimage/setup/src/loader.rs\n--- a/framework/libs/linux-bzimage/setup/src/loader.rs\n+++ b/framework/libs/linux-bzimage/setup/src/loader.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use xmas_elf::program::{ProgramHeader, SegmentData};\n \n /// Load the kernel ELF payload to memory.\ndiff --git a/framework/libs/linux-bzimage/setup/src/main.rs b/framework/libs/linux-bzimage/setup/src/main.rs\n--- a/framework/libs/linux-bzimage/setup/src/main.rs\n+++ b/framework/libs/linux-bzimage/setup/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage setup binary.\n //!\n //! With respect to the format of the bzImage, we design our bzImage setup in the similar\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use uefi::{\n     data_types::Handle,\n     proto::loaded_image::LoadedImage,\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod efi;\n mod paging;\n mod relocation;\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstraction over the Intel IA32E paging mechanism. And\n //! offers method to create linear page tables.\n //!\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::x86::get_image_loaded_offset;\n \n struct Elf64Rela {\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .section \".setup\", \"ax\"\n .code64\n // start_of_setup32 should be loaded at CODE32_START, which is our base.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_boot_params::BootParams;\n \n use core::arch::{asm, global_asm};\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // 32-bit setup code starts here, and will be loaded at CODE32_START.\n .section \".setup\", \"ax\"\n .code32\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n--- a/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")] {\n         mod amd64_efi;\ndiff --git a/framework/libs/tdx-guest/src/asm/mod.rs b/framework/libs/tdx-guest/src/asm/mod.rs\n--- a/framework/libs/tdx-guest/src/asm/mod.rs\n+++ b/framework/libs/tdx-guest/src/asm/mod.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n use crate::{tdcall::TdcallArgs, tdvmcall::TdVmcallArgs};\n use core::arch::global_asm;\n \ndiff --git a/framework/libs/tdx-guest/src/asm/tdcall.asm b/framework/libs/tdx-guest/src/asm/tdcall.asm\n--- a/framework/libs/tdx-guest/src/asm/tdcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Arguments offsets in TdVmcallArgs struct\ndiff --git a/framework/libs/tdx-guest/src/asm/tdvmcall.asm b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n--- a/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Mask used to control which part of the guest TD GPR and XMM\ndiff --git a/framework/libs/tdx-guest/src/lib.rs b/framework/libs/tdx-guest/src/lib.rs\n--- a/framework/libs/tdx-guest/src/lib.rs\n+++ b/framework/libs/tdx-guest/src/lib.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n #![no_std]\n #![allow(dead_code)]\n #![allow(unused_variables)]\ndiff --git a/framework/libs/tdx-guest/src/tdcall.rs b/framework/libs/tdx-guest/src/tdcall.rs\n--- a/framework/libs/tdx-guest/src/tdcall.rs\n+++ b/framework/libs/tdx-guest/src/tdcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDCALL instruction causes a VM exit to the Intel TDX module.\n //! It is used to call guest-side Intel TDX functions. For more information about\n //! TDCALL, please refer to the [Intel\u00ae TDX Module v1.5 ABI Specification](https://cdrdv2.intel.com/v1/dl/getContent/733579)\ndiff --git a/framework/libs/tdx-guest/src/tdvmcall.rs b/framework/libs/tdx-guest/src/tdvmcall.rs\n--- a/framework/libs/tdx-guest/src/tdvmcall.rs\n+++ b/framework/libs/tdx-guest/src/tdvmcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDVMCALL helps invoke services from the host VMM. From the perspective of the host VMM, the TDVMCALL is a trap-like, VM exit into\n //! the host VMM, reported via the SEAMRET instruction flow.\n //! By design, after the SEAMRET, the host VMM services the request specified in the parameters\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![no_main]\n // The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\ndiff --git a/regression/Makefile b/regression/Makefile\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n BUILD_DIR := $(CUR_DIR)/build\ndiff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MAKEFLAGS += --no-builtin-rules # Prevent the implicit rules from compiling \".c\" or \".s\" files automatically.\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\ndiff --git a/regression/apps/execve/execve.c b/regression/apps/execve/execve.c\n--- a/regression/apps/execve/execve.c\n+++ b/regression/apps/execve/execve.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/execve/hello.c b/regression/apps/execve/hello.c\n--- a/regression/apps/execve/hello.c\n+++ b/regression/apps/execve/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main(int argc, char *argv[], char *envp[]) {\ndiff --git a/regression/apps/fork/fork.s b/regression/apps/fork/fork.s\n--- a/regression/apps/fork/fork.s\n+++ b/regression/apps/fork/fork.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/fork_c/fork.c b/regression/apps/fork_c/fork.c\n--- a/regression/apps/fork_c/fork.c\n+++ b/regression/apps/fork_c/fork.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/hello_c/hello.c b/regression/apps/hello_c/hello.c\n--- a/regression/apps/hello_c/hello.c\n+++ b/regression/apps/hello_c/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_pie/hello.c b/regression/apps/hello_pie/hello.c\n--- a/regression/apps/hello_pie/hello.c\n+++ b/regression/apps/hello_pie/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_world/hello_world.s b/regression/apps/hello_world/hello_world.s\n--- a/regression/apps/hello_world/hello_world.s\n+++ b/regression/apps/hello_world/hello_world.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/network/listen_backlog.c b/regression/apps/network/listen_backlog.c\n--- a/regression/apps/network/listen_backlog.c\n+++ b/regression/apps/network/listen_backlog.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/socketpair.c b/regression/apps/network/socketpair.c\n--- a/regression/apps/network/socketpair.c\n+++ b/regression/apps/network/socketpair.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <sys/socket.h>\n #include <stdlib.h>\ndiff --git a/regression/apps/network/sockoption.c b/regression/apps/network/sockoption.c\n--- a/regression/apps/network/sockoption.c\n+++ b/regression/apps/network/sockoption.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <sys/socket.h>\ndiff --git a/regression/apps/network/tcp_client.c b/regression/apps/network/tcp_client.c\n--- a/regression/apps/network/tcp_client.c\n+++ b/regression/apps/network/tcp_client.c\n@@ -1,51 +1,44 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Client side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n #include <stdio.h>\n+#include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-  \n-int main(int argc, char const* argv[])\n-{\n-    int status, valread, client_fd;\n+\n+int main() {\n+    int sock = 0, valread;\n     struct sockaddr_in serv_addr;\n-    char* hello = \"Hello from client\";\n-    char buffer[1024] = { 0 };\n-    if ((client_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char *hello = \"Hello from client\";\n+    char buffer[1024] = {0};\n+\n+    // Create socket\n+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n         printf(\"\\n Socket creation error \\n\");\n         return -1;\n     }\n-  \n+\n     serv_addr.sin_family = AF_INET;\n     serv_addr.sin_port = htons(PORT);\n-  \n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(serv_addr.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    if ((status\n-         = connect(client_fd, (struct sockaddr*)&serv_addr,\n-                   sizeof(serv_addr)))\n-        < 0) {\n-        printf(\"\\nConnection Failed \\n\");\n+\n+    // Connect to the server\n+    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n+        printf(\"\\n Connection Failed \\n\");\n         return -1;\n     }\n-    send(client_fd, hello, strlen(hello), 0);\n+\n+    // Send message to the server and receive the reply\n+    send(sock, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-    valread = read(client_fd, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n-  \n-    // closing the connected socket\n-    close(client_fd);\n+    valread = read(sock, buffer, 1024);\n+    printf(\"Server: %s\\n\", buffer);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/tcp_server.c b/regression/apps/network/tcp_server.c\n--- a/regression/apps/network/tcp_server.c\n+++ b/regression/apps/network/tcp_server.c\n@@ -1,75 +1,65 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Server side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n-#include <netinet/in.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-int main(int argc, char const* argv[])\n-{\n+\n+int main() {\n     int server_fd, new_socket, valread;\n     struct sockaddr_in address;\n     int opt = 1;\n     int addrlen = sizeof(address);\n-    char buffer[1024] = { 0 };\n-    char* hello = \"Hello from server\";\n-  \n-    // Creating socket file descriptor\n-    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char buffer[1024] = {0};\n+    char *hello = \"Hello from server\";\n+\n+    // Create socket\n+    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n         perror(\"socket failed\");\n         exit(EXIT_FAILURE);\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (setsockopt(server_fd, SOL_SOCKET,\n-                   SO_REUSEADDR | SO_REUSEPORT, &opt,\n-                   sizeof(opt))) {\n-        perror(\"setsockopt\");\n+\n+    // Set socket options\n+    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n+        perror(\"setsockopt failed\");\n         exit(EXIT_FAILURE);\n     }\n+    \n     address.sin_family = AF_INET;\n+    address.sin_addr.s_addr = INADDR_ANY;\n     address.sin_port = htons(PORT);\n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &address.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(address.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (bind(server_fd, (struct sockaddr*)&address,\n-             sizeof(address))\n-        < 0) {\n+\n+    // Bind the socket to specified IP and port\n+    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n         perror(\"bind failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Listen for connections\n     if (listen(server_fd, 3) < 0) {\n-        perror(\"listen\");\n+        perror(\"listen failed\");\n         exit(EXIT_FAILURE);\n     }\n-    if ((new_socket\n-         = accept(server_fd, (struct sockaddr*)&address,\n-                  (socklen_t*)&addrlen))\n-        < 0) {\n-        perror(\"accept\");\n+\n+    // Accept the connection\n+    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {\n+        perror(\"accept failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Read the message from the client and reply\n     valread = read(new_socket, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n+    printf(\"Client: %s\\n\", buffer);\n     send(new_socket, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-  \n-    // closing the connected socket\n-    close(new_socket);\n-    // closing the listening socket\n-    shutdown(server_fd, SHUT_RDWR);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/udp_client.c b/regression/apps/network/udp_client.c\n--- a/regression/apps/network/udp_client.c\n+++ b/regression/apps/network/udp_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/udp_server.c b/regression/apps/network/udp_server.c\n--- a/regression/apps/network/udp_server.c\n+++ b/regression/apps/network/udp_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_client.c b/regression/apps/network/unix_client.c\n--- a/regression/apps/network/unix_client.c\n+++ b/regression/apps/network/unix_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_server.c b/regression/apps/network/unix_server.c\n--- a/regression/apps/network/unix_server.c\n+++ b/regression/apps/network/unix_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/pty/open_pty.c b/regression/apps/pty/open_pty.c\n--- a/regression/apps/pty/open_pty.c\n+++ b/regression/apps/pty/open_pty.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <unistd.h>\ndiff --git a/regression/apps/scripts/Makefile b/regression/apps/scripts/Makefile\n--- a/regression/apps/scripts/Makefile\n+++ b/regression/apps/scripts/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .PHONY: all\n \n all: ./*.sh\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n NETTEST_DIR=/regression/network\ndiff --git a/regression/apps/scripts/process.sh b/regression/apps/scripts/process.sh\n--- a/regression/apps/scripts/process.sh\n+++ b/regression/apps/scripts/process.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=/regression\ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n set -x\n \ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the utility to run the GDB scripts for the runner.\n \n use crate::qemu_grub_efi;\ndiff --git a/runner/src/machine/microvm.rs b/runner/src/machine/microvm.rs\n--- a/runner/src/machine/microvm.rs\n+++ b/runner/src/machine/microvm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{\n     fs::OpenOptions,\n     io::{Seek, SeekFrom, Write},\ndiff --git a/runner/src/machine/mod.rs b/runner/src/machine/mod.rs\n--- a/runner/src/machine/mod.rs\n+++ b/runner/src/machine/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod microvm;\n pub mod qemu_grub_efi;\ndiff --git a/runner/src/machine/qemu_grub_efi.rs b/runner/src/machine/qemu_grub_efi.rs\n--- a/runner/src/machine/qemu_grub_efi.rs\n+++ b/runner/src/machine/qemu_grub_efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_bzimage_builder::{make_bzimage, BzImageType};\n \n use std::{\ndiff --git a/services/comps/block/src/bio.rs b/services/comps/block/src/bio.rs\n--- a/services/comps/block/src/bio.rs\n+++ b/services/comps/block/src/bio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{id::Sid, BlockDevice};\ndiff --git a/services/comps/block/src/id.rs b/services/comps/block/src/id.rs\n--- a/services/comps/block/src/id.rs\n+++ b/services/comps/block/src/id.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     iter::Step,\n     ops::{Add, Sub},\ndiff --git a/services/comps/block/src/impl_block_device.rs b/services/comps/block/src/impl_block_device.rs\n--- a/services/comps/block/src/impl_block_device.rs\n+++ b/services/comps/block/src/impl_block_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The block devices of Asterinas.\n //\uff01\n //\uff01This crate provides a number of base components for block devices, including\ndiff --git a/services/comps/block/src/prelude.rs b/services/comps/block/src/prelude.rs\n--- a/services/comps/block/src/prelude.rs\n+++ b/services/comps/block/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(crate) use alloc::collections::{BTreeMap, VecDeque};\n pub(crate) use alloc::string::String;\n pub(crate) use alloc::sync::Arc;\ndiff --git a/services/comps/block/src/request_queue.rs b/services/comps/block/src/request_queue.rs\n--- a/services/comps/block/src/request_queue.rs\n+++ b/services/comps/block/src/request_queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/network/src/buffer.rs b/services/comps/network/src/buffer.rs\n--- a/services/comps/network/src/buffer.rs\n+++ b/services/comps/network/src/buffer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use align_ext::AlignExt;\ndiff --git a/services/comps/network/src/driver.rs b/services/comps/network/src/driver.rs\n--- a/services/comps/network/src/driver.rs\n+++ b/services/comps/network/src/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use smoltcp::{phy, time::Instant};\n \ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(trait_alias)]\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstractions for hardware-assisted timing mechanisms, encapsulated by the `ClockSource` struct.\n //! A `ClockSource` can be constructed from any counter with a stable frequency, enabling precise time measurements to be taken\n //! by retrieving instances of `Instant`.\ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provide a instance of `ClockSource` based on TSC.\n //!\n //! Use `init` to initialize this module.\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     fmt::Debug,\n     hint::spin_loop,\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n \n use aster_frame::io_mem::IoMem;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/console/mod.rs b/services/comps/virtio/src/device/console/mod.rs\n--- a/services/comps/virtio/src/device/console/mod.rs\n+++ b/services/comps/virtio/src/device/console/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n \ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use crate::{device::VirtioDeviceError, queue::VirtQueue, transport::VirtioTransport};\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n // Modified from input.rs in virtio-drivers project\n //\n // MIT License\ndiff --git a/services/comps/virtio/src/device/mod.rs b/services/comps/virtio/src/device/mod.rs\n--- a/services/comps/virtio/src/device/mod.rs\n+++ b/services/comps/virtio/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::queue::QueueError;\n use int_to_c_enum::TryFromInt;\n \ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/network/header.rs b/services/comps/virtio/src/device/network/header.rs\n--- a/services/comps/virtio/src/device/network/header.rs\n+++ b/services/comps/virtio/src/device/network/header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/network/mod.rs b/services/comps/virtio/src/device/network/mod.rs\n--- a/services/comps/virtio/src/device/network/mod.rs\n+++ b/services/comps/virtio/src/device/network/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n pub mod header;\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtqueue\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{boxed::Box, sync::Arc};\n use aster_frame::{\n     bus::mmio::{\ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/mmio/layout.rs b/services/comps/virtio/src/transport/mmio/layout.rs\n--- a/services/comps/virtio/src/transport/mmio/layout.rs\n+++ b/services/comps/virtio/src/transport/mmio/layout.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     bus::{\n         pci::{\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod capability;\n pub mod common_cfg;\n pub mod device;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \ndiff --git a/services/libs/aster-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\n--- a/services/libs/aster-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\ndiff --git a/services/libs/aster-rights-proc/src/require_attr.rs b/services/libs/aster-rights-proc/src/require_attr.rs\n--- a/services/libs/aster-rights-proc/src/require_attr.rs\n+++ b/services/libs/aster-rights-proc/src/require_attr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! expand the require macro\n \n use proc_macro2::{Ident, TokenStream};\ndiff --git a/services/libs/aster-rights-proc/src/require_item.rs b/services/libs/aster-rights-proc/src/require_item.rs\n--- a/services/libs/aster-rights-proc/src/require_item.rs\n+++ b/services/libs/aster-rights-proc/src/require_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use syn::{parse::Parse, ItemFn, ItemImpl, Token};\n \n pub enum RequireItem {\ndiff --git a/services/libs/aster-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\n--- a/services/libs/aster-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n \n use core::ops::{Deref, DerefMut};\ndiff --git a/services/libs/aster-std/src/console.rs b/services/libs/aster-std/src/console.rs\n--- a/services/libs/aster-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! `print` and `println` macros\n //!\n //! FIXME: It will print to all `virtio-console` devices, which is not a good choice.\ndiff --git a/services/libs/aster-std/src/device/mod.rs b/services/libs/aster-std/src/device/mod.rs\n--- a/services/libs/aster-std/src/device/mod.rs\n+++ b/services/libs/aster-std/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod null;\n mod pty;\n mod random;\ndiff --git a/services/libs/aster-std/src/device/null.rs b/services/libs/aster-std/src/device/null.rs\n--- a/services/libs/aster-std/src/device/null.rs\n+++ b/services/libs/aster-std/src/device/null.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/pty/mod.rs b/services/libs/aster-std/src/device/pty/mod.rs\n--- a/services/libs/aster-std/src/device/pty/mod.rs\n+++ b/services/libs/aster-std/src/device/pty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/device/pty/pty.rs b/services/libs/aster-std/src/device/pty/pty.rs\n--- a/services/libs/aster-std/src/device/pty/pty.rs\n+++ b/services/libs/aster-std/src/device/pty/pty.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \ndiff --git a/services/libs/aster-std/src/device/random.rs b/services/libs/aster-std/src/device/random.rs\n--- a/services/libs/aster-std/src/device/random.rs\n+++ b/services/libs/aster-std/src/device/random.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tdxguest/mod.rs b/services/libs/aster-std/src/device/tdxguest/mod.rs\n--- a/services/libs/aster-std/src/device/tdxguest/mod.rs\n+++ b/services/libs/aster-std/src/device/tdxguest/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::error::Error;\n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/device/tty/device.rs b/services/libs/aster-std/src/device/tty/device.rs\n--- a/services/libs/aster-std/src/device/tty/device.rs\n+++ b/services/libs/aster-std/src/device/tty/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\n--- a/services/libs/aster-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \ndiff --git a/services/libs/aster-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\n--- a/services/libs/aster-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\ndiff --git a/services/libs/aster-std/src/device/tty/mod.rs b/services/libs/aster-std/src/device/tty/mod.rs\n--- a/services/libs/aster-std/src/device/tty/mod.rs\n+++ b/services/libs/aster-std/src/device/tty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use spin::Once;\n \n use self::driver::TtyDriver;\ndiff --git a/services/libs/aster-std/src/device/tty/termio.rs b/services/libs/aster-std/src/device/tty/termio.rs\n--- a/services/libs/aster-std/src/device/tty/termio.rs\n+++ b/services/libs/aster-std/src/device/tty/termio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/device/urandom.rs b/services/libs/aster-std/src/device/urandom.rs\n--- a/services/libs/aster-std/src/device/urandom.rs\n+++ b/services/libs/aster-std/src/device/urandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/zero.rs b/services/libs/aster-std/src/device/zero.rs\n--- a/services/libs/aster-std/src/device/zero.rs\n+++ b/services/libs/aster-std/src/device/zero.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/driver/mod.rs b/services/libs/aster-std/src/driver/mod.rs\n--- a/services/libs/aster-std/src/driver/mod.rs\n+++ b/services/libs/aster-std/src/driver/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use log::info;\n \n pub fn init() {\ndiff --git a/services/libs/aster-std/src/error.rs b/services/libs/aster-std/src/error.rs\n--- a/services/libs/aster-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -1,4 +1,6 @@\n-/// Errno. Copied from Occlum\n+// SPDX-License-Identifier: MPL-2.0\n+\n+/// Error number.\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Errno {\ndiff --git a/services/libs/aster-std/src/events/events.rs b/services/libs/aster-std/src/events/events.rs\n--- a/services/libs/aster-std/src/events/events.rs\n+++ b/services/libs/aster-std/src/events/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A trait to represent any events.\n ///\n /// # The unit event\ndiff --git a/services/libs/aster-std/src/events/io_events.rs b/services/libs/aster-std/src/events/io_events.rs\n--- a/services/libs/aster-std/src/events/io_events.rs\n+++ b/services/libs/aster-std/src/events/io_events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Events, EventsFilter};\n \n crate::bitflags! {\ndiff --git a/services/libs/aster-std/src/events/mod.rs b/services/libs/aster-std/src/events/mod.rs\n--- a/services/libs/aster-std/src/events/mod.rs\n+++ b/services/libs/aster-std/src/events/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[allow(clippy::module_inception)]\n mod events;\n mod io_events;\ndiff --git a/services/libs/aster-std/src/events/observer.rs b/services/libs/aster-std/src/events/observer.rs\n--- a/services/libs/aster-std/src/events/observer.rs\n+++ b/services/libs/aster-std/src/events/observer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Events;\n \n /// An observer for events.\ndiff --git a/services/libs/aster-std/src/events/subject.rs b/services/libs/aster-std/src/events/subject.rs\n--- a/services/libs/aster-std/src/events/subject.rs\n+++ b/services/libs/aster-std/src/events/subject.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use core::sync::atomic::{AtomicUsize, Ordering};\ndiff --git a/services/libs/aster-std/src/fs/device.rs b/services/libs/aster-std/src/fs/device.rs\n--- a/services/libs/aster-std/src/fs/device.rs\n+++ b/services/libs/aster-std/src/fs/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n use crate::fs::utils::{InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\n--- a/services/libs/aster-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/devpts/ptmx.rs b/services/libs/aster-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/aster-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/aster-std/src/fs/devpts/ptmx.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/fs/devpts/slave.rs b/services/libs/aster-std/src/fs/devpts/slave.rs\n--- a/services/libs/aster-std/src/fs/devpts/slave.rs\n+++ b/services/libs/aster-std/src/fs/devpts/slave.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/epoll/epoll_file.rs b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n--- a/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n+++ b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::{FdEvents, FileDescripter};\ndiff --git a/services/libs/aster-std/src/fs/epoll/mod.rs b/services/libs/aster-std/src/fs/epoll/mod.rs\n--- a/services/libs/aster-std/src/fs/epoll/mod.rs\n+++ b/services/libs/aster-std/src/fs/epoll/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::file_table::FileDescripter;\n use crate::events::IoEvents;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/block_group.rs b/services/libs/aster-std/src/fs/ext2/block_group.rs\n--- a/services/libs/aster-std/src/fs/ext2/block_group.rs\n+++ b/services/libs/aster-std/src/fs/ext2/block_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::fs::Ext2;\n use super::inode::{Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n--- a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n+++ b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n \n /// A blocks hole descriptor implemented by the `BitVec`.\ndiff --git a/services/libs/aster-std/src/fs/ext2/dir.rs b/services/libs/aster-std/src/fs/ext2/dir.rs\n--- a/services/libs/aster-std/src/fs/ext2/dir.rs\n+++ b/services/libs/aster-std/src/fs/ext2/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::{FileType, MAX_FNAME_LEN};\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/fs.rs b/services/libs/aster-std/src/fs/ext2/fs.rs\n--- a/services/libs/aster-std/src/fs/ext2/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::block_group::{BlockGroup, RawGroupDescriptor};\n use super::inode::{FilePerm, FileType, Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::ext2::{utils::Dirty, Ext2, SuperBlock as Ext2SuperBlock, MAGIC_NUM as EXT2_MAGIC};\n use crate::fs::utils::{FileSystem, FsFlags, Inode, SuperBlock, NAME_MAX};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::fs::ext2::{FilePerm, FileType, Inode as Ext2Inode};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod fs;\n mod inode;\ndiff --git a/services/libs/aster-std/src/fs/ext2/inode.rs b/services/libs/aster-std/src/fs/ext2/inode.rs\n--- a/services/libs/aster-std/src/fs/ext2/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::blocks_hole::BlocksHoleDesc;\n use super::dir::{DirEntry, DirEntryReader, DirEntryWriter};\n use super::fs::Ext2;\ndiff --git a/services/libs/aster-std/src/fs/ext2/mod.rs b/services/libs/aster-std/src/fs/ext2/mod.rs\n--- a/services/libs/aster-std/src/fs/ext2/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust Ext2 filesystem.\n //!\n //! The Second Extended File System(Ext2) is a major rewrite of the Ext filesystem.\ndiff --git a/services/libs/aster-std/src/fs/ext2/prelude.rs b/services/libs/aster-std/src/fs/ext2/prelude.rs\n--- a/services/libs/aster-std/src/fs/ext2/prelude.rs\n+++ b/services/libs/aster-std/src/fs/ext2/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) use super::utils::{Dirty, IsPowerOf};\n \n pub(super) use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/super_block.rs b/services/libs/aster-std/src/fs/ext2/super_block.rs\n--- a/services/libs/aster-std/src/fs/ext2/super_block.rs\n+++ b/services/libs/aster-std/src/fs/ext2/super_block.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::RawInode;\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/utils.rs b/services/libs/aster-std/src/fs/ext2/utils.rs\n--- a/services/libs/aster-std/src/fs/ext2/utils.rs\n+++ b/services/libs/aster-std/src/fs/ext2/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::prelude::*;\n \n use core::ops::MulAssign;\ndiff --git a/services/libs/aster-std/src/fs/file_handle.rs b/services/libs/aster-std/src/fs/file_handle.rs\n--- a/services/libs/aster-std/src/fs/file_handle.rs\n+++ b/services/libs/aster-std/src/fs/file_handle.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\n--- a/services/libs/aster-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/fs_resolver.rs b/services/libs/aster-std/src/fs/fs_resolver.rs\n--- a/services/libs/aster-std/src/fs/fs_resolver.rs\n+++ b/services/libs/aster-std/src/fs/fs_resolver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use alloc::str;\n \ndiff --git a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend Inode-backed File Handle\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n--- a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::{Read, TRightSet, TRights, Write};\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-std/src/fs/mod.rs b/services/libs/aster-std/src/fs/mod.rs\n--- a/services/libs/aster-std/src/fs/mod.rs\n+++ b/services/libs/aster-std/src/fs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n pub mod devpts;\n pub mod epoll;\ndiff --git a/services/libs/aster-std/src/fs/pipe.rs b/services/libs/aster-std/src/fs/pipe.rs\n--- a/services/libs/aster-std/src/fs/pipe.rs\n+++ b/services/libs/aster-std/src/fs/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/procfs/mod.rs b/services/libs/aster-std/src/fs/procfs/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::events::Observer;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/comm.rs b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/comm`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/exe.rs b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/exe`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/fd.rs b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/mod.rs b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::fs::file_table::FdEvents;\n use crate::fs::utils::{DirEntryVecExt, Inode};\ndiff --git a/services/libs/aster-std/src/fs/procfs/self_.rs b/services/libs/aster-std/src/fs/procfs/self_.rs\n--- a/services/libs/aster-std/src/fs/procfs/self_.rs\n+++ b/services/libs/aster-std/src/fs/procfs/self_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/self`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/builder.rs b/services/libs/aster-std/src/fs/procfs/template/builder.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/builder.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::{FileSystem, Inode};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/mod.rs b/services/libs/aster-std/src/fs/procfs/template/mod.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, InodeMode, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n--- a/services/libs/aster-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\n--- a/services/libs/aster-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::sync::RwLockWriteGuard;\n use aster_frame::vm::VmFrame;\n use aster_frame::vm::VmIo;\ndiff --git a/services/libs/aster-std/src/fs/ramfs/mod.rs b/services/libs/aster-std/src/fs/ramfs/mod.rs\n--- a/services/libs/aster-std/src/fs/ramfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Ramfs based on PageCache\n \n pub use fs::RamFS;\ndiff --git a/services/libs/aster-std/src/fs/rootfs.rs b/services/libs/aster-std/src/fs/rootfs.rs\n--- a/services/libs/aster-std/src/fs/rootfs.rs\n+++ b/services/libs/aster-std/src/fs/rootfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::fs_resolver::{FsPath, FsResolver};\ndiff --git a/services/libs/aster-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\n--- a/services/libs/aster-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::Rights;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\n--- a/services/libs/aster-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\ndiff --git a/services/libs/aster-std/src/fs/utils/creation_flags.rs b/services/libs/aster-std/src/fs/utils/creation_flags.rs\n--- a/services/libs/aster-std/src/fs/utils/creation_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/creation_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/fs/utils/dentry.rs b/services/libs/aster-std/src/fs/utils/dentry.rs\n--- a/services/libs/aster-std/src/fs/utils/dentry.rs\n+++ b/services/libs/aster-std/src/fs/utils/dentry.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n--- a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n+++ b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::InodeType;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n--- a/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n--- a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n+++ b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A mask for the file mode of a newly-created file or directory.\n ///\n /// This mask is always a subset of `0o777`.\ndiff --git a/services/libs/aster-std/src/fs/utils/fs.rs b/services/libs/aster-std/src/fs/utils/fs.rs\n--- a/services/libs/aster-std/src/fs/utils/fs.rs\n+++ b/services/libs/aster-std/src/fs/utils/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\n--- a/services/libs/aster-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\ndiff --git a/services/libs/aster-std/src/fs/utils/ioctl.rs b/services/libs/aster-std/src/fs/utils/ioctl.rs\n--- a/services/libs/aster-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/aster-std/src/fs/utils/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[repr(u32)]\ndiff --git a/services/libs/aster-std/src/fs/utils/mod.rs b/services/libs/aster-std/src/fs/utils/mod.rs\n--- a/services/libs/aster-std/src/fs/utils/mod.rs\n+++ b/services/libs/aster-std/src/fs/utils/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! VFS components\n \n pub use access_mode::AccessMode;\ndiff --git a/services/libs/aster-std/src/fs/utils/mount.rs b/services/libs/aster-std/src/fs/utils/mount.rs\n--- a/services/libs/aster-std/src/fs/utils/mount.rs\n+++ b/services/libs/aster-std/src/fs/utils/mount.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Dentry, DentryKey, FileSystem, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\n--- a/services/libs/aster-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n use aster_rights::Full;\ndiff --git a/services/libs/aster-std/src/fs/utils/status_flags.rs b/services/libs/aster-std/src/fs/utils/status_flags.rs\n--- a/services/libs/aster-std/src/fs/utils/status_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/status_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\n--- a/services/libs/aster-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-std/src/net/iface/any_socket.rs b/services/libs/aster-std/src/net/iface/any_socket.rs\n--- a/services/libs/aster-std/src/net/iface/any_socket.rs\n+++ b/services/libs/aster-std/src/net/iface/any_socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/net/iface/common.rs b/services/libs/aster-std/src/net/iface/common.rs\n--- a/services/libs/aster-std/src/net/iface/common.rs\n+++ b/services/libs/aster-std/src/net/iface/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU64, Ordering};\n \n use super::Ipv4Address;\ndiff --git a/services/libs/aster-std/src/net/iface/loopback.rs b/services/libs/aster-std/src/net/iface/loopback.rs\n--- a/services/libs/aster-std/src/net/iface/loopback.rs\n+++ b/services/libs/aster-std/src/net/iface/loopback.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{IpAddress, Ipv4Address};\n use crate::prelude::*;\n use smoltcp::{\ndiff --git a/services/libs/aster-std/src/net/iface/mod.rs b/services/libs/aster-std/src/net/iface/mod.rs\n--- a/services/libs/aster-std/src/net/iface/mod.rs\n+++ b/services/libs/aster-std/src/net/iface/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use self::common::IfaceCommon;\n use crate::prelude::*;\n use smoltcp::iface::SocketSet;\ndiff --git a/services/libs/aster-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\n--- a/services/libs/aster-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\ndiff --git a/services/libs/aster-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\n--- a/services/libs/aster-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\n--- a/services/libs/aster-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::SpinLock;\n use aster_network::AnyNetworkDevice;\ndiff --git a/services/libs/aster-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\n--- a/services/libs/aster-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     net::iface::{Iface, IfaceLoopback, IfaceVirtio},\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/net/socket/ip/always_some.rs b/services/libs/aster-std/src/net/socket/ip/always_some.rs\n--- a/services/libs/aster-std/src/net/socket/ip/always_some.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/always_some.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use core::ops::{Deref, DerefMut};\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/common.rs b/services/libs/aster-std/src/net/socket/ip/common.rs\n--- a/services/libs/aster-std/src/net/socket/ip/common.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::BindPortConfig;\n use crate::net::iface::Iface;\n use crate::net::iface::{AnyBoundSocket, AnyUnboundSocket};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/mod.rs b/services/libs/aster-std/src/net/socket/ip/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod always_some;\n mod common;\n mod datagram;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use alloc::sync::Arc;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/init.rs b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::StatusFlags;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/options.rs b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n \n use super::CongestionControl;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/util.rs b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n--- a/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[derive(Debug, Clone, Copy, CopyGetters, Setters)]\ndiff --git a/services/libs/aster-std/src/net/socket/mod.rs b/services/libs/aster-std/src/net/socket/mod.rs\n--- a/services/libs/aster-std/src/net/socket/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{fs::file_handle::FileLike, prelude::*};\n \n use self::options::SocketOption;\ndiff --git a/services/libs/aster-std/src/net/socket/options/macros.rs b/services/libs/aster-std/src/net/socket/options/macros.rs\n--- a/services/libs/aster-std/src/net/socket/options/macros.rs\n+++ b/services/libs/aster-std/src/net/socket/options/macros.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[macro_export]\n macro_rules! impl_socket_options {\n     ($(\ndiff --git a/services/libs/aster-std/src/net/socket/options/mod.rs b/services/libs/aster-std/src/net/socket/options/mod.rs\n--- a/services/libs/aster-std/src/net/socket/options/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n use crate::prelude::*;\n mod macros;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/addr.rs b/services/libs/aster-std/src/net/socket/unix/addr.rs\n--- a/services/libs/aster-std/src/net/socket/unix/addr.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::Dentry;\n use crate::net::socket::util::socket_addr::SocketAddr;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/mod.rs b/services/libs/aster-std/src/net/socket/unix/mod.rs\n--- a/services/libs/aster-std/src/net/socket/unix/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod stream;\n \ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::endpoint::Endpoint;\n use crate::events::IoEvents;\n use crate::net::socket::{unix::addr::UnixSocketAddrBound, SockShutdownCmd};\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::process::signal::Poller;\n use crate::{\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/init.rs b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{connected::Connected, endpoint::Endpoint, UnixStreamSocket};\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod connected;\n mod endpoint;\n mod init;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n--- a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::fs_resolver::FsPath;\ndiff --git a/services/libs/aster-std/src/net/socket/util/mod.rs b/services/libs/aster-std/src/net/socket/util/mod.rs\n--- a/services/libs/aster-std/src/net/socket/util/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod options;\n pub mod send_recv_flags;\n pub mod shutdown_cmd;\ndiff --git a/services/libs/aster-std/src/net/socket/util/options.rs b/services/libs/aster-std/src/net/socket/util/options.rs\n--- a/services/libs/aster-std/src/net/socket/util/options.rs\n+++ b/services/libs/aster-std/src/net/socket/util/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::net::iface::{RECV_BUF_LEN, SEND_BUF_LEN};\ndiff --git a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n--- a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n+++ b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n--- a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n+++ b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Shutdown types\ndiff --git a/services/libs/aster-std/src/net/socket/util/socket_addr.rs b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n--- a/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n+++ b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::{IpAddress, Ipv4Address};\n use crate::net::iface::{IpEndpoint, IpListenEndpoint};\n use crate::net::socket::unix::UnixSocketAddr;\ndiff --git a/services/libs/aster-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\n--- a/services/libs/aster-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n pub(crate) use alloc::boxed::Box;\ndiff --git a/services/libs/aster-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\n--- a/services/libs/aster-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n use super::process_vm::ProcessVm;\n use super::signal::sig_disposition::SigDispositions;\ndiff --git a/services/libs/aster-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\n--- a/services/libs/aster-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\ndiff --git a/services/libs/aster-std/src/process/credentials/group.rs b/services/libs/aster-std/src/process/credentials/group.rs\n--- a/services/libs/aster-std/src/process/credentials/group.rs\n+++ b/services/libs/aster-std/src/process/credentials/group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\n--- a/services/libs/aster-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod credentials_;\n mod group;\n mod static_cap;\ndiff --git a/services/libs/aster-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\n--- a/services/libs/aster-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/user.rs b/services/libs/aster-std/src/process/credentials/user.rs\n--- a/services/libs/aster-std/src/process/credentials/user.rs\n+++ b/services/libs/aster-std/src/process/credentials/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/exit.rs b/services/libs/aster-std/src/process/exit.rs\n--- a/services/libs/aster-std/src/process/exit.rs\n+++ b/services/libs/aster-std/src/process/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::signals::kernel::KernelSignal;\n use crate::{prelude::*, process::signal::constants::SIGCHLD};\ndiff --git a/services/libs/aster-std/src/process/kill.rs b/services/libs/aster-std/src/process/kill.rs\n--- a/services/libs/aster-std/src/process/kill.rs\n+++ b/services/libs/aster-std/src/process/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::signal::signals::user::UserSignal;\n use super::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/mod.rs b/services/libs/aster-std/src/process/mod.rs\n--- a/services/libs/aster-std/src/process/mod.rs\n+++ b/services/libs/aster-std/src/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod clone;\n mod credentials;\n mod exit;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\n--- a/services/libs/aster-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::user::UserSpace;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\n--- a/services/libs/aster-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use aster_frame::cpu::num_cpus;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\n--- a/services/libs/aster-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::kill::SignalSenderIds;\n use super::signal::sig_mask::SigMask;\n use super::signal::sig_num::SigNum;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/name.rs b/services/libs/aster-std/src/process/posix_thread/name.rs\n--- a/services/libs/aster-std/src/process/posix_thread/name.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/name.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n pub const MAX_THREAD_NAME_LEN: usize = 16;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n--- a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/robust_list.rs b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n--- a/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The implementation of robust list is from occlum.\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/process/builder.rs b/services/libs/aster-std/src/process/process/builder.rs\n--- a/services/libs/aster-std/src/process/process/builder.rs\n+++ b/services/libs/aster-std/src/process/process/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\ndiff --git a/services/libs/aster-std/src/process/process/job_control.rs b/services/libs/aster-std/src/process/process/job_control.rs\n--- a/services/libs/aster-std/src/process/process/job_control.rs\n+++ b/services/libs/aster-std/src/process/process/job_control.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGCONT, SIGHUP};\n use crate::process::signal::signals::kernel::KernelSignal;\ndiff --git a/services/libs/aster-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\n--- a/services/libs/aster-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\ndiff --git a/services/libs/aster-std/src/process/process/process_group.rs b/services/libs/aster-std/src/process/process/process_group.rs\n--- a/services/libs/aster-std/src/process/process/process_group.rs\n+++ b/services/libs/aster-std/src/process/process/process_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid, Process, Session};\n use crate::prelude::*;\n use crate::process::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/process/session.rs b/services/libs/aster-std/src/process/process/session.rs\n--- a/services/libs/aster-std/src/process/process/session.rs\n+++ b/services/libs/aster-std/src/process/process/session.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\ndiff --git a/services/libs/aster-std/src/process/process/terminal.rs b/services/libs/aster-std/src/process/process/terminal.rs\n--- a/services/libs/aster-std/src/process/process/terminal.rs\n+++ b/services/libs/aster-std/src/process/process/terminal.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, ProcessGroup};\ndiff --git a/services/libs/aster-std/src/process/process_filter.rs b/services/libs/aster-std/src/process/process_filter.rs\n--- a/services/libs/aster-std/src/process/process_filter.rs\n+++ b/services/libs/aster-std/src/process/process_filter.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/process_table.rs b/services/libs/aster-std/src/process/process_table.rs\n--- a/services/libs/aster-std/src/process/process_table.rs\n+++ b/services/libs/aster-std/src/process/process_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A global table stores the pid to process mapping.\n //! This table can be used to get process with pid.\n //! TODO: progress group, thread all need similar mapping\ndiff --git a/services/libs/aster-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\n--- a/services/libs/aster-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the UserVm of a process.\n //! The UserSpace of a process only contains the virtual-physical memory mapping.\n //! But we cannot know which vaddr is user heap, which vaddr is mmap areas.\ndiff --git a/services/libs/aster-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n--- a/services/libs/aster-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::vm::perms::VmPerms;\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This implementation is from occlum.\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A wrapper of xmas_elf's elf parsing\n use xmas_elf::{\n     header::{self, Header, HeaderPt1, HeaderPt2, HeaderPt2_, Machine_, Type_},\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the process initial stack.\n //! The process initial stack, contains arguments, environmental variables and auxiliary vectors\n //! The data layout of init stack can be seen in Figure 3.9 in https://uclibc.org/docs/psABI-x86_64.pdf\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module is used to parse elf file content to get elf_load_info.\n //! When create a process from elf file, we will use the elf_load_info to construct the VmSpace\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/mod.rs b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n--- a/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod aux_vec;\n mod elf_file;\n mod init_stack;\ndiff --git a/services/libs/aster-std/src/process/program_loader/mod.rs b/services/libs/aster-std/src/process/program_loader/mod.rs\n--- a/services/libs/aster-std/src/process/program_loader/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod elf;\n mod shebang;\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/shebang.rs b/services/libs/aster-std/src/process/program_loader/shebang.rs\n--- a/services/libs/aster-std/src/process/program_loader/shebang.rs\n+++ b/services/libs/aster-std/src/process/program_loader/shebang.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Try to parse a buffer as a shebang line.\ndiff --git a/services/libs/aster-std/src/process/rlimit.rs b/services/libs/aster-std/src/process/rlimit.rs\n--- a/services/libs/aster-std/src/process/rlimit.rs\n+++ b/services/libs/aster-std/src/process/rlimit.rs\n@@ -1,4 +1,4 @@\n-//! This implementation is from occlum\n+// SPDX-License-Identifier: MPL-2.0\n \n #![allow(non_camel_case_types)]\n \ndiff --git a/services/libs/aster-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\n--- a/services/libs/aster-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::mem;\n \ndiff --git a/services/libs/aster-std/src/process/signal/constants.rs b/services/libs/aster-std/src/process/signal/constants.rs\n--- a/services/libs/aster-std/src/process/signal/constants.rs\n+++ b/services/libs/aster-std/src/process/signal/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Standard signals\n pub(super) const MIN_STD_SIG_NUM: u8 = 1;\n pub(super) const MAX_STD_SIG_NUM: u8 = 31; // inclusive\ndiff --git a/services/libs/aster-std/src/process/signal/events.rs b/services/libs/aster-std/src/process/signal/events.rs\n--- a/services/libs/aster-std/src/process/signal/events.rs\n+++ b/services/libs/aster-std/src/process/signal/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, EventsFilter};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\n--- a/services/libs/aster-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod c_types;\n pub mod constants;\n mod events;\ndiff --git a/services/libs/aster-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\n--- a/services/libs/aster-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/process/signal/poll.rs b/services/libs/aster-std/src/process/signal/poll.rs\n--- a/services/libs/aster-std/src/process/signal/poll.rs\n+++ b/services/libs/aster-std/src/process/signal/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_action.rs b/services/libs/aster-std/src/process/signal/sig_action.rs\n--- a/services/libs/aster-std/src/process/signal/sig_action.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_action.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{c_types::sigaction_t, constants::*, sig_mask::SigMask, sig_num::SigNum};\n use crate::prelude::*;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_disposition.rs b/services/libs/aster-std/src/process/signal/sig_disposition.rs\n--- a/services/libs/aster-std/src/process/signal/sig_disposition.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_disposition.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, sig_action::SigAction, sig_num::SigNum};\n \n #[derive(Copy, Clone)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_mask.rs b/services/libs/aster-std/src/process/signal/sig_mask.rs\n--- a/services/libs/aster-std/src/process/signal/sig_mask.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::MIN_STD_SIG_NUM, sig_num::SigNum};\n \n #[derive(Debug, Copy, Clone, Default, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_num.rs b/services/libs/aster-std/src/process/signal/sig_num.rs\n--- a/services/libs/aster-std/src/process/signal/sig_num.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_num.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::constants::*;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/sig_queues.rs b/services/libs/aster-std/src/process/signal/sig_queues.rs\n--- a/services/libs/aster-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_queues.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SigEvents, SigEventsFilter};\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_stack.rs b/services/libs/aster-std/src/process/signal/sig_stack.rs\n--- a/services/libs/aster-std/src/process/signal/sig_stack.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// User-provided signal stack. `SigStack` is per-thread, and each thread can have\ndiff --git a/services/libs/aster-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\n--- a/services/libs/aster-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\ndiff --git a/services/libs/aster-std/src/process/signal/signals/kernel.rs b/services/libs/aster-std/src/process/signal/signals/kernel.rs\n--- a/services/libs/aster-std/src/process/signal/signals/kernel.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/kernel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::SI_KERNEL;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/mod.rs b/services/libs/aster-std/src/process/signal/signals/mod.rs\n--- a/services/libs/aster-std/src/process/signal/signals/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod fault;\n pub mod kernel;\n pub mod user;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/user.rs b/services/libs/aster-std/src/process/signal/signals/user.rs\n--- a/services/libs/aster-std/src/process/signal/signals/user.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::{SI_QUEUE, SI_TKILL, SI_USER};\ndiff --git a/services/libs/aster-std/src/process/status.rs b/services/libs/aster-std/src/process/status.rs\n--- a/services/libs/aster-std/src/process/status.rs\n+++ b/services/libs/aster-std/src/process/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The process status\n \n use super::TermStatus;\ndiff --git a/services/libs/aster-std/src/process/term_status.rs b/services/libs/aster-std/src/process/term_status.rs\n--- a/services/libs/aster-std/src/process/term_status.rs\n+++ b/services/libs/aster-std/src/process/term_status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::signal::sig_num::SigNum;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/wait.rs b/services/libs/aster-std/src/process/wait.rs\n--- a/services/libs/aster-std/src/process/wait.rs\n+++ b/services/libs/aster-std/src/process/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, process::process_table, thread::thread_table};\n \n use super::{process_filter::ProcessFilter, ExitCode, Pid, Process};\ndiff --git a/services/libs/aster-std/src/sched/mod.rs b/services/libs/aster-std/src/sched/mod.rs\n--- a/services/libs/aster-std/src/sched/mod.rs\n+++ b/services/libs/aster-std/src/sched/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod priority_scheduler;\n \n // There may be multiple scheduling policies in the system,\ndiff --git a/services/libs/aster-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\n--- a/services/libs/aster-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\ndiff --git a/services/libs/aster-std/src/syscall/accept.rs b/services/libs/aster-std/src/syscall/accept.rs\n--- a/services/libs/aster-std/src/syscall/accept.rs\n+++ b/services/libs/aster-std/src/syscall/accept.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/access.rs b/services/libs/aster-std/src/syscall/access.rs\n--- a/services/libs/aster-std/src/syscall/access.rs\n+++ b/services/libs/aster-std/src/syscall/access.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SyscallReturn};\n use crate::{log_syscall_entry, prelude::*, syscall::SYS_ACCESS, util::read_cstring_from_user};\n \ndiff --git a/services/libs/aster-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\n--- a/services/libs/aster-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\ndiff --git a/services/libs/aster-std/src/syscall/bind.rs b/services/libs/aster-std/src/syscall/bind.rs\n--- a/services/libs/aster-std/src/syscall/bind.rs\n+++ b/services/libs/aster-std/src/syscall/bind.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/brk.rs b/services/libs/aster-std/src/syscall/brk.rs\n--- a/services/libs/aster-std/src/syscall/brk.rs\n+++ b/services/libs/aster-std/src/syscall/brk.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/chdir.rs b/services/libs/aster-std/src/syscall/chdir.rs\n--- a/services/libs/aster-std/src/syscall/chdir.rs\n+++ b/services/libs/aster-std/src/syscall/chdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter, fs_resolver::FsPath, inode_handle::InodeHandle, utils::InodeType,\n };\ndiff --git a/services/libs/aster-std/src/syscall/chmod.rs b/services/libs/aster-std/src/syscall/chmod.rs\n--- a/services/libs/aster-std/src/syscall/chmod.rs\n+++ b/services/libs/aster-std/src/syscall/chmod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/clock_gettime.rs b/services/libs/aster-std/src/syscall/clock_gettime.rs\n--- a/services/libs/aster-std/src/syscall/clock_gettime.rs\n+++ b/services/libs/aster-std/src/syscall/clock_gettime.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOCK_GETTIME;\n use crate::time::now_as_duration;\ndiff --git a/services/libs/aster-std/src/syscall/clock_nanosleep.rs b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n--- a/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n+++ b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use super::SyscallReturn;\ndiff --git a/services/libs/aster-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\n--- a/services/libs/aster-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/close.rs b/services/libs/aster-std/src/syscall/close.rs\n--- a/services/libs/aster-std/src/syscall/close.rs\n+++ b/services/libs/aster-std/src/syscall/close.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOSE;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/connect.rs b/services/libs/aster-std/src/syscall/connect.rs\n--- a/services/libs/aster-std/src/syscall/connect.rs\n+++ b/services/libs/aster-std/src/syscall/connect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/constants.rs b/services/libs/aster-std/src/syscall/constants.rs\n--- a/services/libs/aster-std/src/syscall/constants.rs\n+++ b/services/libs/aster-std/src/syscall/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! constants used in syscall\n \n /// LONGEST ALLOWED FILENAME\ndiff --git a/services/libs/aster-std/src/syscall/dup.rs b/services/libs/aster-std/src/syscall/dup.rs\n--- a/services/libs/aster-std/src/syscall/dup.rs\n+++ b/services/libs/aster-std/src/syscall/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/epoll.rs b/services/libs/aster-std/src/syscall/epoll.rs\n--- a/services/libs/aster-std/src/syscall/epoll.rs\n+++ b/services/libs/aster-std/src/syscall/epoll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\n--- a/services/libs/aster-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n use aster_rights::WriteOp;\n \ndiff --git a/services/libs/aster-std/src/syscall/exit.rs b/services/libs/aster-std/src/syscall/exit.rs\n--- a/services/libs/aster-std/src/syscall/exit.rs\n+++ b/services/libs/aster-std/src/syscall/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::TermStatus;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/exit_group.rs b/services/libs/aster-std/src/syscall/exit_group.rs\n--- a/services/libs/aster-std/src/syscall/exit_group.rs\n+++ b/services/libs/aster-std/src/syscall/exit_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{do_exit_group, TermStatus};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/fcntl.rs b/services/libs/aster-std/src/syscall/fcntl.rs\n--- a/services/libs/aster-std/src/syscall/fcntl.rs\n+++ b/services/libs/aster-std/src/syscall/fcntl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_FCNTL};\n use crate::log_syscall_entry;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\n--- a/services/libs/aster-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/fsync.rs b/services/libs/aster-std/src/syscall/fsync.rs\n--- a/services/libs/aster-std/src/syscall/fsync.rs\n+++ b/services/libs/aster-std/src/syscall/fsync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::{\n     fs::{file_table::FileDescripter, inode_handle::InodeHandle},\ndiff --git a/services/libs/aster-std/src/syscall/futex.rs b/services/libs/aster-std/src/syscall/futex.rs\n--- a/services/libs/aster-std/src/syscall/futex.rs\n+++ b/services/libs/aster-std/src/syscall/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::futex::{\n     futex_op_and_flags_from_u32, futex_requeue, futex_wait, futex_wait_bitset, futex_wake,\n     futex_wake_bitset, FutexOp, FutexTimeout,\ndiff --git a/services/libs/aster-std/src/syscall/getcwd.rs b/services/libs/aster-std/src/syscall/getcwd.rs\n--- a/services/libs/aster-std/src/syscall/getcwd.rs\n+++ b/services/libs/aster-std/src/syscall/getcwd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/getdents64.rs b/services/libs/aster-std/src/syscall/getdents64.rs\n--- a/services/libs/aster-std/src/syscall/getdents64.rs\n+++ b/services/libs/aster-std/src/syscall/getdents64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     inode_handle::InodeHandle,\ndiff --git a/services/libs/aster-std/src/syscall/getegid.rs b/services/libs/aster-std/src/syscall/getegid.rs\n--- a/services/libs/aster-std/src/syscall/getegid.rs\n+++ b/services/libs/aster-std/src/syscall/getegid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::credentials;\ndiff --git a/services/libs/aster-std/src/syscall/geteuid.rs b/services/libs/aster-std/src/syscall/geteuid.rs\n--- a/services/libs/aster-std/src/syscall/geteuid.rs\n+++ b/services/libs/aster-std/src/syscall/geteuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETEUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgid.rs b/services/libs/aster-std/src/syscall/getgid.rs\n--- a/services/libs/aster-std/src/syscall/getgid.rs\n+++ b/services/libs/aster-std/src/syscall/getgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgroups.rs b/services/libs/aster-std/src/syscall/getgroups.rs\n--- a/services/libs/aster-std/src/syscall/getgroups.rs\n+++ b/services/libs/aster-std/src/syscall/getgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpeername.rs b/services/libs/aster-std/src/syscall/getpeername.rs\n--- a/services/libs/aster-std/src/syscall/getpeername.rs\n+++ b/services/libs/aster-std/src/syscall/getpeername.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpgrp.rs b/services/libs/aster-std/src/syscall/getpgrp.rs\n--- a/services/libs/aster-std/src/syscall/getpgrp.rs\n+++ b/services/libs/aster-std/src/syscall/getpgrp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETPGRP};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/getpid.rs b/services/libs/aster-std/src/syscall/getpid.rs\n--- a/services/libs/aster-std/src/syscall/getpid.rs\n+++ b/services/libs/aster-std/src/syscall/getpid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETPID;\ndiff --git a/services/libs/aster-std/src/syscall/getppid.rs b/services/libs/aster-std/src/syscall/getppid.rs\n--- a/services/libs/aster-std/src/syscall/getppid.rs\n+++ b/services/libs/aster-std/src/syscall/getppid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/getrandom.rs b/services/libs/aster-std/src/syscall/getrandom.rs\n--- a/services/libs/aster-std/src/syscall/getrandom.rs\n+++ b/services/libs/aster-std/src/syscall/getrandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresgid.rs b/services/libs/aster-std/src/syscall/getresgid.rs\n--- a/services/libs/aster-std/src/syscall/getresgid.rs\n+++ b/services/libs/aster-std/src/syscall/getresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresuid.rs b/services/libs/aster-std/src/syscall/getresuid.rs\n--- a/services/libs/aster-std/src/syscall/getresuid.rs\n+++ b/services/libs/aster-std/src/syscall/getresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsid.rs b/services/libs/aster-std/src/syscall/getsid.rs\n--- a/services/libs/aster-std/src/syscall/getsid.rs\n+++ b/services/libs/aster-std/src/syscall/getsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/getsockname.rs b/services/libs/aster-std/src/syscall/getsockname.rs\n--- a/services/libs/aster-std/src/syscall/getsockname.rs\n+++ b/services/libs/aster-std/src/syscall/getsockname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsockopt.rs b/services/libs/aster-std/src/syscall/getsockopt.rs\n--- a/services/libs/aster-std/src/syscall/getsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/getsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/gettid.rs b/services/libs/aster-std/src/syscall/gettid.rs\n--- a/services/libs/aster-std/src/syscall/gettid.rs\n+++ b/services/libs/aster-std/src/syscall/gettid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETTID;\ndiff --git a/services/libs/aster-std/src/syscall/gettimeofday.rs b/services/libs/aster-std/src/syscall/gettimeofday.rs\n--- a/services/libs/aster-std/src/syscall/gettimeofday.rs\n+++ b/services/libs/aster-std/src/syscall/gettimeofday.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_GETTIMEOFDAY;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/getuid.rs b/services/libs/aster-std/src/syscall/getuid.rs\n--- a/services/libs/aster-std/src/syscall/getuid.rs\n+++ b/services/libs/aster-std/src/syscall/getuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/ioctl.rs b/services/libs/aster-std/src/syscall/ioctl.rs\n--- a/services/libs/aster-std/src/syscall/ioctl.rs\n+++ b/services/libs/aster-std/src/syscall/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::IoctlCmd;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/kill.rs b/services/libs/aster-std/src/syscall/kill.rs\n--- a/services/libs/aster-std/src/syscall/kill.rs\n+++ b/services/libs/aster-std/src/syscall/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_KILL};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/link.rs b/services/libs/aster-std/src/syscall/link.rs\n--- a/services/libs/aster-std/src/syscall/link.rs\n+++ b/services/libs/aster-std/src/syscall/link.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/listen.rs b/services/libs/aster-std/src/syscall/listen.rs\n--- a/services/libs/aster-std/src/syscall/listen.rs\n+++ b/services/libs/aster-std/src/syscall/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/lseek.rs b/services/libs/aster-std/src/syscall/lseek.rs\n--- a/services/libs/aster-std/src/syscall/lseek.rs\n+++ b/services/libs/aster-std/src/syscall/lseek.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, utils::SeekFrom};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/madvise.rs b/services/libs/aster-std/src/syscall/madvise.rs\n--- a/services/libs/aster-std/src/syscall/madvise.rs\n+++ b/services/libs/aster-std/src/syscall/madvise.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::util::read_bytes_from_user;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/mkdir.rs b/services/libs/aster-std/src/syscall/mkdir.rs\n--- a/services/libs/aster-std/src/syscall/mkdir.rs\n+++ b/services/libs/aster-std/src/syscall/mkdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\n--- a/services/libs/aster-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This mod defines mmap flags and the handler to syscall mmap\n \n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\n--- a/services/libs/aster-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read the Cpu context content then dispatch syscall to corrsponding handler\n //! The each sub module contains functions that handle real syscall logic.\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/mprotect.rs b/services/libs/aster-std/src/syscall/mprotect.rs\n--- a/services/libs/aster-std/src/syscall/mprotect.rs\n+++ b/services/libs/aster-std/src/syscall/mprotect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/munmap.rs b/services/libs/aster-std/src/syscall/munmap.rs\n--- a/services/libs/aster-std/src/syscall/munmap.rs\n+++ b/services/libs/aster-std/src/syscall/munmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/open.rs b/services/libs/aster-std/src/syscall/open.rs\n--- a/services/libs/aster-std/src/syscall/open.rs\n+++ b/services/libs/aster-std/src/syscall/open.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_handle::FileLike,\n     file_table::FileDescripter,\ndiff --git a/services/libs/aster-std/src/syscall/pause.rs b/services/libs/aster-std/src/syscall/pause.rs\n--- a/services/libs/aster-std/src/syscall/pause.rs\n+++ b/services/libs/aster-std/src/syscall/pause.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::signal::Pauser;\ndiff --git a/services/libs/aster-std/src/syscall/pipe.rs b/services/libs/aster-std/src/syscall/pipe.rs\n--- a/services/libs/aster-std/src/syscall/pipe.rs\n+++ b/services/libs/aster-std/src/syscall/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::pipe::{PipeReader, PipeWriter};\n use crate::fs::utils::{Channel, StatusFlags};\ndiff --git a/services/libs/aster-std/src/syscall/poll.rs b/services/libs/aster-std/src/syscall/poll.rs\n--- a/services/libs/aster-std/src/syscall/poll.rs\n+++ b/services/libs/aster-std/src/syscall/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::Cell;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/syscall/prctl.rs b/services/libs/aster-std/src/syscall/prctl.rs\n--- a/services/libs/aster-std/src/syscall/prctl.rs\n+++ b/services/libs/aster-std/src/syscall/prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/pread64.rs b/services/libs/aster-std/src/syscall/pread64.rs\n--- a/services/libs/aster-std/src/syscall/pread64.rs\n+++ b/services/libs/aster-std/src/syscall/pread64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::SeekFrom;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/prlimit64.rs b/services/libs/aster-std/src/syscall/prlimit64.rs\n--- a/services/libs/aster-std/src/syscall/prlimit64.rs\n+++ b/services/libs/aster-std/src/syscall/prlimit64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::ResourceType;\n use crate::util::{read_val_from_user, write_val_to_user};\n use crate::{log_syscall_entry, prelude::*, process::Pid};\ndiff --git a/services/libs/aster-std/src/syscall/read.rs b/services/libs/aster-std/src/syscall/read.rs\n--- a/services/libs/aster-std/src/syscall/read.rs\n+++ b/services/libs/aster-std/src/syscall/read.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::util::write_bytes_to_user;\n use crate::{fs::file_table::FileDescripter, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/readlink.rs b/services/libs/aster-std/src/syscall/readlink.rs\n--- a/services/libs/aster-std/src/syscall/readlink.rs\n+++ b/services/libs/aster-std/src/syscall/readlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/recvfrom.rs b/services/libs/aster-std/src/syscall/recvfrom.rs\n--- a/services/libs/aster-std/src/syscall/recvfrom.rs\n+++ b/services/libs/aster-std/src/syscall/recvfrom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/rename.rs b/services/libs/aster-std/src/syscall/rename.rs\n--- a/services/libs/aster-std/src/syscall/rename.rs\n+++ b/services/libs/aster-std/src/syscall/rename.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rmdir.rs b/services/libs/aster-std/src/syscall/rmdir.rs\n--- a/services/libs/aster-std/src/syscall/rmdir.rs\n+++ b/services/libs/aster-std/src/syscall/rmdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigaction.rs b/services/libs/aster-std/src/syscall/rt_sigaction.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigaction.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigaction.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_RT_SIGPROCMASK};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n--- a/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/sched_yield.rs b/services/libs/aster-std/src/syscall/sched_yield.rs\n--- a/services/libs/aster-std/src/syscall/sched_yield.rs\n+++ b/services/libs/aster-std/src/syscall/sched_yield.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::thread::Thread;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/select.rs b/services/libs/aster-std/src/syscall/select.rs\n--- a/services/libs/aster-std/src/syscall/select.rs\n+++ b/services/libs/aster-std/src/syscall/select.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/sendto.rs b/services/libs/aster-std/src/syscall/sendto.rs\n--- a/services/libs/aster-std/src/syscall/sendto.rs\n+++ b/services/libs/aster-std/src/syscall/sendto.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/set_robust_list.rs b/services/libs/aster-std/src/syscall/set_robust_list.rs\n--- a/services/libs/aster-std/src/syscall/set_robust_list.rs\n+++ b/services/libs/aster-std/src/syscall/set_robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SET_ROBUST_LIST};\n use crate::{\n     log_syscall_entry,\ndiff --git a/services/libs/aster-std/src/syscall/set_tid_address.rs b/services/libs/aster-std/src/syscall/set_tid_address.rs\n--- a/services/libs/aster-std/src/syscall/set_tid_address.rs\n+++ b/services/libs/aster-std/src/syscall/set_tid_address.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_SET_TID_ADDRESS;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/setfsgid.rs b/services/libs/aster-std/src/syscall/setfsgid.rs\n--- a/services/libs/aster-std/src/syscall/setfsgid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setfsuid.rs b/services/libs/aster-std/src/syscall/setfsuid.rs\n--- a/services/libs/aster-std/src/syscall/setfsuid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setgid.rs b/services/libs/aster-std/src/syscall/setgid.rs\n--- a/services/libs/aster-std/src/syscall/setgid.rs\n+++ b/services/libs/aster-std/src/syscall/setgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setgroups.rs b/services/libs/aster-std/src/syscall/setgroups.rs\n--- a/services/libs/aster-std/src/syscall/setgroups.rs\n+++ b/services/libs/aster-std/src/syscall/setgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setpgid.rs b/services/libs/aster-std/src/syscall/setpgid.rs\n--- a/services/libs/aster-std/src/syscall/setpgid.rs\n+++ b/services/libs/aster-std/src/syscall/setpgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/setregid.rs b/services/libs/aster-std/src/syscall/setregid.rs\n--- a/services/libs/aster-std/src/syscall/setregid.rs\n+++ b/services/libs/aster-std/src/syscall/setregid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresgid.rs b/services/libs/aster-std/src/syscall/setresgid.rs\n--- a/services/libs/aster-std/src/syscall/setresgid.rs\n+++ b/services/libs/aster-std/src/syscall/setresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresuid.rs b/services/libs/aster-std/src/syscall/setresuid.rs\n--- a/services/libs/aster-std/src/syscall/setresuid.rs\n+++ b/services/libs/aster-std/src/syscall/setresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setreuid.rs b/services/libs/aster-std/src/syscall/setreuid.rs\n--- a/services/libs/aster-std/src/syscall/setreuid.rs\n+++ b/services/libs/aster-std/src/syscall/setreuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setsid.rs b/services/libs/aster-std/src/syscall/setsid.rs\n--- a/services/libs/aster-std/src/syscall/setsid.rs\n+++ b/services/libs/aster-std/src/syscall/setsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/setsockopt.rs b/services/libs/aster-std/src/syscall/setsockopt.rs\n--- a/services/libs/aster-std/src/syscall/setsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/setsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setuid.rs b/services/libs/aster-std/src/syscall/setuid.rs\n--- a/services/libs/aster-std/src/syscall/setuid.rs\n+++ b/services/libs/aster-std/src/syscall/setuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/shutdown.rs b/services/libs/aster-std/src/syscall/shutdown.rs\n--- a/services/libs/aster-std/src/syscall/shutdown.rs\n+++ b/services/libs/aster-std/src/syscall/shutdown.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SockShutdownCmd;\ndiff --git a/services/libs/aster-std/src/syscall/sigaltstack.rs b/services/libs/aster-std/src/syscall/sigaltstack.rs\n--- a/services/libs/aster-std/src/syscall/sigaltstack.rs\n+++ b/services/libs/aster-std/src/syscall/sigaltstack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/socket.rs b/services/libs/aster-std/src/syscall/socket.rs\n--- a/services/libs/aster-std/src/syscall/socket.rs\n+++ b/services/libs/aster-std/src/syscall/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_handle::FileLike;\n use crate::net::socket::ip::{DatagramSocket, StreamSocket};\n use crate::net::socket::unix::UnixStreamSocket;\ndiff --git a/services/libs/aster-std/src/syscall/socketpair.rs b/services/libs/aster-std/src/syscall/socketpair.rs\n--- a/services/libs/aster-std/src/syscall/socketpair.rs\n+++ b/services/libs/aster-std/src/syscall/socketpair.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::net::socket::unix::UnixStreamSocket;\n use crate::util::net::{CSocketAddrFamily, Protocol, SockFlags, SockType, SOCK_TYPE_MASK};\ndiff --git a/services/libs/aster-std/src/syscall/stat.rs b/services/libs/aster-std/src/syscall/stat.rs\n--- a/services/libs/aster-std/src/syscall/stat.rs\n+++ b/services/libs/aster-std/src/syscall/stat.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/statfs.rs b/services/libs/aster-std/src/syscall/statfs.rs\n--- a/services/libs/aster-std/src/syscall/statfs.rs\n+++ b/services/libs/aster-std/src/syscall/statfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::FsPath,\ndiff --git a/services/libs/aster-std/src/syscall/symlink.rs b/services/libs/aster-std/src/syscall/symlink.rs\n--- a/services/libs/aster-std/src/syscall/symlink.rs\n+++ b/services/libs/aster-std/src/syscall/symlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/sync.rs b/services/libs/aster-std/src/syscall/sync.rs\n--- a/services/libs/aster-std/src/syscall/sync.rs\n+++ b/services/libs/aster-std/src/syscall/sync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/tgkill.rs b/services/libs/aster-std/src/syscall/tgkill.rs\n--- a/services/libs/aster-std/src/syscall/tgkill.rs\n+++ b/services/libs/aster-std/src/syscall/tgkill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/time.rs b/services/libs/aster-std/src/syscall/time.rs\n--- a/services/libs/aster-std/src/syscall/time.rs\n+++ b/services/libs/aster-std/src/syscall/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::time::SystemTime;\ndiff --git a/services/libs/aster-std/src/syscall/umask.rs b/services/libs/aster-std/src/syscall/umask.rs\n--- a/services/libs/aster-std/src/syscall/umask.rs\n+++ b/services/libs/aster-std/src/syscall/umask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_UMASK;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/uname.rs b/services/libs/aster-std/src/syscall/uname.rs\n--- a/services/libs/aster-std/src/syscall/uname.rs\n+++ b/services/libs/aster-std/src/syscall/uname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_UNAME;\ndiff --git a/services/libs/aster-std/src/syscall/unlink.rs b/services/libs/aster-std/src/syscall/unlink.rs\n--- a/services/libs/aster-std/src/syscall/unlink.rs\n+++ b/services/libs/aster-std/src/syscall/unlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/utimens.rs b/services/libs/aster-std/src/syscall/utimens.rs\n--- a/services/libs/aster-std/src/syscall/utimens.rs\n+++ b/services/libs/aster-std/src/syscall/utimens.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, fs_resolver::FsPath};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/wait4.rs b/services/libs/aster-std/src/syscall/wait4.rs\n--- a/services/libs/aster-std/src/syscall/wait4.rs\n+++ b/services/libs/aster-std/src/syscall/wait4.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     process::{wait_child_exit, ProcessFilter},\ndiff --git a/services/libs/aster-std/src/syscall/waitid.rs b/services/libs/aster-std/src/syscall/waitid.rs\n--- a/services/libs/aster-std/src/syscall/waitid.rs\n+++ b/services/libs/aster-std/src/syscall/waitid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{wait_child_exit, ProcessFilter};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/write.rs b/services/libs/aster-std/src/syscall/write.rs\n--- a/services/libs/aster-std/src/syscall/write.rs\n+++ b/services/libs/aster-std/src/syscall/write.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/writev.rs b/services/libs/aster-std/src/syscall/writev.rs\n--- a/services/libs/aster-std/src/syscall/writev.rs\n+++ b/services/libs/aster-std/src/syscall/writev.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\n--- a/services/libs/aster-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\ndiff --git a/services/libs/aster-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\n--- a/services/libs/aster-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::CpuSet;\n use aster_frame::task::{Priority, TaskOptions};\n \ndiff --git a/services/libs/aster-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\n--- a/services/libs/aster-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Posix thread implementation\n \n use core::{\ndiff --git a/services/libs/aster-std/src/thread/status.rs b/services/libs/aster-std/src/thread/status.rs\n--- a/services/libs/aster-std/src/thread/status.rs\n+++ b/services/libs/aster-std/src/thread/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[derive(Debug, PartialEq, Clone, Copy)]\n pub enum ThreadStatus {\n     Init,\ndiff --git a/services/libs/aster-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\n--- a/services/libs/aster-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\ndiff --git a/services/libs/aster-std/src/thread/thread_table.rs b/services/libs/aster-std/src/thread/thread_table.rs\n--- a/services/libs/aster-std/src/thread/thread_table.rs\n+++ b/services/libs/aster-std/src/thread/thread_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Thread, Tid};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\n--- a/services/libs/aster-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use spin::Once;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n--- a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Weak;\n \n use super::worker_pool::{WorkerPool, WorkerScheduler};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n--- a/services/libs/aster-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\n--- a/services/libs/aster-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n--- a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\ndiff --git a/services/libs/aster-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\n--- a/services/libs/aster-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\n--- a/services/libs/aster-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n use time::{Date, Month, PrimitiveDateTime, Time};\ndiff --git a/services/libs/aster-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\n--- a/services/libs/aster-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n pub mod net;\ndiff --git a/services/libs/aster-std/src/util/net/addr.rs b/services/libs/aster-std/src/util/net/addr.rs\n--- a/services/libs/aster-std/src/util/net/addr.rs\n+++ b/services/libs/aster-std/src/util/net/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::Ipv4Address;\n use crate::net::socket::unix::UnixSocketAddr;\n use crate::net::socket::SocketAddr;\ndiff --git a/services/libs/aster-std/src/util/net/mod.rs b/services/libs/aster-std/src/util/net/mod.rs\n--- a/services/libs/aster-std/src/util/net/mod.rs\n+++ b/services/libs/aster-std/src/util/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod options;\n mod socket;\ndiff --git a/services/libs/aster-std/src/util/net/options/mod.rs b/services/libs/aster-std/src/util/net/options/mod.rs\n--- a/services/libs/aster-std/src/util/net/options/mod.rs\n+++ b/services/libs/aster-std/src/util/net/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module introduces utilities to support Linux get/setsockopt syscalls.\n //!\n //! These two syscalls are used to get/set options for a socket. These options can be at different\ndiff --git a/services/libs/aster-std/src/util/net/options/socket.rs b/services/libs/aster-std/src/util/net/options/socket.rs\n--- a/services/libs/aster-std/src/util/net/options/socket.rs\n+++ b/services/libs/aster-std/src/util/net/options/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::net::socket::options::{\n     Error, Linger, RecvBuf, ReuseAddr, ReusePort, SendBuf, SocketOption,\ndiff --git a/services/libs/aster-std/src/util/net/options/tcp.rs b/services/libs/aster-std/src/util/net/options/tcp.rs\n--- a/services/libs/aster-std/src/util/net/options/tcp.rs\n+++ b/services/libs/aster-std/src/util/net/options/tcp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::impl_raw_socket_option;\n use crate::net::socket::ip::stream::options::{Congestion, MaxSegment, NoDelay, WindowClamp};\ndiff --git a/services/libs/aster-std/src/util/net/options/utils.rs b/services/libs/aster-std/src/util/net/options/utils.rs\n--- a/services/libs/aster-std/src/util/net/options/utils.rs\n+++ b/services/libs/aster-std/src/util/net/options/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::socket::ip::stream::CongestionControl;\n use crate::net::socket::LingerOption;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/util/net/socket.rs b/services/libs/aster-std/src/util/net/socket.rs\n--- a/services/libs/aster-std/src/util/net/socket.rs\n+++ b/services/libs/aster-std/src/util/net/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Standard well-defined IP protocols.\ndiff --git a/services/libs/aster-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\n--- a/services/libs/aster-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Virtual Dynamic Shared Object (VDSO) module enables user space applications to access kernel space routines\n //! without the need for context switching. This is particularly useful for frequently invoked operations such as\n //! obtaining the current time, which can be more efficiently handled within the user space.\ndiff --git a/services/libs/aster-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\n--- a/services/libs/aster-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n //!\n //! There are two primary VM abstractions:\ndiff --git a/services/libs/aster-std/src/vm/page_fault_handler.rs b/services/libs/aster-std/src/vm/page_fault_handler.rs\n--- a/services/libs/aster-std/src/vm/page_fault_handler.rs\n+++ b/services/libs/aster-std/src/vm/page_fault_handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This trait is implemented by structs which can handle a user space page fault.\ndiff --git a/services/libs/aster-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\n--- a/services/libs/aster-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::VmPerm;\n use aster_rights::Rights;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n--- a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::{Vaddr, VmIo};\n use aster_rights::Rights;\n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\n--- a/services/libs/aster-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Address Regions (VMARs).\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\n--- a/services/libs/aster-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating child VMARs.\n \n use aster_frame::config::PAGE_SIZE;\ndiff --git a/services/libs/aster-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n--- a/services/libs/aster-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::Mutex;\n use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\ndiff --git a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n--- a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\n--- a/services/libs/aster-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Objects (VMOs).\n \n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\n--- a/services/libs/aster-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating root and child VMOs.\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/aster-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\n--- a/services/libs/aster-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmFrame;\n \ndiff --git a/services/libs/aster-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n--- a/services/libs/aster-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-util/src/coeff.rs b/services/libs/aster-util/src/coeff.rs\n--- a/services/libs/aster-util/src/coeff.rs\n+++ b/services/libs/aster-util/src/coeff.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides an abstraction `Coeff` to server for efficient and accurate calculation\n //! of fraction multiplication.\n \ndiff --git a/services/libs/aster-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\n--- a/services/libs/aster-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// This trait is a _fallible_ version of `Clone`.\n ///\n /// If any object of a type `T` is duplicable, then `T` should implement\ndiff --git a/services/libs/aster-util/src/id_allocator.rs b/services/libs/aster-util/src/id_allocator.rs\n--- a/services/libs/aster-util/src/id_allocator.rs\n+++ b/services/libs/aster-util/src/id_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n use core::fmt::Debug;\n \ndiff --git a/services/libs/aster-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\n--- a/services/libs/aster-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\n--- a/services/libs/aster-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::Paddr;\n use aster_frame::vm::{HasPaddr, VmIo};\n use aster_frame::Result;\ndiff --git a/services/libs/aster-util/src/slot_vec.rs b/services/libs/aster-util/src/slot_vec.rs\n--- a/services/libs/aster-util/src/slot_vec.rs\n+++ b/services/libs/aster-util/src/slot_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n /// SlotVec is the variant of Vector.\ndiff --git a/services/libs/aster-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\n--- a/services/libs/aster-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n use pod::Pod;\ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n--- a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n use std::collections::{BTreeMap, HashSet};\n use std::{env, fs, io, path::PathBuf};\n \ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n--- a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n #![feature(rustc_private)]\n \n extern crate rustc_ast;\ndiff --git a/services/libs/comp-sys/cargo-component/build.rs b/services/libs/comp-sys/cargo-component/build.rs\n--- a/services/libs/comp-sys/cargo-component/build.rs\n+++ b/services/libs/comp-sys/cargo-component/build.rs\n@@ -1,4 +1,7 @@\n-//! This implementation is from rust-clippy\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n fn main() {\n     // Forward the profile to the main compilation\ndiff --git a/services/libs/comp-sys/cargo-component/src/driver.rs b/services/libs/comp-sys/cargo-component/src/driver.rs\n--- a/services/libs/comp-sys/cargo-component/src/driver.rs\n+++ b/services/libs/comp-sys/cargo-component/src/driver.rs\n@@ -1,7 +1,8 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n-//! This implementation is from rust clippy. We modified the code.\n #![feature(rustc_private)]\n #![feature(once_cell)]\n \ndiff --git a/services/libs/comp-sys/cargo-component/src/main.rs b/services/libs/comp-sys/cargo-component/src/main.rs\n--- a/services/libs/comp-sys/cargo-component/src/main.rs\n+++ b/services/libs/comp-sys/cargo-component/src/main.rs\n@@ -1,7 +1,7 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n \n-//! This implementation is from rust clippy. We modified the code.\n+// This implementation is from rust clippy. We modified the code.\n \n use std::env;\n use std::path::PathBuf;\ndiff --git a/services/libs/comp-sys/component-macro/src/init_comp.rs b/services/libs/comp-sys/component-macro/src/init_comp.rs\n--- a/services/libs/comp-sys/component-macro/src/init_comp.rs\n+++ b/services/libs/comp-sys/component-macro/src/init_comp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{TokenStream, TokenTree};\n use quote::{ToTokens, TokenStreamExt};\n use syn::parse::Parse;\ndiff --git a/services/libs/comp-sys/component-macro/src/lib.rs b/services/libs/comp-sys/component-macro/src/lib.rs\n--- a/services/libs/comp-sys/component-macro/src/lib.rs\n+++ b/services/libs/comp-sys/component-macro/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the component system related macros.\n //!\n \ndiff --git a/services/libs/comp-sys/component-macro/src/priority.rs b/services/libs/comp-sys/component-macro/src/priority.rs\n--- a/services/libs/comp-sys/component-macro/src/priority.rs\n+++ b/services/libs/comp-sys/component-macro/src/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{collections::HashMap, fs::File, io::Read, ops::Add, process::Command, str::FromStr};\n \n use json::JsonValue;\ndiff --git a/services/libs/comp-sys/component/src/lib.rs b/services/libs/comp-sys/component/src/lib.rs\n--- a/services/libs/comp-sys/component/src/lib.rs\n+++ b/services/libs/comp-sys/component/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Component system\n //!\n \ndiff --git a/services/libs/comp-sys/controlled/src/lib.rs b/services/libs/comp-sys/controlled/src/lib.rs\n--- a/services/libs/comp-sys/controlled/src/lib.rs\n+++ b/services/libs/comp-sys/controlled/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate defines two attribute macros `controlled` and `uncontrolled`.\n //! This two macros are attached to functions or static variables to enable crate level access control.\n //! To use these two macros, a crate must at first registers a tool named `component_access_control`,\ndiff --git a/services/libs/cpio-decoder/src/error.rs b/services/libs/cpio-decoder/src/error.rs\n--- a/services/libs/cpio-decoder/src/error.rs\n+++ b/services/libs/cpio-decoder/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub type Result<T> = core::result::Result<T, self::Error>;\n \n /// Errors of CPIO decoder.\ndiff --git a/services/libs/cpio-decoder/src/lib.rs b/services/libs/cpio-decoder/src/lib.rs\n--- a/services/libs/cpio-decoder/src/lib.rs\n+++ b/services/libs/cpio-decoder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust CPIO (the newc format) decoder.\n //!\n //! # Example\ndiff --git a/services/libs/int-to-c-enum/derive/src/lib.rs b/services/libs/int-to-c-enum/derive/src/lib.rs\n--- a/services/libs/int-to-c-enum/derive/src/lib.rs\n+++ b/services/libs/int-to-c-enum/derive/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote, TokenStreamExt};\n use syn::{parse_macro_input, Attribute, Data, DataEnum, DeriveInput, Generics};\ndiff --git a/services/libs/int-to-c-enum/src/lib.rs b/services/libs/int-to-c-enum/src/lib.rs\n--- a/services/libs/int-to-c-enum/src/lib.rs\n+++ b/services/libs/int-to-c-enum/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate provides a derive macro named TryFromInt. This macro can be used to automatically implement TryFrom trait\n //! for [C-like enums](https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum/c_like.html).\n //!\ndiff --git a/services/libs/keyable-arc/src/lib.rs b/services/libs/keyable-arc/src/lib.rs\n--- a/services/libs/keyable-arc/src/lib.rs\n+++ b/services/libs/keyable-arc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Same as the standard `Arc`, except that it can be used as the key type of a hash table.\n //!\n //! # Motivation\ndiff --git a/services/libs/typeflags-util/src/assert.rs b/services/libs/typeflags-util/src/assert.rs\n--- a/services/libs/typeflags-util/src/assert.rs\n+++ b/services/libs/typeflags-util/src/assert.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! define macro assert_type_same\n \n use crate::same::SameAs;\ndiff --git a/services/libs/typeflags-util/src/bool.rs b/services/libs/typeflags-util/src/bool.rs\n--- a/services/libs/typeflags-util/src/bool.rs\n+++ b/services/libs/typeflags-util/src/bool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type level bools\n \n pub use core::ops::BitAnd as And;\ndiff --git a/services/libs/typeflags-util/src/extend.rs b/services/libs/typeflags-util/src/extend.rs\n--- a/services/libs/typeflags-util/src/extend.rs\n+++ b/services/libs/typeflags-util/src/extend.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{Cons, Nil};\n \n /// This trait will extend a set with another item.\ndiff --git a/services/libs/typeflags-util/src/if_.rs b/services/libs/typeflags-util/src/if_.rs\n--- a/services/libs/typeflags-util/src/if_.rs\n+++ b/services/libs/typeflags-util/src/if_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type Level If\n \n use crate::bool::{False, True};\ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\ndiff --git a/services/libs/typeflags-util/src/same.rs b/services/libs/typeflags-util/src/same.rs\n--- a/services/libs/typeflags-util/src/same.rs\n+++ b/services/libs/typeflags-util/src/same.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Traits used to check if two types are the same, returning a Bool.\n //! This check happens at compile time\n \ndiff --git a/services/libs/typeflags-util/src/set.rs b/services/libs/typeflags-util/src/set.rs\n--- a/services/libs/typeflags-util/src/set.rs\n+++ b/services/libs/typeflags-util/src/set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Common types and traits to deal with type-level sets\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/typeflags/src/flag_set.rs b/services/libs/typeflags/src/flag_set.rs\n--- a/services/libs/typeflags/src/flag_set.rs\n+++ b/services/libs/typeflags/src/flag_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use itertools::Itertools;\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\ndiff --git a/services/libs/typeflags/src/type_flag.rs b/services/libs/typeflags/src/type_flag.rs\n--- a/services/libs/typeflags/src/type_flag.rs\n+++ b/services/libs/typeflags/src/type_flag.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::TokenStream;\n use quote::quote;\n use syn::{\ndiff --git a/services/libs/typeflags/src/util.rs b/services/libs/typeflags/src/util.rs\n--- a/services/libs/typeflags/src/util.rs\n+++ b/services/libs/typeflags/src/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\n \ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n # This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n FROM ubuntu:22.04 as build-base\n \n SHELL [\"/bin/bash\", \"-c\"]\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n",
        "test_patch": "",
        "problem_statement": "Add copyright and license info to the header of every file\nNeed to insert the copyright header to every source code file.\r\n\r\nHere is the header for each Rust file.\r\n\r\n```rust\r\n// SPDX-License-Identifier: MPL-2.0\r\n```\n",
        "hints_text": "As a side note, the MPL license is unfortunately hard-coded to allow implicit upgrades when the Mozilla Foundation releases a new license version. Not sure if we like that or not (or at least accept it).\r\n\r\n> 10.2. Effect of New Versions\r\n> \r\n> You may distribute the Covered Software under the terms of the version\r\n> of the License under which You originally received the Covered Software,\r\n> or under the terms of any subsequent version published by the license\r\n> steward.\r\n\r\nA similar statement in GPL-2.0 instead offers two choices, i.e., `GPL-2.0-only` or `GPL-2.0-or-later`.\r\n> 9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\r\n> Each version is given a distinguishing version number. *If the Program specifies a version number of this License which applies to it and \"any later version\",* you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\r\n\r\nLinux uses `GPL-2.0-only` because there are some problems with GPL-3.0, or at least Linus Torvalds does not like GPL-3.0.",
        "created_at": "2024-01-03T06:45:56Z"
    }
]