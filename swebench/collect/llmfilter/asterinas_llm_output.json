[
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1559,
        "instance_id": "asterinas__asterinas-1559",
        "issue_numbers": [
            "1554"
        ],
        "base_commit": "11382524d1d23cc6d41adf977a72138baa39e38d",
        "patch": "diff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -343,7 +343,7 @@ mod test {\n     fn test_write_closed() {\n         test_blocking(\n             |writer| {\n-                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2, 3])).unwrap(), 2);\n                 assert_eq!(\n                     writer.write(&mut reader_from(&[2])).unwrap_err().error(),\n                     Errno::EPIPE\n\ndiff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -354,6 +354,24 @@ mod test {\n         );\n     }\n \n+    #[ktest]\n+    fn test_write_atomicity() {\n+        test_blocking(\n+            |writer| {\n+                assert_eq!(writer.write(&mut reader_from(&[1])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 2);\n+            },\n+            |reader| {\n+                let mut buf = [0; 3];\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n+                assert_eq!(&buf[..1], &[1]);\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 2);\n+                assert_eq!(&buf[..2], &[1, 2]);\n+            },\n+            Ordering::WriteThenRead,\n+        );\n+    }\n+\n     fn reader_from(buf: &[u8]) -> VmReader {\n         VmReader::from(buf).to_fallible()\n     }\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -22,6 +22,19 @@ pub struct Channel<T> {\n     consumer: Consumer<T>,\n }\n \n+/// Maximum number of bytes guaranteed to be written to a pipe atomically.\n+///\n+/// If the number of bytes to be written is less than the threshold, the write must be atomic.\n+/// A non-blocking atomic write may fail with `EAGAIN`, even if there is room for a partial write.\n+/// In other words, a partial write is not allowed for an atomic write.\n+///\n+/// For more details, see the description of `PIPE_BUF` in\n+/// <https://man7.org/linux/man-pages/man7/pipe.7.html>.\n+#[cfg(not(ktest))]\n+const PIPE_BUF: usize = 4096;\n+#[cfg(ktest)]\n+const PIPE_BUF: usize = 2;\n+\n impl<T> Channel<T> {\n     /// Creates a new channel with the given capacity.\n     ///\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -114,7 +127,7 @@ impl<T> Producer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -123,7 +136,7 @@ impl<T> Producer<T> {\n         let rb = this_end.rb();\n         if self.is_shutdown() {\n             // The POLLOUT event is always set in this case. Don't try to remove it.\n-        } else if rb.is_full() {\n+        } else if rb.free_len() < PIPE_BUF {\n             this_end.pollee.del_events(IoEvents::OUT);\n         }\n         drop(rb);\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -204,7 +217,7 @@ impl<T> Consumer<T> {\n     }\n \n     fn update_pollee(&self) {\n-        // In theory, `rb.is_full()`/`rb.is_empty()`, where the `rb` is taken from either\n+        // In theory, `rb.free_len()`/`rb.is_empty()`, where the `rb` is taken from either\n         // `this_end` or `peer_end`, should reflect the same state. However, we need to take the\n         // correct lock when updating the events to avoid races between the state check and the\n         // event update.\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -218,7 +231,7 @@ impl<T> Consumer<T> {\n \n         let peer_end = self.peer_end();\n         let rb = peer_end.rb();\n-        if !rb.is_full() {\n+        if rb.free_len() >= PIPE_BUF {\n             peer_end.pollee.add_events(IoEvents::OUT);\n         }\n         drop(rb);\n\ndiff --git a/kernel/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\n--- a/kernel/src/fs/utils/channel.rs\n+++ b/kernel/src/fs/utils/channel.rs\n@@ -307,6 +320,10 @@ impl<R: TRights> Fifo<u8, R> {\n     #[require(R > Write)]\n     pub fn write(&self, reader: &mut dyn MultiRead) -> Result<usize> {\n         let mut rb = self.common.producer.rb();\n+        if rb.free_len() < reader.sum_lens() && reader.sum_lens() <= PIPE_BUF {\n+            // No sufficient space for an atomic write\n+            return Ok(0);\n+        }\n         rb.write_fallible(reader)\n     }\n }\n",
        "test_patch": "diff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -247,7 +247,7 @@ mod test {\n         W: Fn(Arc<PipeWriter>) + Sync + Send + 'static,\n         R: Fn(Arc<PipeReader>) + Sync + Send + 'static,\n     {\n-        let channel = Channel::with_capacity(1);\n+        let channel = Channel::with_capacity(2);\n         let (writer, readr) = channel.split();\n \n         let writer = PipeWriter::new(writer, StatusFlags::empty()).unwrap();\n\ndiff --git a/kernel/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\n--- a/kernel/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -313,13 +313,13 @@ mod test {\n     fn test_write_full() {\n         test_blocking(\n             |writer| {\n-                assert_eq!(writer.write(&mut reader_from(&[1, 2])).unwrap(), 1);\n+                assert_eq!(writer.write(&mut reader_from(&[1, 2, 3])).unwrap(), 2);\n                 assert_eq!(writer.write(&mut reader_from(&[2])).unwrap(), 1);\n             },\n             |reader| {\n-                let mut buf = [0; 2];\n-                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n-                assert_eq!(&buf[..1], &[1]);\n+                let mut buf = [0; 3];\n+                assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 2);\n+                assert_eq!(&buf[..2], &[1, 2]);\n                 assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 1);\n                 assert_eq!(&buf[..1], &[2]);\n             },\n",
        "problem_statement": "PIPE implementation does not guarantee atomic writes for up to PIPE_BUF bytes\n### Describe the bug\r\n\r\nThe current implementation of the PIPE in Asterinas does not ensure that writes of up to PIPE_BUF bytes are atomic. \r\n\r\n### To Reproduce\r\n\r\nApply the following patch and run `test/pipe/pipe_atomicity`\r\n\r\n<details><summary>patch file</summary>\r\n\r\n```diff\r\ndiff --git a/test/apps/pipe/pipe_atomicity.c b/test/apps/pipe/pipe_atomicity.c\r\nnew file mode 100644\r\nindex 00000000..1e473d78\r\n--- /dev/null\r\n+++ b/test/apps/pipe/pipe_atomicity.c\r\n@@ -0,0 +1,36 @@\r\n+// SPDX-License-Identifier: MPL-2.0\r\n+\r\n+#define _GNU_SOURCE\r\n+\r\n+#include \"../network/test.h\"\r\n+#include <signal.h>\r\n+#include <string.h>\r\n+#include <sys/poll.h>\r\n+#include <unistd.h>\r\n+\r\n+static int rfd, wfd;\r\n+\r\n+FN_SETUP(short_read_and_write)\r\n+{\r\n+       int fildes[2];\r\n+\r\n+       CHECK(pipe(fildes));\r\n+       rfd = fildes[0];\r\n+       wfd = fildes[1];\r\n+\r\n+}\r\n+END_SETUP()\r\n+\r\n+FN_TEST(atomicity)\r\n+{\r\n+       char buf[511] = { 0 };\r\n+\r\n+       // for (int i = 0; i < 130; i++)\r\n+       //      TEST_RES(write(wfd, buf, 511), _ret == 511);\r\n+       for (int i = 0; i < 130; i++)\r\n+       {\r\n+               ssize_t res = write(wfd, buf, 511);\r\n+               printf(\"i=%d, res=%ld\\n\", i, res);\r\n+       }\r\n+}\r\n+END_TEST()\r\n```\r\n</details>\r\n\r\n### Expected behavior\r\n\r\nIn the current Asterinas implementation, writing 511 bytes results in partial writes (128 bytes) after 128 iterations, while the Linux implementation blocks after 127 iterations:\r\n\r\n![aster_vs_linux](https://github.com/user-attachments/assets/e8b9377b-fff3-4c23-bb81-8e3fa6f253e1)\r\n\r\n### Environment\r\n\r\nbranch: [7ddfd42](https://github.com/asterinas/asterinas/tree/7ddfd42baa210656127044995d8707fde74fab4d)\r\n\n",
        "hints_text": "This one is easy to fix. Just check if the remaining space in the internal buffer of a pipe is no less than `PIPE_BUF` before actually writing the data.",
        "created_at": "2024-11-05T07:28:33Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1642,
        "instance_id": "asterinas__asterinas-1642",
        "issue_numbers": [
            "1587"
        ],
        "base_commit": "9da6af03943c15456cdfd781021820a7da78ea40",
        "patch": "diff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -253,7 +253,9 @@ impl FutexBucket {\n             }\n \n             let item = item_cursor.remove().unwrap();\n-            item.wake();\n+            if !item.wake() {\n+                continue;\n+            }\n             count += 1;\n         }\n \n\ndiff --git /dev/null b/test/apps/pthread/pthread_signal_test.c\nnew file mode 100644\n--- /dev/null\n+++ b/test/apps/pthread/pthread_signal_test.c\n@@ -0,0 +1,109 @@\n+// SPDX-License-Identifier: MPL-2.0\n+// A regression test for the futex lost wakeup bug fixed in https://github.com/asterinas/asterinas/pull/1642\n+\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <signal.h>\n+#include <stdatomic.h>\n+\n+pthread_mutex_t mutex;\n+atomic_int sync_flag = ATOMIC_VAR_INIT(0); // Atomic flag for synchronization\n+\n+// Signal handler for SIGUSR1\n+void signal_handler(int signum)\n+{\n+\tatomic_store(&sync_flag, 2);\n+}\n+\n+// Thread function that tries to lock the mutex and waits if it is locked\n+void *thread_function(void *arg)\n+{\n+\tprintf(\"Thread: Trying to lock mutex...\\n\");\n+\n+\t// Set the atomic flag to signal the main thread\n+\tatomic_store(&sync_flag, 1);\n+\n+\t// Try to lock the mutex\n+\tpthread_mutex_lock(&mutex);\n+\tprintf(\"Thread: Got the mutex!\\n\");\n+\n+\tprintf(\"Thread: Exiting.\\n\");\n+\tpthread_mutex_unlock(&mutex);\n+\n+\t// Set the atomic flag to signal the main thread\n+\tatomic_store(&sync_flag, 3);\n+\treturn NULL;\n+}\n+\n+int main()\n+{\n+\tpthread_t thread;\n+\n+\t// Initialize mutex\n+\tif (pthread_mutex_init(&mutex, NULL) != 0) {\n+\t\tperror(\"Mutex initialization failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Set up signal handler for SIGUSR1\n+\tstruct sigaction sa;\n+\tsa.sa_handler = signal_handler;\n+\tsa.sa_flags = 0;\n+\tsigemptyset(&sa.sa_mask);\n+\tif (sigaction(SIGUSR1, &sa, NULL) == -1) {\n+\t\tperror(\"sigaction failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Main thread locks the mutex\n+\tpthread_mutex_lock(&mutex);\n+\tprintf(\"Main thread: Mutex locked.\\n\");\n+\n+\t// Create the second thread\n+\tif (pthread_create(&thread, NULL, thread_function, NULL) != 0) {\n+\t\tperror(\"Thread creation failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Detach the thread to allow it to run independently\n+\tif (pthread_detach(thread) != 0) {\n+\t\tperror(\"Thread detachment failed\");\n+\t\treturn -1;\n+\t}\n+\n+\t// Wait for the second thread to prepare\n+\twhile (atomic_load(&sync_flag) != 1) {\n+\t}\n+\tsleep(1);\n+\n+\t// Send signal to the second thread\n+\tpthread_kill(thread, SIGUSR1);\n+\tprintf(\"Main thread: Signal sent to the thread.\\n\");\n+\n+\t// Wait for the second thread to process signal\n+\twhile (atomic_load(&sync_flag) != 2) {\n+\t}\n+\tsleep(1);\n+\n+\t// Unlock the mutex\n+\tpthread_mutex_unlock(&mutex);\n+\tprintf(\"Main thread: Mutex unlocked.\\n\");\n+\n+\t// Wait for the second thread to exit\n+\tint count = 3;\n+\twhile (atomic_load(&sync_flag) != 3 && count--) {\n+\t\tsleep(1);\n+\t}\n+\tif (atomic_load(&sync_flag) != 3) {\n+\t\tprintf(\"ERROR: Thread does not exit after timeout.\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Destroy mutex\n+\tpthread_mutex_destroy(&mutex);\n+\n+\tprintf(\"All tests passed.\\n\");\n+\treturn 0;\n+}\n",
        "test_patch": "diff --git a/kernel/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\n--- a/kernel/src/process/posix_thread/futex.rs\n+++ b/kernel/src/process/posix_thread/futex.rs\n@@ -323,8 +325,9 @@ impl FutexItem {\n         (futex_item, waiter)\n     }\n \n-    pub fn wake(&self) {\n-        self.waker.wake_up();\n+    #[must_use]\n+    pub fn wake(&self) -> bool {\n+        self.waker.wake_up()\n     }\n \n     pub fn match_up(&self, another: &Self) -> bool {\n",
        "problem_statement": "`futex_wait_bitset()` should remove `futex_item` when `pause_timeout()` fails\n### Describe the bug\r\n\r\n1. When signaled or timeout, the `futex_item` is not removed from the `futex_bucket`, which can lead to lost-wakeup.\r\n2. `waiter.pause_timeout()` returns `Ok(())` upon waking up from a signal, which can lead to incorrect handling of the wake-up event.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/11382524d1d23cc6d41adf977a72138baa39e38d/kernel/src/process/posix_thread/futex.rs#L76\n",
        "hints_text": "The [wakeup test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L671-L673) must take precedence over the [pending signals test](https://github.com/torvalds/linux/blob/2d5404caa8c7bb5c4e0435f94b28834ae5456623/kernel/futex/waitwake.c#L678-L683).\r\n\r\nThis is the real cause of the failed CI due to 6421fd0b36aafb3fcd9a8f12d5bc6e89f3f86546, cc https://github.com/asterinas/asterinas/pull/1577.\r\n\r\nI also wonder if we can remove the `pause_timeout` API and let the futex use the normal `pause_until` API, but I am not sure since I have not read the futex implementation.\r\n\r\n> can lead to lost-wakeup.\r\n\r\nThis should only result in spurious wake?",
        "created_at": "2024-11-26T12:04:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1369,
        "instance_id": "asterinas__asterinas-1369",
        "issue_numbers": [
            "919"
        ],
        "base_commit": "ae4ac384713e63232b74915593ebdef680049d31",
        "patch": "diff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -16,7 +16,7 @@ use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::{\n     cpu::CpuExceptionInfo,\n-    mm::{VmSpace, MAX_USERSPACE_VADDR},\n+    mm::{tlb::TlbFlushOp, PageFlags, PageProperty, VmSpace, MAX_USERSPACE_VADDR},\n };\n \n use self::{\n\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -220,13 +220,6 @@ impl Vmar_ {\n     }\n \n     fn new_root() -> Arc<Self> {\n-        fn handle_page_fault_wrapper(\n-            vm_space: &VmSpace,\n-            trap_info: &CpuExceptionInfo,\n-        ) -> core::result::Result<(), ()> {\n-            handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n-        }\n-\n         let mut free_regions = BTreeMap::new();\n         let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\n\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -236,7 +229,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        let vm_space = VmSpace::new();\n+        let mut vm_space = VmSpace::new();\n         vm_space.register_page_fault_handler(handle_page_fault_wrapper);\n         Vmar_::new(vmar_inner, Arc::new(vm_space), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\n\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -668,17 +661,19 @@ impl Vmar_ {\n             let vm_space = if let Some(parent) = parent {\n                 parent.vm_space().clone()\n             } else {\n-                Arc::new(self.vm_space().fork_copy_on_write())\n+                let mut new_space = VmSpace::new();\n+                new_space.register_page_fault_handler(handle_page_fault_wrapper);\n+                Arc::new(new_space)\n             };\n             Vmar_::new(vmar_inner, vm_space, self.base, self.size, parent)\n         };\n \n         let inner = self.inner.lock();\n+        let mut new_inner = new_vmar_.inner.lock();\n+\n         // Clone free regions.\n         for (free_region_base, free_region) in &inner.free_regions {\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .free_regions\n                 .insert(*free_region_base, free_region.clone());\n         }\n\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -686,26 +681,49 @@ impl Vmar_ {\n         // Clone child vmars.\n         for (child_vmar_base, child_vmar_) in &inner.child_vmar_s {\n             let new_child_vmar = child_vmar_.new_fork(Some(&new_vmar_))?;\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .child_vmar_s\n                 .insert(*child_vmar_base, new_child_vmar);\n         }\n \n         // Clone mappings.\n-        for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n-            let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n-            new_vmar_\n-                .inner\n-                .lock()\n-                .vm_mappings\n-                .insert(*vm_mapping_base, new_mapping);\n+        {\n+            let new_vmspace = new_vmar_.vm_space();\n+            let range = self.base..(self.base + self.size);\n+            let mut new_cursor = new_vmspace.cursor_mut(&range).unwrap();\n+            let cur_vmspace = self.vm_space();\n+            let mut cur_cursor = cur_vmspace.cursor_mut(&range).unwrap();\n+            for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n+                // Clone the `VmMapping` to the new VMAR.\n+                let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n+                new_inner.vm_mappings.insert(*vm_mapping_base, new_mapping);\n+\n+                // Protect the mapping and copy to the new page table for COW.\n+                cur_cursor.jump(*vm_mapping_base).unwrap();\n+                new_cursor.jump(*vm_mapping_base).unwrap();\n+                let mut op = |page: &mut PageProperty| {\n+                    page.flags -= PageFlags::W;\n+                };\n+                new_cursor.copy_from(&mut cur_cursor, vm_mapping.map_size(), &mut op);\n+            }\n+            cur_cursor.flusher().issue_tlb_flush(TlbFlushOp::All);\n+            cur_cursor.flusher().dispatch_tlb_flush();\n         }\n+\n+        drop(new_inner);\n+\n         Ok(new_vmar_)\n     }\n }\n \n+/// This is for fallible user space write handling.\n+fn handle_page_fault_wrapper(\n+    vm_space: &VmSpace,\n+    trap_info: &CpuExceptionInfo,\n+) -> core::result::Result<(), ()> {\n+    handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n+}\n+\n impl<R> Vmar<R> {\n     /// The base address, i.e., the offset relative to the root VMAR.\n     ///\n\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -11,7 +11,8 @@ use core::{\n use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::mm::{\n-    vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags, PageProperty, VmSpace,\n+    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags,\n+    PageProperty, VmSpace,\n };\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\n\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -224,7 +225,7 @@ impl VmMapping {\n \n         match cursor.query().unwrap() {\n             VmItem::Mapped {\n-                va: _,\n+                va,\n                 frame,\n                 mut prop,\n             } if is_write => {\n\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -245,7 +246,9 @@ impl VmMapping {\n                 let new_flags = PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n \n                 if self.is_shared || only_reference {\n-                    cursor.protect(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.protect_next(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.flusher().issue_tlb_flush(TlbFlushOp::Address(va));\n+                    cursor.flusher().dispatch_tlb_flush();\n                 } else {\n                     let new_frame = duplicate_frame(&frame)?;\n                     prop.flags |= new_flags;\n\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -18,6 +18,7 @@ pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n pub mod stat;\n+pub mod tlb;\n pub mod vm_space;\n \n use core::{fmt::Debug, ops::Range};\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -734,26 +734,93 @@ where\n         None\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.0.preempt_guard\n-    }\n-\n-    /// Consumes itself and leak the root guard for the caller if it locked the root level.\n+    /// Copies the mapping from the given cursor to the current cursor.\n     ///\n-    /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\n-    pub(super) fn leak_root_guard(mut self) -> Option<PageTableNode<E, C>> {\n-        if self.0.guard_level != C::NR_LEVELS {\n-            return None;\n-        }\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// It can only copy tracked mappings since we consider the untracked\n+    /// mappings not useful to be copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that\n+    ///  - the range being copied with the operation does not affect kernel's\n+    ///    memory safety.\n+    ///  - both of the cursors are in tracked mappings.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub unsafe fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        assert!(len % page_size::<C>(1) == 0);\n+        let this_end = self.0.va + len;\n+        assert!(this_end <= self.0.barrier_va.end);\n+        let src_end = src.0.va + len;\n+        assert!(src_end <= src.0.barrier_va.end);\n \n-        while self.0.level < C::NR_LEVELS {\n-            self.0.level_up();\n-        }\n+        while self.0.va < this_end && src.0.va < src_end {\n+            let cur_pte = src.0.read_cur_pte();\n+            if !cur_pte.is_present() {\n+                src.0.move_forward();\n+                continue;\n+            }\n+\n+            // Go down if it's not a last node.\n+            if !cur_pte.is_last(src.0.level) {\n+                src.0.level_down();\n+\n+                // We have got down a level. If there's no mapped PTEs in\n+                // the current node, we can go back and skip to save time.\n+                if src.0.guards[(src.0.level - 1) as usize]\n+                    .as_ref()\n+                    .unwrap()\n+                    .nr_children()\n+                    == 0\n+                {\n+                    src.0.level_up();\n+                    src.0.move_forward();\n+                }\n+\n+                continue;\n+            }\n \n-        self.0.guards[(C::NR_LEVELS - 1) as usize].take()\n+            // Do protection.\n+            let mut pte_prop = cur_pte.prop();\n+            op(&mut pte_prop);\n+\n+            let idx = src.0.cur_idx();\n+            src.cur_node_mut().protect(idx, pte_prop);\n \n-        // Ok to drop the cursor here because we ensure not to access the page table if the current\n-        // level is the root level when running the dropping method.\n+            // Do copy.\n+            let child = src.cur_node_mut().child(idx, true);\n+            let Child::<E, C>::Page(page, prop) = child else {\n+                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n+            };\n+            self.jump(src.0.va).unwrap();\n+            let mapped_page_size = page.size();\n+            let original = self.map(page, prop);\n+            debug_assert!(original.is_none());\n+\n+            // Only move the source cursor forward since `Self::map` will do it.\n+            // This assertion is to ensure that they move by the same length.\n+            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+            src.0.move_forward();\n+        }\n     }\n \n     /// Goes down a level assuming the current slot is absent.\n\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -92,53 +92,29 @@ impl PageTable<UserMode> {\n             self.root.activate();\n         }\n     }\n-\n-    /// Create a cloned new page table.\n-    ///\n-    /// This method takes a mutable cursor to the old page table that locks the\n-    /// entire virtual address range. The caller may implement the copy-on-write\n-    /// mechanism by first protecting the old page table and then clone it using\n-    /// this method.\n-    ///\n-    /// TODO: We may consider making the page table itself copy-on-write.\n-    pub fn clone_with(\n-        &self,\n-        cursor: CursorMut<'_, UserMode, PageTableEntry, PagingConsts>,\n-    ) -> Self {\n-        let root_node = cursor.leak_root_guard().unwrap();\n-\n-        const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node = unsafe {\n-            root_node.make_copy(\n-                0..NR_PTES_PER_NODE / 2,\n-                NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE,\n-            )\n-        };\n-\n-        PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n-            _phantom: PhantomData,\n-        }\n-    }\n }\n \n impl PageTable<KernelMode> {\n     /// Create a new user page table.\n     ///\n-    /// This should be the only way to create the first user page table, that is\n-    /// to fork the kernel page table with all the kernel mappings shared.\n-    ///\n-    /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n-    /// other child page tables.\n+    /// This should be the only way to create the user page table, that is to\n+    /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n+        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n \n+        // Make a shallow copy of the root node in the kernel space range.\n+        // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node =\n-            unsafe { root_node.make_copy(0..0, NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE) };\n+        for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n+            let child = root_node.child(i, /* meaningless */ true);\n+            if !child.is_none() {\n+                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            }\n+        }\n \n         PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n+            root: new_node.into_raw(),\n             _phantom: PhantomData,\n         }\n     }\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -25,9 +25,7 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{\n-    fmt, marker::PhantomData, mem::ManuallyDrop, ops::Range, panic, sync::atomic::Ordering,\n-};\n+use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n \n use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n use crate::{\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -374,74 +372,6 @@ where\n         }\n     }\n \n-    /// Makes a copy of the page table node.\n-    ///\n-    /// This function allows you to control about the way to copy the children.\n-    /// For indexes in `deep`, the children are deep copied and this function will be recursively called.\n-    /// For indexes in `shallow`, the children are shallow copied as new references.\n-    ///\n-    /// You cannot shallow copy a child that is mapped to a page. Deep copying a page child will not\n-    /// copy the mapped page but will copy the handle to the page.\n-    ///\n-    /// You cannot either deep copy or shallow copy a child that is mapped to an untracked page.\n-    ///\n-    /// The ranges must be disjoint.\n-    pub(super) unsafe fn make_copy(&self, deep: Range<usize>, shallow: Range<usize>) -> Self {\n-        debug_assert!(deep.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(shallow.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(deep.end <= shallow.start || deep.start >= shallow.end);\n-\n-        let mut new_pt = Self::alloc(self.level());\n-        let mut copied_child_count = self.nr_children();\n-        for i in deep {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            match self.child(i, true) {\n-                Child::PageTable(pt) => {\n-                    let guard = pt.clone_shallow().lock();\n-                    let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::Page(page, prop) => {\n-                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        for i in shallow {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            debug_assert_eq!(self.level(), C::NR_LEVELS);\n-            match self.child(i, /*meaningless*/ true) {\n-                Child::PageTable(pt) => {\n-                    let old = new_pt.replace_child(\n-                        i,\n-                        Child::PageTable(pt.clone_shallow()),\n-                        /*meaningless*/ true,\n-                    );\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Page(_, _) | Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        new_pt\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\n\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -81,6 +81,10 @@ fn test_untracked_map_unmap() {\n \n #[ktest]\n fn test_user_copy_on_write() {\n+    fn prot_op(prop: &mut PageProperty) {\n+        prop.flags -= PageFlags::W;\n+    }\n+\n     let pt = PageTable::<UserMode>::empty();\n     let from = PAGE_SIZE..PAGE_SIZE * 2;\n     let page = allocator::alloc_single(FrameMeta::default()).unwrap();\n\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -96,7 +100,14 @@ fn test_user_copy_on_write() {\n     unsafe { pt.cursor_mut(&from).unwrap().map(page.clone().into(), prop) };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let child_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let child_pt = {\n+        let child_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut child_cursor = child_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { child_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        child_pt\n+    };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert!(matches!(\n\ndiff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -106,7 +117,14 @@ fn test_user_copy_on_write() {\n     assert!(pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let sibling_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let sibling_pt = {\n+        let sibling_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut sibling_cursor = sibling_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { sibling_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        sibling_pt\n+    };\n     assert!(sibling_pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     drop(pt);\n\ndiff --git /dev/null b/ostd/src/mm/tlb.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/tlb.rs\n@@ -0,0 +1,222 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! TLB flush operations.\n+\n+use alloc::vec::Vec;\n+use core::ops::Range;\n+\n+use super::{page::DynPage, Vaddr, PAGE_SIZE};\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    task::disable_preempt,\n+};\n+\n+/// A TLB flusher that is aware of which CPUs are needed to be flushed.\n+///\n+/// The flusher needs to stick to the current CPU.\n+pub struct TlbFlusher<G: PinCurrentCpu> {\n+    target_cpus: CpuSet,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead.\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+    _pin_current: G,\n+}\n+\n+impl<G: PinCurrentCpu> TlbFlusher<G> {\n+    /// Creates a new TLB flusher with the specified CPUs to be flushed.\n+    ///\n+    /// The flusher needs to stick to the current CPU. So please provide a\n+    /// guard that implements [`PinCurrentCpu`].\n+    pub fn new(target_cpus: CpuSet, pin_current_guard: G) -> Self {\n+        let current_cpu = pin_current_guard.current_cpu();\n+\n+        let mut need_self_flush = false;\n+        let mut need_remote_flush = false;\n+\n+        for cpu in target_cpus.iter() {\n+            if cpu == current_cpu {\n+                need_self_flush = true;\n+            } else {\n+                need_remote_flush = true;\n+            }\n+        }\n+        Self {\n+            target_cpus,\n+            need_remote_flush,\n+            need_self_flush,\n+            _pin_current: pin_current_guard,\n+        }\n+    }\n+\n+    /// Issues a pending TLB flush request.\n+    ///\n+    /// On SMP systems, the notification is sent to all the relevant CPUs only\n+    /// when [`Self::dispatch_tlb_flush`] is called.\n+    pub fn issue_tlb_flush(&self, op: TlbFlushOp) {\n+        self.issue_tlb_flush_(op, None);\n+    }\n+\n+    /// Dispatches all the pending TLB flush requests.\n+    ///\n+    /// The pending requests are issued by [`Self::issue_tlb_flush`].\n+    pub fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        crate::smp::inter_processor_call(&self.target_cpus, do_remote_flush);\n+    }\n+\n+    /// Issues a TLB flush request that must happen before dropping the page.\n+    ///\n+    /// If we need to remove a mapped page from the page table, we can only\n+    /// recycle the page after all the relevant TLB entries in all CPUs are\n+    /// flushed. Otherwise if the page is recycled for other purposes, the user\n+    /// space program can still access the page through the TLB entries. This\n+    /// method is designed to be used in such cases.\n+    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: DynPage) {\n+        self.issue_tlb_flush_(op, Some(drop_after_flush));\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on other CPUs.\n+    pub fn need_remote_flush(&self) -> bool {\n+        self.need_remote_flush\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on the current CPU.\n+    pub fn need_self_flush(&self) -> bool {\n+        self.need_self_flush\n+    }\n+\n+    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let op = op.optimize_for_large_range();\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                op.perform_on_current();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.target_cpus.iter() {\n+            let mut op_queue = FLUSH_OPS.get_on_cpu(cpu).lock();\n+            if let Some(drop_after_flush) = drop_after_flush.clone() {\n+                PAGE_KEEPER.get_on_cpu(cpu).lock().push(drop_after_flush);\n+            }\n+            op_queue.push(op.clone());\n+        }\n+    }\n+}\n+\n+/// The operation to flush TLB entries.\n+#[derive(Debug, Clone)]\n+pub enum TlbFlushOp {\n+    /// Flush all TLB entries except for the global entries.\n+    All,\n+    /// Flush the TLB entry for the specified virtual address.\n+    Address(Vaddr),\n+    /// Flush the TLB entries for the specified virtual address range.\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushOp {\n+    /// Performs the TLB flush operation on the current CPU.\n+    pub fn perform_on_current(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match self {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n+        }\n+    }\n+\n+    fn optimize_for_large_range(self) -> Self {\n+        match self {\n+            TlbFlushOp::Range(range) => {\n+                if range.len() > FLUSH_ALL_RANGE_THRESHOLD {\n+                    TlbFlushOp::All\n+                } else {\n+                    TlbFlushOp::Range(range)\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+}\n+\n+// The queues of pending requests on each CPU.\n+//\n+// Lock ordering: lock FLUSH_OPS before PAGE_KEEPER.\n+cpu_local! {\n+    static FLUSH_OPS: SpinLock<OpsStack> = SpinLock::new(OpsStack::new());\n+    static PAGE_KEEPER: SpinLock<Vec<DynPage>> = SpinLock::new(Vec::new());\n+}\n+\n+fn do_remote_flush() {\n+    let preempt_guard = disable_preempt();\n+    let current_cpu = preempt_guard.current_cpu();\n+\n+    let mut op_queue = FLUSH_OPS.get_on_cpu(current_cpu).lock();\n+    op_queue.flush_all();\n+    PAGE_KEEPER.get_on_cpu(current_cpu).lock().clear();\n+}\n+\n+/// If a TLB flushing request exceeds this threshold, we flush all.\n+pub(crate) const FLUSH_ALL_RANGE_THRESHOLD: usize = 32 * PAGE_SIZE;\n+\n+/// If the number of pending requests exceeds this threshold, we flush all the\n+/// TLB entries instead of flushing them one by one.\n+const FLUSH_ALL_OPS_THRESHOLD: usize = 32;\n+\n+struct OpsStack {\n+    ops: [Option<TlbFlushOp>; FLUSH_ALL_OPS_THRESHOLD],\n+    need_flush_all: bool,\n+    size: usize,\n+}\n+\n+impl OpsStack {\n+    const fn new() -> Self {\n+        const ARRAY_REPEAT_VALUE: Option<TlbFlushOp> = None;\n+        Self {\n+            ops: [ARRAY_REPEAT_VALUE; FLUSH_ALL_OPS_THRESHOLD],\n+            need_flush_all: false,\n+            size: 0,\n+        }\n+    }\n+\n+    fn push(&mut self, op: TlbFlushOp) {\n+        if self.need_flush_all {\n+            return;\n+        }\n+\n+        if self.size < FLUSH_ALL_OPS_THRESHOLD {\n+            self.ops[self.size] = Some(op);\n+            self.size += 1;\n+        } else {\n+            self.need_flush_all = true;\n+            self.size = 0;\n+        }\n+    }\n+\n+    fn flush_all(&mut self) {\n+        if self.need_flush_all {\n+            crate::arch::mm::tlb_flush_all_excluding_global();\n+            self.need_flush_all = false;\n+        } else {\n+            for i in 0..self.size {\n+                if let Some(op) = &self.ops[i] {\n+                    op.perform_on_current();\n+                }\n+            }\n+        }\n+\n+        self.size = 0;\n+    }\n+}\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,32 +9,25 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use alloc::collections::vec_deque::VecDeque;\n use core::{\n     ops::Range,\n     sync::atomic::{AtomicPtr, Ordering},\n };\n \n-use spin::Once;\n-\n-use super::{\n-    io::Fallible,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page::DynPage,\n-    page_table::{PageTable, UserMode},\n-    PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n-};\n use crate::{\n     arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n     cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n     cpu_local,\n     mm::{\n-        page_table::{self, PageTableItem},\n-        Frame, MAX_USERSPACE_VADDR,\n+        io::Fallible,\n+        kspace::KERNEL_PAGE_TABLE,\n+        page_table::{self, PageTable, PageTableItem, UserMode},\n+        tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\n+        Frame, PageProperty, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::{RwLock, RwLockReadGuard, SpinLock},\n-    task::disable_preempt,\n+    sync::{RwLock, RwLockReadGuard},\n+    task::{disable_preempt, DisabledPreemptGuard},\n     Error,\n };\n \n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -56,7 +49,7 @@ use crate::{\n #[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+    page_fault_handler: Option<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n     /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n     /// Cursors hold read locks and activation require a write lock.\n     activation_lock: RwLock<()>,\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -67,7 +60,7 @@ impl VmSpace {\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n+            page_fault_handler: None,\n             activation_lock: RwLock::new(()),\n         }\n     }\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -98,11 +91,7 @@ impl VmSpace {\n         Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n             let activation_lock = self.activation_lock.read();\n \n-            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n-\n             let mut activated_cpus = CpuSet::new_empty();\n-            let mut need_self_flush = false;\n-            let mut need_remote_flush = false;\n \n             for cpu in 0..num_cpus() {\n                 // The activation lock is held; other CPUs cannot activate this `VmSpace`.\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -110,20 +99,13 @@ impl VmSpace {\n                     ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n                 if ptr == self as *const VmSpace {\n                     activated_cpus.add(cpu);\n-                    if cpu == cur_cpu {\n-                        need_self_flush = true;\n-                    } else {\n-                        need_remote_flush = true;\n-                    }\n                 }\n             }\n \n             CursorMut {\n                 pt_cursor,\n                 activation_lock,\n-                activated_cpus,\n-                need_remote_flush,\n-                need_self_flush,\n+                flusher: TlbFlusher::new(activated_cpus, disable_preempt()),\n             }\n         })?)\n     }\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -156,63 +138,18 @@ impl VmSpace {\n         &self,\n         info: &CpuExceptionInfo,\n     ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n+        if let Some(func) = self.page_fault_handler {\n             return func(self, info);\n         }\n         Err(())\n     }\n \n     /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n     pub fn register_page_fault_handler(\n-        &self,\n+        &mut self,\n         func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n     ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        // Protect the parent VM space as read-only.\n-        let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n-        let mut op = |prop: &mut PageProperty| {\n-            prop.flags -= PageFlags::W;\n-        };\n-\n-        cursor.protect(end, &mut op);\n-\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-\n-        let CursorMut {\n-            pt_cursor,\n-            activation_lock,\n-            ..\n-        } = cursor;\n-\n-        let new_pt = self.pt.clone_with(pt_cursor);\n-\n-        // Release the activation lock after the page table is cloned to\n-        // prevent modification to the parent page table while cloning.\n-        drop(activation_lock);\n-\n-        Self {\n-            pt: new_pt,\n-            page_fault_handler,\n-            activation_lock: RwLock::new(()),\n-        }\n+        self.page_fault_handler = Some(func);\n     }\n \n     /// Creates a reader to read data from the user space of the current task.\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -311,12 +248,9 @@ pub struct CursorMut<'a, 'b> {\n     pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n     #[allow(dead_code)]\n     activation_lock: RwLockReadGuard<'b, ()>,\n-    // Better to store them here since loading and counting them from the CPUs\n-    // list brings non-trivial overhead. We have a read lock so the stored set\n-    // is always a superset of actual activated CPUs.\n-    activated_cpus: CpuSet,\n-    need_remote_flush: bool,\n-    need_self_flush: bool,\n+    // We have a read lock so the CPU set in the flusher is always a superset\n+    // of actual activated CPUs.\n+    flusher: TlbFlusher<DisabledPreemptGuard>,\n }\n \n impl CursorMut<'_, '_> {\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -345,6 +279,11 @@ impl CursorMut<'_, '_> {\n         self.pt_cursor.virt_addr()\n     }\n \n+    /// Get the dedicated TLB flusher for this cursor.\n+    pub fn flusher(&self) -> &TlbFlusher<DisabledPreemptGuard> {\n+        &self.flusher\n+    }\n+\n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -353,9 +292,10 @@ impl CursorMut<'_, '_> {\n         // SAFETY: It is safe to map untyped memory into the userspace.\n         let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        if old.is_some() {\n-            self.issue_tlb_flush(TlbFlushOp::Address(start_va), old);\n-            self.dispatch_tlb_flush();\n+        if let Some(old) = old {\n+            self.flusher\n+                .issue_tlb_flush_with(TlbFlushOp::Address(start_va), old);\n+            self.flusher.dispatch_tlb_flush();\n         }\n     }\n \n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -367,25 +307,31 @@ impl CursorMut<'_, '_> {\n     /// Already-absent mappings encountered by the cursor will be skipped. It\n     /// is valid to unmap a range that is not mapped.\n     ///\n+    /// It must issue and dispatch a TLB flush after the operation. Otherwise,\n+    /// the memory safety will be compromised. Please call this function less\n+    /// to avoid the overhead of TLB flush. Using a large `len` is wiser than\n+    /// splitting the operation into multiple small ones.\n+    ///\n     /// # Panics\n     ///\n     /// This method will panic if `len` is not page-aligned.\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+        let tlb_prefer_flush_all = len > FLUSH_ALL_RANGE_THRESHOLD;\n \n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n             let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !self.need_remote_flush && tlb_prefer_flush_all {\n+                    if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n                         // Only on single-CPU cases we can drop the page immediately before flushing.\n                         drop(page);\n                         continue;\n                     }\n-                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n+                    self.flusher\n+                        .issue_tlb_flush_with(TlbFlushOp::Address(va), page);\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -396,103 +342,79 @@ impl CursorMut<'_, '_> {\n             }\n         }\n \n-        if !self.need_remote_flush && tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n+            self.flusher.issue_tlb_flush(TlbFlushOp::All);\n         }\n \n-        self.dispatch_tlb_flush();\n+        self.flusher.dispatch_tlb_flush();\n     }\n \n-    /// Change the mapping property starting from the current slot.\n+    /// Applies the operation to the next slot of mapping within the range.\n     ///\n-    /// This method will bring the cursor forward by `len` bytes in the virtual\n-    /// address space after the modification.\n+    /// The range to be found in is the current virtual address with the\n+    /// provided length.\n+    ///\n+    /// The function stops and yields the actually protected range if it has\n+    /// actually protected a page, no matter if the following pages are also\n+    /// required to be protected.\n+    ///\n+    /// It also makes the cursor moves forward to the next page after the\n+    /// protected one. If no mapped pages exist in the following range, the\n+    /// cursor will stop at the end of the range and return [`None`].\n     ///\n-    /// The way to change the property is specified by the closure `op`.\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// [`Self::flusher`].\n     ///\n     /// # Panics\n     ///\n-    /// This method will panic if `len` is not page-aligned.\n-    pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n-        assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n-\n+    /// This function will panic if:\n+    ///  - the range to be protected is out of the range where the cursor\n+    ///    is required to operate;\n+    ///  - the specified virtual address range only covers a part of a page.\n+    pub fn protect_next(\n+        &mut self,\n+        len: usize,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) -> Option<Range<Vaddr>> {\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) =\n-            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n-        {\n-            if !tlb_prefer_flush_all {\n-                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n-            }\n-        }\n-\n-        if tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n-        }\n-        self.dispatch_tlb_flush();\n+        unsafe { self.pt_cursor.protect_next(len, &mut op) }\n     }\n \n-    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n-        let request = TlbFlushRequest {\n-            op,\n-            drop_after_flush,\n-        };\n-\n-        // Fast path for single CPU cases.\n-        if !self.need_remote_flush {\n-            if self.need_self_flush {\n-                request.do_flush();\n-            }\n-            return;\n-        }\n-\n-        // Slow path for multi-CPU cases.\n-        for cpu in self.activated_cpus.iter() {\n-            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n-            queue.push_back(request.clone());\n-        }\n-    }\n-\n-    fn dispatch_tlb_flush(&self) {\n-        if !self.need_remote_flush {\n-            return;\n-        }\n-\n-        fn do_remote_flush() {\n-            let preempt_guard = disable_preempt();\n-            let mut requests = TLB_FLUSH_REQUESTS\n-                .get_on_cpu(preempt_guard.current_cpu())\n-                .lock();\n-            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n-                // TODO: in most cases, we need only to flush all the TLB entries\n-                // for an ASID if it is enabled.\n-                crate::arch::mm::tlb_flush_all_excluding_global();\n-                requests.clear();\n-            } else {\n-                while let Some(request) = requests.pop_front() {\n-                    request.do_flush();\n-                    if matches!(request.op, TlbFlushOp::All) {\n-                        requests.clear();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    /// Copies the mapping from the given cursor to the current cursor.\n+    ///\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// the source's [`CursorMut::flusher`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        // SAFETY: Operations on user memory spaces are safe if it doesn't\n+        // involve dropping any pages.\n+        unsafe { self.pt_cursor.copy_from(&mut src.pt_cursor, len, op) }\n     }\n }\n \n-/// The threshold used to determine whether we need to flush all TLB entries\n-/// when handling a bunch of TLB flush requests. If the number of requests\n-/// exceeds this threshold, the overhead incurred by flushing pages\n-/// individually would surpass the overhead of flushing all entries at once.\n-const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n-\n cpu_local! {\n-    /// The queue of pending requests.\n-    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n     /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n     /// is NULL, it means that the activated page table is merely the kernel\n     /// page table.\n\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -502,38 +424,6 @@ cpu_local! {\n     static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n }\n \n-#[derive(Debug, Clone)]\n-struct TlbFlushRequest {\n-    op: TlbFlushOp,\n-    // If we need to remove a mapped page from the page table, we can only\n-    // recycle the page after all the relevant TLB entries in all CPUs are\n-    // flushed. Otherwise if the page is recycled for other purposes, the user\n-    // space program can still access the page through the TLB entries.\n-    #[allow(dead_code)]\n-    drop_after_flush: Option<DynPage>,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TlbFlushOp {\n-    All,\n-    Address(Vaddr),\n-    Range(Range<Vaddr>),\n-}\n-\n-impl TlbFlushRequest {\n-    /// Perform the TLB flush operation on the current CPU.\n-    fn do_flush(&self) {\n-        use crate::arch::mm::{\n-            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        };\n-        match &self.op {\n-            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n-            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n-            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n-        }\n-    }\n-}\n-\n /// The result of a query over the VM space.\n #[derive(Debug)]\n pub enum VmItem {\n",
        "test_patch": "diff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -558,7 +561,15 @@ impl VmMappingInner {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n         let mut cursor = vm_space.cursor_mut(&range).unwrap();\n-        cursor.protect(range.len(), |p| p.flags = perms.into());\n+        let op = |p: &mut PageProperty| p.flags = perms.into();\n+        while cursor.virt_addr() < range.end {\n+            if let Some(va) = cursor.protect_next(range.end - cursor.virt_addr(), op) {\n+                cursor.flusher().issue_tlb_flush(TlbFlushOp::Range(va));\n+            } else {\n+                break;\n+            }\n+        }\n+        cursor.flusher().dispatch_tlb_flush();\n         Ok(())\n     }\n \n",
        "problem_statement": "[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "I've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-23T14:17:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1187,
        "instance_id": "asterinas__asterinas-1187",
        "issue_numbers": [
            "1155"
        ],
        "base_commit": "0291b5dc6bb142b9c6165c1cb29b7658eefdaa63",
        "patch": "",
        "test_patch": "diff --git a/test/benchmark/lmbench-mem-fcp/config.json b/test/benchmark/lmbench-mem-fcp/config.json\n--- a/test/benchmark/lmbench-mem-fcp/config.json\n+++ b/test/benchmark/lmbench-mem-fcp/config.json\n@@ -1,7 +1,7 @@\n {\n     \"alert_threshold\": \"125%\",\n     \"alert_tool\": \"customBiggerIsBetter\",\n-    \"search_pattern\": \"134.22\",\n+    \"search_pattern\": \"536.87\",\n     \"result_index\": \"2\",\n-    \"description\": \"The memory bandwidth for copying 128 MB of data on a single processor using the fcp (fast copy) method.\"\n+    \"description\": \"The memory bandwidth for copying 512 MB of data on a single processor using the fcp (fast copy) method.\"\n }\n\ndiff --git a/test/benchmark/lmbench-mem-fcp/run.sh b/test/benchmark/lmbench-mem-fcp/run.sh\n--- a/test/benchmark/lmbench-mem-fcp/run.sh\n+++ b/test/benchmark/lmbench-mem-fcp/run.sh\n@@ -6,4 +6,4 @@ set -e\n \n echo \"*** Running the LMbench memory-copy bandwidth test ***\"\n \n-/benchmark/bin/lmbench/bw_mem -P 1 128m fcp\n\\ No newline at end of file\n+/benchmark/bin/lmbench/bw_mem -P 1 -N 50 512m fcp\n\\ No newline at end of file\n\ndiff --git a/test/benchmark/lmbench-mem-frd/config.json b/test/benchmark/lmbench-mem-frd/config.json\n--- a/test/benchmark/lmbench-mem-frd/config.json\n+++ b/test/benchmark/lmbench-mem-frd/config.json\n@@ -1,7 +1,7 @@\n {\n     \"alert_threshold\": \"125%\",\n     \"alert_tool\": \"customBiggerIsBetter\",\n-    \"search_pattern\": \"268.44\",\n+    \"search_pattern\": \"536.87\",\n     \"result_index\": \"2\",\n-    \"description\": \"The memory bandwidth for reading 256 MB of data on a single processor.\"\n+    \"description\": \"The memory bandwidth for reading 512 MB of data on a single processor.\"\n }\n\ndiff --git a/test/benchmark/lmbench-mem-frd/run.sh b/test/benchmark/lmbench-mem-frd/run.sh\n--- a/test/benchmark/lmbench-mem-frd/run.sh\n+++ b/test/benchmark/lmbench-mem-frd/run.sh\n@@ -6,4 +6,4 @@ set -e\n \n echo \"*** Running the LMbench memory-read bandwidth test ***\"\n \n-/benchmark/bin/lmbench/bw_mem -P 1 256m frd\n\\ No newline at end of file\n+/benchmark/bin/lmbench/bw_mem -P 1 -N 50 512m frd\n\\ No newline at end of file\n\ndiff --git a/test/benchmark/lmbench-mem-fwr/config.json b/test/benchmark/lmbench-mem-fwr/config.json\n--- a/test/benchmark/lmbench-mem-fwr/config.json\n+++ b/test/benchmark/lmbench-mem-fwr/config.json\n@@ -1,7 +1,7 @@\n {\n     \"alert_threshold\": \"125%\",\n     \"alert_tool\": \"customBiggerIsBetter\",\n-    \"search_pattern\": \"268.44\",\n+    \"search_pattern\": \"536.87\",\n     \"result_index\": \"2\",\n-    \"description\": \"The memory bandwidth for writing 256 MB of data on a single processor using the fwr (fast write) method.\"\n+    \"description\": \"The memory bandwidth for writing 512 MB of data on a single processor using the fwr (fast write) method.\"\n }\n\ndiff --git a/test/benchmark/lmbench-mem-fwr/run.sh b/test/benchmark/lmbench-mem-fwr/run.sh\n--- a/test/benchmark/lmbench-mem-fwr/run.sh\n+++ b/test/benchmark/lmbench-mem-fwr/run.sh\n@@ -6,4 +6,4 @@ set -e\n \n echo \"*** Running the LMbench memory-write bandwidth test ***\"\n \n-/benchmark/bin/lmbench/bw_mem -P 1 256m fwr\n\\ No newline at end of file\n+/benchmark/bin/lmbench/bw_mem -P 1 -N 50 512m fwr\n\\ No newline at end of file\n",
        "problem_statement": "Unexpected benchmark alert triggered\nI've observed that the recent benchmark workflow has consistently failed due to the `lmbench-mem` alert being triggered. This benchmark exhibits considerable instability on both Asterinas and Linux platforms. Notably, even identical commits can yield divergent results. In light of the existing benchmark alerts, it might be prudent to increase the `alert_threshold` to `1.5`.\n \n![image](https://github.com/user-attachments/assets/912645d8-e0eb-456f-9ad8-b5ac98969740)\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"grief8\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->\n",
        "hints_text": "Or we can run the benchmark for more times?\n@boterinas claim",
        "created_at": "2024-08-16T08:24:13Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1154,
        "instance_id": "asterinas__asterinas-1154",
        "issue_numbers": [
            "1130"
        ],
        "base_commit": "38b46f7ac3dd206d116f7db1fa33654569a8e443",
        "patch": "diff --git a/kernel/aster-nix/src/lib.rs b/kernel/aster-nix/src/lib.rs\n--- a/kernel/aster-nix/src/lib.rs\n+++ b/kernel/aster-nix/src/lib.rs\n@@ -89,9 +89,6 @@ fn init_thread() {\n     // Work queue should be initialized before interrupt is enabled,\n     // in case any irq handler uses work queue as bottom half\n     thread::work_queue::init();\n-    // FIXME: Remove this if we move the step of mounting\n-    // the filesystems to be done within the init process.\n-    ostd::trap::enable_local();\n     net::lazy_init();\n     fs::lazy_init();\n     // driver::pci::virtio::block::block_device_test();\n\ndiff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -18,12 +18,14 @@ use ostd::{\n \n use super::Process;\n use crate::{\n-    prelude::*,\n     process::{\n         posix_thread::PosixThreadExt,\n         signal::{constants::SIGALRM, signals::kernel::KernelSignal},\n     },\n-    thread::work_queue::{submit_work_item, work_item::WorkItem},\n+    thread::{\n+        work_queue::{submit_work_item, work_item::WorkItem},\n+        Thread,\n+    },\n     time::{\n         clocks::{ProfClock, RealTimeClock},\n         Timer, TimerManager,\n\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -190,7 +190,7 @@ fn taskless_softirq_handler(\n mod test {\n     use core::sync::atomic::AtomicUsize;\n \n-    use ostd::{prelude::*, trap::enable_local};\n+    use ostd::prelude::*;\n \n     use super::*;\n \n\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -198,7 +198,6 @@ mod test {\n         static DONE: AtomicBool = AtomicBool::new(false);\n         if !DONE.load(Ordering::SeqCst) {\n             super::init();\n-            enable_local();\n             DONE.store(true, Ordering::SeqCst);\n         }\n     }\n\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -119,6 +119,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     }\n \n     trap::init();\n+    crate::arch::irq::enable_local();\n \n     // Mark the AP as started.\n     let ap_boot_info = AP_BOOT_INFO.get().unwrap();\n\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -86,6 +86,8 @@ pub fn init() {\n \n     mm::kspace::activate_kernel_page_table();\n \n+    arch::irq::enable_local();\n+\n     invoke_ffi_init_funcs();\n }\n \n\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -71,6 +71,11 @@ pub fn preempt(task: &Arc<Task>) {\n ///\n /// If the current task's status not [`TaskStatus::Runnable`], it will not be\n /// added to the scheduler.\n+///\n+/// # Panics\n+///\n+/// This function will panic if called while holding preemption locks or with\n+/// local IRQ disabled.\n fn switch_to_task(next_task: Arc<Task>) {\n     let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n     if preemt_lock_count != 0 {\n\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -80,6 +85,11 @@ fn switch_to_task(next_task: Arc<Task>) {\n         );\n     }\n \n+    assert!(\n+        crate::arch::irq::is_local_enabled(),\n+        \"Switching task with local IRQ disabled\"\n+    );\n+\n     let irq_guard = crate::trap::disable_local();\n \n     let current_task_ptr = CURRENT_TASK_PTR.load();\n\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -9,7 +9,6 @@ use trapframe::TrapFrame;\n use crate::{\n     arch::irq::{self, IrqCallbackHandle, IRQ_ALLOCATOR},\n     prelude::*,\n-    task::{disable_preempt, DisablePreemptGuard},\n     Error,\n };\n \n\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -135,7 +134,6 @@ pub fn disable_local() -> DisabledLocalIrqGuard {\n #[must_use]\n pub struct DisabledLocalIrqGuard {\n     was_enabled: bool,\n-    preempt_guard: DisablePreemptGuard,\n }\n \n impl !Send for DisabledLocalIrqGuard {}\n\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -146,11 +144,7 @@ impl DisabledLocalIrqGuard {\n         if was_enabled {\n             irq::disable_local();\n         }\n-        let preempt_guard = disable_preempt();\n-        Self {\n-            was_enabled,\n-            preempt_guard,\n-        }\n+        Self { was_enabled }\n     }\n \n     /// Transfers the saved IRQ status of this guard to a new guard.\n\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -158,10 +152,7 @@ impl DisabledLocalIrqGuard {\n     pub fn transfer_to(&mut self) -> Self {\n         let was_enabled = self.was_enabled;\n         self.was_enabled = false;\n-        Self {\n-            was_enabled,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { was_enabled }\n     }\n }\n \n\ndiff --git a/ostd/src/trap/irq.rs b/ostd/src/trap/irq.rs\n--- a/ostd/src/trap/irq.rs\n+++ b/ostd/src/trap/irq.rs\n@@ -172,18 +163,3 @@ impl Drop for DisabledLocalIrqGuard {\n         }\n     }\n }\n-\n-/// Enables all IRQs on the current CPU.\n-///\n-/// FIXME: The reason we need to add this API is that currently IRQs\n-/// are enabled when the CPU enters the user space for the first time,\n-/// which is too late. During the OS initialization phase,\n-/// we need to get the block device working and mount the filesystems,\n-/// thus requiring the IRQs should be enabled as early as possible.\n-///\n-/// FIXME: this method may be unsound.\n-pub fn enable_local() {\n-    if !crate::arch::irq::is_local_enabled() {\n-        crate::arch::irq::enable_local();\n-    }\n-}\n\ndiff --git a/ostd/src/trap/mod.rs b/ostd/src/trap/mod.rs\n--- a/ostd/src/trap/mod.rs\n+++ b/ostd/src/trap/mod.rs\n@@ -11,9 +11,7 @@ pub use softirq::SoftIrqLine;\n pub use trapframe::TrapFrame;\n \n pub(crate) use self::handler::call_irq_callback_functions;\n-pub use self::irq::{\n-    disable_local, enable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine,\n-};\n+pub use self::irq::{disable_local, DisabledLocalIrqGuard, IrqCallbackFunction, IrqLine};\n \n pub(crate) fn init() {\n     unsafe {\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/aster-nix/src/process/process/timer_manager.rs\n--- a/kernel/aster-nix/src/process/process/timer_manager.rs\n+++ b/kernel/aster-nix/src/process/process/timer_manager.rs\n@@ -36,40 +38,43 @@ use crate::{\n /// invoke the callbacks of expired timers which are based on the updated\n /// CPU clock.\n fn update_cpu_time() {\n-    let current_thread = current_thread!();\n-    if let Some(posix_thread) = current_thread.as_posix_thread() {\n-        let process = posix_thread.process();\n-        let timer_manager = process.timer_manager();\n-        let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n-        // Based on whether the timer interrupt occurs in kernel mode or user mode,\n-        // the function will add the duration of one timer interrupt interval to the\n-        // corresponding CPU clocks.\n-        if is_kernel_interrupted() {\n-            posix_thread\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-            process\n-                .prof_clock()\n-                .kernel_clock()\n-                .add_time(jiffies_interval);\n-        } else {\n-            posix_thread\n-                .prof_clock()\n-                .user_clock()\n-                .add_time(jiffies_interval);\n-            process.prof_clock().user_clock().add_time(jiffies_interval);\n-            timer_manager\n-                .virtual_timer()\n-                .timer_manager()\n-                .process_expired_timers();\n-        }\n+    let Some(current_thread) = Thread::current() else {\n+        return;\n+    };\n+    let Some(posix_thread) = current_thread.as_posix_thread() else {\n+        return;\n+    };\n+    let process = posix_thread.process();\n+    let timer_manager = process.timer_manager();\n+    let jiffies_interval = Duration::from_millis(1000 / TIMER_FREQ);\n+    // Based on whether the timer interrupt occurs in kernel mode or user mode,\n+    // the function will add the duration of one timer interrupt interval to the\n+    // corresponding CPU clocks.\n+    if is_kernel_interrupted() {\n+        posix_thread\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+        process\n+            .prof_clock()\n+            .kernel_clock()\n+            .add_time(jiffies_interval);\n+    } else {\n+        posix_thread\n+            .prof_clock()\n+            .user_clock()\n+            .add_time(jiffies_interval);\n+        process.prof_clock().user_clock().add_time(jiffies_interval);\n         timer_manager\n-            .prof_timer()\n+            .virtual_timer()\n             .timer_manager()\n             .process_expired_timers();\n-        posix_thread.process_expired_timers();\n     }\n+    timer_manager\n+        .prof_timer()\n+        .timer_manager()\n+        .process_expired_timers();\n+    posix_thread.process_expired_timers();\n }\n \n /// Registers a function to update the CPU clock in processes and\n",
        "problem_statement": "We shouldn't disable preemption when disabling IRQ.\nCurrently `ostd::trap::disable_local` disables preemption as well when disabling IRQ. However, such a policy would like to be based on an observation that: \"we shouldn't do `switch_to_task()` when IRQ is disabled\". Indeed we shouldn't do so. But this is not the best way to solve the problem.\r\n\r\nWe shouldn't disable preemption in `ostd::trap::disable_local`, instead, we should check if the IRQ is disabled in `switch_to_task()`. This alternative solution precisely resolves the problem without other overheads.\r\n\r\nIn contrast, if we disable preemption in `ostd::trap::disable_local`, an enormous number of places that preemption won't ever happen will try to disable preemption, introducing non negligible costs since a memory write must happen when disabling preemption. Even worse, in the case of #1125, if the architecture don't implement single instruction writes, the fall back implementation will disable IRQ. But disabling preemption would need a CPU-local write, which in turn needs to disable preemption, causing a dead loop here.\r\n\r\nSo, we need only to check if the IRQ is disabled in `switch_to_task()`. The user should disable both preemption and IRQ if they indeed need both. We should check the entire code base for such needs and add `disable_preempt` delicately.\n",
        "hints_text": "",
        "created_at": "2024-08-12T13:23:15Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1138,
        "instance_id": "asterinas__asterinas-1138",
        "issue_numbers": [
            "1135"
        ],
        "base_commit": "6414111cc57b42db2bae1a0c8b01b85c3830a3b3",
        "patch": "diff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -163,18 +163,14 @@ fn get_manifest_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str\n fn get_src_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str) -> &'a str {\n     let metadata = get_package_metadata(cargo_metadata, crate_name);\n     let targets = metadata.get(\"targets\").unwrap().as_array().unwrap();\n-\n-    for target in targets {\n-        let name = target.get(\"name\").unwrap().as_str().unwrap();\n-        if name != crate_name {\n-            continue;\n-        }\n-\n-        let src_path = target.get(\"src_path\").unwrap();\n-        return src_path.as_str().unwrap();\n-    }\n-\n-    panic!(\"the crate name does not match with any target\");\n+    assert!(\n+        targets.len() == 1,\n+        \"there must be one and only one target generated\"\n+    );\n+\n+    let target = &targets[0];\n+    let src_path = target.get(\"src_path\").unwrap();\n+    return src_path.as_str().unwrap();\n }\n \n fn get_workspace_root(cargo_metadata: &serde_json::Value) -> &str {\n\ndiff --git a/osdk/tests/cli/mod.rs b/osdk/tests/cli/mod.rs\n--- a/osdk/tests/cli/mod.rs\n+++ b/osdk/tests/cli/mod.rs\n@@ -50,3 +52,13 @@ fn cli_clippy_help_message() {\n     assert_success(&output);\n     assert_stdout_contains_msg(&output, \"cargo osdk clippy\");\n }\n+\n+#[test]\n+fn cli_new_crate_with_hyphen() {\n+    let output = cargo_osdk(&[\"new\", \"--kernel\", \"my-first-os\"])\n+        .output()\n+        .unwrap();\n+    assert_success(&output);\n+    assert!(fs::metadata(\"my-first-os\").is_ok());\n+    fs::remove_dir_all(\"my-first-os\");\n+}\n",
        "test_patch": "diff --git a/osdk/tests/cli/mod.rs b/osdk/tests/cli/mod.rs\n--- a/osdk/tests/cli/mod.rs\n+++ b/osdk/tests/cli/mod.rs\n@@ -1,5 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::fs;\n+\n use crate::util::*;\n \n #[test]\n",
        "problem_statement": "OSDK should support creating crate with `-` in its name\nAs discovered by #1133, `cargo osdk new --kernel my-first-os` will panic due to `my-first-os` contains `-`.\r\n\r\nSince `cargo new my-first-os` is allowed, we should fix the problem to keep osdk consistent with cargo.\r\n\r\n\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2024-08-08T01:38:09Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1098,
        "instance_id": "asterinas__asterinas-1098",
        "issue_numbers": [
            "819"
        ],
        "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -59,14 +59,7 @@ impl AnyUnboundSocket {\n     }\n }\n \n-pub struct AnyBoundSocket {\n-    iface: Arc<dyn Iface>,\n-    handle: smoltcp::iface::SocketHandle,\n-    port: u16,\n-    socket_family: SocketFamily,\n-    observer: RwLock<Weak<dyn Observer<()>>>,\n-    weak_self: Weak<Self>,\n-}\n+pub struct AnyBoundSocket(Arc<AnyBoundSocketInner>);\n \n impl AnyBoundSocket {\n     pub(super) fn new(\n\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -75,21 +68,18 @@ impl AnyBoundSocket {\n         port: u16,\n         socket_family: SocketFamily,\n         observer: Weak<dyn Observer<()>>,\n-    ) -> Arc<Self> {\n-        Arc::new_cyclic(|weak_self| Self {\n+    ) -> Self {\n+        Self(Arc::new(AnyBoundSocketInner {\n             iface,\n             handle,\n             port,\n             socket_family,\n             observer: RwLock::new(observer),\n-            weak_self: weak_self.clone(),\n-        })\n+        }))\n     }\n \n-    pub(super) fn on_iface_events(&self) {\n-        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n-            observer.on_events(&())\n-        }\n+    pub(super) fn inner(&self) -> &Arc<AnyBoundSocketInner> {\n+        &self.0\n     }\n \n     /// Set the observer whose `on_events` will be called when certain iface events happen. After\n\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -99,34 +89,32 @@ impl AnyBoundSocket {\n     /// that the old observer will never be called after the setting. Users should be aware of this\n     /// and proactively handle the race conditions if necessary.\n     pub fn set_observer(&self, handler: Weak<dyn Observer<()>>) {\n-        *self.observer.write() = handler;\n+        *self.0.observer.write() = handler;\n \n-        self.on_iface_events();\n+        self.0.on_iface_events();\n     }\n \n     pub fn local_endpoint(&self) -> Option<IpEndpoint> {\n         let ip_addr = {\n-            let ipv4_addr = self.iface.ipv4_addr()?;\n+            let ipv4_addr = self.0.iface.ipv4_addr()?;\n             IpAddress::Ipv4(ipv4_addr)\n         };\n-        Some(IpEndpoint::new(ip_addr, self.port))\n+        Some(IpEndpoint::new(ip_addr, self.0.port))\n     }\n \n     pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n         &self,\n-        mut f: F,\n+        f: F,\n     ) -> R {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<T>(self.handle);\n-        f(socket)\n+        self.0.raw_with(f)\n     }\n \n     /// Try to connect to a remote endpoint. Tcp socket only.\n     pub fn do_connect(&self, remote_endpoint: IpEndpoint) -> Result<()> {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<RawTcpSocket>(self.handle);\n-        let port = self.port;\n-        let mut iface_inner = self.iface.iface_inner();\n+        let mut sockets = self.0.iface.sockets();\n+        let socket = sockets.get_mut::<RawTcpSocket>(self.0.handle);\n+        let port = self.0.port;\n+        let mut iface_inner = self.0.iface.iface_inner();\n         let cx = iface_inner.context();\n         socket\n             .connect(cx, remote_endpoint, port)\n\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -135,28 +123,84 @@ impl AnyBoundSocket {\n     }\n \n     pub fn iface(&self) -> &Arc<dyn Iface> {\n-        &self.iface\n+        &self.0.iface\n     }\n+}\n \n-    pub(super) fn weak_ref(&self) -> Weak<Self> {\n-        self.weak_self.clone()\n+impl Drop for AnyBoundSocket {\n+    fn drop(&mut self) {\n+        if self.0.start_closing() {\n+            self.0.iface.common().remove_bound_socket_now(&self.0);\n+        } else {\n+            self.0\n+                .iface\n+                .common()\n+                .remove_bound_socket_when_closed(&self.0);\n+        }\n     }\n+}\n \n-    fn close(&self) {\n+pub(super) struct AnyBoundSocketInner {\n+    iface: Arc<dyn Iface>,\n+    handle: smoltcp::iface::SocketHandle,\n+    port: u16,\n+    socket_family: SocketFamily,\n+    observer: RwLock<Weak<dyn Observer<()>>>,\n+}\n+\n+impl AnyBoundSocketInner {\n+    pub(super) fn on_iface_events(&self) {\n+        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n+            observer.on_events(&())\n+        }\n+    }\n+\n+    pub(super) fn is_closed(&self) -> bool {\n+        match self.socket_family {\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => true,\n+        }\n+    }\n+\n+    /// Starts closing the socket and returns whether the socket is closed.\n+    ///\n+    /// For sockets that can be closed immediately, such as UDP sockets and TCP listening sockets,\n+    /// this method will always return `true`.\n+    ///\n+    /// For other sockets, such as TCP connected sockets, they cannot be closed immediately because\n+    /// we at least need to send the FIN packet and wait for the remote end to send an ACK packet.\n+    /// In this case, this method will return `false` and [`Self::is_closed`] can be used to\n+    /// determine if the closing process is complete.\n+    fn start_closing(&self) -> bool {\n         match self.socket_family {\n-            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| socket.close()),\n-            SocketFamily::Udp => self.raw_with(|socket: &mut RawUdpSocket| socket.close()),\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.close();\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => {\n+                self.raw_with(|socket: &mut RawUdpSocket| socket.close());\n+                true\n+            }\n         }\n     }\n+\n+    pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n+        &self,\n+        mut f: F,\n+    ) -> R {\n+        let mut sockets = self.iface.sockets();\n+        let socket = sockets.get_mut::<T>(self.handle);\n+        f(socket)\n+    }\n }\n \n-impl Drop for AnyBoundSocket {\n+impl Drop for AnyBoundSocketInner {\n     fn drop(&mut self) {\n-        self.close();\n-        self.iface.poll();\n-        self.iface.common().remove_socket(self.handle);\n-        self.iface.common().release_port(self.port);\n-        self.iface.common().remove_bound_socket(self.weak_ref());\n+        let iface_common = self.iface.common();\n+        iface_common.remove_socket(self.handle);\n+        iface_common.release_port(self.port);\n     }\n }\n \n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,7 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n-use keyable_arc::KeyableWeak;\n+use keyable_arc::KeyableArc;\n use ostd::sync::WaitQueue;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -12,10 +12,10 @@ use smoltcp::{\n };\n \n use super::{\n-    any_socket::{AnyBoundSocket, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n+    any_socket::{AnyBoundSocketInner, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n     time::get_network_timestamp,\n     util::BindPortConfig,\n-    Iface, Ipv4Address,\n+    AnyBoundSocket, Iface, Ipv4Address,\n };\n use crate::prelude::*;\n \n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -25,7 +25,8 @@ pub struct IfaceCommon {\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n     /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n-    bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    bound_sockets: RwLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n+    closing_sockets: SpinLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n     /// The wait queue that background polling thread will sleep on\n     polling_wait_queue: WaitQueue,\n }\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -40,14 +41,21 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            closing_sockets: SpinLock::new(BTreeSet::new()),\n             polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \n+    /// Acquires the lock to the interface.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn interface(&self) -> SpinLockGuard<smoltcp::iface::Interface> {\n         self.interface.lock_irq_disabled()\n     }\n \n+    /// Acuqires the lock to the sockets.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn sockets(&self) -> SpinLockGuard<smoltcp::iface::SocketSet<'static>> {\n         self.sockets.lock_irq_disabled()\n     }\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -109,7 +117,7 @@ impl IfaceCommon {\n         iface: Arc<dyn Iface>,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let port = if let Some(port) = config.port() {\n             port\n         } else {\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -135,7 +143,7 @@ impl IfaceCommon {\n             ),\n         };\n         let bound_socket = AnyBoundSocket::new(iface, handle, port, socket_family, observer);\n-        self.insert_bound_socket(&bound_socket).unwrap();\n+        self.insert_bound_socket(bound_socket.inner());\n \n         Ok(bound_socket)\n     }\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n--- a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n@@ -13,12 +13,12 @@ use crate::{\n };\n \n pub struct BoundDatagram {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: Option<IpEndpoint>,\n }\n \n impl BoundDatagram {\n-    pub fn new(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new(bound_socket: AnyBoundSocket) -> Self {\n         Self {\n             bound_socket,\n             remote_endpoint: None,\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -15,7 +15,7 @@ use crate::{\n };\n \n pub struct ConnectedStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     /// Indicates whether this connection is \"new\" in a `connect()` system call.\n     ///\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -32,7 +32,7 @@ pub struct ConnectedStream {\n \n impl ConnectedStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n         is_new_connection: bool,\n     ) -> Self {\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub struct ConnectingStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     conn_result: RwLock<Option<ConnResult>>,\n }\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -26,9 +26,9 @@ pub enum NonConnectedStream {\n \n impl ConnectingStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         if let Err(err) = bound_socket.do_connect(remote_endpoint) {\n             return Err((err, bound_socket));\n         }\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -15,7 +15,7 @@ use crate::{\n \n pub enum InitStream {\n     Unbound(Box<AnyUnboundSocket>),\n-    Bound(Arc<AnyBoundSocket>),\n+    Bound(AnyBoundSocket),\n }\n \n impl InitStream {\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -23,14 +23,14 @@ impl InitStream {\n         InitStream::Unbound(Box::new(AnyUnboundSocket::new_tcp(observer)))\n     }\n \n-    pub fn new_bound(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new_bound(bound_socket: AnyBoundSocket) -> Self {\n         InitStream::Bound(bound_socket)\n     }\n \n     pub fn bind(\n         self,\n         endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let unbound_socket = match self {\n             InitStream::Unbound(unbound_socket) => unbound_socket,\n             InitStream::Bound(bound_socket) => {\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -50,7 +50,7 @@ impl InitStream {\n     fn bind_to_ephemeral_endpoint(\n         self,\n         remote_endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let endpoint = get_ephemeral_endpoint(remote_endpoint);\n         self.bind(&endpoint)\n     }\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -13,16 +13,16 @@ use crate::{\n pub struct ListenStream {\n     backlog: usize,\n     /// A bound socket held to ensure the TCP port cannot be released\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     /// Backlog sockets listening at the local endpoint\n     backlog_sockets: RwLock<Vec<BacklogSocket>>,\n }\n \n impl ListenStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         backlog: usize,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         let listen_stream = Self {\n             backlog,\n             bound_socket,\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -99,13 +99,13 @@ impl ListenStream {\n }\n \n struct BacklogSocket {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n }\n \n impl BacklogSocket {\n     // FIXME: All of the error codes below seem to have no Linux equivalents, and I see no reason\n     // why the error may occur. Perhaps it is better to call `unwrap()` directly?\n-    fn new(bound_socket: &Arc<AnyBoundSocket>) -> Result<Self> {\n+    fn new(bound_socket: &AnyBoundSocket) -> Result<Self> {\n         let local_endpoint = bound_socket.local_endpoint().ok_or(Error::with_message(\n             Errno::EINVAL,\n             \"the socket is not bound\",\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -143,7 +143,7 @@ impl BacklogSocket {\n             .raw_with(|socket: &mut RawTcpSocket| socket.remote_endpoint())\n     }\n \n-    fn into_bound_socket(self) -> Arc<AnyBoundSocket> {\n+    fn into_bound_socket(self) -> AnyBoundSocket {\n         self.bound_socket\n     }\n }\n\ndiff --git a/test/apps/network/listen_backlog.c b/test/apps/network/listen_backlog.c\n--- a/test/apps/network/listen_backlog.c\n+++ b/test/apps/network/listen_backlog.c\n@@ -131,7 +131,7 @@ int main(void)\n \n \tfor (backlog = 0; backlog <= MAX_TEST_BACKLOG; ++backlog) {\n \t\t// Avoid \"bind: Address already in use\"\n-\t\taddr.sin_port = htons(8080 + backlog);\n+\t\taddr.sin_port = htons(10000 + backlog);\n \n \t\terr = test_listen_backlog(&addr, backlog);\n \t\tif (err != 0)\n\ndiff --git a/test/apps/network/send_buf_full.c b/test/apps/network/send_buf_full.c\n--- a/test/apps/network/send_buf_full.c\n+++ b/test/apps/network/send_buf_full.c\n@@ -265,7 +265,7 @@ int main(void)\n \tstruct sockaddr_in addr;\n \n \taddr.sin_family = AF_INET;\n-\taddr.sin_port = htons(8080);\n+\taddr.sin_port = htons(9999);\n \tif (inet_aton(\"127.0.0.1\", &addr.sin_addr) < 0) {\n \t\tfprintf(stderr, \"inet_aton cannot parse 127.0.0.1\\n\");\n \t\treturn -1;\n\ndiff --git a/test/apps/network/tcp_err.c b/test/apps/network/tcp_err.c\n--- a/test/apps/network/tcp_err.c\n+++ b/test/apps/network/tcp_err.c\n@@ -338,26 +338,23 @@ FN_TEST(sendmsg_and_recvmsg)\n \n \t// Send two message and receive two message\n \n-\t// This test is commented out due to a known issue:\n-\t// See <https://github.com/asterinas/asterinas/issues/819>\n-\n-\t// iov[0].iov_base = message;\n-\t// iov[0].iov_len = strlen(message);\n-\t// msg.msg_iovlen = 1;\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\n-\t// char first_buffer[BUFFER_SIZE] = { 0 };\n-\t// char second_buffer[BUFFER_SIZE] = { 0 };\n-\t// iov[0].iov_base = first_buffer;\n-\t// iov[0].iov_len = BUFFER_SIZE;\n-\t// iov[1].iov_base = second_buffer;\n-\t// iov[1].iov_len = BUFFER_SIZE;\n-\t// msg.msg_iovlen = 2;\n-\n-\t// // Ensure two messages are prepared for receiving\n-\t// sleep(1);\n-\n-\t// TEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n+\tiov[0].iov_base = message;\n+\tiov[0].iov_len = strlen(message);\n+\tmsg.msg_iovlen = 1;\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\n+\tchar first_buffer[BUFFER_SIZE] = { 0 };\n+\tchar second_buffer[BUFFER_SIZE] = { 0 };\n+\tiov[0].iov_base = first_buffer;\n+\tiov[0].iov_len = BUFFER_SIZE;\n+\tiov[1].iov_base = second_buffer;\n+\tiov[1].iov_len = BUFFER_SIZE;\n+\tmsg.msg_iovlen = 2;\n+\n+\t// Ensure two messages are prepared for receiving\n+\tsleep(1);\n+\n+\tTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n }\n END_TEST()\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -146,37 +154,60 @@ impl IfaceCommon {\n     }\n \n     pub(super) fn poll<D: Device + ?Sized>(&self, device: &mut D) {\n+        let mut sockets = self.sockets.lock_irq_disabled();\n         let mut interface = self.interface.lock_irq_disabled();\n+\n         let timestamp = get_network_timestamp();\n-        let has_events = {\n-            let mut sockets = self.sockets.lock_irq_disabled();\n-            interface.poll(timestamp, device, &mut sockets)\n-            // drop sockets here to avoid deadlock\n-        };\n-        if has_events {\n-            self.bound_sockets.read().iter().for_each(|bound_socket| {\n-                if let Some(bound_socket) = bound_socket.upgrade() {\n-                    bound_socket.on_iface_events();\n+        let (has_events, poll_at) = {\n+            let mut has_events = false;\n+            let mut poll_at;\n+            loop {\n+                has_events |= interface.poll(timestamp, device, &mut sockets);\n+                poll_at = interface.poll_at(timestamp, &sockets);\n+                let Some(instant) = poll_at else {\n+                    break;\n+                };\n+                if instant > timestamp {\n+                    break;\n                 }\n-            });\n-        }\n+            }\n+            (has_events, poll_at)\n+        };\n+\n+        // drop sockets here to avoid deadlock\n+        drop(interface);\n+        drop(sockets);\n \n-        let sockets = self.sockets.lock_irq_disabled();\n-        if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n-            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+        if let Some(instant) = poll_at {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Relaxed);\n             let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms.store(new_instant, Ordering::Relaxed);\n \n-            if new_instant < old_instant {\n+            if old_instant == 0 || new_instant < old_instant {\n                 self.polling_wait_queue.wake_all();\n             }\n         } else {\n             self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n+\n+        if has_events {\n+            // We never try to hold the write lock in the IRQ context, and we disable IRQ when\n+            // holding the write lock. So we don't need to disable IRQ when holding the read lock.\n+            self.bound_sockets.read().iter().for_each(|bound_socket| {\n+                bound_socket.on_iface_events();\n+            });\n+\n+            let closed_sockets = self\n+                .closing_sockets\n+                .lock_irq_disabled()\n+                .extract_if(|closing_socket| closing_socket.is_closed())\n+                .collect::<Vec<_>>();\n+            drop(closed_sockets);\n+        }\n     }\n \n     pub(super) fn next_poll_at_ms(&self) -> Option<u64> {\n-        let millis = self.next_poll_at_ms.load(Ordering::SeqCst);\n+        let millis = self.next_poll_at_ms.load(Ordering::Relaxed);\n         if millis == 0 {\n             None\n         } else {\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -184,19 +215,44 @@ impl IfaceCommon {\n         }\n     }\n \n-    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocket>) -> Result<()> {\n-        let weak_ref = KeyableWeak::from(Arc::downgrade(socket));\n-        let mut bound_sockets = self.bound_sockets.write();\n-        if bound_sockets.contains(&weak_ref) {\n-            return_errno_with_message!(Errno::EINVAL, \"the socket is already bound\");\n-        }\n-        bound_sockets.insert(weak_ref);\n-        Ok(())\n+    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let inserted = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .insert(keyable_socket);\n+        assert!(inserted);\n     }\n \n-    pub(super) fn remove_bound_socket(&self, socket: Weak<AnyBoundSocket>) {\n-        let weak_ref = KeyableWeak::from(socket);\n-        self.bound_sockets.write().remove(&weak_ref);\n+    pub(super) fn remove_bound_socket_now(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+    }\n+\n+    pub(super) fn remove_bound_socket_when_closed(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+\n+        let mut closing_sockets = self.closing_sockets.lock_irq_disabled();\n+\n+        // Check `is_closed` after holding the lock to avoid race conditions.\n+        if keyable_socket.is_closed() {\n+            return;\n+        }\n+\n+        let inserted = closing_sockets.insert(keyable_socket);\n+        assert!(inserted);\n     }\n }\n \n\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -45,7 +45,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n         &self,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let common = self.common();\n         common.bind_socket(self.arc_self(), socket, config)\n     }\n\ndiff --git a/kernel/aster-nix/src/net/socket/ip/common.rs b/kernel/aster-nix/src/net/socket/ip/common.rs\n--- a/kernel/aster-nix/src/net/socket/ip/common.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/common.rs\n@@ -46,7 +46,7 @@ pub(super) fn bind_socket(\n     unbound_socket: Box<AnyUnboundSocket>,\n     endpoint: &IpEndpoint,\n     can_reuse: bool,\n-) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n     let iface = match get_iface_to_bind(&endpoint.addr) {\n         Some(iface) => iface,\n         None => {\n",
        "problem_statement": "Polling ifaces may not ensure packets be transmitted\nThe problem occurs when I trying to send two messages to the same TCP socket, and trying to receive the two messages at once.\r\n\r\n```C\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\n\r\n// Ensure two messages are ready for receiving\r\nsleep(1);\r\n\r\nTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\r\n```\r\n\r\nThe test program always succeeds when running on Linux.\r\n\r\nHowever, when running on Asterinas, `sk_connected` can only accept the first message.\r\n\r\nThe problem disappears when I running in set log level as TRACE. So it may be some problems with timeout.......\r\n\r\n# Possible solution\r\n\r\nThis problem may be related to the [nagle-enabled feature](https://docs.rs/smoltcp/latest/smoltcp/socket/tcp/struct.Socket.html#method.set_nagle_enabled), which disables small packets to be transmitted. If set `nagle-enabled` as false, the problem will also disappear.\r\n\r\nBut totally disabling this feature may affect performance. This feature is same as the `TCP_NODELAY` option in Linux, but Linux keeps this option on by default.\n",
        "hints_text": "",
        "created_at": "2024-07-26T01:51:02Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1035,
        "instance_id": "asterinas__asterinas-1035",
        "issue_numbers": [
            "868"
        ],
        "base_commit": "c7d2a908e04f359f99443e6ea9423fff736de361",
        "patch": "diff --git a/test/syscall_test/run_syscall_test.sh b/test/syscall_test/run_syscall_test.sh\n--- a/test/syscall_test/run_syscall_test.sh\n+++ b/test/syscall_test/run_syscall_test.sh\n@@ -25,7 +25,7 @@ get_blocklist_subtests(){\n \n     for extra_dir in $EXTRA_BLOCKLISTS_DIRS ; do\n         if [ -f $SCRIPT_DIR/$extra_dir/$1 ]; then\n-            BLOCK=\"${BLOCK}:$(sed ':a;N;$!ba;s/\\n/:/g' $SCRIPT_DIR/$extra_dir/$1)\"\n+            BLOCK=\"${BLOCK}:$(grep -v '^#' $SCRIPT_DIR/$extra_dir/$1 | tr '\\n' ':')\"\n         fi\n     done\n \n",
        "test_patch": "diff --git a/test/syscall_test/blocklists/epoll_test b/test/syscall_test/blocklists/epoll_test\n--- a/test/syscall_test/blocklists/epoll_test\n+++ b/test/syscall_test/blocklists/epoll_test\n@@ -6,4 +6,7 @@ EpollTest.EdgeTriggered_NoRandomSave\n EpollTest.OneshotAndEdgeTriggered\n EpollTest.CycleOfOneDisallowed\n EpollTest.CycleOfThreeDisallowed\n-EpollTest.CloseFile\n\\ No newline at end of file\n+EpollTest.CloseFile\n+# `UnblockWithSignal` contains races. Better not to enable it.\n+# See https://github.com/asterinas/asterinas/pull/1035 for details.\n+EpollTest.UnblockWithSignal\n\ndiff --git a/test/syscall_test/run_syscall_test.sh b/test/syscall_test/run_syscall_test.sh\n--- a/test/syscall_test/run_syscall_test.sh\n+++ b/test/syscall_test/run_syscall_test.sh\n@@ -17,7 +17,7 @@ NC='\\033[0m'\n \n get_blocklist_subtests(){\n     if [ -f $BLOCKLIST_DIR/$1 ]; then\n-        BLOCK=$(sed ':a;N;$!ba;s/\\n/:/g' $BLOCKLIST_DIR/$1)\n+        BLOCK=$(grep -v '^#' $BLOCKLIST_DIR/$1 | tr '\\n' ':')\n     else\n         BLOCK=\"\"\n         return 1\n",
        "problem_statement": "Epoll syscall tests crash occasionally\nWhen running tests with the command `make run AUTO_TEST=syscall ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1`, some `epoll` tests (from gvisor) will crash.\r\n\r\n```\r\nEpollTest.TimeoutNoFds\r\nEpollTest.UnblockWithNewFD\r\nEpollTest.Oneshot\r\n```\r\n\r\nThe above tests crashed with a \"page fault handler\" error with message \"page fault addr is not in current vmar\" (shown below).\r\n\r\n![Pasted Graphic 1](https://github.com/asterinas/asterinas/assets/7992257/962c8de2-9d90-4628-b37b-f4df420e74dc)\r\n\r\n```\r\nEpollTest.EdgeTriggered_NoRandomSave\r\nEpollTest.OneshotAndEdgeTriggered\r\nEpollTest.CloseFile\r\n```\r\n\r\nThe above tests crashed with a \"page fault handler\" error with message \"perm chech fails\" (shown below).\r\n\r\n![Pasted Graphic](https://github.com/asterinas/asterinas/assets/7992257/33aecc42-413a-4693-9fcd-0926ff263fde)\r\n\n",
        "hints_text": "",
        "created_at": "2024-07-07T20:03:32Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 928,
        "instance_id": "asterinas__asterinas-928",
        "issue_numbers": [
            "906"
        ],
        "base_commit": "e210e68920481c911f62f03ade0a780f96e48e24",
        "patch": "diff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -161,13 +161,6 @@ impl PageTableEntryTrait for PageTableEntry {\n         let flags = PageTableFlags::PRESENT.bits()\n             | PageTableFlags::WRITABLE.bits()\n             | PageTableFlags::USER.bits();\n-        #[cfg(feature = \"intel_tdx\")]\n-        let flags = flags\n-            | parse_flags!(\n-                prop.priv_flags.bits(),\n-                PrivFlags::SHARED,\n-                PageTableFlags::SHARED\n-            );\n         Self(paddr & Self::PHYS_ADDR_MASK | flags)\n     }\n \n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -11,15 +11,12 @@ use tdx_guest::{\n };\n use trapframe::TrapFrame;\n \n-use crate::{\n-    arch::mm::PageTableFlags,\n-    mm::{\n-        kspace::KERNEL_PAGE_TABLE,\n-        paddr_to_vaddr,\n-        page_prop::{CachePolicy, PageProperty, PrivilegedPageFlags as PrivFlags},\n-        page_table::PageTableError,\n-        KERNEL_BASE_VADDR, KERNEL_END_VADDR, PAGE_SIZE,\n-    },\n+use crate::mm::{\n+    kspace::{BOOT_PAGE_TABLE, KERNEL_BASE_VADDR, KERNEL_END_VADDR, KERNEL_PAGE_TABLE},\n+    paddr_to_vaddr,\n+    page_prop::{PageProperty, PrivilegedPageFlags as PrivFlags},\n+    page_table::PageTableError,\n+    PAGE_SIZE,\n };\n \n const SHARED_BIT: u8 = 51;\n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -416,16 +413,28 @@ pub unsafe fn unprotect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Pa\n     if gpa & PAGE_MASK != 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags | PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa(\n         (gpa & (!PAGE_MASK)) as u64 | SHARED_MASK,\n         (page_num * PAGE_SIZE) as u64,\n\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -452,16 +461,28 @@ pub unsafe fn protect_gpa_range(gpa: TdxGpa, page_num: usize) -> Result<(), Page\n     if gpa & !PAGE_MASK == 0 {\n         warn!(\"Misaligned address: {:x}\", gpa);\n     }\n-    let vaddr = paddr_to_vaddr(gpa);\n+    // Protect the page in the kernel page table.\n     let pt = KERNEL_PAGE_TABLE.get().unwrap();\n-    pt.protect(&(vaddr..page_num * PAGE_SIZE), |prop| {\n-        prop = PageProperty {\n+    let protect_op = |prop: &mut PageProperty| {\n+        *prop = PageProperty {\n             flags: prop.flags,\n             cache: prop.cache,\n             priv_flags: prop.priv_flags - PrivFlags::SHARED,\n         }\n-    })\n-    .map_err(PageConvertError::PageTableError)?;\n+    };\n+    let vaddr = paddr_to_vaddr(gpa);\n+    pt.protect(&(vaddr..page_num * PAGE_SIZE), protect_op)\n+        .map_err(PageConvertError::PageTableError)?;\n+    // Protect the page in the boot page table if in the boot phase.\n+    {\n+        let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+        if let Some(boot_pt) = boot_pt_lock.as_mut() {\n+            for i in 0..page_num {\n+                let vaddr = paddr_to_vaddr(gpa + i * PAGE_SIZE);\n+                boot_pt.protect_base_page(vaddr, protect_op);\n+            }\n+        }\n+    }\n     map_gpa((gpa & PAGE_MASK) as u64, (page_num * PAGE_SIZE) as u64)\n         .map_err(PageConvertError::TdVmcallError)?;\n     for i in 0..page_num {\n\ndiff --git a/framework/aster-frame/src/arch/x86/trap.rs b/framework/aster-frame/src/arch/x86/trap.rs\n--- a/framework/aster-frame/src/arch/x86/trap.rs\n+++ b/framework/aster-frame/src/arch/x86/trap.rs\n@@ -11,11 +11,7 @@ use tdx_guest::tdcall;\n use trapframe::TrapFrame;\n \n #[cfg(feature = \"intel_tdx\")]\n-use crate::arch::{\n-    cpu::VIRTUALIZATION_EXCEPTION,\n-    mm::PageTableFlags,\n-    tdx_guest::{handle_virtual_exception, TdxTrapFrame},\n-};\n+use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, PageFaultErrorCode, PAGE_FAULT},\n     cpu_local,\n\ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -76,15 +76,15 @@ pub fn init() {\n     boot::init();\n \n     mm::page::allocator::init();\n-    let mut boot_pt = mm::get_boot_pt();\n-    let meta_pages = mm::init_page_meta(&mut boot_pt);\n+    mm::kspace::init_boot_page_table();\n+    mm::kspace::init_kernel_page_table(mm::init_page_meta());\n     mm::misc_init();\n \n     trap::init();\n     arch::after_all_init();\n     bus::init();\n \n-    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\n+    mm::kspace::activate_kernel_page_table();\n \n     invoke_ffi_init_funcs();\n }\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -7,24 +7,27 @@\n //! The kernel memory space is currently managed as follows, if the\n //! address width is 48 bits (with 47 bits kernel space).\n //!\n+//! TODO: the cap of linear mapping (the start of vm alloc) are raised\n+//! to workaround for high IO in TDX. We need actual vm alloc API to have\n+//! a proper fix.\n+//!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n //! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n-//! +-+ <- 0xffff_e100_0000_0000\n-//! | |         For frame metadata, 1 TiB. Mapped frames are untracked.\n-//! +-+ <- 0xffff_e000_0000_0000\n-//! | |\n-//! | |         For vm alloc/io mappings, 32 TiB.\n+//! +-+ <- 0xffff_ff00_0000_0000\n+//! | |         For frame metadata, 1 TiB.\n+//! | |         Mapped frames are untracked.\n+//! +-+ <- 0xffff_fe00_0000_0000\n+//! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\n+//! +-+ <- 0xffff_fd00_0000_0000\n //! | |\n-//! +-+ <- the middle of the higher half (0xffff_c000_0000_0000)\n //! | |\n //! | |\n-//! | |\n-//! | |         For linear mappings, 64 TiB.\n+//! | |         For linear mappings.\n //! | |         Mapped physical addresses are untracked.\n //! | |\n //! | |\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -36,7 +39,7 @@\n //! 39 bits or 57 bits, the memory space just adjust porportionally.\n \n use alloc::vec::Vec;\n-use core::ops::Range;\n+use core::{mem::ManuallyDrop, ops::Range};\n \n use align_ext::AlignExt;\n use log::info;\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -52,7 +55,10 @@ use super::{\n     page_table::{boot_pt::BootPageTable, KernelMode, PageTable},\n     MemoryRegionType, Paddr, PagingConstsTrait, Vaddr, PAGE_SIZE,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    sync::SpinLock,\n+};\n \n /// The shortest supported address width is 39 bits. And the literal\n /// values are written for 48 bits address width. Adjust the values\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -95,9 +101,25 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// The boot page table instance.\n+///\n+/// It is used in the initialization phase before [`KERNEL_PAGE_TABLE`] is activated.\n+/// Since we want dropping the boot page table unsafe, it is wrapped in a [`ManuallyDrop`].\n+pub static BOOT_PAGE_TABLE: SpinLock<Option<ManuallyDrop<BootPageTable>>> = SpinLock::new(None);\n+\n+/// The kernel page table instance.\n+///\n+/// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\n+/// is unlikely to be activated.\n pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingConsts>> =\n     Once::new();\n \n+/// Initializes the boot page table.\n+pub(crate) fn init_boot_page_table() {\n+    let boot_pt = BootPageTable::from_current_pt();\n+    *BOOT_PAGE_TABLE.lock() = Some(ManuallyDrop::new(boot_pt));\n+}\n+\n /// Initializes the kernel page table.\n ///\n /// This function should be called after:\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -106,10 +128,7 @@ pub static KERNEL_PAGE_TABLE: Once<PageTable<KernelMode, PageTableEntry, PagingC\n ///\n /// This function should be called before:\n ///  - any initializer that modifies the kernel page table.\n-pub fn init_kernel_page_table(\n-    boot_pt: BootPageTable<PageTableEntry, PagingConsts>,\n-    meta_pages: Vec<Range<Paddr>>,\n-) {\n+pub fn init_kernel_page_table(meta_pages: Vec<Range<Paddr>>) {\n     info!(\"Initializing the kernel page table\");\n \n     let regions = crate::boot::memory_regions();\n\ndiff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -201,15 +220,21 @@ pub fn init_kernel_page_table(\n         }\n     }\n \n+    KERNEL_PAGE_TABLE.call_once(|| kpt);\n+}\n+\n+pub fn activate_kernel_page_table() {\n+    let kpt = KERNEL_PAGE_TABLE\n+        .get()\n+        .expect(\"The kernel page table is not initialized yet\");\n     // SAFETY: the kernel page table is initialized properly.\n     unsafe {\n         kpt.first_activate_unchecked();\n         crate::arch::mm::tlb_flush_all_including_global();\n     }\n \n-    KERNEL_PAGE_TABLE.call_once(|| kpt);\n-\n-    // SAFETY: the boot page table is OK to be retired now since\n+    // SAFETY: the boot page table is OK to be dropped now since\n     // the kernel page table is activated.\n-    unsafe { boot_pt.retire() };\n+    let mut boot_pt = BOOT_PAGE_TABLE.lock().take().unwrap();\n+    unsafe { ManuallyDrop::drop(&mut boot_pt) };\n }\n\ndiff --git a/framework/aster-frame/src/mm/mod.rs b/framework/aster-frame/src/mm/mod.rs\n--- a/framework/aster-frame/src/mm/mod.rs\n+++ b/framework/aster-frame/src/mm/mod.rs\n@@ -131,7 +131,3 @@ pub(crate) fn misc_init() {\n     }\n     FRAMEBUFFER_REGIONS.call_once(|| framebuffer_regions);\n }\n-\n-pub(crate) fn get_boot_pt() -> page_table::boot_pt::BootPageTable {\n-    unsafe { page_table::boot_pt::BootPageTable::from_current_pt() }\n-}\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -53,12 +53,9 @@ use super::Page;\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr,\n-        page::allocator::FRAME_ALLOCATOR,\n-        page_size,\n-        page_table::{boot_pt::BootPageTable, PageTableEntryTrait},\n-        CachePolicy, Paddr, PageFlags, PageProperty, PagingConstsTrait, PagingLevel,\n-        PrivilegedPageFlags, PAGE_SIZE,\n+        kspace::BOOT_PAGE_TABLE, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, page_size,\n+        page_table::PageTableEntryTrait, CachePolicy, Paddr, PageFlags, PageProperty,\n+        PagingConstsTrait, PagingLevel, PrivilegedPageFlags, PAGE_SIZE,\n     },\n };\n \n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -191,7 +188,7 @@ impl PageMeta for KernelMeta {\n /// Initializes the metadata of all physical pages.\n ///\n /// The function returns a list of `Page`s containing the metadata.\n-pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n+pub(crate) fn init() -> Vec<Range<Paddr>> {\n     let max_paddr = {\n         let regions = crate::boot::memory_regions();\n         regions.iter().map(|r| r.base() + r.len()).max().unwrap()\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -207,8 +204,11 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n     let num_pages = max_paddr / page_size::<PagingConsts>(1);\n     let num_meta_pages = (num_pages * size_of::<MetaSlot>()).div_ceil(PAGE_SIZE);\n     let meta_pages = alloc_meta_pages(num_meta_pages);\n-\n     // Map the metadata pages.\n+    let mut boot_pt_lock = BOOT_PAGE_TABLE.lock();\n+    let boot_pt = boot_pt_lock\n+        .as_mut()\n+        .expect(\"boot page table not initialized\");\n     for (i, frame_paddr) in meta_pages.iter().enumerate() {\n         let vaddr = mapping::page_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n         let prop = PageProperty {\n\ndiff --git a/framework/aster-frame/src/mm/page/meta.rs b/framework/aster-frame/src/mm/page/meta.rs\n--- a/framework/aster-frame/src/mm/page/meta.rs\n+++ b/framework/aster-frame/src/mm/page/meta.rs\n@@ -216,9 +216,9 @@ pub(crate) fn init(boot_pt: &mut BootPageTable) -> Vec<Range<Paddr>> {\n             cache: CachePolicy::Writeback,\n             priv_flags: PrivilegedPageFlags::GLOBAL,\n         };\n-        boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop);\n+        // SAFETY: we are doing the metadata mappings for the kernel.\n+        unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n     }\n-\n     // Now the metadata pages are mapped, we can initialize the metadata.\n     meta_pages\n         .into_iter()\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -10,8 +10,8 @@ use super::{pte_index, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n-        paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty, PagingConstsTrait, Vaddr,\n-        PAGE_SIZE,\n+        nr_subpage_per_huge, paddr_to_vaddr, page::allocator::FRAME_ALLOCATOR, PageProperty,\n+        PagingConstsTrait, Vaddr, PAGE_SIZE,\n     },\n };\n \n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -34,10 +34,7 @@ pub struct BootPageTable<\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     /// Creates a new boot page table from the current page table root physical address.\n-    ///\n-    /// The caller must ensure that the current page table may be set up by the firmware,\n-    /// loader or the setup code.\n-    pub unsafe fn from_current_pt() -> Self {\n+    pub fn from_current_pt() -> Self {\n         let root_paddr = crate::arch::mm::current_page_table_paddr();\n         Self {\n             root_pt: root_paddr / C::BASE_PAGE_SIZE,\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -47,8 +44,16 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n     }\n \n     /// Maps a base page to a frame.\n+    ///\n+    /// # Panics\n+    ///\n     /// This function will panic if the page is already mapped.\n-    pub fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n         let mut pt = self.root_pt;\n         let mut level = C::NR_LEVELS;\n         // Walk to the last level of the page table.\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -77,6 +82,67 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { pte_ptr.write(E::new_frame(to * C::BASE_PAGE_SIZE, 1, prop)) };\n     }\n \n+    /// Maps a base page to a frame.\n+    ///\n+    /// This function may split a huge page into base pages, causing page allocations\n+    /// if the original mapping is a huge page.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the page is already mapped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it can cause undefined behavior if the caller\n+    /// maps a page in the kernel address space.\n+    pub unsafe fn protect_base_page(\n+        &mut self,\n+        virt_addr: Vaddr,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) {\n+        let mut pt = self.root_pt;\n+        let mut level = C::NR_LEVELS;\n+        // Walk to the last level of the page table.\n+        while level > 1 {\n+            let index = pte_index::<C>(virt_addr, level);\n+            let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+            let pte = unsafe { pte_ptr.read() };\n+            pt = if !pte.is_present() {\n+                panic!(\"protecting an unmapped page in the boot page table\");\n+            } else if pte.is_last(level) {\n+                // Split the huge page.\n+                let frame = self.alloc_frame();\n+                let huge_pa = pte.paddr();\n+                for i in 0..nr_subpage_per_huge::<C>() {\n+                    let nxt_ptr =\n+                        unsafe { (paddr_to_vaddr(frame * C::BASE_PAGE_SIZE) as *mut E).add(i) };\n+                    unsafe {\n+                        nxt_ptr.write(E::new_frame(\n+                            huge_pa + i * C::BASE_PAGE_SIZE,\n+                            level - 1,\n+                            pte.prop(),\n+                        ))\n+                    };\n+                }\n+                unsafe { pte_ptr.write(E::new_pt(frame * C::BASE_PAGE_SIZE)) };\n+                frame\n+            } else {\n+                pte.paddr() / C::BASE_PAGE_SIZE\n+            };\n+            level -= 1;\n+        }\n+        // Do protection in the last level page table.\n+        let index = pte_index::<C>(virt_addr, 1);\n+        let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n+        let pte = unsafe { pte_ptr.read() };\n+        if !pte.is_present() {\n+            panic!(\"protecting an unmapped page in the boot page table\");\n+        }\n+        let mut prop = pte.prop();\n+        op(&mut prop);\n+        unsafe { pte_ptr.write(E::new_frame(pte.paddr(), 1, prop)) };\n+    }\n+\n     fn alloc_frame(&mut self) -> FrameNumber {\n         let frame = FRAME_ALLOCATOR.get().unwrap().lock().alloc(1).unwrap();\n         self.frames.push(frame);\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -85,43 +151,19 @@ impl<E: PageTableEntryTrait, C: PagingConstsTrait> BootPageTable<E, C> {\n         unsafe { core::ptr::write_bytes(vaddr, 0, PAGE_SIZE) };\n         frame\n     }\n-\n-    /// Retires this boot-stage page table.\n-    ///\n-    /// Do not drop a boot-stage page table. Instead, retire it.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method can only be called when this boot-stage page table is no longer in use,\n-    /// e.g., after the permanent kernel page table has been activated.\n-    pub unsafe fn retire(mut self) {\n-        // Manually free all heap and frame memory allocated.\n-        let frames = core::mem::take(&mut self.frames);\n-        for frame in frames {\n-            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(frame, 1);\n-        }\n-        // We do not want or need to trigger drop.\n-        core::mem::forget(self);\n-        // FIXME: an empty `Vec` is leaked on the heap here since the drop is not called\n-        // and we have no ways to free it.\n-        // The best solution to recycle the boot-phase page table is to initialize all\n-        // page table page metadata of the boot page table by page walk after the metadata\n-        // pages are mapped. Therefore the boot page table can be recycled or dropped by\n-        // the routines in the [`super::node`] module. There's even without a need of\n-        // `first_activate` concept if the boot page table can be managed by page table\n-        // pages.\n-    }\n }\n \n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for BootPageTable<E, C> {\n     fn drop(&mut self) {\n-        panic!(\"the boot page table is dropped rather than retired.\");\n+        for frame in &self.frames {\n+            FRAME_ALLOCATOR.get().unwrap().lock().dealloc(*frame, 1);\n+        }\n     }\n }\n \n #[cfg(ktest)]\n #[ktest]\n-fn test_boot_pt() {\n+fn test_boot_pt_map_protect() {\n     use super::page_walk;\n     use crate::{\n         arch::mm::{PageTableEntry, PagingConsts},\n\ndiff --git a/framework/aster-frame/src/mm/page_table/boot_pt.rs b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n--- a/framework/aster-frame/src/mm/page_table/boot_pt.rs\n+++ b/framework/aster-frame/src/mm/page_table/boot_pt.rs\n@@ -140,20 +182,34 @@ fn test_boot_pt() {\n     let from1 = 0x1000;\n     let to1 = 0x2;\n     let prop1 = PageProperty::new(PageFlags::RW, CachePolicy::Writeback);\n-    boot_pt.map_base_page(from1, to1, prop1);\n+    unsafe { boot_pt.map_base_page(from1, to1, prop1) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n         Some((to1 * PAGE_SIZE + 1, prop1))\n     );\n+    unsafe { boot_pt.protect_base_page(from1, |prop| prop.flags = PageFlags::RX) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from1 + 1) },\n+        Some((\n+            to1 * PAGE_SIZE + 1,\n+            PageProperty::new(PageFlags::RX, CachePolicy::Writeback)\n+        ))\n+    );\n \n     let from2 = 0x2000;\n     let to2 = 0x3;\n     let prop2 = PageProperty::new(PageFlags::RX, CachePolicy::Uncacheable);\n-    boot_pt.map_base_page(from2, to2, prop2);\n+    unsafe { boot_pt.map_base_page(from2, to2, prop2) };\n     assert_eq!(\n         unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n         Some((to2 * PAGE_SIZE + 2, prop2))\n     );\n-\n-    unsafe { boot_pt.retire() }\n+    unsafe { boot_pt.protect_base_page(from2, |prop| prop.flags = PageFlags::RW) };\n+    assert_eq!(\n+        unsafe { page_walk::<PageTableEntry, PagingConsts>(root_paddr, from2 + 2) },\n+        Some((\n+            to2 * PAGE_SIZE + 2,\n+            PageProperty::new(PageFlags::RW, CachePolicy::Uncacheable)\n+        ))\n+    );\n }\n",
        "test_patch": "diff --git a/framework/aster-frame/src/mm/kspace.rs b/framework/aster-frame/src/mm/kspace.rs\n--- a/framework/aster-frame/src/mm/kspace.rs\n+++ b/framework/aster-frame/src/mm/kspace.rs\n@@ -76,12 +82,12 @@ pub fn kernel_loaded_offset() -> usize {\n \n const KERNEL_CODE_BASE_VADDR: usize = 0xffff_ffff_8000_0000 << ADDR_WIDTH_SHIFT;\n \n-const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_e100_0000_0000 << ADDR_WIDTH_SHIFT;\n-const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_e000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_CAP_VADDR: Vaddr = 0xffff_ff00_0000_0000 << ADDR_WIDTH_SHIFT;\n+const FRAME_METADATA_BASE_VADDR: Vaddr = 0xffff_fe00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub(in crate::mm) const FRAME_METADATA_RANGE: Range<Vaddr> =\n     FRAME_METADATA_BASE_VADDR..FRAME_METADATA_CAP_VADDR;\n \n-const VMALLOC_BASE_VADDR: Vaddr = 0xffff_c000_0000_0000 << ADDR_WIDTH_SHIFT;\n+const VMALLOC_BASE_VADDR: Vaddr = 0xffff_fd00_0000_0000 << ADDR_WIDTH_SHIFT;\n pub const VMALLOC_VADDR_RANGE: Range<Vaddr> = VMALLOC_BASE_VADDR..FRAME_METADATA_BASE_VADDR;\n \n /// The base address of the linear mapping of all physical\n",
        "problem_statement": "[TDX BUG] The TDX SHARED bit can\u2018t be set in the page table during IOAPIC initialization.\nIn `framework/aster-frame/src/arch/x86/tdx_guest.rs`:\r\n```rust\r\n    trap::init();\r\n    arch::after_all_init();\r\n    bus::init();\r\n\r\n    mm::kspace::init_kernel_page_table(boot_pt, meta_pages);\r\n```\r\n\r\nThe kernel page table is initialized and activated in the `init_kernel_page_table` function. This step occurs after ioapic is initialized (via `after_all_init` function).\r\n\r\nHowever, we should set the ioapic MMIO space as shared page in TDX env, this process manipulates the page table, but the page table is not yet activated.\r\n\n",
        "hints_text": "",
        "created_at": "2024-06-12T07:29:38Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 954,
        "instance_id": "asterinas__asterinas-954",
        "issue_numbers": [
            "871"
        ],
        "base_commit": "cd2b305fa890bca9c4374ccd83c9ccb24bf8dda3",
        "patch": "diff --git a/docs/src/ostd/a-100-line-kernel.md b/docs/src/ostd/a-100-line-kernel.md\n--- a/docs/src/ostd/a-100-line-kernel.md\n+++ b/docs/src/ostd/a-100-line-kernel.md\n@@ -7,23 +7,7 @@ we will show a new kernel in about 100 lines of safe Rust.\n Our new kernel will be able to run the following Hello World program.\n \n ```s\n-.global _start                      # entry point\n-.section .text                      # code section\n-_start:\n-    mov     $1, %rax                # syscall number of write\n-    mov     $1, %rdi                # stdout\n-    mov     $message, %rsi          # address of message         \n-    mov     $message_end, %rdx\n-    sub     %rsi, %rdx              # calculate message len\n-    syscall\n-    mov     $60, %rax               # syscall number of exit, move it to rax\n-    mov     $0, %rdi                # exit code, move it to rdi\n-    syscall  \n-\n-.section .rodata                    # read only data section\n-message:\n-    .ascii  \"Hello, world\\n\"\n-message_end:\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S}}\n ```\n \n The assembly program above can be compiled with the following command.\n\ndiff --git a/docs/src/ostd/a-100-line-kernel.md b/docs/src/ostd/a-100-line-kernel.md\n--- a/docs/src/ostd/a-100-line-kernel.md\n+++ b/docs/src/ostd/a-100-line-kernel.md\n@@ -42,131 +26,5 @@ Comments are added\n to highlight how the APIs of Asterinas OSTD enable safe kernel development.\n \n ```rust\n-#![no_std]\n-\n-extern crate alloc;\n-\n-use align_ext::AlignExt;\n-use core::str;\n-\n-use alloc::sync::Arc;\n-use alloc::vec;\n-\n-use ostd::cpu::UserContext;\n-use ostd::prelude::*;\n-use ostd::task::{Task, TaskOptions};\n-use ostd::user::{ReturnReason, UserMode, UserSpace};\n-use ostd::mm::{PageFlags, PAGE_SIZE, Vaddr, FrameAllocOptions, VmIo, VmMapOptions, VmSpace};\n-\n-/// The kernel's boot and initialization process is managed by Asterinas OSTD.\n-/// After the process is done, the kernel's execution environment\n-/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n-/// labeled as `#[ostd::main]` will be called.\n-#[ostd::main]\n-pub fn main() {\n-    let program_binary = include_bytes!(\"../hello_world\");\n-    let user_space = create_user_space(program_binary);\n-    let user_task = create_user_task(Arc::new(user_space));\n-    user_task.run();\n-}\n-\n-fn create_user_space(program: &[u8]) -> UserSpace {\n-    let user_pages = {\n-        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n-        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n-        // Phyiscal memory pages can be only accessed\n-        // via the Frame abstraction.\n-        vm_frames.write_bytes(0, program).unwrap();\n-        vm_frames\n-    };\n-    let user_address_space = {\n-        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n-\n-        // The page table of the user space can be\n-        // created and manipulated safely through\n-        // the VmSpace abstraction.\n-        let vm_space = VmSpace::new();\n-        let mut options = VmMapOptions::new();\n-        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n-        vm_space.map(user_pages, &options).unwrap();\n-        vm_space\n-    };\n-    let user_cpu_state = {\n-        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n-\n-        // The user-space CPU states can be initialized\n-        // to arbitrary values via the UserContext\n-        // abstraction.\n-        let mut user_cpu_state = UserContext::default();\n-        user_cpu_state.set_rip(ENTRY_POINT);\n-        user_cpu_state\n-    };\n-    UserSpace::new(user_address_space, user_cpu_state)\n-}\n-\n-fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n-    fn user_task() {\n-        let current = Task::current();\n-        // Switching between user-kernel space is\n-        // performed via the UserMode abstraction.\n-        let mut user_mode = {\n-            let user_space = current.user_space().unwrap();\n-            UserMode::new(user_space)\n-        };\n-\n-        loop {\n-            // The execute method returns when system\n-            // calls or CPU exceptions occur or some\n-            // events specified by the kernel occur.\n-            let return_reason = user_mode.execute(|| false);\n-\n-            // The CPU registers of the user space\n-            // can be accessed and manipulated via\n-            // the `UserContext` abstraction.\n-            let user_context = user_mode.context_mut();\n-            if ReturnReason::UserSyscall == return_reason {\n-                handle_syscall(user_context, current.user_space().unwrap());\n-            }\n-        }\n-    }\n-\n-    // Kernel tasks are managed by OSTD,\n-    // while scheduling algorithms for them can be\n-    // determined by the users of OSTD.\n-    TaskOptions::new(user_task)\n-        .user_space(Some(user_space))\n-        .data(0)\n-        .build()\n-        .unwrap()\n-}\n-\n-fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n-    const SYS_WRITE: usize = 1;\n-    const SYS_EXIT: usize = 60;\n-\n-    match user_context.rax() {\n-        SYS_WRITE => {\n-            // Access the user-space CPU registers safely.\n-            let (_, buf_addr, buf_len) =\n-                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n-            let buf = {\n-                let mut buf = vec![0u8; buf_len];\n-                // Copy data from the user space without\n-                // unsafe pointer dereferencing.\n-                user_space\n-                    .vm_space()\n-                    .read_bytes(buf_addr, &mut buf)\n-                    .unwrap();\n-                buf\n-            };\n-            // Use the console for output safely.\n-            println!(\"{}\", str::from_utf8(&buf).unwrap());\n-            // Manipulate the user-space CPU registers safely.\n-            user_context.set_rax(buf_len);\n-        }\n-        SYS_EXIT => Task::current().exit(),\n-        _ => unimplemented!(),\n-    }\n-}\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs}}\n ```\n-\n\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -158,7 +158,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n     cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // FIXME: Uses a fixed tag instaed of relies on remote branch\n+    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n+    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\n\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -1,7 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use std::{\n-    env,\n     fs::{self, OpenOptions},\n     io::Write,\n     path::PathBuf,\n\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\n@@ -0,0 +1,19 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n+.global _start                      # entry point\n+.section .text                      # code section\n+_start:\n+    mov     $1, %rax                # syscall number of write\n+    mov     $1, %rdi                # stdout\n+    mov     $message, %rsi          # address of message         \n+    mov     $message_end, %rdx\n+    sub     %rsi, %rdx              # calculate message len\n+    syscall\n+    mov     $60, %rax               # syscall number of exit, move it to rax\n+    mov     $0, %rdi                # exit code, move it to rdi\n+    syscall  \n+\n+.section .rodata                    # read only data section\n+message:\n+    .ascii  \"Hello, world\\n\"\n+message_end:\n\\ No newline at end of file\n\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -0,0 +1,132 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#![no_std]\n+\n+extern crate alloc;\n+\n+use align_ext::AlignExt;\n+use core::str;\n+\n+use alloc::sync::Arc;\n+use alloc::vec;\n+\n+use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n+use ostd::cpu::UserContext;\n+use ostd::mm::{\n+    FrameAllocOptions, PageFlags, Vaddr, VmIo, VmMapOptions, VmSpace, VmWriter, PAGE_SIZE,\n+};\n+use ostd::prelude::*;\n+use ostd::task::{Task, TaskOptions};\n+use ostd::user::{ReturnReason, UserMode, UserSpace};\n+\n+/// The kernel's boot and initialization process is managed by OSTD.\n+/// After the process is done, the kernel's execution environment\n+/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n+/// labeled as `#[ostd::main]` will be called.\n+#[ostd::main]\n+pub fn main() {\n+    let program_binary = include_bytes!(\"../hello\");\n+    let user_space = create_user_space(program_binary);\n+    let user_task = create_user_task(Arc::new(user_space));\n+    user_task.run();\n+}\n+\n+fn create_user_space(program: &[u8]) -> UserSpace {\n+    let user_pages = {\n+        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n+        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n+        // Phyiscal memory pages can be only accessed\n+        // via the Frame abstraction.\n+        vm_frames.write_bytes(0, program).unwrap();\n+        vm_frames\n+    };\n+    let user_address_space = {\n+        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n+\n+        // The page table of the user space can be\n+        // created and manipulated safely through\n+        // the VmSpace abstraction.\n+        let vm_space = VmSpace::new();\n+        let mut options = VmMapOptions::new();\n+        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n+        vm_space.map(user_pages, &options).unwrap();\n+        Arc::new(vm_space)\n+    };\n+    let user_cpu_state = {\n+        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n+\n+        // The user-space CPU states can be initialized\n+        // to arbitrary values via the UserContext\n+        // abstraction.\n+        let mut user_cpu_state = UserContext::default();\n+        user_cpu_state.set_rip(ENTRY_POINT);\n+        user_cpu_state\n+    };\n+    UserSpace::new(user_address_space, user_cpu_state)\n+}\n+\n+fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n+    fn user_task() {\n+        let current = Task::current();\n+        // Switching between user-kernel space is\n+        // performed via the UserMode abstraction.\n+        let mut user_mode = {\n+            let user_space = current.user_space().unwrap();\n+            UserMode::new(user_space)\n+        };\n+\n+        loop {\n+            // The execute method returns when system\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n+            // The CPU registers of the user space\n+            // can be accessed and manipulated via\n+            // the `UserContext` abstraction.\n+            let user_context = user_mode.context_mut();\n+            if ReturnReason::UserSyscall == return_reason {\n+                handle_syscall(user_context, current.user_space().unwrap());\n+            }\n+        }\n+    }\n+\n+    // Kernel tasks are managed by the Framework,\n+    // while scheduling algorithms for them can be\n+    // determined by the users of the Framework.\n+    TaskOptions::new(user_task)\n+        .user_space(Some(user_space))\n+        .data(0)\n+        .build()\n+        .unwrap()\n+}\n+\n+fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n+    const SYS_WRITE: usize = 1;\n+    const SYS_EXIT: usize = 60;\n+\n+    match user_context.rax() {\n+        SYS_WRITE => {\n+            // Access the user-space CPU registers safely.\n+            let (_, buf_addr, buf_len) =\n+                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n+            let buf = {\n+                let mut buf = vec![0u8; buf_len];\n+                // Copy data from the user space without\n+                // unsafe pointer dereferencing.\n+                let current_vm_space = user_space.vm_space();\n+                let mut reader = current_vm_space.reader(buf_addr, buf_len).unwrap();\n+                reader\n+                    .read_fallible(&mut VmWriter::from(&mut buf as &mut [u8]))\n+                    .unwrap();\n+                buf\n+            };\n+            // Use the console for output safely.\n+            println!(\"{}\", str::from_utf8(&buf).unwrap());\n+            // Manipulate the user-space CPU registers safely.\n+            user_context.set_rax(buf_len);\n+        }\n+        SYS_EXIT => exit_qemu(QemuExitCode::Success),\n+        _ => unimplemented!(),\n+    }\n+}\n",
        "test_patch": "diff --git a/osdk/tests/examples_in_book/mod.rs b/osdk/tests/examples_in_book/mod.rs\n--- a/osdk/tests/examples_in_book/mod.rs\n+++ b/osdk/tests/examples_in_book/mod.rs\n@@ -5,3 +5,4 @@\n mod create_os_projects;\n mod test_and_run_projects;\n mod work_in_workspace;\n+mod write_a_kernel_in_100_lines;\n\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -21,7 +20,6 @@ fn work_in_workspace() {\n     }\n \n     fs::create_dir_all(&workspace_dir).unwrap();\n-    env::set_current_dir(&workspace_dir).unwrap();\n \n     let workspace_toml = include_str!(\"work_in_workspace_templates/Cargo.toml\");\n     fs::write(workspace_dir.join(\"Cargo.toml\"), workspace_toml).unwrap();\n\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -29,8 +27,14 @@ fn work_in_workspace() {\n     // Create a kernel project and a library project\n     let kernel = \"myos\";\n     let module = \"mylib\";\n-    cargo_osdk(&[\"new\", \"--kernel\", kernel]).ok().unwrap();\n-    cargo_osdk(&[\"new\", module]).ok().unwrap();\n+    cargo_osdk(&[\"new\", \"--kernel\", kernel])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    cargo_osdk(&[\"new\", module])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Add a test function to mylib/src/lib.rs\n     let module_src_path = workspace_dir.join(module).join(\"src\").join(\"lib.rs\");\n\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -75,13 +79,22 @@ fn work_in_workspace() {\n     .unwrap();\n \n     // Run subcommand build & run\n-    cargo_osdk(&[\"build\"]).ok().unwrap();\n-    let output = cargo_osdk(&[\"run\"]).output().unwrap();\n+    cargo_osdk(&[\"build\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    let output = cargo_osdk(&[\"run\"])\n+        .current_dir(&workspace_dir)\n+        .output()\n+        .unwrap();\n     let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n     assert!(stdout.contains(\"The available memory is\"));\n \n     // Run subcommand test\n-    cargo_osdk(&[\"test\"]).ok().unwrap();\n+    cargo_osdk(&[\"test\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Remove the directory\n     fs::remove_dir_all(&workspace_dir).unwrap();\n\ndiff --git /dev/null b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\nnew file mode 100644\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\n@@ -0,0 +1,65 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use std::{fs, path::PathBuf, process::Command};\n+\n+use assert_cmd::output::OutputOkExt;\n+\n+use crate::util::{cargo_osdk, depends_on_local_ostd};\n+\n+#[test]\n+fn write_a_kernel_in_100_lines() {\n+    let workdir = \"/tmp\";\n+    let os_name = \"kernel_in_100_lines\";\n+\n+    let os_dir = PathBuf::from(workdir).join(os_name);\n+\n+    if os_dir.exists() {\n+        fs::remove_dir_all(&os_dir).unwrap()\n+    }\n+\n+    // Creates a new kernel project\n+    cargo_osdk(&[\"new\", \"--kernel\", os_name])\n+        .current_dir(&workdir)\n+        .ok()\n+        .unwrap();\n+\n+    // Depends on local OSTD\n+    let manifest_path = os_dir.join(\"Cargo.toml\");\n+    depends_on_local_ostd(manifest_path);\n+\n+    // Copies the kernel content\n+    let kernel_contents = include_str!(\"write_a_kernel_in_100_lines_templates/lib.rs\");\n+    fs::write(os_dir.join(\"src\").join(\"lib.rs\"), kernel_contents).unwrap();\n+\n+    // Copies and compiles the user program\n+    let user_program_contents = include_str!(\"write_a_kernel_in_100_lines_templates/hello.S\");\n+    fs::write(os_dir.join(\"hello.S\"), user_program_contents).unwrap();\n+    Command::new(\"gcc\")\n+        .args(&[\"-static\", \"-nostdlib\", \"hello.S\", \"-o\", \"hello\"])\n+        .current_dir(&os_dir)\n+        .ok()\n+        .unwrap();\n+\n+    // Adds align ext as the dependency\n+    let file_contents = fs::read_to_string(os_dir.join(\"Cargo.toml\")).unwrap();\n+    let mut manifest: toml::Table = toml::from_str(&file_contents).unwrap();\n+    let dependencies = manifest\n+        .get_mut(\"dependencies\")\n+        .unwrap()\n+        .as_table_mut()\n+        .unwrap();\n+    dependencies.insert(\n+        \"align_ext\".to_string(),\n+        toml::Value::String(\"0.1.0\".to_string()),\n+    );\n+\n+    let new_file_content = manifest.to_string();\n+    fs::write(os_dir.join(\"Cargo.toml\"), new_file_content).unwrap();\n+\n+    // Runs the kernel\n+    let output = cargo_osdk(&[\"run\"]).current_dir(&os_dir).ok().unwrap();\n+    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+    println!(\"stdout = {}\", stdout);\n+\n+    fs::remove_dir_all(&os_dir).unwrap();\n+}\n",
        "problem_statement": "\"[ERROR]: Uncaught panic!\" when running the 100-line kernel example in the asterinas book.\nWhen running the 100-line kernel example in the asterinas book [https://asterinas.github.io/book/framework/a-100-line-kernel.html ](url), the following error is reported:\r\n```\r\nDrive current: -outdev 'stdio:/root/workspace/asterinas/target/osdk/myos-osdk-bin.iso'\r\nMedia current: stdio file, overwriteable\r\nMedia status : is blank\r\nMedia summary: 0 sessions, 0 data blocks, 0 data,  931g free\r\nAdded to ISO image: directory '/'='/tmp/grub.CQmOUp'\r\nxorriso : UPDATE :     341 files added in 1 seconds\r\nAdded to ISO image: directory '/'='/root/workspace/asterinas/target/osdk/iso_root'\r\nxorriso : UPDATE :     346 files added in 1 seconds\r\nxorriso : UPDATE :  0.00% done\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/scheduler.rs:44:24:\r\ncalled `Option::unwrap()` on a `None` value\r\nprinting stack trace:\r\n   1: fn 0xffffffff8809f660 - pc 0xffffffff8809f678 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047820;\r\n\r\n   2: fn 0xffffffff8809f160 - pc 0xffffffff8809f617 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047830;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a80;\r\n\r\n   4: fn 0xffffffff8818f4a0 - pc 0xffffffff8818f4ef / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a90;\r\n\r\n   5: fn 0xffffffff8818f5d0 - pc 0xffffffff8818f615 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047ae0;\r\n\r\n   6: fn 0xffffffff88124fd0 - pc 0xffffffff88125011 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b50;\r\n\r\n   7: fn 0xffffffff8806efa0 - pc 0xffffffff8806efce / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b80;\r\n\r\n   8: fn 0xffffffff8806f0c0 - pc 0xffffffff8806f16e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047bc0;\r\n\r\n   9: fn 0xffffffff8806e450 - pc 0xffffffff8806e462 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c20;\r\n\r\n  10: fn 0xffffffff880489e0 - pc 0xffffffff88048a30 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c30;\r\n\r\n  11: fn 0xffffffff880489d0 - pc 0xffffffff880489db / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f50;\r\n\r\n  12: fn 0xffffffff880a3b00 - pc 0xffffffff880a3b06 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f60;\r\n\r\n  13: fn 0xffffffff8810d3b0 - pc 0xffffffff8810d477 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f70;\r\n\r\n  14: fn                0x0 - pc 0xffffffff880ad052 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88048000;\r\n```\n",
        "hints_text": "It seems that the scheduler is not set. And the guide does not mention that.\r\n\r\n```rust\r\nuse aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\nlet simple_scheduler = Box::new(FifoScheduler::new());\r\nlet static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\nset_scheduler(static_scheduler);\r\n```\r\n\r\nCould you please check if this works? If so you can help us improve the guide!\nThanks. After adding your code into the example, the program runs successfully and outputs \"Hello, world\". However, the below error message follows. Is this normal? \r\n```\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\nHello, world\r\n\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/task.rs:191:9:\r\ninternal error: entered unreachable code\r\nprinting stack trace:\r\n   1: fn 0xffffffff880a1840 - pc 0xffffffff880a1858 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06d0;\r\n\r\n   2: fn 0xffffffff880a1340 - pc 0xffffffff880a17f7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06e0;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0930;\r\n\r\n   4: fn 0xffffffff88191e30 - pc 0xffffffff88191e7f / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0940;\r\n\r\n   5: fn 0xffffffff88191f60 - pc 0xffffffff88191fa5 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0990;\r\n\r\n   6: fn 0xffffffff8806ee80 - pc 0xffffffff8806eef9 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a00;\r\n\r\n   7: fn 0xffffffff88048660 - pc 0xffffffff880489c7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a40;\r\n\r\n   8: fn 0xffffffff880484d0 - pc 0xffffffff8804863c / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0c10;\r\n\r\n   9: fn 0xffffffff88049e60 - pc 0xffffffff88049e6e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0f90;\r\n\r\n  10: fn 0xffffffff880bae20 - pc 0xffffffff880bae36 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fb0;\r\n\r\n  11: fn 0xffffffff8806f710 - pc 0xffffffff8806f774 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fd0;\r\n```\nYes it is normal and the scheduler expect that the main task of the kernel will never return.\r\n\r\nSo a well formed hello world kernel may shut the system down after printing.\r\n\r\nHowever we do not have ACPI shutdown at this moment. Here is a debug fix.\r\n\r\n```rust\r\n#[aster_main]\r\npub fn main() {\r\n    let program_binary = include_bytes!(\"../hello_world\");\r\n    let user_space = create_user_space(program_binary);\r\n    let user_task = create_user_task(Arc::new(user_space));\r\n    user_task.run();\r\n    use aster_frame::arch::qemu::{exit_qemu, QemuExitCode};\r\n    exit_qemu(QemuExitCode::Success);\r\n}\r\n```\r\n\r\n\nOk! Thanks again.\n> It seems that the scheduler is not set. And the guide does not mention that.\r\n> \r\n> ```rust\r\n> use aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\n> let simple_scheduler = Box::new(FifoScheduler::new());\r\n> let static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\n> set_scheduler(static_scheduler);\r\n> ```\r\n> \r\n> Could you please check if this works? If so you can help us improve the guide!\r\n\r\n#748 introduces such a scheduler initialization for `ktest`. Maybe it will be better to set the scheduler in `aster_frame::init()` and it will work for both.",
        "created_at": "2024-06-20T08:52:42Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 1372,
        "instance_id": "asterinas__asterinas-1372",
        "issue_numbers": [
            "1399",
            "919"
        ],
        "base_commit": "96efd620072a0cbdccc95b58901894111f17bb3a",
        "patch": "diff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -13,13 +13,13 @@\n //!\n //! ```text\n //! +-+ <- the highest used address (0xffff_ffff_ffff_0000)\n-//! | |         For the kernel code, 1 GiB. Mapped frames are untracked.\n+//! | |         For the kernel code, 1 GiB. Mapped frames are tracked.\n //! +-+ <- 0xffff_ffff_8000_0000\n //! | |\n //! | |         Unused hole.\n //! +-+ <- 0xffff_ff00_0000_0000\n //! | |         For frame metadata, 1 TiB.\n-//! | |         Mapped frames are untracked.\n+//! | |         Mapped frames are tracked with handles.\n //! +-+ <- 0xffff_fe00_0000_0000\n //! | |         For vm alloc/io mappings, 1 TiB.\n //! | |         Mapped frames are tracked with handles.\n\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -104,6 +104,13 @@ pub fn paddr_to_vaddr(pa: Paddr) -> usize {\n     pa + LINEAR_MAPPING_BASE_VADDR\n }\n \n+/// Returns whether the given address should be mapped as tracked.\n+///\n+/// About what is tracked mapping, see [`crate::mm::page::meta::MapTrackingStatus`].\n+pub(crate) fn should_map_as_tracked(addr: Vaddr) -> bool {\n+    !LINEAR_MAPPING_VADDR_RANGE.contains(&addr)\n+}\n+\n /// The kernel page table instance.\n ///\n /// It manages the kernel mapping of all address spaces by sharing the kernel part. And it\n\ndiff --git a/ostd/src/mm/page/meta.rs b/ostd/src/mm/page/meta.rs\n--- a/ostd/src/mm/page/meta.rs\n+++ b/ostd/src/mm/page/meta.rs\n@@ -180,29 +180,50 @@ impl Sealed for FrameMeta {}\n /// Make sure the the generic parameters don't effect the memory layout.\n #[derive(Debug)]\n #[repr(C)]\n-pub struct PageTablePageMeta<\n+pub(in crate::mm) struct PageTablePageMeta<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n+    /// The number of valid PTEs. It is mutable if the lock is held.\n+    pub nr_children: UnsafeCell<u16>,\n+    /// The level of the page table page. A page table page cannot be\n+    /// referenced by page tables of different levels.\n     pub level: PagingLevel,\n+    /// Whether the pages mapped by the node is tracked.\n+    pub is_tracked: MapTrackingStatus,\n     /// The lock for the page table page.\n     pub lock: AtomicU8,\n-    /// The number of valid PTEs. It is mutable if the lock is held.\n-    pub nr_children: UnsafeCell<u16>,\n     _phantom: core::marker::PhantomData<(E, C)>,\n }\n \n+/// Describe if the physical address recorded in this page table refers to a\n+/// page tracked by metadata.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+#[repr(u8)]\n+pub(in crate::mm) enum MapTrackingStatus {\n+    /// The page table node cannot contain references to any pages. It can only\n+    /// contain references to child page table nodes.\n+    NotApplicable,\n+    /// The mapped pages are not tracked by metadata. If any child page table\n+    /// nodes exist, they should also be tracked.\n+    Untracked,\n+    /// The mapped pages are tracked by metadata. If any child page table nodes\n+    /// exist, they should also be tracked.\n+    Tracked,\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTablePageMeta<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub fn new_locked(level: PagingLevel) -> Self {\n+    pub fn new_locked(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n         Self {\n+            nr_children: UnsafeCell::new(0),\n             level,\n+            is_tracked,\n             lock: AtomicU8::new(1),\n-            nr_children: UnsafeCell::new(0),\n             _phantom: PhantomData,\n         }\n     }\n\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -119,25 +119,6 @@ impl<M: PageMeta> Page<M> {\n         }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The physical address must represent a valid page.\n-    ///\n-    /// And the caller must ensure the metadata slot pointed through the corresponding\n-    /// virtual address is initialized by holding a reference count of the page firstly.\n-    /// Otherwise the function may add a reference count to an unused page.\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        // SAFETY: The virtual address points to an initialized metadata slot.\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address.\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\n\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -248,20 +229,6 @@ impl DynPage {\n         Self { ptr }\n     }\n \n-    /// Increase the reference count of the page by one.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This is the same as [`Page::inc_ref_count`].\n-    pub(in crate::mm) unsafe fn inc_ref_count(paddr: Paddr) {\n-        debug_assert!(paddr % PAGE_SIZE == 0);\n-        debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n-        let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n-        (*(vaddr as *const MetaSlot))\n-            .ref_count\n-            .fetch_add(1, Ordering::Relaxed);\n-    }\n-\n     /// Get the physical address of the start of the page\n     pub fn paddr(&self) -> Paddr {\n         mapping::meta_to_page::<PagingConsts>(self.ptr as Vaddr)\n\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -363,3 +330,22 @@ impl Drop for DynPage {\n         }\n     }\n }\n+\n+/// Increases the reference count of the page by one.\n+///\n+/// # Safety\n+///\n+/// The caller should ensure the following conditions:\n+///  1. The physical address must represent a valid page;\n+///  2. The caller must have already held a reference to the page.\n+pub(in crate::mm) unsafe fn inc_page_ref_count(paddr: Paddr) {\n+    debug_assert!(paddr % PAGE_SIZE == 0);\n+    debug_assert!(paddr < MAX_PADDR.load(Ordering::Relaxed) as Paddr);\n+\n+    let vaddr: Vaddr = mapping::page_to_meta::<PagingConsts>(paddr);\n+    // SAFETY: The virtual address points to an initialized metadata slot.\n+    let slot = unsafe { &*(vaddr as *const MetaSlot) };\n+    let old = slot.ref_count.fetch_add(1, Ordering::Relaxed);\n+\n+    debug_assert!(old > 0);\n+}\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -65,17 +65,21 @@\n //! table cursor should add additional entry point checks to prevent these defined\n //! behaviors if they are not wanted.\n \n-use core::{any::TypeId, marker::PhantomData, mem::ManuallyDrop, ops::Range};\n+use core::{any::TypeId, marker::PhantomData, ops::Range};\n \n use align_ext::AlignExt;\n \n use super::{\n-    page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n+    page_size, pte_index, Child, Entry, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n use crate::{\n     mm::{\n-        page::{meta::PageTablePageMeta, DynPage, Page},\n+        kspace::should_map_as_tracked,\n+        page::{\n+            meta::{MapTrackingStatus, PageTablePageMeta},\n+            DynPage, Page,\n+        },\n         Paddr, PageProperty, Vaddr,\n     },\n     task::{disable_preempt, DisabledPreemptGuard},\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -134,6 +138,7 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n+    #[allow(dead_code)]\n     preempt_guard: DisabledPreemptGuard,\n     _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -190,12 +195,15 @@ where\n                 break;\n             }\n \n-            let cur_pte = cursor.read_cur_pte();\n-            if !cur_pte.is_present() || cur_pte.is_last(cursor.level) {\n+            let entry = cursor.cur_entry();\n+            if !entry.is_node() {\n                 break;\n             }\n+            let Child::PageTable(child_pt) = entry.to_owned() else {\n+                unreachable!(\"Already checked\");\n+            };\n \n-            cursor.level_down();\n+            cursor.push_level(child_pt.lock());\n \n             // Release the guard of the previous (upper) level.\n             cursor.guards[cursor.level as usize] = None;\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -215,9 +223,9 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            match self.cur_child() {\n-                Child::PageTable(_) => {\n-                    self.level_down();\n+            match self.cur_entry().to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.push_level(pt.lock());\n                     continue;\n                 }\n                 Child::None => {\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -229,7 +237,8 @@ where\n                 Child::Page(page, prop) => {\n                     return Ok(PageTableItem::Mapped { va, page, prop });\n                 }\n-                Child::Untracked(pa, prop) => {\n+                Child::Untracked(pa, plevel, prop) => {\n+                    debug_assert_eq!(plevel, level);\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -249,7 +258,7 @@ where\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\n-            self.level_up();\n+            self.pop_level();\n         }\n         self.va = next_va;\n     }\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -283,7 +292,7 @@ where\n             }\n \n             debug_assert!(self.level < self.guard_level);\n-            self.level_up();\n+            self.pop_level();\n         }\n     }\n \n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -291,70 +300,37 @@ where\n         self.va\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.preempt_guard\n-    }\n-\n-    /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n-    /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n-    /// cursor is dropped.\n+    /// Goes up a level.\n+    ///\n+    /// We release the current page if it has no mappings since the cursor\n+    /// only moves forward. And if needed we will do the final cleanup using\n+    /// this method after re-walk when the cursor is dropped.\n     ///\n-    /// This method requires locks acquired before calling it. The discarded level will be unlocked.\n-    fn level_up(&mut self) {\n+    /// This method requires locks acquired before calling it. The discarded\n+    /// level will be unlocked.\n+    fn pop_level(&mut self) {\n         self.guards[(self.level - 1) as usize] = None;\n         self.level += 1;\n \n         // TODO: Drop page tables if page tables become empty.\n     }\n \n-    /// Goes down a level assuming a child page table exists.\n-    fn level_down(&mut self) {\n-        debug_assert!(self.level > 1);\n-\n-        let Child::PageTable(nxt_lvl_ptn) = self.cur_child() else {\n-            panic!(\"Trying to level down when it is not mapped to a page table\");\n-        };\n-\n-        let nxt_lvl_ptn_locked = nxt_lvl_ptn.lock();\n-\n+    /// Goes down a level to a child page table.\n+    fn push_level(&mut self, child_pt: PageTableNode<E, C>) {\n         self.level -= 1;\n-        debug_assert_eq!(self.level, nxt_lvl_ptn_locked.level());\n-\n-        self.guards[(self.level - 1) as usize] = Some(nxt_lvl_ptn_locked);\n+        debug_assert_eq!(self.level, child_pt.level());\n+        self.guards[(self.level - 1) as usize] = Some(child_pt);\n     }\n \n-    fn cur_node(&self) -> &PageTableNode<E, C> {\n-        self.guards[(self.level - 1) as usize].as_ref().unwrap()\n+    fn should_map_as_tracked(&self) -> bool {\n+        (TypeId::of::<M>() == TypeId::of::<KernelMode>()\n+            || TypeId::of::<M>() == TypeId::of::<UserMode>())\n+            && should_map_as_tracked(self.va)\n     }\n \n-    fn cur_idx(&self) -> usize {\n-        pte_index::<C>(self.va, self.level)\n-    }\n-\n-    fn cur_child(&self) -> Child<E, C> {\n-        self.cur_node()\n-            .child(self.cur_idx(), self.in_tracked_range())\n-    }\n-\n-    fn read_cur_pte(&self) -> E {\n-        self.cur_node().read_pte(self.cur_idx())\n-    }\n-\n-    /// Tells if the current virtual range must contain untracked mappings.\n-    ///\n-    /// _Tracked mappings_ means that the mapped physical addresses (in PTEs) points to pages\n-    /// tracked by the metadata system. _Tracked mappings_ must be created with page handles.\n-    /// While _untracked mappings_ solely maps to plain physical addresses.\n-    ///\n-    /// In the kernel mode, this is aligned with the definition in [`crate::mm::kspace`].\n-    /// Only linear mappings in the kernel should be considered as untracked mappings.\n-    ///\n-    /// All mappings in the user mode are tracked. And all mappings in the IOMMU\n-    /// page table are untracked.\n-    fn in_tracked_range(&self) -> bool {\n-        TypeId::of::<M>() == TypeId::of::<UserMode>()\n-            || TypeId::of::<M>() == TypeId::of::<KernelMode>()\n-                && !crate::mm::kspace::LINEAR_MAPPING_VADDR_RANGE.contains(&self.va)\n+    fn cur_entry(&mut self) -> Entry<'_, E, C> {\n+        let node = self.guards[(self.level - 1) as usize].as_mut().unwrap();\n+        node.entry(pte_index::<C>(self.va, self.level))\n     }\n }\n \n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -445,30 +421,38 @@ where\n     pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n-        debug_assert!(self.0.in_tracked_range());\n \n         // Go down if not applicable.\n         while self.0.level > C::HIGHEST_TRANSLATION_LEVEL\n             || self.0.va % page_size::<C>(self.0.level) != 0\n             || self.0.va + page_size::<C>(self.0.level) > end\n         {\n-            let pte = self.0.read_cur_pte();\n-            if pte.is_present() && !pte.is_last(self.0.level) {\n-                self.0.level_down();\n-            } else if !pte.is_present() {\n-                self.level_down_create();\n-            } else {\n-                panic!(\"Mapping a smaller page in an already mapped huge page\");\n+            debug_assert!(self.0.should_map_as_tracked());\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n+            match cur_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    self.0.push_level(pt.lock());\n+                }\n+                Child::None => {\n+                    let pt =\n+                        PageTableNode::<E, C>::alloc(cur_level - 1, MapTrackingStatus::Tracked);\n+                    let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                    self.0.push_level(pt);\n+                }\n+                Child::Page(_, _) => {\n+                    panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Mapping a tracked page in an untracked range\");\n+                }\n             }\n             continue;\n         }\n         debug_assert_eq!(self.0.level, page.level());\n \n         // Map the current page.\n-        let idx = self.0.cur_idx();\n-        let old = self\n-            .cur_node_mut()\n-            .replace_child(idx, Child::Page(page, prop), true);\n+        let old = self.0.cur_entry().replace(Child::Page(page, prop));\n         self.0.move_forward();\n \n         match old {\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -477,7 +461,7 @@ where\n             Child::PageTable(_) => {\n                 todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n             }\n-            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+            Child::Untracked(_, _, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n         }\n     }\n \n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -525,25 +509,40 @@ where\n                 || self.0.va + page_size::<C>(self.0.level) > end\n                 || pa % page_size::<C>(self.0.level) != 0\n             {\n-                let pte = self.0.read_cur_pte();\n-                if pte.is_present() && !pte.is_last(self.0.level) {\n-                    self.0.level_down();\n-                } else if !pte.is_present() {\n-                    self.level_down_create();\n-                } else {\n-                    self.level_down_split();\n+                let cur_level = self.0.level;\n+                let cur_entry = self.0.cur_entry();\n+                match cur_entry.to_owned() {\n+                    Child::PageTable(pt) => {\n+                        self.0.push_level(pt.lock());\n+                    }\n+                    Child::None => {\n+                        let pt = PageTableNode::<E, C>::alloc(\n+                            cur_level - 1,\n+                            MapTrackingStatus::Untracked,\n+                        );\n+                        let _ = cur_entry.replace(Child::PageTable(pt.clone_raw()));\n+                        self.0.push_level(pt);\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Mapping a smaller page in an already mapped huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Map the current page.\n-            debug_assert!(!self.0.in_tracked_range());\n-            let idx = self.0.cur_idx();\n+            debug_assert!(!self.0.should_map_as_tracked());\n+            let level = self.0.level;\n             let _ = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::Untracked(pa, prop), false);\n+                .0\n+                .cur_entry()\n+                .replace(Child::Untracked(pa, level, prop));\n \n-            let level = self.0.level;\n+            // Move forward.\n             pa += page_size::<C>(level);\n             self.0.move_forward();\n         }\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -580,11 +579,12 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            let is_tracked = self.0.in_tracked_range();\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let cur_entry = self.0.cur_entry();\n \n             // Skip if it is already absent.\n-            if !cur_pte.is_present() {\n+            if cur_entry.is_none() {\n                 if self.0.va + page_size::<C>(self.0.level) > end {\n                     self.0.va = end;\n                     break;\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -593,64 +593,61 @@ where\n                 continue;\n             }\n \n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if !is_tracked {\n-                    // Level down if we are removing part of a huge untracked page.\n-                    self.level_down_split();\n-                    continue;\n-                }\n-\n-                if cur_pte.is_last(self.0.level) {\n-                    panic!(\"removing part of a huge page\");\n-                }\n-\n-                // Level down if the current PTE points to a page table and we cannot\n-                // unmap this page table node entirely.\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n-                    self.0.move_forward();\n+            // Go down if not applicable.\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let child = cur_entry.to_owned();\n+                match child {\n+                    Child::PageTable(pt) => {\n+                        let pt = pt.lock();\n+                        // If there's no mapped PTEs in the next level, we can\n+                        // skip to save time.\n+                        if pt.nr_children() != 0 {\n+                            self.0.push_level(pt);\n+                        } else {\n+                            if self.0.va + page_size::<C>(self.0.level) > end {\n+                                self.0.va = end;\n+                                break;\n+                            }\n+                            self.0.move_forward();\n+                        }\n+                    }\n+                    Child::None => {\n+                        unreachable!(\"Already checked\");\n+                    }\n+                    Child::Page(_, _) => {\n+                        panic!(\"Removing part of a huge page\");\n+                    }\n+                    Child::Untracked(_, _, _) => {\n+                        let split_child = cur_entry.split_if_untracked_huge().unwrap();\n+                        self.0.push_level(split_child);\n+                    }\n                 }\n                 continue;\n             }\n \n             // Unmap the current page and return it.\n-            let idx = self.0.cur_idx();\n-            let ret = self\n-                .cur_node_mut()\n-                .replace_child(idx, Child::None, is_tracked);\n-            let ret_page_va = self.0.va;\n-            let ret_page_size = page_size::<C>(self.0.level);\n+            let old = cur_entry.replace(Child::None);\n \n             self.0.move_forward();\n \n-            return match ret {\n+            return match old {\n                 Child::Page(page, prop) => PageTableItem::Mapped {\n-                    va: ret_page_va,\n+                    va: self.0.va,\n                     page,\n                     prop,\n                 },\n-                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n-                    va: ret_page_va,\n-                    pa,\n-                    len: ret_page_size,\n-                    prop,\n-                },\n-                Child::PageTable(node) => {\n-                    let node = ManuallyDrop::new(node);\n-                    let page = Page::<PageTablePageMeta<E, C>>::from_raw(node.paddr());\n-                    PageTableItem::PageTableNode { page: page.into() }\n+                Child::Untracked(pa, level, prop) => {\n+                    debug_assert_eq!(level, self.0.level);\n+                    PageTableItem::MappedUntracked {\n+                        va: self.0.va,\n+                        pa,\n+                        len: page_size::<C>(level),\n+                        prop,\n+                    }\n                 }\n+                Child::PageTable(node) => PageTableItem::PageTableNode {\n+                    page: Page::<PageTablePageMeta<E, C>>::from(node).into(),\n+                },\n                 Child::None => unreachable!(),\n             };\n         }\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -692,51 +689,46 @@ where\n         assert!(end <= self.0.barrier_va.end);\n \n         while self.0.va < end {\n-            let cur_pte = self.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n+            let cur_va = self.0.va;\n+            let cur_level = self.0.level;\n+            let mut cur_entry = self.0.cur_entry();\n+\n+            // Skip if it is already absent.\n+            if cur_entry.is_none() {\n                 self.0.move_forward();\n                 continue;\n             }\n \n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(self.0.level) {\n-                self.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if self.0.guards[(self.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    self.0.level_up();\n+            // Go down if it's not a last entry.\n+            if cur_entry.is_node() {\n+                let Child::PageTable(pt) = cur_entry.to_owned() else {\n+                    unreachable!(\"Already checked\");\n+                };\n+                let pt = pt.lock();\n+                // If there's no mapped PTEs in the next level, we can\n+                // skip to save time.\n+                if pt.nr_children() != 0 {\n+                    self.0.push_level(pt);\n+                } else {\n                     self.0.move_forward();\n                 }\n-\n                 continue;\n             }\n \n             // Go down if the page size is too big and we are protecting part\n             // of untracked huge pages.\n-            if self.0.va % page_size::<C>(self.0.level) != 0\n-                || self.0.va + page_size::<C>(self.0.level) > end\n-            {\n-                if self.0.in_tracked_range() {\n-                    panic!(\"protecting part of a huge page\");\n-                } else {\n-                    self.level_down_split();\n-                    continue;\n-                }\n+            if cur_va % page_size::<C>(cur_level) != 0 || cur_va + page_size::<C>(cur_level) > end {\n+                let split_child = cur_entry\n+                    .split_if_untracked_huge()\n+                    .expect(\"Protecting part of a huge page\");\n+                self.0.push_level(split_child);\n+                continue;\n             }\n \n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+            // Protect the current page.\n+            cur_entry.protect(op);\n \n-            let idx = self.0.cur_idx();\n-            self.cur_node_mut().protect(idx, pte_prop);\n             let protected_va = self.0.va..self.0.va + page_size::<C>(self.0.level);\n-\n             self.0.move_forward();\n \n             return Some(protected_va);\n\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -785,91 +777,46 @@ where\n         assert!(src_end <= src.0.barrier_va.end);\n \n         while self.0.va < this_end && src.0.va < src_end {\n-            let cur_pte = src.0.read_cur_pte();\n-            if !cur_pte.is_present() {\n-                src.0.move_forward();\n-                continue;\n-            }\n-\n-            // Go down if it's not a last node.\n-            if !cur_pte.is_last(src.0.level) {\n-                src.0.level_down();\n-\n-                // We have got down a level. If there's no mapped PTEs in\n-                // the current node, we can go back and skip to save time.\n-                if src.0.guards[(src.0.level - 1) as usize]\n-                    .as_ref()\n-                    .unwrap()\n-                    .nr_children()\n-                    == 0\n-                {\n-                    src.0.level_up();\n+            let src_va = src.0.va;\n+            let mut src_entry = src.0.cur_entry();\n+\n+            match src_entry.to_owned() {\n+                Child::PageTable(pt) => {\n+                    let pt = pt.lock();\n+                    // If there's no mapped PTEs in the next level, we can\n+                    // skip to save time.\n+                    if pt.nr_children() != 0 {\n+                        src.0.push_level(pt);\n+                    } else {\n+                        src.0.move_forward();\n+                    }\n+                    continue;\n+                }\n+                Child::None => {\n                     src.0.move_forward();\n+                    continue;\n                 }\n+                Child::Untracked(_, _, _) => {\n+                    panic!(\"Copying untracked mappings\");\n+                }\n+                Child::Page(page, mut prop) => {\n+                    let mapped_page_size = page.size();\n \n-                continue;\n-            }\n-\n-            // Do protection.\n-            let mut pte_prop = cur_pte.prop();\n-            op(&mut pte_prop);\n+                    // Do protection.\n+                    src_entry.protect(op);\n \n-            let idx = src.0.cur_idx();\n-            src.cur_node_mut().protect(idx, pte_prop);\n+                    // Do copy.\n+                    op(&mut prop);\n+                    self.jump(src_va).unwrap();\n+                    let original = self.map(page, prop);\n+                    assert!(original.is_none());\n \n-            // Do copy.\n-            let child = src.cur_node_mut().child(idx, true);\n-            let Child::<E, C>::Page(page, prop) = child else {\n-                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n-            };\n-            self.jump(src.0.va).unwrap();\n-            let mapped_page_size = page.size();\n-            let original = self.map(page, prop);\n-            debug_assert!(original.is_none());\n-\n-            // Only move the source cursor forward since `Self::map` will do it.\n-            // This assertion is to ensure that they move by the same length.\n-            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n-            src.0.move_forward();\n+                    // Only move the source cursor forward since `Self::map` will do it.\n+                    // This assertion is to ensure that they move by the same length.\n+                    debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+                    src.0.move_forward();\n+                }\n+            }\n         }\n     }\n-\n-    /// Goes down a level assuming the current slot is absent.\n-    ///\n-    /// This method will create a new child page table node and go down to it.\n-    fn level_down_create(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n-        let idx = self.0.cur_idx();\n-        let is_tracked = self.0.in_tracked_range();\n-        let old = self.cur_node_mut().replace_child(\n-            idx,\n-            Child::PageTable(new_node.clone_raw()),\n-            is_tracked,\n-        );\n-        debug_assert!(old.is_none());\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n-    }\n-\n-    /// Goes down a level assuming the current slot is an untracked huge page.\n-    ///\n-    /// This method will split the huge page and go down to the next level.\n-    fn level_down_split(&mut self) {\n-        debug_assert!(self.0.level > 1);\n-        debug_assert!(!self.0.in_tracked_range());\n-\n-        let idx = self.0.cur_idx();\n-        self.cur_node_mut().split_untracked_huge(idx);\n-\n-        let Child::PageTable(new_node) = self.0.cur_child() else {\n-            unreachable!();\n-        };\n-        self.0.level -= 1;\n-        self.0.guards[(self.0.level - 1) as usize] = Some(new_node.lock());\n-    }\n-\n-    fn cur_node_mut(&mut self) -> &mut PageTableNode<E, C> {\n-        self.0.guards[(self.0.level - 1) as usize].as_mut().unwrap()\n-    }\n }\n\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,8 +3,8 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, page_prop::PageProperty, page_size, Paddr, PagingConstsTrait, PagingLevel,\n-    Vaddr,\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size, Paddr,\n+    PagingConstsTrait, PagingLevel, Vaddr,\n };\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -100,16 +100,17 @@ impl PageTable<KernelMode> {\n     /// This should be the only way to create the user page table, that is to\n     /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n-        let root_node = self.root.clone_shallow().lock();\n-        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n+        let mut root_node = self.root.clone_shallow().lock();\n+        let mut new_node =\n+            PageTableNode::alloc(PagingConsts::NR_LEVELS, MapTrackingStatus::NotApplicable);\n \n         // Make a shallow copy of the root node in the kernel space range.\n         // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n         for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n-            let child = root_node.child(i, /* meaningless */ true);\n-            if !child.is_none() {\n-                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            let root_entry = root_node.entry(i);\n+            if !root_entry.is_none() {\n+                let _ = new_node.entry(i).replace(root_entry.to_owned());\n             }\n         }\n \n\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -136,13 +137,18 @@ impl PageTable<KernelMode> {\n \n         let mut root_node = self.root.clone_shallow().lock();\n         for i in start..end {\n-            if !root_node.read_pte(i).is_present() {\n-                let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                let _ = root_node.replace_child(\n-                    i,\n-                    Child::PageTable(node.into_raw()),\n-                    i < NR_PTES_PER_NODE * 3 / 4,\n-                );\n+            let root_entry = root_node.entry(i);\n+            if root_entry.is_none() {\n+                let nxt_level = PagingConsts::NR_LEVELS - 1;\n+                let is_tracked = if super::kspace::should_map_as_tracked(\n+                    i * page_size::<PagingConsts>(nxt_level),\n+                ) {\n+                    MapTrackingStatus::Tracked\n+                } else {\n+                    MapTrackingStatus::Untracked\n+                };\n+                let node = PageTableNode::alloc(nxt_level, is_tracked);\n+                let _ = root_entry.replace(Child::PageTable(node.into_raw()));\n             }\n         }\n     }\n\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -175,7 +181,8 @@ where\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n     pub fn empty() -> Self {\n         PageTable {\n-            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n+            root: PageTableNode::<E, C>::alloc(C::NR_LEVELS, MapTrackingStatus::NotApplicable)\n+                .into_raw(),\n             _phantom: PhantomData,\n         }\n     }\n\ndiff --git /dev/null b/ostd/src/mm/page_table/node/child.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/child.rs\n@@ -0,0 +1,172 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module specifies the type of the children of a page table node.\n+\n+use core::{mem::ManuallyDrop, panic};\n+\n+use super::{PageTableEntryTrait, RawPageTableNode};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    mm::{\n+        page::{inc_page_ref_count, meta::MapTrackingStatus, DynPage},\n+        page_prop::PageProperty,\n+        Paddr, PagingConstsTrait, PagingLevel,\n+    },\n+};\n+\n+/// A child of a page table node.\n+///\n+/// This is a owning handle to a child of a page table node. If the child is\n+/// either a page table node or a page, it holds a reference count to the\n+/// corresponding page.\n+#[derive(Debug)]\n+pub(in crate::mm) enum Child<\n+    E: PageTableEntryTrait = PageTableEntry,\n+    C: PagingConstsTrait = PagingConsts,\n+> where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    PageTable(RawPageTableNode<E, C>),\n+    Page(DynPage, PageProperty),\n+    /// Pages not tracked by handles.\n+    Untracked(Paddr, PagingLevel, PageProperty),\n+    None,\n+}\n+\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns whether the child does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+\n+    /// Returns whether the child is compatible with the given node.\n+    ///\n+    /// In other words, it checks whether the child can be a child of a node\n+    /// with the given level and tracking status.\n+    pub(super) fn is_compatible(\n+        &self,\n+        node_level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> bool {\n+        match self {\n+            Child::PageTable(pt) => node_level == pt.level() + 1,\n+            Child::Page(p, _) => {\n+                node_level == p.level() && is_tracked == MapTrackingStatus::Tracked\n+            }\n+            Child::Untracked(_, level, _) => {\n+                node_level == *level && is_tracked == MapTrackingStatus::Untracked\n+            }\n+            Child::None => true,\n+        }\n+    }\n+\n+    /// Converts a child into a owning PTE.\n+    ///\n+    /// By conversion it loses information about whether the page is tracked\n+    /// or not. Also it loses the level information. However, the returned PTE\n+    /// takes the ownership (reference count) of the child.\n+    ///\n+    /// Usually this is for recording the PTE into a page table node. When the\n+    /// child is needed again by reading the PTE of a page table node, extra\n+    /// information should be provided using the [`Child::from_pte`] method.\n+    pub(super) fn into_pte(self) -> E {\n+        match self {\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                E::new_pt(pt.paddr())\n+            }\n+            Child::Page(page, prop) => {\n+                let level = page.level();\n+                E::new_page(page.into_raw(), level, prop)\n+            }\n+            Child::Untracked(pa, level, prop) => E::new_page(pa, level, prop),\n+            Child::None => E::new_absent(),\n+        }\n+    }\n+\n+    /// Converts a PTE back to a child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`]. And the\n+    /// provided information (level and tracking status) must be the same with\n+    /// the lost information during the conversion. Strictly speaking, the\n+    /// provided arguments must be compatible with the original child (\n+    /// specified by [`Child::is_compatible`]).\n+    ///\n+    /// This method should be only used no more than once for a PTE that has\n+    /// been converted from a child using the [`Child::into_pte`] method.\n+    pub(super) unsafe fn from_pte(\n+        pte: E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+\n+    /// Gains an extra owning reference to the child.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The provided PTE must be originated from [`Child::into_pte`], which is\n+    /// the same requirement as the [`Child::from_pte`] method.\n+    ///\n+    /// This method must not be used with a PTE that has been restored to a\n+    /// child using the [`Child::from_pte`] method.\n+    pub(super) unsafe fn clone_from_pte(\n+        pte: &E,\n+        level: PagingLevel,\n+        is_tracked: MapTrackingStatus,\n+    ) -> Self {\n+        if !pte.is_present() {\n+            return Child::None;\n+        }\n+\n+        let paddr = pte.paddr();\n+\n+        if !pte.is_last(level) {\n+            // SAFETY: The physical address is valid and the PTE already owns\n+            // the reference to the page.\n+            unsafe { inc_page_ref_count(paddr) };\n+            // SAFETY: The physical address points to a valid page table node\n+            // at the given level.\n+            return Child::PageTable(unsafe { RawPageTableNode::from_raw_parts(paddr, level - 1) });\n+        }\n+\n+        match is_tracked {\n+            MapTrackingStatus::Tracked => {\n+                // SAFETY: The physical address is valid and the PTE already owns\n+                // the reference to the page.\n+                unsafe { inc_page_ref_count(paddr) };\n+                // SAFETY: The physical address points to a valid page.\n+                let page = unsafe { DynPage::from_raw(paddr) };\n+                Child::Page(page, pte.prop())\n+            }\n+            MapTrackingStatus::Untracked => Child::Untracked(paddr, level, pte.prop()),\n+            MapTrackingStatus::NotApplicable => panic!(\"Invalid tracking status\"),\n+        }\n+    }\n+}\n\ndiff --git /dev/null b/ostd/src/mm/page_table/node/entry.rs\nnew file mode 100644\n--- /dev/null\n+++ b/ostd/src/mm/page_table/node/entry.rs\n@@ -0,0 +1,161 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! This module provides accessors to the page table entries in a node.\n+\n+use super::{Child, PageTableEntryTrait, PageTableNode};\n+use crate::mm::{\n+    nr_subpage_per_huge, page::meta::MapTrackingStatus, page_prop::PageProperty, page_size,\n+    PagingConstsTrait,\n+};\n+\n+/// A view of an entry in a page table node.\n+///\n+/// It can be borrowed from a node using the [`PageTableNode::entry`] method.\n+///\n+/// This is a static reference to an entry in a node that does not account for\n+/// a dynamic reference count to the child. It can be used to create a owned\n+/// handle, which is a [`Child`].\n+pub(in crate::mm) struct Entry<'a, E: PageTableEntryTrait, C: PagingConstsTrait>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// The page table entry.\n+    ///\n+    /// We store the page table entry here to optimize the number of reads from\n+    /// the node. We cannot hold a `&mut E` reference to the entry because that\n+    /// other CPUs may modify the memory location for accessed/dirty bits. Such\n+    /// accesses will violate the aliasing rules of Rust and cause undefined\n+    /// behaviors.\n+    pte: E,\n+    /// The index of the entry in the node.\n+    idx: usize,\n+    /// The node that contains the entry.\n+    node: &'a mut PageTableNode<E, C>,\n+}\n+\n+impl<'a, E: PageTableEntryTrait, C: PagingConstsTrait> Entry<'a, E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    /// Returns if the entry does not map to anything.\n+    pub(in crate::mm) fn is_none(&self) -> bool {\n+        !self.pte.is_present()\n+    }\n+\n+    /// Returns if the entry maps to a page table node.\n+    pub(in crate::mm) fn is_node(&self) -> bool {\n+        self.pte.is_present() && !self.pte.is_last(self.node.level())\n+    }\n+\n+    /// Gets a owned handle to the child.\n+    pub(in crate::mm) fn to_owned(&self) -> Child<E, C> {\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information.\n+        unsafe { Child::clone_from_pte(&self.pte, self.node.level(), self.node.is_tracked()) }\n+    }\n+\n+    /// Operates on the mapping properties of the entry.\n+    ///\n+    /// It only modifies the properties if the entry is present.\n+    // FIXME: in x86_64, you can protect a page with neither of the RWX\n+    // permissions. This would make the page not accessible and leaked. Such a\n+    // behavior is memory-safe but wrong. In RISC-V there's no problem.\n+    pub(in crate::mm) fn protect(&mut self, op: &mut impl FnMut(&mut PageProperty)) {\n+        if !self.pte.is_present() {\n+            return;\n+        }\n+\n+        let prop = self.pte.prop();\n+        let mut new_prop = prop;\n+        op(&mut new_prop);\n+\n+        if prop == new_prop {\n+            return;\n+        }\n+\n+        self.pte.set_prop(new_prop);\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. We replace the PTE with a new one, which differs only in\n+        //     `PageProperty`, so it is still compatible with the current\n+        //     page table node.\n+        unsafe { self.node.write_pte(self.idx, self.pte) };\n+    }\n+\n+    /// Replaces the entry with a new child.\n+    ///\n+    /// The old child is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The method panics if the given child is not compatible with the node.\n+    /// The compatibility is specified by the [`Child::is_compatible`].\n+    pub(in crate::mm) fn replace(self, new_child: Child<E, C>) -> Child<E, C> {\n+        assert!(new_child.is_compatible(self.node.level(), self.node.is_tracked()));\n+\n+        // SAFETY: The entry structure represents an existent entry with the\n+        // right node information. The old PTE is overwritten by the new child\n+        // so that it is not used anymore.\n+        let old_child =\n+            unsafe { Child::from_pte(self.pte, self.node.level(), self.node.is_tracked()) };\n+\n+        if old_child.is_none() && !new_child.is_none() {\n+            *self.node.nr_children_mut() += 1;\n+        } else if !old_child.is_none() && new_child.is_none() {\n+            *self.node.nr_children_mut() -= 1;\n+        }\n+\n+        // SAFETY:\n+        //  1. The index is within the bounds.\n+        //  2. The new PTE is compatible with the page table node, as asserted above.\n+        unsafe { self.node.write_pte(self.idx, new_child.into_pte()) };\n+\n+        old_child\n+    }\n+\n+    /// Splits the entry to smaller pages if it maps to a untracked huge page.\n+    ///\n+    /// If the entry does map to a untracked huge page, it is split into smaller\n+    /// pages mapped by a child page table node. The new child page table node\n+    /// is returned.\n+    ///\n+    /// If the entry does not map to a untracked huge page, the method returns\n+    /// `None`.\n+    pub(in crate::mm) fn split_if_untracked_huge(self) -> Option<PageTableNode<E, C>> {\n+        let level = self.node.level();\n+\n+        if !(self.pte.is_last(level)\n+            && level > 1\n+            && self.node.is_tracked() == MapTrackingStatus::Untracked)\n+        {\n+            return None;\n+        }\n+\n+        let pa = self.pte.paddr();\n+        let prop = self.pte.prop();\n+\n+        let mut new_page = PageTableNode::<E, C>::alloc(level - 1, MapTrackingStatus::Untracked);\n+        for i in 0..nr_subpage_per_huge::<C>() {\n+            let small_pa = pa + i * page_size::<C>(level - 1);\n+            let _ = new_page\n+                .entry(i)\n+                .replace(Child::Untracked(small_pa, level - 1, prop));\n+        }\n+\n+        let _ = self.replace(Child::PageTable(new_page.clone_raw()));\n+\n+        Some(new_page)\n+    }\n+\n+    /// Create a new entry at the node.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bounds of the node.\n+    pub(super) unsafe fn new_at(node: &'a mut PageTableNode<E, C>, idx: usize) -> Self {\n+        // SAFETY: The index is within the bound.\n+        let pte = unsafe { node.read_pte(idx) };\n+        Self { pte, idx, node }\n+    }\n+}\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -25,19 +25,22 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n+mod child;\n+mod entry;\n \n-use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n+use core::{marker::PhantomData, mem::ManuallyDrop, sync::atomic::Ordering};\n+\n+pub(in crate::mm) use self::{child::Child, entry::Entry};\n+use super::{nr_subpage_per_huge, PageTableEntryTrait};\n use crate::{\n     arch::mm::{PageTableEntry, PagingConsts},\n     mm::{\n         paddr_to_vaddr,\n         page::{\n-            self,\n-            meta::{PageMeta, PageTablePageMeta, PageUsage},\n+            self, inc_page_ref_count,\n+            meta::{MapTrackingStatus, PageMeta, PageTablePageMeta, PageUsage},\n             DynPage, Page,\n         },\n-        page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n };\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -55,7 +58,8 @@ pub(super) struct RawPageTableNode<E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) raw: Paddr,\n+    raw: Paddr,\n+    level: PagingLevel,\n     _phantom: PhantomData<(E, C)>,\n }\n \n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -67,15 +71,14 @@ where\n         self.raw\n     }\n \n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.level\n+    }\n+\n     /// Converts a raw handle to an accessible handle by pertaining the lock.\n     pub(super) fn lock(self) -> PageTableNode<E, C> {\n-        // Prevent dropping the handle.\n-        let this = ManuallyDrop::new(self);\n-\n-        // SAFETY: The physical address in the raw handle is valid and we are\n-        // transferring the ownership to a new handle. No increment of the reference\n-        // count is needed.\n-        let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n+        let level = self.level;\n+        let page: Page<PageTablePageMeta<E, C>> = self.into();\n \n         // Acquire the lock.\n         while page\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -87,7 +90,9 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> { page, _private: () }\n+        debug_assert_eq!(page.meta().level, level);\n+\n+        PageTableNode::<E, C> { page }\n     }\n \n     /// Creates a copy of the handle.\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -96,6 +101,7 @@ where\n \n         Self {\n             raw: self.raw,\n+            level: self.level,\n             _phantom: PhantomData,\n         }\n     }\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -112,12 +118,18 @@ where\n     /// The caller must ensure that the page table to be activated has\n     /// proper mappings for the kernel and has the correct const parameters\n     /// matching the current CPU.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Only top-level page tables can be activated using this function.\n     pub(crate) unsafe fn activate(&self) {\n         use crate::{\n             arch::mm::{activate_page_table, current_page_table_paddr},\n             mm::CachePolicy,\n         };\n \n+        assert_eq!(self.level, C::NR_LEVELS);\n+\n         let last_activated_paddr = current_page_table_paddr();\n \n         if last_activated_paddr == self.raw {\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -132,6 +144,7 @@ where\n         // Restore and drop the last activated page table.\n         drop(Self {\n             raw: last_activated_paddr,\n+            level: C::NR_LEVELS,\n             _phantom: PhantomData,\n         });\n     }\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -152,11 +165,40 @@ where\n         // SAFETY: We have a reference count to the page and can safely increase the reference\n         // count by one more.\n         unsafe {\n-            Page::<PageTablePageMeta<E, C>>::inc_ref_count(self.paddr());\n+            inc_page_ref_count(self.paddr());\n+        }\n+    }\n+\n+    /// Restores the handle from the physical address and level.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the physical address is valid and points to\n+    /// a forgotten page table node. A forgotten page table node can only be\n+    /// restored once. The level must match the level of the page table node.\n+    unsafe fn from_raw_parts(paddr: Paddr, level: PagingLevel) -> Self {\n+        Self {\n+            raw: paddr,\n+            level,\n+            _phantom: PhantomData,\n         }\n     }\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> From<RawPageTableNode<E, C>>\n+    for Page<PageTablePageMeta<E, C>>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    fn from(raw: RawPageTableNode<E, C>) -> Self {\n+        let raw = ManuallyDrop::new(raw);\n+        // SAFETY: The physical address in the raw handle is valid and we are\n+        // transferring the ownership to a new handle. No increment of the reference\n+        // count is needed.\n+        unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(raw.paddr()) }\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> Drop for RawPageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -175,64 +217,49 @@ where\n /// of the page table. Dropping the page table node will also drop all handles if the page\n /// table node has no references. You can set the page table node as a child of another\n /// page table node.\n+#[derive(Debug)]\n pub(super) struct PageTableNode<\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n > where\n     [(); C::NR_LEVELS as usize]:,\n {\n-    pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    _private: (),\n+    page: Page<PageTablePageMeta<E, C>>,\n }\n \n-// FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\n-// this field or implement the `Debug` trait also for `DisabledPreemptGuard`?\n-impl<E, C> fmt::Debug for PageTableNode<E, C>\n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n-    E: PageTableEntryTrait,\n-    C: PagingConstsTrait,\n     [(); C::NR_LEVELS as usize]:,\n {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"PageTableEntryTrait\")\n-            .field(\"page\", &self.page)\n-            .finish()\n+    /// Borrows an entry in the node at a given index.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the index is not within the bound of\n+    /// [`nr_subpage_per_huge<C>`].\n+    pub(super) fn entry(&mut self, idx: usize) -> Entry<'_, E, C> {\n+        assert!(idx < nr_subpage_per_huge::<C>());\n+        // SAFETY: The index is within the bound.\n+        unsafe { Entry::new_at(self, idx) }\n     }\n-}\n \n-/// A child of a page table node.\n-#[derive(Debug)]\n-pub(super) enum Child<E: PageTableEntryTrait = PageTableEntry, C: PagingConstsTrait = PagingConsts>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage, PageProperty),\n-    /// Pages not tracked by handles.\n-    Untracked(Paddr, PageProperty),\n-    None,\n-}\n+    /// Gets the level of the page table node.\n+    pub(super) fn level(&self) -> PagingLevel {\n+        self.page.meta().level\n+    }\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n-    pub(super) fn is_none(&self) -> bool {\n-        matches!(self, Child::None)\n+    /// Gets the tracking status of the page table node.\n+    pub(super) fn is_tracked(&self) -> MapTrackingStatus {\n+        self.page.meta().is_tracked\n     }\n-}\n \n-impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n-where\n-    [(); C::NR_LEVELS as usize]:,\n-{\n     /// Allocates a new empty page table node.\n     ///\n     /// This function returns an owning handle. The newly created handle does not\n     /// set the lock bit for performance as it is exclusive and unlocking is an\n     /// extra unnecessary expensive operation.\n-    pub(super) fn alloc(level: PagingLevel) -> Self {\n-        let meta = PageTablePageMeta::new_locked(level);\n+    pub(super) fn alloc(level: PagingLevel, is_tracked: MapTrackingStatus) -> Self {\n+        let meta = PageTablePageMeta::new_locked(level, is_tracked);\n         let page = page::allocator::alloc_single::<PageTablePageMeta<E, C>>(meta).unwrap();\n \n         // Zero out the page table node.\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -242,209 +269,76 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self { page, _private: () }\n-    }\n-\n-    pub fn level(&self) -> PagingLevel {\n-        self.meta().level\n+        Self { page }\n     }\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n         let this = ManuallyDrop::new(self);\n \n-        let raw = this.page.paddr();\n-\n+        // Release the lock.\n         this.page.meta().lock.store(0, Ordering::Release);\n \n-        RawPageTableNode {\n-            raw,\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is not changed.\n+        unsafe { RawPageTableNode::from_raw_parts(this.page.paddr(), this.page.meta().level) }\n     }\n \n     /// Gets a raw handle while still preserving the original handle.\n     pub(super) fn clone_raw(&self) -> RawPageTableNode<E, C> {\n-        core::mem::forget(self.page.clone());\n+        let page = ManuallyDrop::new(self.page.clone());\n \n-        RawPageTableNode {\n-            raw: self.page.paddr(),\n-            _phantom: PhantomData,\n-        }\n+        // SAFETY: The provided physical address is valid and the level is\n+        // correct. The reference count is increased by one.\n+        unsafe { RawPageTableNode::from_raw_parts(page.paddr(), page.meta().level) }\n     }\n \n-    /// Gets an extra reference of the child at the given index.\n-    pub(super) fn child(&self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            if !pte.is_last(self.level()) {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n-                unsafe {\n-                    Page::<PageTablePageMeta<E, C>>::inc_ref_count(paddr);\n-                }\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely\n-                // increase the reference count by one more.\n-                unsafe {\n-                    DynPage::inc_ref_count(paddr);\n-                }\n-                // SAFETY: The physical address of the PTE points to a forgotten\n-                // page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n-            } else {\n-                Child::Untracked(paddr, pte.prop())\n-            }\n-        }\n+    /// Gets the number of valid PTEs in the node.\n+    pub(super) fn nr_children(&self) -> u16 {\n+        // SAFETY: The lock is held so we have an exclusive access.\n+        unsafe { *self.page.meta().nr_children.get() }\n     }\n \n-    /// Replace the child at the given index with a new child.\n+    /// Reads a non-owning PTE at the given index.\n     ///\n-    /// The old child is returned.\n-    pub(super) fn replace_child(\n-        &mut self,\n-        idx: usize,\n-        new_child: Child<E, C>,\n-        in_tracked_range: bool,\n-    ) -> Child<E, C> {\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let old_pte = self.read_pte(idx);\n-\n-        let new_child_is_none = match new_child {\n-            Child::None => {\n-                if old_pte.is_present() {\n-                    self.write_pte(idx, E::new_absent());\n-                }\n-                true\n-            }\n-            Child::PageTable(pt) => {\n-                let pt = ManuallyDrop::new(pt);\n-                let new_pte = E::new_pt(pt.paddr());\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Page(page, prop) => {\n-                debug_assert!(in_tracked_range);\n-                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-            Child::Untracked(pa, prop) => {\n-                debug_assert!(!in_tracked_range);\n-                let new_pte = E::new_page(pa, self.level(), prop);\n-                self.write_pte(idx, new_pte);\n-                false\n-            }\n-        };\n-\n-        if old_pte.is_present() {\n-            if new_child_is_none {\n-                *self.nr_children_mut() -= 1;\n-            }\n-            let paddr = old_pte.paddr();\n-            if !old_pte.is_last(self.level()) {\n-                Child::PageTable(RawPageTableNode {\n-                    raw: paddr,\n-                    _phantom: PhantomData,\n-                })\n-            } else if in_tracked_range {\n-                // SAFETY: The physical address of the old PTE points to a\n-                // forgotten page. It is reclaimed only once.\n-                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n-            } else {\n-                Child::Untracked(paddr, old_pte.prop())\n-            }\n-        } else {\n-            if !new_child_is_none {\n-                *self.nr_children_mut() += 1;\n-            }\n-            Child::None\n-        }\n-    }\n-\n-    /// Splits the untracked huge page mapped at `idx` to smaller pages.\n-    pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n-        // These should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert!(self.level() > 1);\n-\n-        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n-            panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n-        };\n-\n-        let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n-        for i in 0..nr_subpage_per_huge::<C>() {\n-            let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n-        }\n-\n-        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n-    }\n-\n-    /// Protects an already mapped child at a given index.\n-    pub(super) fn protect(&mut self, idx: usize, prop: PageProperty) {\n-        let mut pte = self.read_pte(idx);\n-        debug_assert!(pte.is_present()); // This should be ensured by the cursor.\n-\n-        pte.set_prop(prop);\n-\n-        // SAFETY: the index is within the bound and the PTE is valid.\n-        unsafe {\n-            (self.as_ptr() as *mut E).add(idx).write(pte);\n-        }\n-    }\n-\n-    pub(super) fn read_pte(&self, idx: usize) -> E {\n-        // It should be ensured by the cursor.\n+    /// A non-owning PTE means that it does not account for a reference count\n+    /// of the a page if the PTE points to a page. The original PTE still owns\n+    /// the child page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the index is within the bound.\n+    unsafe fn read_pte(&self, idx: usize) -> E {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { self.as_ptr().add(idx).read() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *const E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).read() }\n     }\n \n     /// Writes a page table entry at a given index.\n     ///\n-    /// This operation will leak the old child if the PTE is present.\n-    fn write_pte(&mut self, idx: usize, pte: E) {\n-        // It should be ensured by the cursor.\n+    /// This operation will leak the old child if the old PTE is present.\n+    ///\n+    /// The child represented by the given PTE will handover the ownership to\n+    /// the node. The PTE will be rendered invalid after this operation.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that:\n+    ///  1. The index must be within the bound;\n+    ///  2. The PTE must represent a child compatible with this page table node\n+    ///     (see [`Child::is_compatible`]).\n+    unsafe fn write_pte(&mut self, idx: usize, pte: E) {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // SAFETY: the index is within the bound and PTE is plain-old-data.\n-        unsafe { (self.as_ptr() as *mut E).add(idx).write(pte) };\n-    }\n-\n-    /// The number of valid PTEs.\n-    pub(super) fn nr_children(&self) -> u16 {\n-        // SAFETY: The lock is held so there is no mutable reference to it.\n-        // It would be safe to read.\n-        unsafe { *self.meta().nr_children.get() }\n+        let ptr = paddr_to_vaddr(self.page.paddr()) as *mut E;\n+        // SAFETY: The index is within the bound and the PTE is plain-old-data.\n+        unsafe { ptr.add(idx).write(pte) }\n     }\n \n+    /// Gets the mutable reference to the number of valid PTEs in the node.\n     fn nr_children_mut(&mut self) -> &mut u16 {\n         // SAFETY: The lock is held so we have an exclusive access.\n-        unsafe { &mut *self.meta().nr_children.get() }\n-    }\n-\n-    fn as_ptr(&self) -> *const E {\n-        paddr_to_vaddr(self.start_paddr()) as *const E\n-    }\n-\n-    fn start_paddr(&self) -> Paddr {\n-        self.page.paddr()\n-    }\n-\n-    fn meta(&self) -> &PageTablePageMeta<E, C> {\n-        self.page.meta()\n+        unsafe { &mut *self.page.meta().nr_children.get() }\n     }\n }\n \n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -465,8 +359,16 @@ where\n     const USAGE: PageUsage = PageUsage::PageTable;\n \n     fn on_drop(page: &mut Page<Self>) {\n+        // SAFETY: This is the last reference so we have an exclusive access.\n+        let nr_children = unsafe { *page.meta().nr_children.get() };\n+\n+        if nr_children == 0 {\n+            return;\n+        }\n+\n         let paddr = page.paddr();\n         let level = page.meta().level;\n+        let is_tracked = page.meta().is_tracked;\n \n         // Drop the children.\n         for i in 0..nr_subpage_per_huge::<C>() {\n\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node/mod.rs\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node/mod.rs\n@@ -476,19 +378,21 @@ where\n             let pte_ptr = unsafe { (paddr_to_vaddr(paddr) as *const E).add(i) };\n             // SAFETY: The pointer is valid and the PTE is plain-old-data.\n             let pte = unsafe { pte_ptr.read() };\n+\n+            // Here if we use directly `Child::from_pte` we would experience a\n+            // 50% increase in the overhead of the `drop` function. It seems that\n+            // Rust is very conservative about inlining and optimizing dead code\n+            // for `unsafe` code. So we manually inline the function here.\n             if pte.is_present() {\n-                // Just restore the handle and drop the handle.\n+                let paddr = pte.paddr();\n                 if !pte.is_last(level) {\n-                    // This is a page table.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page table node.\n-                    drop(unsafe { Page::<Self>::from_raw(pte.paddr()) });\n-                } else {\n-                    // This is a page. You cannot drop a page table node that maps to\n-                    // untracked pages. This must be verified.\n-                    // SAFETY: The physical address must be casted from a handle to a\n-                    // page.\n-                    drop(unsafe { DynPage::from_raw(pte.paddr()) });\n+                    // SAFETY: The PTE points to a page table node. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { Page::<Self>::from_raw(paddr) });\n+                } else if is_tracked == MapTrackingStatus::Tracked {\n+                    // SAFETY: The PTE points to a tracked page. The ownership\n+                    // of the child is transferred to the child then dropped.\n+                    drop(unsafe { DynPage::from_raw(paddr) });\n                 }\n             }\n         }\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -226,6 +226,8 @@ ktest: initramfs $(CARGO_OSDK)\n \t@for dir in $(OSDK_CRATES); do \\\n \t\t[ $$dir = \"ostd/libs/linux-bzimage/setup\" ] && continue; \\\n \t\t(cd $$dir && cargo osdk test) || exit 1; \\\n+\t\ttail --lines 10 qemu.log | grep -q \"^\\\\[ktest runner\\\\] All crates tested.\" \\\n+\t\t\t|| (echo \"Test failed\" && exit 1); \\\n \tdone\n \n .PHONY: docs\n",
        "problem_statement": "Silently failed ktest in OSTD: untracked_map_unmap\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/11101937778/job/30840638910#step:6:634\r\n\r\nThe ktest `test_untracked_map_unmap` failed, but CI doesn't notice it. The failure is reproducible locally.\r\n\r\n### To Reproduce\r\n\r\n```bash\r\ncd ostd && cargo osdk test test_untracked_map_unmap\r\n```\r\n\n[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n",
        "hints_text": "\nI've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.",
        "created_at": "2024-09-24T09:24:48Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 782,
        "instance_id": "asterinas__asterinas-782",
        "issue_numbers": [
            "774",
            "790"
        ],
        "base_commit": "34e9d71fe4501bf4cac4d8263ccb568a814ac4b7",
        "patch": "diff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -55,7 +55,7 @@ use alloc::vec;\n use aster_frame::cpu::UserContext;\n use aster_frame::prelude::*;\n use aster_frame::task::{Task, TaskOptions};\n-use aster_frame::user::{UserEvent, UserMode, UserSpace};\n+use aster_frame::user::{ReturnReason, UserMode, UserSpace};\n use aster_frame::vm::{PageFlags, PAGE_SIZE, Vaddr, VmAllocOptions, VmIo, VmMapOptions, VmSpace};\n \n /// The kernel's boot and initialization process is managed by Asterinas Framework.\n\ndiff --git a/docs/src/framework/a-100-line-kernel.md b/docs/src/framework/a-100-line-kernel.md\n--- a/docs/src/framework/a-100-line-kernel.md\n+++ b/docs/src/framework/a-100-line-kernel.md\n@@ -116,13 +116,15 @@ fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n \n         loop {\n             // The execute method returns when system\n-            // calls or CPU exceptions occur.\n-            let user_event = user_mode.execute();\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n             // The CPU registers of the user space\n             // can be accessed and manipulated via\n             // the `UserContext` abstraction.\n             let user_context = user_mode.context_mut();\n-            if UserEvent::Syscall == user_event {\n+            if ReturnReason::UserSyscall == return_reason {\n                 handle_syscall(user_context, current.user_space().unwrap());\n             }\n         }\n\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -23,7 +23,7 @@ use x86_64::registers::rflags::RFlags;\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\n use crate::{\n     trap::call_irq_callback_functions,\n-    user::{UserContextApi, UserContextApiInternal, UserEvent},\n+    user::{ReturnReason, UserContextApi, UserContextApiInternal},\n };\n \n /// Returns the number of CPUs.\n\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -257,11 +257,15 @@ impl UserContext {\n }\n \n impl UserContextApiInternal for UserContext {\n-    fn execute(&mut self) -> crate::user::UserEvent {\n+    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         // set interrupt flag so that in user mode it can receive external interrupts\n         // set ID flag which means cpu support CPUID instruction\n         self.user_context.general.rflags |= (RFlags::INTERRUPT_FLAG | RFlags::ID).bits() as usize;\n \n+        let return_reason: ReturnReason;\n         const SYSCALL_TRAPNUM: u16 = 0x100;\n \n         let mut user_preemption = UserPreemption::new();\n\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -281,31 +285,36 @@ impl UserContextApiInternal for UserContext {\n                         || exception.typ == CpuExceptionType::Fault\n                         || exception.typ == CpuExceptionType::Trap\n                     {\n+                        return_reason = ReturnReason::UserException;\n                         break;\n                     }\n                 }\n                 None => {\n                     if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\n+                        return_reason = ReturnReason::UserSyscall;\n                         break;\n                     }\n                 }\n             };\n             call_irq_callback_functions(&self.as_trap_frame());\n+            if has_kernel_event() {\n+                return_reason = ReturnReason::KernelEvent;\n+                break;\n+            }\n \n             user_preemption.might_preempt();\n         }\n \n         crate::arch::irq::enable_local();\n-        if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\n+        if return_reason == ReturnReason::UserException {\n             self.cpu_exception_info = CpuExceptionInfo {\n                 page_fault_addr: unsafe { x86::controlregs::cr2() },\n                 id: self.user_context.trap_num,\n                 error_code: self.user_context.error_code,\n             };\n-            UserEvent::Exception\n-        } else {\n-            UserEvent::Syscall\n         }\n+\n+        return_reason\n     }\n \n     fn as_trap_frame(&self) -> trapframe::TrapFrame {\n\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -51,7 +51,9 @@ impl UserSpace {\n /// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n-    fn execute(&mut self) -> UserEvent;\n+    fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool;\n \n     /// Use the information inside CpuContext to build a trapframe\n     fn as_trap_frame(&self) -> TrapFrame;\n\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -93,9 +95,9 @@ pub trait UserContextApi {\n ///     .expect(\"the current task is associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n-///     // Execute in the user space until some interesting user event occurs\n-///     let user_event = user_mode.execute();\n-///     todo!(\"handle the user event, e.g., syscall\");\n+///     // Execute in the user space until some interesting events occur.\n+///     let return_reason = user_mode.execute(|| false);\n+///     todo!(\"handle the event, e.g., syscall\");\n /// }\n /// ```\n pub struct UserMode<'a> {\n\ndiff --git /dev/null b/regression/apps/alarm/alarm.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/alarm/alarm.c\n@@ -0,0 +1,11 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#include <unistd.h>\n+\n+int main()\n+{\n+\talarm(3);\n+\twhile (1) {\n+\t}\n+\treturn 0;\n+}\n",
        "test_patch": "diff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -118,17 +120,22 @@ impl<'a> UserMode<'a> {\n \n     /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\n     ///\n-    /// The method returns for one of three possible reasons indicated by `UserEvent`.\n-    /// 1. The user invokes a system call;\n-    /// 2. The user triggers an exception;\n-    /// 3. The user triggers a fault.\n+    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\n+    /// 1. A system call is issued by the user space;\n+    /// 2. A CPU exception is triggered by the user space;\n+    /// 3. A kernel event is pending, as indicated by the given closure.\n     ///\n-    /// After handling the user event and updating the user-mode CPU context,\n+    /// After handling whatever user or kernel events that\n+    /// cause the method to return\n+    /// and updating the user-mode CPU context,\n     /// this method can be invoked again to go back to the user space.\n-    pub fn execute(&mut self) -> UserEvent {\n+    pub fn execute<F>(&mut self, has_kernel_event: F) -> ReturnReason\n+    where\n+        F: FnMut() -> bool,\n+    {\n         self.user_space.vm_space().activate();\n         debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n-        self.context.execute()\n+        self.context.execute(has_kernel_event)\n     }\n \n     /// Returns an immutable reference the user-mode CPU context.\n\ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -143,14 +150,13 @@ impl<'a> UserMode<'a> {\n }\n \n #[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n-/// A user event is what brings back the control of the CPU back from\n-/// the user space to the kernel space.\n-///\n-/// Note that hardware interrupts are not considered user events as they\n-/// are triggered by devices and not visible to user programs.\n-/// To handle interrupts, one should register callback funtions for\n-/// IRQ lines (`IrqLine`).\n-pub enum UserEvent {\n-    Syscall,\n-    Exception,\n+/// A reason as to why the control of the CPU is returned from\n+/// the user space to the kernel.\n+pub enum ReturnReason {\n+    /// A system call is issued by the user space.\n+    UserSyscall,\n+    /// A CPU exception is triggered by the user space.\n+    UserException,\n+    /// A kernel event is pending\n+    KernelEvent,\n }\n\ndiff --git a/kernel/aster-nix/src/thread/kernel_thread.rs b/kernel/aster-nix/src/thread/kernel_thread.rs\n--- a/kernel/aster-nix/src/thread/kernel_thread.rs\n+++ b/kernel/aster-nix/src/thread/kernel_thread.rs\n@@ -44,6 +44,8 @@ impl KernelThreadExt for Thread {\n             let weal_thread = thread_ref.clone();\n             let task = TaskOptions::new(thread_fn)\n                 .data(weal_thread)\n+                .priority(thread_options.priority)\n+                .cpu_affinity(thread_options.cpu_affinity)\n                 .build()\n                 .unwrap();\n             let status = ThreadStatus::Init;\n\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -1,20 +1,27 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_frame::{\n-    cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n-    user::{UserContextApi, UserEvent, UserMode, UserSpace},\n+    user::{ReturnReason, UserContextApi, UserMode, UserSpace},\n };\n \n use super::Thread;\n use crate::{\n-    cpu::LinuxAbi, prelude::*, process::signal::handle_pending_signal, syscall::handle_syscall,\n+    cpu::LinuxAbi,\n+    prelude::*,\n+    process::{posix_thread::PosixThreadExt, signal::handle_pending_signal},\n+    syscall::handle_syscall,\n     thread::exception::handle_exception,\n };\n \n /// create new task with userspace and parent process\n pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n     fn user_task_entry() {\n+        fn has_pending_signal(current_thread: &Arc<Thread>) -> bool {\n+            let posix_thread = current_thread.as_posix_thread().unwrap();\n+            posix_thread.has_pending_signal()\n+        }\n+\n         let current_thread = current_thread!();\n         let current_task = current_thread.task();\n         let user_space = current_task\n\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -34,11 +41,17 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             user_mode.context().syscall_ret()\n         );\n \n+        #[allow(clippy::redundant_closure)]\n+        let has_kernel_event_fn = || has_pending_signal(&current_thread);\n         loop {\n-            let user_event = user_mode.execute();\n+            let return_reason = user_mode.execute(has_kernel_event_fn);\n             let context = user_mode.context_mut();\n             // handle user event:\n-            handle_user_event(user_event, context);\n+            match return_reason {\n+                ReturnReason::UserException => handle_exception(context),\n+                ReturnReason::UserSyscall => handle_syscall(context),\n+                ReturnReason::KernelEvent => {}\n+            };\n             // should be do this comparison before handle signal?\n             if current_thread.status().is_exited() {\n                 break;\n\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/aster-nix/src/thread/task.rs\n--- a/kernel/aster-nix/src/thread/task.rs\n+++ b/kernel/aster-nix/src/thread/task.rs\n@@ -68,10 +81,3 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         .build()\n         .expect(\"spawn task failed\")\n }\n-\n-fn handle_user_event(user_event: UserEvent, context: &mut UserContext) {\n-    match user_event {\n-        UserEvent::Syscall => handle_syscall(context),\n-        UserEvent::Exception => handle_exception(context),\n-    }\n-}\n\ndiff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -10,6 +10,7 @@ REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n \n # These test apps are sorted by name\n TEST_APPS := \\\n+\talarm \\\n \tclone3 \\\n \teventfd2 \\\n \texecve \\\n\ndiff --git /dev/null b/regression/apps/alarm/Makefile\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/alarm/Makefile\n@@ -0,0 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n+include ../test_common.mk\n+\n+EXTRA_C_FLAGS := -static\n",
        "problem_statement": "Deliver POSIX signals for busy-loop user code\n## Problem\r\n\r\nCurrently, the POSIX signals are handled in the main loop of user tasks, after `UserMode::execute` returns.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            \r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n            \r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            // POSIX signals are handled here!\r\n            handle_pending_signal(context).unwrap();\r\n            \r\n            // ...\r\n        }\r\n    }\r\n    \r\n    TaskOptions::new(user_task_entry)\r\n        .data(thread_ref)\r\n        .user_space(Some(user_space))\r\n        .build()\r\n        .expect(\"spawn task failed\")\r\n}\r\n```\r\n\r\nThis means that if `UserMode::execute` does not returns, then the kernel has no chance to handle signals. Consider the following simple user program in C.\r\n\r\n```rust\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\n\r\nOf course. The `SIGALRM` shall never be delivered to the process by Asterinas as the kernel can only handles POSIX signals when the user code requests system calls.\r\n\r\n## Analysis\r\n\r\nTo figure out a solution, let's dig into the `UserMode::execute` function, which calls `UserContext::execute` to do the real job.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n    \r\n    loop {\r\n        self.user_context.run();\r\n        match CpuException::to_cpu_exception(self.user_context.trap_num as u16) {\r\n            Some(exception) => {\r\n                if exception.typ == CpuExceptionType::FaultOrTrap\r\n                    || exception.typ == CpuExceptionType::Fault\r\n                    || exception.typ == CpuExceptionType::Trap\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            None => {\r\n                if self.user_context.trap_num as u16 == SYSCALL_TRAPNUM {\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        call_irq_callback_functions(&self.as_trap_frame());\r\n    }\r\n\r\n    if self.user_context.trap_num as u16 != SYSCALL_TRAPNUM {\r\n        // ...\r\n        \r\n        UserEvent::Exception\r\n    } else {\r\n        UserEvent::Syscall\r\n    }\r\n}\r\n```\r\n\r\nIf the periodic timer interrupt is triggered while the CPU is running in the user mode, then `self.user_context.run()` returns and the interrupt is handled by the `call_irq_callback_functions` function.\r\n\r\nSo the control of the CPU does return to the kernel at regular intervals. However, a significant issue arises with the `UserContext::execute` method from the Asterinas Framework\u2014it lacks awareness and handling of POSIX signals, and appropriately so.\r\n\r\n## Solution\r\n\r\n### Major changes to `aster-frame`\r\n\r\nSo this issue proposes to extend the API of the `UserMode::execute` method as well as that of `UserContext::execute` so that the two methods would return the control of the CPU to its caller (e.g., the `aster-nix` crate) if there are pending events (e.g., POSIX signals).\r\n\r\nThe new interface is as shown below.\r\n\r\n```rust\r\nimpl<'a> UserMode<'a> {\r\n    /// Starts executing in the user mode. Make sure current task is the task in `UserMode`.\r\n    ///\r\n    /// The method returns for one of three possible reasons indicated by `ReturnReason`.\r\n    /// 1. A system call is issued by the user space;\r\n    /// 2. A CPU exception is triggered by the user space;\r\n    /// 3. A kernel event is pending, as indicated by the given closure.\r\n    ///\r\n    /// After handling whatever user or kernel events that \r\n    /// cause the method to return\r\n    /// and updating the user-mode CPU context,\r\n    /// this method can be invoked again to go back to the user space.\r\n    fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason \r\n    where\r\n        F: FnMut() -> bool,\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nThe new `ReturnReason` replaces the old `UserEvent`.\r\n\r\n```rust\r\n/// A reason as to why the control of the CPU is returned from\r\n/// the user space to the kernel.\r\n#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\r\npub enum ReturnReason {\r\n    /// A system call is issued by the user space.\r\n    UserSyscall,\r\n    /// A CPU exception is triggered by the user space.\r\n    UserException,\r\n    /// A kernel event is pending \r\n    KernelEvent,\r\n}\r\n```\r\n\r\n### Major changes to `aster-nix`\r\n\r\nThe main loop of a user task is modifed to utilize the extended interface of `UserMode::execute`.\r\n\r\n```rust\r\nfn execute(&mut self) -> crate::user::UserEvent {\r\n    // ...\r\n\r\n    fn user_task_entry() {\r\n        let has_kernel_events_fn = {\r\n            let current = current!();\r\n            let current_thread = current_thread!();\r\n            || {\r\n                current.has_pending_signals()\r\n            }\r\n        };\r\n        \r\n        loop {\r\n            let return_reason = user_mode.execute(has_kernel_events_fn);\r\n            let context = user_mode.context_mut();\r\n            match user_event {\r\n                ReturnReason::UserSyscall => handle_syscall(context),\r\n                ReturnReason::UserException => handle_exception(context),\r\n                _ =>,\r\n            }\r\n\r\n            let current_thread = current_thread!();\r\n            if current_thread.status().lock().is_exited() {\r\n                break;\r\n            }\r\n            handle_pending_signal(context).unwrap();\r\n            // ...\r\n        }\r\n    }\r\n\r\n    // ...\r\n}\r\n```\r\n\n`ThreadOptions` is not fully used while creating new kernel thread\nHere is the `aster-nix::thread::kernel_thread::ThreadOptions`.\r\n```rust\r\n/// Options to create or spawn a new thread.\r\npub struct ThreadOptions {\r\n    func: Option<Box<dyn Fn() + Send + Sync>>,\r\n    priority: Priority,\r\n    cpu_affinity: CpuSet,\r\n}\r\n```\r\nIt has fields representing priority and cpu affinity. But when we create new kernel thread in the code below,\r\n```rust\r\nfn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\r\n        let task_fn = thread_options.take_func();\r\n        let thread_fn = move || {\r\n            task_fn();\r\n            let current_thread = current_thread!();\r\n            // ensure the thread is exit\r\n            current_thread.exit();\r\n        };\r\n        let tid = allocate_tid();\r\n        let thread = Arc::new_cyclic(|thread_ref| {\r\n            let weal_thread = thread_ref.clone();\r\n            let task = TaskOptions::new(thread_fn)\r\n                .data(weal_thread)\r\n                .build()\r\n                .unwrap();\r\n            let status = ThreadStatus::Init;\r\n            let kernel_thread = KernelThread;\r\n            Thread::new(tid, task, kernel_thread, status)\r\n        });\r\n        thread_table::add_thread(thread.clone());\r\n        thread\r\n    }\r\n```\r\nwe never use this two fields to construct `TaskOptions`, therefore the bound task is always of default configuration. \r\n\r\nOne problem caused by this issue is that all `Worker`s in `WORKERPOOL_HIGH_PRI` are of normal priority instead of real-time priority, which is incorrect and can cause starvation in some specific cases.\n",
        "hints_text": "I made some modification in #782 to enable timely delivery of POSIX signals based on the solution you proposed. But as to this specific MRE that you mentioned,\r\n```c\r\nint main() {\r\n    // When the one second elapses, a SIGALRM will be triggered.\r\n    // The default behavior of a process when receiving SIGALRM\r\n    // is to terminate the process.\r\n    alarm(1);\r\n    // But currently, the busy loop will prevent the program\r\n    // from being terminated!\r\n    while (1) { }\r\n    return 0;\r\n}\r\n```\r\nI'm afraid that's not enough. \r\n\r\nUnder current implementation of alarm syscall, the actual callback, in which we enqueue the `SIGALRM` to corresponding `posix_thread`'s `sig_queues`, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed. \n> Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted to the work queue? \r\n\r\nBut I'm not sure whether we need to trigger preemtion before handling irq or after handling irq.\n> > Under current implementation of alarm syscall, the actual callback, in which we enqueue the SIGALRM to corresponding posix_thread's sig_queues, is submitted to the global workqueue once the timer expires. However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n> \r\n> @jellllly420, there's a preemption point in the main loop of `user_task_entry`, after handling pending signal. So the workqueue thread should be scheduled to run after some signal is submitted the the work queue?\r\n\r\nWill the `Usermode::execute` in `user_task_entry` ever return once we enter the `while(1)` busy-looping?\r\n\r\n\n> Will the Usermode::execute in user_task_entry ever return once we enter the while(1) busy-looping?\r\n\r\nCurrently, it won't. Maybe the `has_kernel_events_fn` should also check whether there are any pending workitems, and if any, `Usermode.execute` should also return to `aster-nix` to enable workqueue thread run. \r\n\r\nI'm not sure whether it's suitable to do so. \n> However, our scheduler doesn't support preemption, therefore the submitted workitem will never be executed.\r\n\r\n@jellllly420 The following small change should be enough to address the issue you raised.\r\n\r\n### The change\r\n\r\nThe `aster_frame::task::preempt` function should be made private and called internally in `UserMode::execute`. This way, the Framework ensures that the user-kernel switching is always a preemption point.\r\n\r\n### The rationale\r\n\r\nPreemptive scheduling, as opposite to cooperative scheduling, is by definition transparent to the tasks that are subject to scheduling. In other words, Asterinas Framework must enforce preemption, without cooperation from the users of Asterinas Framework.\r\n\r\nBut in our current implementation, the `preempt` method from `aster-frame` is explicitly called by its user.\r\n\r\n```rust\r\npub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\r\n    fn user_task_entry() {\r\n        loop {\r\n            let user_event = user_mode.execute();\r\n            let context = user_mode.context_mut();\r\n            handle_user_event(user_event, context);\r\n\r\n            // ...\r\n\r\n            // a preemption point after handling user event.\r\n            preempt();\r\n        }\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\nThe proposed change can address this problem.\r\n\nThanks for your advice.\r\n\r\nI have some question about how the `WorkQueue` mechanism works after we submit some `WorkItem`s. If I understood  correctly, the `Monitor` of `WorkerPool` should be scheduled to run first and the `Monitor` will `wake_worker` or `add_worker`, then we should wait for the running worker to be scheduled and the `Worker` will pick a  `WorkItem` to run if there is any. \r\n\r\nIf that is the case, how can a `Monitor` of `normal` priority `preempt` a running thread in current `PriorityScheduler`? Calling `schedule` instead of `preempt` may be a workaround, though logically incorrect (because the user loop should not explicitly give up cpu).\nUpdate:\r\n\r\nWhen I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nAfter fixing that issue, the `SIGALRM` signal can finally be correctly enqueued. I expected that the `while(1)` thread would be rescheduled to run and the signal would be handled in next timer interrupt. The `while(1)` did get on the cpu. However, this time the `UserContext::run` never returned. I'm not that familiar with this part and need to dig in more to find out what happened.\n> When I replaced `preempt` with `schedule`, the `Monitor` can be scheduled to run. However, `Workers` waken by `Monitor` still cannot be scheduled even though they are supposed to be of real-time priority. It's caused by #790.\r\n\r\nGood point \ud83d\udc4d \n@jellllly420 Good job on spotting the bug. Could you try to fix it?",
        "created_at": "2024-04-23T16:18:28Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 650,
        "instance_id": "asterinas__asterinas-650",
        "issue_numbers": [
            "646"
        ],
        "base_commit": "07fbbcfd8c22459719c9af7eeeb3dee5ad24ba92",
        "patch": "diff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -105,14 +105,9 @@ static ssize_t receive_all(int sockfd)\n \tsize_t recv_len = 0;\n \tssize_t ret;\n \n-\tif (mark_filde_nonblock(sockfd) < 0) {\n-\t\tperror(\"receive_all: mark_filde_nonblock\");\n-\t\treturn -1;\n-\t}\n-\n \tfor (;;) {\n \t\tret = recv(sockfd, buffer, sizeof(buffer), 0);\n-\t\tif (ret < 0 && errno == EAGAIN)\n+\t\tif (ret == 0)\n \t\t\tbreak;\n \n \t\tif (ret < 0) {\n\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -230,6 +228,9 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tsent_len += 1;\n \tfprintf(stderr, \"Sent bytes: %lu\\n\", sent_len);\n \n+\tclose(sendfd);\n+\tsendfd = -1;\n+\n \tret = 0;\n \n wait:\n\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -250,7 +251,8 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tclose(recvfd);\n \n out_send:\n-\tclose(sendfd);\n+\tif (sendfd >= 0)\n+\t\tclose(sendfd);\n \n out_listen:\n \tclose(listenfd);\n\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -18,7 +18,7 @@ echo \"Start network test......\"\n ./socketpair\n ./sockoption\n ./listen_backlog\n-# ./send_buf_full\n+./send_buf_full\n ./http_server &\n ./http_client\n ./tcp_err\n",
        "test_patch": "diff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -197,6 +192,9 @@ int test_full_send_buffer(struct sockaddr_in *addr)\n \tif (pid == 0) {\n \t\tssize_t recv_len;\n \n+\t\tclose(sendfd);\n+\t\tsendfd = -1;\n+\n \t\t// Ensure that the parent executes send() first, then the child\n \t\t// executes recv().\n \t\tsleep(1);\n",
        "problem_statement": "The send_buf_full test fails on host linux\nThe test is run within Asterinas dev container. \r\n\r\nTo replay the results, commands are \r\n```bash\r\nmake build\r\ncd regression/build/initramfs/regression/network\r\n./send_buf_full\r\n```\r\nI run `./send_buf_full` for four times, the results are\r\n```\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2553825\r\nTest failed: Mismatched sent bytes and received bytes\r\nTest failed: Error occurs in child process\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nStart receiving...\r\nSent bytes: 2586567\r\nReceived bytes: 2586567\r\nTest passed: Equal sent bytes and received bytes\r\nroot@kx-2288H-V6:~/asterinas/regression/build/initramfs/regression/network# ./send_buf_full \r\nnew_bound_socket: bind: Address already in use\r\nTest failed: Error occurs in new_bound_socket\r\n```\r\nI have repeated the test several time and find the same results: the test fails at the first run and succeeds in some following run. And once the test succeeds, the following run will report `Address already in use` error.\r\n\n",
        "hints_text": "",
        "created_at": "2024-02-23T12:37:06Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 630,
        "instance_id": "asterinas__asterinas-630",
        "issue_numbers": [
            "625"
        ],
        "base_commit": "b450eef1660c0362ba65de07a3bd03c8199c3265",
        "patch": "diff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,6 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n+use aster_frame::sync::WaitQueue;\n use keyable_arc::KeyableWeak;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -22,9 +23,11 @@ pub struct IfaceCommon {\n     interface: SpinLock<smoltcp::iface::Interface>,\n     sockets: SpinLock<SocketSet<'static>>,\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n-    /// The time should do next poll. We stores the total microseconds since system boots up.\n+    /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n     bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    /// The wait queue that background polling thread will sleep on\n+    polling_wait_queue: WaitQueue,\n }\n \n impl IfaceCommon {\n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -37,6 +40,7 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \n\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -60,6 +64,10 @@ impl IfaceCommon {\n         })\n     }\n \n+    pub(super) fn polling_wait_queue(&self) -> &WaitQueue {\n+        &self.polling_wait_queue\n+    }\n+\n     /// Alloc an unused port range from 49152 ~ 65535 (According to smoltcp docs)\n     fn alloc_ephemeral_port(&self) -> Result<u16> {\n         let mut used_ports = self.used_ports.write();\n\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -1,5 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use aster_frame::sync::WaitQueue;\n use smoltcp::iface::SocketSet;\n \n use self::common::IfaceCommon;\n\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -60,6 +61,11 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n     fn netmask(&self) -> Option<Ipv4Address> {\n         self.common().netmask()\n     }\n+\n+    /// The waitqueue used to background polling thread\n+    fn polling_wait_queue(&self) -> &WaitQueue {\n+        self.common().polling_wait_queue()\n+    }\n }\n \n mod internal {\n\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -1,6 +1,8 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use aster_frame::timer::read_monotonic_milli_seconds;\n+use core::time::Duration;\n+\n+use aster_frame::{task::Priority, timer::read_monotonic_milli_seconds};\n \n use super::Iface;\n use crate::{\n\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/aster-nix/src/net/iface/util.rs\n--- a/kernel/aster-nix/src/net/iface/util.rs\n+++ b/kernel/aster-nix/src/net/iface/util.rs\n@@ -46,30 +48,40 @@ impl BindPortConfig {\n }\n \n pub fn spawn_background_poll_thread(iface: Arc<dyn Iface>) {\n-    // FIXME: use timer or wait_timeout when timer is enable.\n     let task_fn = move || {\n-        debug!(\"spawn background poll thread\");\n+        trace!(\"spawn background poll thread for {}\", iface.name());\n+        let wait_queue = iface.polling_wait_queue();\n         loop {\n-            let next_poll_time = if let Some(next_poll_time) = iface.next_poll_at_ms() {\n-                next_poll_time\n+            let next_poll_at_ms = if let Some(next_poll_at_ms) = iface.next_poll_at_ms() {\n+                next_poll_at_ms\n             } else {\n-                Thread::yield_now();\n-                continue;\n+                wait_queue.wait_until(|| iface.next_poll_at_ms())\n             };\n-            let now = read_monotonic_milli_seconds();\n-            if now > next_poll_time {\n-                // FIXME: now is later than next poll time. This may cause problem.\n+\n+            let now_as_ms = read_monotonic_milli_seconds();\n+\n+            // FIXME: Ideally, we should perform the `poll` just before `next_poll_at_ms`.\n+            // However, this approach may result in a spinning busy loop\n+            // if the `poll` operation yields no results.\n+            // To mitigate this issue,\n+            // we have opted to assign a high priority to the polling thread,\n+            // ensuring that the `poll` runs as soon as possible.\n+            // For a more in-depth discussion, please refer to the following link:\n+            // <https://github.com/asterinas/asterinas/pull/630#discussion_r1496817030>.\n+            if now_as_ms >= next_poll_at_ms {\n                 iface.poll();\n                 continue;\n             }\n-            let duration = next_poll_time - now;\n-            // FIXME: choose a suitable time interval\n-            if duration < 10 {\n-                iface.poll();\n-            } else {\n-                Thread::yield_now();\n-            }\n+\n+            let duration = Duration::from_millis(next_poll_at_ms - now_as_ms);\n+            wait_queue.wait_until_or_timeout(\n+                // If `iface.next_poll_at_ms()` changes to an earlier time, we will end the waiting.\n+                || (iface.next_poll_at_ms()? < next_poll_at_ms).then_some(()),\n+                &duration,\n+            );\n         }\n     };\n-    Thread::spawn_kernel_thread(ThreadOptions::new(task_fn));\n+\n+    let options = ThreadOptions::new(task_fn).priority(Priority::high());\n+    Thread::spawn_kernel_thread(options);\n }\n\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -18,7 +18,7 @@ echo \"Start network test......\"\n ./socketpair\n ./sockoption\n ./listen_backlog\n-./send_buf_full\n+# ./send_buf_full\n \n \n echo \"All network test passed\"\n",
        "test_patch": "diff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -155,10 +163,16 @@ impl IfaceCommon {\n \n         let sockets = self.sockets.lock_irq_disabled();\n         if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+            let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms\n-                .store(instant.total_millis() as u64, Ordering::SeqCst);\n+                .store(instant.total_millis() as u64, Ordering::Relaxed);\n+\n+            if new_instant < old_instant {\n+                self.polling_wait_queue.wake_all();\n+            }\n         } else {\n-            self.next_poll_at_ms.store(0, Ordering::SeqCst);\n+            self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n     }\n \n",
        "problem_statement": "Support for in-kernel sleep\nCurrently sleep function we provide seems to be the only `pauser.pause_until_or_timeout()` for the POSIX threads from users, as in the `clock_nanosleep` syscall. However, some functionalities within kernel also need sleep like\r\nhttps://github.com/asterinas/asterinas/blob/bd6f65667df494f6fb88fc60eb4ed18a106bed71/services/libs/aster-std/src/net/iface/util.rs#L49-L76\r\nWithout the support for kernel-level sleep, the polling would consume all the CPU cycles just to busy polling, while there is already hint for how long it should wait.\n",
        "hints_text": "In-kernel sleep is supported. A kernel thread can sleep using the `WaitQueue` API provided by the Framework. `Pauser` is in fact based on `WaitQueue`.\r\n\r\nIn theory, the specific code snippet you show can and should be refactored using `WaitQueue` to avoid busy looping. But it is written that way. Why? My guess is that at the time when this busy loop is written, the timer API of the Framework is not ready.\r\n\r\n```rust\r\n// FIXME: use timer or wait_timeout when timer is enable. \r\n```\r\n\r\n@StevenJiang1110 is the original author so his answer is the most wanted. \r\n\nYes, the origin code is added when `WaitQueue` cannot accept a `timeout` parameter.  Since timeout is supported now, we can avoid using busy loop here. #630 provides a fix for this problem.",
        "created_at": "2024-01-29T03:53:41Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 395,
        "instance_id": "asterinas__asterinas-395",
        "issue_numbers": [
            "254"
        ],
        "base_commit": "576578baf4025686ae4c2893c2aafbc8d1e14722",
        "patch": "diff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -12,6 +12,8 @@ pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \n+use self::tty::get_n_tty;\n+\n /// Init the device node in fs, must be called after mounting rootfs.\n pub fn init() -> Result<()> {\n     let null = Arc::new(null::Null);\n\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -19,7 +21,9 @@ pub fn init() -> Result<()> {\n     let zero = Arc::new(zero::Zero);\n     add_node(zero, \"zero\")?;\n     tty::init();\n-    let tty = tty::get_n_tty().clone();\n+    let console = get_n_tty().clone();\n+    add_node(console, \"console\")?;\n+    let tty = Arc::new(tty::TtyDevice);\n     add_node(tty, \"tty\")?;\n     let random = Arc::new(random::Random);\n     add_node(random, \"random\")?;\n\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Null;\n \n\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -12,7 +15,9 @@ impl Device for Null {\n         // Same value with Linux\n         DeviceId::new(1, 3)\n     }\n+}\n \n+impl FileIo for Null {\n     fn read(&self, _buf: &mut [u8]) -> Result<usize> {\n         Ok(0)\n     }\n\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -20,4 +25,9 @@ impl Device for Null {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/jinux-std/src/device/pty/mod.rs\n--- a/services/libs/jinux-std/src/device/pty/mod.rs\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -33,7 +33,7 @@ pub fn init() -> Result<()> {\n \n pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n     debug!(\"pty index = {}\", index);\n-    let master = Arc::new(PtyMaster::new(ptmx, index));\n-    let slave = Arc::new(PtySlave::new(master.clone()));\n+    let master = PtyMaster::new(ptmx, index);\n+    let slave = PtySlave::new(&master);\n     Ok((master, slave))\n }\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -2,16 +2,18 @@ use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \n use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::device::tty::new_job_control_and_ldisc;\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n-use crate::fs::file_handle::FileLike;\n+use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::FsPath;\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::{AccessMode, Inode, InodeMode, IoctlCmd};\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n+use crate::process::{JobControl, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n-const PTS_DIR: &str = \"/dev/pts\";\n const BUFFER_CAPACITY: usize = 4096;\n \n /// Pesudo terminal master.\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -23,19 +25,24 @@ pub struct PtyMaster {\n     index: u32,\n     output: Arc<LineDiscipline>,\n     input: SpinLock<HeapRb<u8>>,\n+    job_control: Arc<JobControl>,\n     /// The state of input buffer\n     pollee: Pollee,\n+    weak_self: Weak<Self>,\n }\n \n impl PtyMaster {\n-    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n-        Self {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| PtyMaster {\n             ptmx,\n             index,\n-            output: LineDiscipline::new(),\n+            output: ldisc,\n             input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            job_control,\n             pollee: Pollee::new(IoEvents::OUT),\n-        }\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -46,16 +53,12 @@ impl PtyMaster {\n         &self.ptmx\n     }\n \n-    pub(super) fn slave_push_byte(&self, byte: u8) {\n+    pub(super) fn slave_push_char(&self, ch: u8) {\n         let mut input = self.input.lock_irq_disabled();\n-        input.push_overwrite(byte);\n+        input.push_overwrite(ch);\n         self.update_state(&input);\n     }\n \n-    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.output.read(buf)\n-    }\n-\n     pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         let mut poll_status = IoEvents::empty();\n \n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -87,7 +90,7 @@ impl PtyMaster {\n     }\n }\n \n-impl FileLike for PtyMaster {\n+impl FileIo for PtyMaster {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         // TODO: deal with nonblocking read\n         if buf.is_empty() {\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -122,7 +125,6 @@ impl FileLike for PtyMaster {\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut input = self.input.lock();\n-\n         for character in buf {\n             self.output.push_char(*character, |content| {\n                 for byte in content.as_bytes() {\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -193,29 +195,35 @@ impl FileLike for PtyMaster {\n                 self.output.set_window_size(winsize);\n                 Ok(0)\n             }\n-            IoctlCmd::TIOCSCTTY => {\n-                // TODO: reimplement when adding session.\n-                let foreground = {\n-                    let current = current!();\n-                    let process_group = current.process_group().unwrap();\n-                    Arc::downgrade(&process_group)\n-                };\n-                self.output.set_fg(foreground);\n-                Ok(0)\n-            }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                let Some(foreground) = self.foreground() else {\n                     return_errno_with_message!(\n                         Errno::ESRCH,\n                         \"the foreground process group does not exist\"\n                     );\n                 };\n+                let fg_pgid = foreground.pgid();\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO: reimplement when adding session.\n-                self.output.set_fg(Weak::new());\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -246,15 +254,47 @@ impl FileLike for PtyMaster {\n     }\n }\n \n-pub struct PtySlave(Arc<PtyMaster>);\n+impl Terminal for PtyMaster {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Drop for PtyMaster {\n+    fn drop(&mut self) {\n+        let fs = self.ptmx.fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.index;\n+        devpts.remove_slave(index);\n+    }\n+}\n+\n+pub struct PtySlave {\n+    master: Weak<PtyMaster>,\n+    job_control: JobControl,\n+    weak_self: Weak<Self>,\n+}\n \n impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Self {\n-        PtySlave(master)\n+    pub fn new(master: &Arc<PtyMaster>) -> Arc<Self> {\n+        Arc::new_cyclic(|weak_ref| PtySlave {\n+            master: Arc::downgrade(master),\n+            job_control: JobControl::new(),\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n-        self.0.index()\n+        self.master().index()\n+    }\n+\n+    fn master(&self) -> Arc<PtyMaster> {\n+        self.master.upgrade().unwrap()\n     }\n }\n \n\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -266,50 +306,91 @@ impl Device for PtySlave {\n     fn id(&self) -> crate::fs::device::DeviceId {\n         DeviceId::new(88, self.index())\n     }\n+}\n \n+impl Terminal for PtySlave {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl FileIo for PtySlave {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.0.slave_read(buf)\n+        self.job_control.wait_until_in_foreground()?;\n+        self.master().output.read(buf)\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let master = self.master();\n         for ch in buf {\n             // do we need to add '\\r' here?\n             if *ch == b'\\n' {\n-                self.0.slave_push_byte(b'\\r');\n-                self.0.slave_push_byte(b'\\n');\n+                master.slave_push_char(b'\\r');\n+                master.slave_push_char(b'\\n');\n             } else {\n-                self.0.slave_push_byte(*ch);\n+                master.slave_push_char(*ch);\n             }\n         }\n         Ok(buf.len())\n     }\n \n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.master().slave_poll(mask, poller)\n+    }\n+\n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n         match cmd {\n             IoctlCmd::TCGETS\n             | IoctlCmd::TCSETS\n-            | IoctlCmd::TIOCGPGRP\n             | IoctlCmd::TIOCGPTN\n             | IoctlCmd::TIOCGWINSZ\n-            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            | IoctlCmd::TIOCSWINSZ => self.master().ioctl(cmd, arg),\n+            IoctlCmd::TIOCGPGRP => {\n+                if !self.is_controlling_terminal() {\n+                    return_errno_with_message!(Errno::ENOTTY, \"slave is not controlling terminal\");\n+                }\n+\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+\n+                let fg_pgid = foreground.pgid();\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCSCTTY => {\n-                // TODO:\n+                self.set_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO:\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n-                let buffer_len = self.0.slave_buf_len() as i32;\n+                let buffer_len = self.master().slave_buf_len() as i32;\n                 write_val_to_user(arg, &buffer_len)?;\n                 Ok(0)\n             }\n             _ => Ok(0),\n         }\n     }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.slave_poll(mask, poller)\n-    }\n }\n\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Random;\n \n\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -19,7 +22,9 @@ impl Device for Random {\n         // The same value as Linux\n         DeviceId::new(1, 8)\n     }\n+}\n \n+impl FileIo for Random {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\n\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -27,6 +32,11 @@ impl Device for Random {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n \n impl From<getrandom::Error> for Error {\n\ndiff --git /dev/null b/services/libs/jinux-std/src/device/tty/device.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/tty/device.rs\n@@ -0,0 +1,47 @@\n+use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::signal::Poller;\n+\n+/// Corresponds to `/dev/tty` in the file system. This device represents the controlling terminal\n+/// of the session of current process.\n+pub struct TtyDevice;\n+\n+impl Device for TtyDevice {\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let current = current!();\n+        let session = current.session().unwrap();\n+\n+        let Some(terminal) = session.terminal() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the session does not have controlling terminal\"\n+            );\n+        };\n+\n+        Ok(Some(terminal as Arc<dyn FileIo>))\n+    }\n+\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        DeviceId::new(5, 0)\n+    }\n+}\n+\n+impl FileIo for TtyDevice {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read tty device\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write tty device\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+}\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -1,13 +1,10 @@\n use crate::events::IoEvents;\n+use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::{Pollee, Poller};\n-use crate::process::ProcessGroup;\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n-use crate::{\n-    prelude::*,\n-    process::{signal::signals::kernel::KernelSignal, Pgid},\n-};\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -19,19 +16,21 @@ use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n const BUFFER_CAPACITY: usize = 4096;\n \n+pub type LdiscSignalSender = Arc<dyn Fn(KernelSignal) + Send + Sync + 'static>;\n+\n pub struct LineDiscipline {\n     /// current line\n     current_line: SpinLock<CurrentLine>,\n     /// The read buffer\n     read_buffer: SpinLock<StaticRb<u8, BUFFER_CAPACITY>>,\n-    /// The foreground process group\n-    foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n     /// Windows size,\n     winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n+    /// Used to send signal for foreground processes, when some char comes.\n+    send_signal: LdiscSignalSender,\n     /// work item\n     work_item: Arc<WorkItem>,\n     /// Parameters used by a work item.\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -76,8 +75,8 @@ impl CurrentLine {\n \n impl LineDiscipline {\n     /// Create a new line discipline\n-    pub fn new() -> Arc<Self> {\n-        Arc::new_cyclic(|line_ref: &Weak<LineDiscipline>| {\n+    pub fn new(send_signal: LdiscSignalSender) -> Arc<Self> {\n+        Arc::new_cyclic(move |line_ref: &Weak<LineDiscipline>| {\n             let line_discipline = line_ref.clone();\n             let work_item = Arc::new(WorkItem::new(Box::new(move || {\n                 if let Some(line_discipline) = line_discipline.upgrade() {\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -87,10 +86,10 @@ impl LineDiscipline {\n             Self {\n                 current_line: SpinLock::new(CurrentLine::new()),\n                 read_buffer: SpinLock::new(StaticRb::default()),\n-                foreground: SpinLock::new(Weak::new()),\n                 termios: SpinLock::new(KernelTermios::default()),\n                 winsize: SpinLock::new(WinSize::default()),\n                 pollee: Pollee::new(IoEvents::empty()),\n+                send_signal,\n                 work_item,\n                 work_item_para: Arc::new(SpinLock::new(LineDisciplineWorkPara::new())),\n             }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -98,7 +97,7 @@ impl LineDiscipline {\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char<F: FnMut(&str)>(&self, ch: u8, echo_callback: F) {\n+    pub fn push_char<F2: FnMut(&str)>(&self, ch: u8, echo_callback: F2) {\n         let termios = self.termios.lock_irq_disabled();\n \n         let ch = if termios.contains_icrnl() && ch == b'\\r' {\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -107,7 +106,7 @@ impl LineDiscipline {\n             ch\n         };\n \n-        if self.may_send_signal_to_foreground(&termios, ch) {\n+        if self.may_send_signal(&termios, ch) {\n             // The char is already dealt with, so just return\n             return;\n         }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -158,22 +157,14 @@ impl LineDiscipline {\n         self.update_readable_state_deferred();\n     }\n \n-    fn may_send_signal_to_foreground(&self, termios: &KernelTermios, ch: u8) -> bool {\n-        if !termios.contains_isig() {\n+    fn may_send_signal(&self, termios: &KernelTermios, ch: u8) -> bool {\n+        if !termios.is_canonical_mode() || !termios.contains_isig() {\n             return false;\n         }\n \n-        let Some(foreground) = self.foreground.lock().upgrade() else {\n-            return false;\n-        };\n-\n         let signal = match ch {\n-            item if item == *termios.get_special_char(CC_C_CHAR::VINTR) => {\n-                KernelSignal::new(SIGINT)\n-            }\n-            item if item == *termios.get_special_char(CC_C_CHAR::VQUIT) => {\n-                KernelSignal::new(SIGQUIT)\n-            }\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VINTR) => KernelSignal::new(SIGINT),\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VQUIT) => KernelSignal::new(SIGQUIT),\n             _ => return false,\n         };\n         // `kernel_signal()` may cause sleep, so only construct parameters here.\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -182,7 +173,7 @@ impl LineDiscipline {\n         true\n     }\n \n-    fn update_readable_state(&self) {\n+    pub fn update_readable_state(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n         if !buffer.is_empty() {\n             self.pollee.add_events(IoEvents::IN);\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -193,7 +184,6 @@ impl LineDiscipline {\n \n     fn update_readable_state_deferred(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n-        let pollee = self.pollee.clone();\n         // add/del events may sleep, so only construct parameters here.\n         if !buffer.is_empty() {\n             self.work_item_para.lock_irq_disabled().pollee_type = Some(PolleeType::Add);\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -206,11 +196,7 @@ impl LineDiscipline {\n     /// include all operations that may cause sleep, and processes by a work queue.\n     fn update_readable_state_after(&self) {\n         if let Some(signal) = self.work_item_para.lock_irq_disabled().kernel_signal.take() {\n-            self.foreground\n-                .lock()\n-                .upgrade()\n-                .unwrap()\n-                .kernel_signal(signal)\n+            (self.send_signal)(signal);\n         };\n         if let Some(pollee_type) = self.work_item_para.lock_irq_disabled().pollee_type.take() {\n             match pollee_type {\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -243,42 +229,24 @@ impl LineDiscipline {\n         }\n     }\n \n-    /// read all bytes buffered to dst, return the actual read length.\n-    pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let mut poller = None;\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         loop {\n-            let res = self.try_read(dst);\n+            let res = self.try_read(buf);\n             match res {\n-                Ok(read_len) => {\n-                    return Ok(read_len);\n-                }\n-                Err(e) => {\n-                    if e.error() != Errno::EAGAIN {\n-                        return Err(e);\n+                Ok(len) => return Ok(len),\n+                Err(e) if e.error() != Errno::EAGAIN => return Err(e),\n+                Err(_) => {\n+                    let poller = Some(Poller::new());\n+                    if self.poll(IoEvents::IN, poller.as_ref()).is_empty() {\n+                        poller.as_ref().unwrap().wait()?\n                     }\n                 }\n             }\n-\n-            // Wait for read event\n-            let need_poller = if poller.is_none() {\n-                poller = Some(Poller::new());\n-                poller.as_ref()\n-            } else {\n-                None\n-            };\n-            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n-            if revents.is_empty() {\n-                // FIXME: deal with ldisc read timeout\n-                poller.as_ref().unwrap().wait()?;\n-            }\n         }\n     }\n \n-    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n-        if !self.current_can_read() {\n-            return_errno!(Errno::EAGAIN);\n-        }\n-\n+    /// read all bytes buffered to dst, return the actual read length.\n+    fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n         let (vmin, vtime) = {\n             let termios = self.termios.lock_irq_disabled();\n             let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -326,7 +294,8 @@ impl LineDiscipline {\n                 if termios.is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if is_line_terminator(next_char, &termios) {\n-                        if !should_not_be_read(next_char, &termios) {\n+                        // The eof should not be read\n+                        if !is_eof(next_char, &termios) {\n                             *dst_i = next_char;\n                             read_len += 1;\n                         }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -368,31 +337,6 @@ impl LineDiscipline {\n         todo!()\n     }\n \n-    /// Determine whether current process can read the line discipline. If current belongs to the foreground process group.\n-    /// or the foreground process group is None, returns true.\n-    fn current_can_read(&self) -> bool {\n-        let current = current!();\n-        let Some(foreground) = self.foreground.lock_irq_disabled().upgrade() else {\n-            return true;\n-        };\n-        foreground.contains_process(current.pid())\n-    }\n-\n-    /// set foreground process group\n-    pub fn set_fg(&self, foreground: Weak<ProcessGroup>) {\n-        *self.foreground.lock_irq_disabled() = foreground;\n-        // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n-        self.update_readable_state();\n-    }\n-\n-    /// get foreground process group id\n-    pub fn fg_pgid(&self) -> Option<Pgid> {\n-        self.foreground\n-            .lock_irq_disabled()\n-            .upgrade()\n-            .map(|foreground| foreground.pgid())\n-    }\n-\n     /// whether there is buffered data\n     pub fn is_empty(&self) -> bool {\n         self.read_buffer.lock_irq_disabled().len() == 0\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -439,8 +383,7 @@ fn is_line_terminator(item: u8, termios: &KernelTermios) -> bool {\n     false\n }\n \n-/// The special char should not be read by reading process\n-fn should_not_be_read(ch: u8, termios: &KernelTermios) -> bool {\n+fn is_eof(ch: u8, termios: &KernelTermios) -> bool {\n     ch == *termios.get_special_char(CC_C_CHAR::VEOF)\n }\n \n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -467,6 +410,7 @@ enum PolleeType {\n }\n \n struct LineDisciplineWorkPara {\n+    #[allow(clippy::type_complexity)]\n     kernel_signal: Option<KernelSignal>,\n     pollee_type: Option<PolleeType>,\n }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -2,23 +2,28 @@ use spin::Once;\n \n use self::driver::TtyDriver;\n use self::line_discipline::LineDiscipline;\n-use super::*;\n use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::IoctlCmd;\n use crate::prelude::*;\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::Poller;\n-use crate::process::{process_table, ProcessGroup};\n+use crate::process::{JobControl, Process, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n+mod device;\n pub mod driver;\n pub mod line_discipline;\n pub mod termio;\n \n+pub use device::TtyDevice;\n+\n static N_TTY: Once<Arc<Tty>> = Once::new();\n \n pub(super) fn init() {\n     let name = CString::new(\"console\").unwrap();\n-    let tty = Arc::new(Tty::new(name));\n+    let tty = Tty::new(name);\n     N_TTY.call_once(|| tty);\n     driver::init();\n }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -28,44 +33,36 @@ pub struct Tty {\n     name: CString,\n     /// line discipline\n     ldisc: Arc<LineDiscipline>,\n+    job_control: Arc<JobControl>,\n     /// driver\n     driver: SpinLock<Weak<TtyDriver>>,\n+    weak_self: Weak<Self>,\n }\n \n impl Tty {\n-    pub fn new(name: CString) -> Self {\n-        Tty {\n+    pub fn new(name: CString) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| Tty {\n             name,\n-            ldisc: LineDiscipline::new(),\n+            ldisc,\n+            job_control,\n             driver: SpinLock::new(Weak::new()),\n-        }\n-    }\n-\n-    /// Set foreground process group\n-    pub fn set_fg(&self, process_group: Weak<ProcessGroup>) {\n-        self.ldisc.set_fg(process_group);\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn set_driver(&self, driver: Weak<TtyDriver>) {\n         *self.driver.lock_irq_disabled() = driver;\n     }\n \n-    pub fn receive_char(&self, item: u8) {\n-        self.ldisc.push_char(item, |content| print!(\"{}\", content));\n+    pub fn receive_char(&self, ch: u8) {\n+        self.ldisc.push_char(ch, |content| print!(\"{}\", content));\n     }\n }\n \n-impl Device for Tty {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        // Same value with Linux\n-        DeviceId::new(5, 0)\n-    }\n-\n+impl FileIo for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.job_control.wait_until_in_foreground()?;\n         self.ldisc.read(buf)\n     }\n \n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -92,23 +89,28 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.ldisc.fg_pgid() else {\n-                    return_errno_with_message!(Errno::ENOENT, \"No fg process group\")\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(Errno::ESRCH, \"No fg process group\")\n                 };\n+                let fg_pgid = foreground.pgid();\n                 debug!(\"fg_pgid = {}\", fg_pgid);\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCSPGRP => {\n                 // Set the process group id of fg progress group\n-                let pgid = read_val_from_user::<i32>(arg)?;\n-                if pgid < 0 {\n-                    return_errno_with_message!(Errno::EINVAL, \"invalid pgid\");\n-                }\n-                match process_table::pgid_to_process_group(pgid as u32) {\n-                    None => self.ldisc.set_fg(Weak::new()),\n-                    Some(process_group) => self.ldisc.set_fg(Arc::downgrade(&process_group)),\n-                }\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                // Some background processes may be waiting on the wait queue,\n+                // when set_fg, the background processes may be able to read.\n+                self.ldisc.update_readable_state();\n                 Ok(0)\n             }\n             IoctlCmd::TCSETS => {\n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -143,12 +145,73 @@ impl Device for Tty {\n                 self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             _ => todo!(),\n         }\n     }\n }\n \n-/// FIXME: should we maintain a static console?\n+impl Terminal for Tty {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Device for Tty {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        // The same value as /dev/console in linux.\n+        DeviceId::new(88, 0)\n+    }\n+}\n+\n+pub fn new_job_control_and_ldisc() -> (Arc<JobControl>, Arc<LineDiscipline>) {\n+    let job_control = Arc::new(JobControl::new());\n+\n+    let send_signal = {\n+        let cloned_job_control = job_control.clone();\n+        move |signal: KernelSignal| {\n+            let Some(foreground) = cloned_job_control.foreground() else {\n+                return;\n+            };\n+\n+            foreground.broadcast_signal(signal);\n+        }\n+    };\n+\n+    let ldisc = LineDiscipline::new(Arc::new(send_signal));\n+\n+    (job_control, ldisc)\n+}\n+\n pub fn get_n_tty() -> &'static Arc<Tty> {\n     N_TTY.get().unwrap()\n }\n+\n+/// Open `N_TTY` as the controlling terminal for the process. This method should\n+/// only be called when creating the init process.\n+pub fn open_ntty_as_controlling_terminal(process: &Process) -> Result<()> {\n+    let tty = get_n_tty();\n+\n+    let session = &process.session().unwrap();\n+    let process_group = process.process_group().unwrap();\n+\n+    session.set_terminal(|| {\n+        tty.job_control.set_session(session);\n+        Ok(tty.clone())\n+    })?;\n+\n+    tty.job_control.set_foreground(Some(&process_group))?;\n+\n+    Ok(())\n+}\n\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Urandom;\n \n\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -19,7 +22,9 @@ impl Device for Urandom {\n         // The same value as Linux\n         DeviceId::new(1, 9)\n     }\n+}\n \n+impl FileIo for Urandom {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\n\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -27,4 +32,9 @@ impl Device for Urandom {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Zero;\n \n\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -12,7 +15,9 @@ impl Device for Zero {\n         // Same value with Linux\n         DeviceId::new(1, 5)\n     }\n+}\n \n+impl FileIo for Zero {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         for byte in buf.iter_mut() {\n             *byte = 0;\n\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -23,4 +28,9 @@ impl Device for Zero {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/device.rs b/services/libs/jinux-std/src/fs/device.rs\n--- a/services/libs/jinux-std/src/fs/device.rs\n+++ b/services/libs/jinux-std/src/fs/device.rs\n@@ -1,33 +1,21 @@\n-use crate::events::IoEvents;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n-use crate::fs::utils::{InodeMode, InodeType, IoctlCmd};\n+use crate::fs::utils::{InodeMode, InodeType};\n use crate::prelude::*;\n-use crate::process::signal::Poller;\n+\n+use super::inode_handle::FileIo;\n \n /// The abstract of device\n-pub trait Device: Sync + Send {\n+pub trait Device: Sync + Send + FileIo {\n     /// Return the device type.\n     fn type_(&self) -> DeviceType;\n \n     /// Return the device ID.\n     fn id(&self) -> DeviceId;\n \n-    /// Read from the device.\n-    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n-\n-    /// Write to the device.\n-    fn write(&self, buf: &[u8]) -> Result<usize>;\n-\n-    /// Poll on the device.\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        let events = IoEvents::IN | IoEvents::OUT;\n-        events & mask\n-    }\n-\n-    /// Ioctl on the device.\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    /// Open a device.\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        Ok(None)\n     }\n }\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs /dev/null\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-use crate::events::IoEvents;\n-use crate::fs::file_handle::FileLike;\n-use crate::prelude::*;\n-use crate::process::signal::Poller;\n-\n-use super::*;\n-\n-use crate::device::PtyMaster;\n-\n-/// Pty master inode for the master device.\n-pub struct PtyMasterInode(Arc<PtyMaster>);\n-\n-impl PtyMasterInode {\n-    pub fn new(device: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self(device))\n-    }\n-}\n-\n-impl Drop for PtyMasterInode {\n-    fn drop(&mut self) {\n-        // Remove the slave from fs.\n-        let fs = self.0.ptmx().fs();\n-        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n-\n-        let index = self.0.index();\n-        devpts.remove_slave(index);\n-    }\n-}\n-\n-impl Inode for PtyMasterInode {\n-    /// Do not cache dentry in DCACHE.\n-    ///\n-    /// Each file descriptor obtained by opening \"/dev/ptmx\" is an independent pty master\n-    /// with its own associated pty slave.\n-    fn is_dentry_cacheable(&self) -> bool {\n-        false\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.0.ptmx().metadata().size\n-    }\n-\n-    fn resize(&self, new_size: usize) {}\n-\n-    fn metadata(&self) -> Metadata {\n-        self.0.ptmx().metadata()\n-    }\n-\n-    fn type_(&self) -> InodeType {\n-        self.0.ptmx().metadata().type_\n-    }\n-\n-    fn mode(&self) -> InodeMode {\n-        self.0.ptmx().metadata().mode\n-    }\n-\n-    fn set_mode(&self, mode: InodeMode) {}\n-\n-    fn atime(&self) -> Duration {\n-        self.0.ptmx().metadata().atime\n-    }\n-\n-    fn set_atime(&self, time: Duration) {}\n-\n-    fn mtime(&self) -> Duration {\n-        self.0.ptmx().metadata().mtime\n-    }\n-\n-    fn set_mtime(&self, time: Duration) {}\n-\n-    fn read_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn write_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_direct_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn write_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_direct_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.0.ioctl(cmd, arg)\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.poll(mask, poller)\n-    }\n-\n-    fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().fs()\n-    }\n-}\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,4 @@\n+use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\n     DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,11 +10,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\n \n-mod master;\n mod ptmx;\n mod slave;\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -52,7 +51,7 @@ impl DevPts {\n     }\n \n     /// Create the master and slave pair.\n-    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMasterInode>, Arc<PtySlaveInode>)> {\n+    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMaster>, Arc<PtySlaveInode>)> {\n         let index = self\n             .index_alloc\n             .lock()\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -61,17 +60,16 @@ impl DevPts {\n \n         let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n-        let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\n         self.root.add_slave(index.to_string(), slave_inode.clone());\n \n-        Ok((master_inode, slave_inode))\n+        Ok((master, slave_inode))\n     }\n \n     /// Remove the slave from fs.\n     ///\n     /// This is called when the master is being dropped.\n-    fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n+    pub fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n         let removed_slave = self.root.remove_slave(&index.to_string());\n         if removed_slave.is_some() {\n             self.index_alloc.lock().free(index as usize);\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -241,7 +239,7 @@ impl Inode for RootInode {\n         let inode = match name {\n             \".\" | \"..\" => self.fs().root_inode(),\n             // Call the \"open\" method of ptmx to create a master and slave pair.\n-            \"ptmx\" => self.ptmx.open()?,\n+            \"ptmx\" => self.ptmx.clone(),\n             slave => self\n                 .slaves\n                 .read()\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -1,4 +1,8 @@\n+use crate::device::PtyMaster;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n use super::*;\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -14,12 +18,14 @@ const PTMX_MINOR_NUM: u32 = 2;\n pub struct Ptmx {\n     inner: Inner,\n     metadata: Metadata,\n-    fs: Weak<DevPts>,\n }\n \n+#[derive(Clone)]\n+struct Inner(Weak<DevPts>);\n+\n impl Ptmx {\n     pub fn new(sb: &SuperBlock, fs: Weak<DevPts>) -> Arc<Self> {\n-        let inner = Inner;\n+        let inner = Inner(fs);\n         Arc::new(Self {\n             metadata: Metadata::new_device(\n                 PTMX_INO,\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -28,20 +34,19 @@ impl Ptmx {\n                 &inner,\n             ),\n             inner,\n-            fs,\n         })\n     }\n \n     /// The open method for ptmx.\n     ///\n     /// Creates a master and slave pair and returns the master inode.\n-    pub fn open(&self) -> Result<Arc<PtyMasterInode>> {\n+    pub fn open(&self) -> Result<Arc<PtyMaster>> {\n         let (master, _) = self.devpts().create_master_slave_pair()?;\n         Ok(master)\n     }\n \n     pub fn devpts(&self) -> Arc<DevPts> {\n-        self.fs.upgrade().unwrap()\n+        self.inner.0.upgrade().unwrap()\n     }\n \n     pub fn device_type(&self) -> DeviceType {\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -119,9 +124,11 @@ impl Inode for Ptmx {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.devpts()\n     }\n-}\n \n-struct Inner;\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(Arc::new(self.inner.clone()))\n+    }\n+}\n \n impl Device for Inner {\n     fn type_(&self) -> DeviceType {\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -132,13 +139,23 @@ impl Device for Inner {\n         DeviceId::new(PTMX_MAJOR_NUM, PTMX_MINOR_NUM)\n     }\n \n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let devpts = self.0.upgrade().unwrap();\n+        let (master, _) = devpts.create_master_slave_pair()?;\n+        Ok(Some(master as _))\n+    }\n+}\n+\n+impl FileIo for Inner {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        // do nothing because it should not be used to read.\n-        Ok(0)\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read ptmx\");\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n-        // do nothing because it should not be used to write.\n-        Ok(buf.len())\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write ptmx\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n     }\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -1,4 +1,5 @@\n use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -107,4 +108,8 @@ impl Inode for PtySlaveInode {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.fs.upgrade().unwrap()\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(self.device.clone())\n+    }\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -1,6 +1,7 @@\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\n+use crate::fs::device::Device;\n use crate::fs::utils::{AccessMode, IoctlCmd, Metadata, SeekFrom, StatusFlags};\n use crate::net::socket::Socket;\n use crate::prelude::*;\n\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -73,6 +74,10 @@ pub trait FileLike: Send + Sync + Any {\n     fn as_socket(&self) -> Option<&dyn Socket> {\n         None\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n }\n \n impl dyn FileLike {\n\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -27,7 +27,7 @@ impl FileTable {\n     pub fn new_with_stdio() -> Self {\n         let mut table = SlotVec::new();\n         let fs_resolver = FsResolver::new();\n-        let tty_path = FsPath::new(AT_FDCWD, \"/dev/tty\").expect(\"cannot find tty\");\n+        let tty_path = FsPath::new(AT_FDCWD, \"/dev/console\").expect(\"cannot find tty\");\n         let stdin = {\n             let flags = AccessMode::O_RDONLY as u32;\n             let mode = InodeMode::S_IRUSR;\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -21,8 +21,16 @@ impl InodeHandle<Rights> {\n         if access_mode.is_writable() && inode.type_() == InodeType::Dir {\n             return_errno_with_message!(Errno::EISDIR, \"Directory cannot open to write\");\n         }\n+\n+        let file_io = if let Some(device) = inode.as_device() {\n+            device.open()?\n+        } else {\n+            None\n+        };\n+\n         let inner = Arc::new(InodeHandle_ {\n             dentry,\n+            file_io,\n             offset: Mutex::new(0),\n             access_mode,\n             status_flags: AtomicU32::new(status_flags.bits()),\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -42,6 +50,7 @@ impl InodeHandle<Rights> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n         }\n+\n         self.0.read_to_end(buf)\n     }\n \n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -75,11 +84,11 @@ impl FileLike for InodeHandle<Rights> {\n     }\n \n     fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.dentry().inode().poll(mask, poller)\n+        self.0.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.dentry().inode().ioctl(cmd, arg)\n+        self.0.ioctl(cmd, arg)\n     }\n \n     fn metadata(&self) -> Metadata {\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -107,4 +116,8 @@ impl FileLike for InodeHandle<Rights> {\n         // Close does not guarantee that the data has been successfully saved to disk.\n         Ok(())\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.dentry().inode().as_device()\n+    }\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -5,11 +5,14 @@ mod static_cap;\n \n use core::sync::atomic::{AtomicU32, Ordering};\n \n+use crate::events::IoEvents;\n+use crate::fs::device::Device;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::{\n     AccessMode, Dentry, DirentVisitor, InodeType, IoctlCmd, Metadata, SeekFrom, StatusFlags,\n };\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n use jinux_rights::Rights;\n \n #[derive(Debug)]\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -17,6 +20,10 @@ pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\n \n struct InodeHandle_ {\n     dentry: Arc<Dentry>,\n+    /// `file_io` is Similar to `file_private` field in `file` structure in linux. If\n+    /// `file_io` is Some, typical file operations including `read`, `write`, `poll`,\n+    /// `ioctl` will be provided by `file_io`, instead of `dentry`.\n+    file_io: Option<Arc<dyn FileIo>>,\n     offset: Mutex<usize>,\n     access_mode: AccessMode,\n     status_flags: AtomicU32,\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -25,6 +32,11 @@ struct InodeHandle_ {\n impl InodeHandle_ {\n     pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.read(buf);\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_at(*offset, buf)?\n         } else {\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -37,6 +49,11 @@ impl InodeHandle_ {\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.write(buf);\n+        }\n+\n         if self.status_flags().contains(StatusFlags::O_APPEND) {\n             *offset = self.dentry.inode_len();\n         }\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -51,6 +68,10 @@ impl InodeHandle_ {\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        if self.file_io.is_some() {\n+            return_errno_with_message!(Errno::EINVAL, \"file io does not support read to end\");\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_to_end(buf)?\n         } else {\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -117,6 +138,22 @@ impl InodeHandle_ {\n         *offset += read_cnt;\n         Ok(read_cnt)\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.poll(mask, poller);\n+        }\n+\n+        self.dentry.inode().poll(mask, poller)\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.ioctl(cmd, arg);\n+        }\n+\n+        self.dentry.inode().ioctl(cmd, arg)\n+    }\n }\n \n impl Debug for InodeHandle_ {\n\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -136,3 +173,15 @@ impl<R> InodeHandle<R> {\n         &self.0.dentry\n     }\n }\n+\n+pub trait FileIo: Send + Sync + 'static {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize>;\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents;\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    }\n+}\n\ndiff --git a/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/jinux-std/src/fs/procfs/mod.rs\n--- a/services/libs/jinux-std/src/fs/procfs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/mod.rs\n@@ -91,7 +91,7 @@ impl DirOps for RootDirOps {\n             SelfSymOps::new_inode(this_ptr.clone())\n         } else if let Ok(pid) = name.parse::<Pid>() {\n             let process_ref =\n-                process_table::pid_to_process(pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n+                process_table::get_process(&pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n             PidDirOps::new_inode(process_ref, this_ptr.clone())\n         } else {\n             return_errno!(Errno::ENOENT);\n\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -574,6 +574,10 @@ impl Inode for RamInode {\n         Ok(device_inode)\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.0.read().inner.as_device().cloned()\n+    }\n+\n     fn create(&self, name: &str, type_: InodeType, mode: InodeMode) -> Result<Arc<dyn Inode>> {\n         if self.0.read().metadata.type_ != InodeType::Dir {\n             return_errno_with_message!(Errno::ENOTDIR, \"self is not dir\");\n\ndiff --git a/services/libs/jinux-std/src/fs/rootfs.rs b/services/libs/jinux-std/src/fs/rootfs.rs\n--- a/services/libs/jinux-std/src/fs/rootfs.rs\n+++ b/services/libs/jinux-std/src/fs/rootfs.rs\n@@ -84,7 +84,7 @@ pub fn init(initramfs_buf: &[u8]) -> Result<()> {\n \n static ROOT_MOUNT: Once<Arc<MountNode>> = Once::new();\n \n-fn init_root_mount() {\n+pub fn init_root_mount() {\n     ROOT_MOUNT.call_once(|| -> Arc<MountNode> {\n         let rootfs = RamFS::new();\n         MountNode::new_root(rootfs)\n\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -285,6 +285,10 @@ pub trait Inode: Any + Sync + Send {\n         Err(Error::new(Errno::ENOTDIR))\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n+\n     fn readdir_at(&self, offset: usize, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         Err(Error::new(Errno::ENOTDIR))\n     }\n\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -1,26 +1,20 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace, vm::VmIo};\n-\n+use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n+use super::process_vm::ProcessVm;\n+use super::signal::sig_disposition::SigDispositions;\n+use super::{process_table, Process, ProcessBuilder};\n+use crate::current_thread;\n+use crate::fs::file_table::FileTable;\n+use crate::fs::fs_resolver::FsResolver;\n+use crate::fs::utils::FileCreationMask;\n+use crate::prelude::*;\n+use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n+use crate::util::write_val_to_user;\n+use crate::vm::vmar::Vmar;\n+use jinux_frame::cpu::UserContext;\n+use jinux_frame::user::UserSpace;\n+use jinux_frame::vm::VmIo;\n use jinux_rights::Full;\n \n-use crate::{\n-    current_thread,\n-    fs::file_table::FileTable,\n-    fs::{fs_resolver::FsResolver, utils::FileCreationMask},\n-    prelude::*,\n-    process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt, ThreadName},\n-        process_table,\n-    },\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n-    util::write_val_to_user,\n-    vm::vmar::Vmar,\n-};\n-\n-use super::{\n-    posix_thread::PosixThread, process_vm::ProcessVm, signal::sig_disposition::SigDispositions,\n-    Process, ProcessBuilder,\n-};\n-\n bitflags! {\n     pub struct CloneFlags: u32 {\n         const CLONE_VM      = 0x00000100;       /* Set if VM shared between processes.  */\n\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -275,16 +269,13 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n             .file_table(child_file_table)\n             .fs(child_fs)\n             .umask(child_umask)\n-            .sig_dispositions(child_sig_dispositions)\n-            .process_group(current.process_group().unwrap());\n+            .sig_dispositions(child_sig_dispositions);\n \n         process_builder.build()?\n     };\n \n-    current!().add_child(child.clone());\n-    process_table::add_process(child.clone());\n-\n-    let child_thread = thread_table::tid_to_thread(child_tid).unwrap();\n+    // Deals with clone flags\n+    let child_thread = thread_table::get_thread(child_tid).unwrap();\n     let child_posix_thread = child_thread.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -296,6 +287,10 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n         clone_args.child_tidptr,\n         clone_flags,\n     )?;\n+\n+    // Sets parent process and group for child process.\n+    set_parent_and_group(&current, &child);\n+\n     Ok(child)\n }\n \n\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -414,3 +409,19 @@ fn clone_sysvsem(clone_flags: CloneFlags) -> Result<()> {\n     }\n     Ok(())\n }\n+\n+fn set_parent_and_group(parent: &Arc<Process>, child: &Arc<Process>) {\n+    let process_group = parent.process_group().unwrap();\n+\n+    let mut process_table_mut = process_table::process_table_mut();\n+    let mut group_inner = process_group.inner.lock();\n+    let mut child_group_mut = child.process_group.lock();\n+    let mut children_mut = parent.children().lock();\n+\n+    children_mut.insert(child.pid(), child.clone());\n+\n+    group_inner.processes.insert(child.pid(), child.clone());\n+    *child_group_mut = Arc::downgrade(&process_group);\n+\n+    process_table_mut.insert(child.pid(), child.clone());\n+}\n\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -37,9 +37,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     // Move children to the init process\n     if !is_init_process(&current) {\n         if let Some(init_process) = get_init_process() {\n+            let mut init_children = init_process.children().lock();\n             for (_, child_process) in current.children().lock().extract_if(|_, _| true) {\n-                child_process.set_parent(Arc::downgrade(&init_process));\n-                init_process.add_child(child_process);\n+                let mut parent = child_process.parent.lock();\n+                init_children.insert(child_process.pid(), child_process.clone());\n+                *parent = Arc::downgrade(&init_process);\n             }\n         }\n     }\n\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -56,7 +58,7 @@ const INIT_PROCESS_PID: Pid = 1;\n \n /// Get the init process\n fn get_init_process() -> Option<Arc<Process>> {\n-    process_table::pid_to_process(INIT_PROCESS_PID)\n+    process_table::get_process(&INIT_PROCESS_PID)\n }\n \n fn is_init_process(process: &Process) -> bool {\n\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -4,7 +4,6 @@ pub mod posix_thread;\n #[allow(clippy::module_inception)]\n mod process;\n mod process_filter;\n-mod process_group;\n pub mod process_table;\n mod process_vm;\n mod program_loader;\n\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -17,9 +16,10 @@ mod wait;\n pub use clone::{clone_child, CloneArgs, CloneFlags};\n pub use exit::do_exit_group;\n pub use process::ProcessBuilder;\n-pub use process::{current, ExitCode, Pgid, Pid, Process};\n+pub use process::{\n+    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessGroup, Session, Sid, Terminal,\n+};\n pub use process_filter::ProcessFilter;\n-pub use process_group::ProcessGroup;\n pub use program_loader::{check_executable_file, load_program_to_vm};\n pub use rlimit::ResourceType;\n pub use term_status::TermStatus;\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -1,12 +1,10 @@\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\n-use crate::process::posix_thread::PosixThreadBuilder;\n-use crate::process::process_group::ProcessGroup;\n-use crate::process::process_table;\n+use crate::process::posix_thread::{PosixThreadBuilder, PosixThreadExt};\n use crate::process::process_vm::ProcessVm;\n use crate::process::rlimit::ResourceLimits;\n-use crate::process::{posix_thread::PosixThreadExt, signal::sig_disposition::SigDispositions};\n+use crate::process::signal::sig_disposition::SigDispositions;\n use crate::thread::Thread;\n \n use super::{Pid, Process};\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -23,7 +21,6 @@ pub struct ProcessBuilder<'a> {\n     argv: Option<Vec<CString>>,\n     envp: Option<Vec<CString>>,\n     process_vm: Option<ProcessVm>,\n-    process_group: Option<Arc<ProcessGroup>>,\n     file_table: Option<Arc<Mutex<FileTable>>>,\n     fs: Option<Arc<RwLock<FsResolver>>>,\n     umask: Option<Arc<RwLock<FileCreationMask>>>,\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -41,7 +38,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv: None,\n             envp: None,\n             process_vm: None,\n-            process_group: None,\n             file_table: None,\n             fs: None,\n             umask: None,\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -60,11 +56,6 @@ impl<'a> ProcessBuilder<'a> {\n         self\n     }\n \n-    pub fn process_group(&mut self, process_group: Arc<ProcessGroup>) -> &mut Self {\n-        self.process_group = Some(process_group);\n-        self\n-    }\n-\n     pub fn file_table(&mut self, file_table: Arc<Mutex<FileTable>>) -> &mut Self {\n         self.file_table = Some(file_table);\n         self\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -126,7 +117,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv,\n             envp,\n             process_vm,\n-            process_group,\n             file_table,\n             fs,\n             umask,\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -136,10 +126,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         let process_vm = process_vm.or_else(|| Some(ProcessVm::alloc())).unwrap();\n \n-        let process_group_ref = process_group\n-            .as_ref()\n-            .map_or_else(Weak::new, Arc::downgrade);\n-\n         let file_table = file_table\n             .or_else(|| Some(Arc::new(Mutex::new(FileTable::new_with_stdio()))))\n             .unwrap();\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -168,7 +154,6 @@ impl<'a> ProcessBuilder<'a> {\n                 threads,\n                 executable_path.to_string(),\n                 process_vm,\n-                process_group_ref,\n                 file_table,\n                 fs,\n                 umask,\n\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -194,15 +179,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         process.threads().lock().push(thread);\n \n-        if let Some(process_group) = process_group {\n-            process_group.add_process(process.clone());\n-        } else {\n-            let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-            let pgid = new_process_group.pgid();\n-            process.set_process_group(Arc::downgrade(&new_process_group));\n-            process_table::add_process_group(new_process_group);\n-        }\n-\n         process.set_runnable();\n \n         Ok(process)\n\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/job_control.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/job_control.rs\n@@ -0,0 +1,161 @@\n+use crate::prelude::*;\n+use crate::process::signal::constants::{SIGCONT, SIGHUP};\n+use crate::process::signal::signals::kernel::KernelSignal;\n+use crate::process::signal::Pauser;\n+use crate::process::{ProcessGroup, Session};\n+\n+/// The job control for terminals like tty and pty.\n+///\n+/// This struct is used to support shell job control, which allows users to\n+/// run commands in the foreground or in the background. This struct manages\n+/// the session and foreground process group for a terminal.\n+pub struct JobControl {\n+    foreground: SpinLock<Weak<ProcessGroup>>,\n+    session: SpinLock<Weak<Session>>,\n+    pauser: Arc<Pauser>,\n+}\n+\n+impl JobControl {\n+    /// Creates a new `TtyJobControl`\n+    pub fn new() -> Self {\n+        Self {\n+            foreground: SpinLock::new(Weak::new()),\n+            session: SpinLock::new(Weak::new()),\n+            pauser: Pauser::new(),\n+        }\n+    }\n+\n+    // *************** Session ***************\n+\n+    /// Returns the session whose controlling terminal is the terminal.\n+    fn session(&self) -> Option<Arc<Session>> {\n+        self.session.lock().upgrade()\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the `session`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This terminal should not belong to any session.\n+    pub fn set_session(&self, session: &Arc<Session>) {\n+        debug_assert!(self.session().is_none());\n+        *self.session.lock() = Arc::downgrade(session);\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn set_current_session(&self) -> Result<()> {\n+        if self.session().is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal is already controlling terminal of another session\"\n+            );\n+        }\n+\n+        let current = current!();\n+\n+        let process_group = current.process_group().unwrap();\n+        *self.foreground.lock() = Arc::downgrade(&process_group);\n+\n+        let session = current.session().unwrap();\n+        *self.session.lock() = Arc::downgrade(&session);\n+\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Releases the current session from this terminal.\n+    pub fn release_current_session(&self) -> Result<()> {\n+        let Some(session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the terminal is not controlling terminal now\"\n+            );\n+        };\n+\n+        if let Some(foreground) = self.foreground() {\n+            foreground.broadcast_signal(KernelSignal::new(SIGHUP));\n+            foreground.broadcast_signal(KernelSignal::new(SIGCONT));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // *************** Foreground process group ***************\n+\n+    /// Returns the foreground process group\n+    pub fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.foreground.lock().upgrade()\n+    }\n+\n+    /// Sets the foreground process group.\n+    ///\n+    /// # Panic\n+    ///\n+    /// The process group should belong to one session.\n+    pub fn set_foreground(&self, process_group: Option<&Arc<ProcessGroup>>) -> Result<()> {\n+        let Some(process_group) = process_group else {\n+            // FIXME: should we allow this branch?\n+            *self.foreground.lock() = Weak::new();\n+            return Ok(());\n+        };\n+\n+        let session = process_group.session().unwrap();\n+        let Some(terminal_session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal does not become controlling terminal of one session.\"\n+            );\n+        };\n+\n+        if !Arc::ptr_eq(&terminal_session, &session) {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the process proup belongs to different session\"\n+            );\n+        }\n+\n+        *self.foreground.lock() = Arc::downgrade(process_group);\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Wait until the current process is the foreground process group. If\n+    /// the foreground process group is None, returns true.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn wait_until_in_foreground(&self) -> Result<()> {\n+        // Fast path\n+        if self.current_belongs_to_foreground() {\n+            return Ok(());\n+        }\n+\n+        // Slow path\n+        self.pauser.pause_until(|| {\n+            if self.current_belongs_to_foreground() {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn current_belongs_to_foreground(&self) -> bool {\n+        let Some(foreground) = self.foreground() else {\n+            return true;\n+        };\n+\n+        foreground.contains_process(current!().pid())\n+    }\n+}\n+\n+impl Default for JobControl {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -1,7 +1,4 @@\n-mod builder;\n-\n use super::posix_thread::PosixThreadExt;\n-use super::process_group::ProcessGroup;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\n use super::rlimit::ResourceLimits;\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -13,7 +10,7 @@ use super::signal::signals::Signal;\n use super::signal::{Pauser, SigEvents, SigEventsFilter};\n use super::status::ProcessStatus;\n use super::{process_table, TermStatus};\n-use crate::device::tty::get_n_tty;\n+use crate::device::tty::open_ntty_as_controlling_terminal;\n use crate::events::Observer;\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -23,10 +20,25 @@ use crate::thread::{allocate_tid, Thread};\n use crate::vm::vmar::Vmar;\n use jinux_rights::Full;\n \n+mod builder;\n+mod job_control;\n+mod process_group;\n+mod session;\n+mod terminal;\n+\n pub use builder::ProcessBuilder;\n+pub use job_control::JobControl;\n+pub use process_group::ProcessGroup;\n+pub use session::Session;\n+pub use terminal::Terminal;\n \n+/// Process id.\n pub type Pid = u32;\n+/// Process group id.\n pub type Pgid = u32;\n+/// Session Id.\n+pub type Sid = u32;\n+\n pub type ExitCode = i32;\n \n /// Process stands for a set of threads that shares the same userspace.\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -46,11 +58,11 @@ pub struct Process {\n     /// Process status\n     status: Mutex<ProcessStatus>,\n     /// Parent process\n-    parent: Mutex<Weak<Process>>,\n+    pub(super) parent: Mutex<Weak<Process>>,\n     /// Children processes\n     children: Mutex<BTreeMap<Pid, Arc<Process>>>,\n     /// Process group\n-    process_group: Mutex<Weak<ProcessGroup>>,\n+    pub(super) process_group: Mutex<Weak<ProcessGroup>>,\n     /// File table\n     file_table: Arc<Mutex<FileTable>>,\n     /// FsResolver\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -75,7 +87,6 @@ impl Process {\n         threads: Vec<Arc<Thread>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n-        process_group: Weak<ProcessGroup>,\n         file_table: Arc<Mutex<FileTable>>,\n         fs: Arc<RwLock<FsResolver>>,\n         umask: Arc<RwLock<FileCreationMask>>,\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -99,7 +110,7 @@ impl Process {\n             status: Mutex::new(ProcessStatus::Uninit),\n             parent: Mutex::new(parent),\n             children: Mutex::new(BTreeMap::new()),\n-            process_group: Mutex::new(process_group),\n+            process_group: Mutex::new(Weak::new()),\n             file_table,\n             fs,\n             umask,\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -118,11 +129,9 @@ impl Process {\n         // spawn user process should give an absolute path\n         debug_assert!(executable_path.starts_with('/'));\n         let process = Process::create_user_process(executable_path, argv, envp)?;\n-        // FIXME: How to determine the fg process group?\n-        let process_group = Weak::clone(&process.process_group.lock());\n-        // FIXME: tty should be a parameter?\n-        let tty = get_n_tty();\n-        tty.set_fg(process_group);\n+\n+        open_ntty_as_controlling_terminal(&process)?;\n+\n         process.run();\n         Ok(process)\n     }\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -141,7 +150,25 @@ impl Process {\n         };\n \n         let process = process_builder.build()?;\n-        process_table::add_process(process.clone());\n+\n+        // Lock order: session table -> group table -> process table -> group of process\n+        // -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut process_table_mut = process_table::process_table_mut();\n+\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+        group_table_mut.insert(group.pgid(), group.clone());\n+\n+        // Creates new session\n+        let session = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&session);\n+        session.inner.lock().leader = Some(process.clone());\n+        session_table_mut.insert(session.sid(), session);\n+\n+        process_table_mut.insert(process.pid(), process.clone());\n         Ok(process)\n     }\n \n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -180,30 +207,25 @@ impl Process {\n     }\n \n     // *********** Parent and child ***********\n-\n-    pub fn add_child(&self, child: Arc<Process>) {\n-        let child_pid = child.pid();\n-        self.children.lock().insert(child_pid, child);\n-    }\n-\n-    pub fn set_parent(&self, parent: Weak<Process>) {\n-        *self.parent.lock() = parent;\n-    }\n-\n     pub fn parent(&self) -> Option<Arc<Process>> {\n         self.parent.lock().upgrade()\n     }\n \n-    pub fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n+    pub(super) fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n         &self.children\n     }\n \n+    pub fn has_child(&self, pid: &Pid) -> bool {\n+        self.children.lock().contains_key(pid)\n+    }\n+\n     pub fn children_pauser(&self) -> &Arc<Pauser> {\n         &self.children_pauser\n     }\n \n-    // *********** Process group ***********\n+    // *********** Process group & Session***********\n \n+    /// Returns the process group id of the process.\n     pub fn pgid(&self) -> Pgid {\n         if let Some(process_group) = self.process_group.lock().upgrade() {\n             process_group.pgid()\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -212,17 +234,237 @@ impl Process {\n         }\n     }\n \n-    /// Set process group for current process. If old process group exists,\n-    /// remove current process from old process group.\n-    pub fn set_process_group(&self, process_group: Weak<ProcessGroup>) {\n-        if let Some(old_process_group) = self.process_group() {\n-            old_process_group.remove_process(self.pid());\n+    /// Returns the process group which the process belongs to.\n+    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n+        self.process_group.lock().upgrade()\n+    }\n+\n+    /// Returns whether `self` is the leader of process group.\n+    fn is_group_leader(self: &Arc<Self>) -> bool {\n+        let Some(process_group) = self.process_group() else {\n+            return false;\n+        };\n+\n+        let Some(leader) = process_group.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leader)\n+    }\n+\n+    /// Returns the session which the process belongs to.\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        let process_group = self.process_group()?;\n+        process_group.session()\n+    }\n+\n+    /// Returns whether the process is session leader.\n+    pub fn is_session_leader(self: &Arc<Self>) -> bool {\n+        let session = self.session().unwrap();\n+\n+        let Some(leading_process) = session.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leading_process)\n+    }\n+\n+    /// Moves the process to the new session.\n+    ///\n+    /// If the process is already session leader, this method does nothing.\n+    ///\n+    /// Otherwise, this method creates a new process group in a new session\n+    /// and moves the process to the session, returning the new session.\n+    ///\n+    /// This method may return the following errors:\n+    /// * `EPERM`, if the process is a process group leader, or some existing session\n+    /// or process group has the same id as the process.\n+    pub fn to_new_session(self: &Arc<Self>) -> Result<Arc<Session>> {\n+        if self.is_session_leader() {\n+            return Ok(self.session().unwrap());\n+        }\n+\n+        if self.is_group_leader() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"process group leader cannot be moved to new session.\"\n+            );\n+        }\n+\n+        let session = self.session().unwrap();\n+\n+        // Lock order: session table -> group table -> group of process -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        if session_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create new session\");\n+        }\n+\n+        if group_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create process group\");\n+        }\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                session_inner.process_groups.remove(&old_group.pgid());\n+\n+                if session_inner.is_empty() {\n+                    session_table_mut.remove(&session.sid());\n+                }\n+            }\n         }\n-        *self.process_group.lock() = process_group;\n+\n+        // Creates a new process group\n+        let new_group = ProcessGroup::new(self.clone());\n+        *self_group_mut = Arc::downgrade(&new_group);\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        // Creates a new session\n+        let new_session = Session::new(new_group.clone());\n+        let mut new_group_inner = new_group.inner.lock();\n+        new_group_inner.session = Arc::downgrade(&new_session);\n+        new_session.inner.lock().leader = Some(self.clone());\n+        session_table_mut.insert(new_session.sid(), new_session.clone());\n+\n+        // Removes the process from session.\n+        let mut session_inner = session.inner.lock();\n+        session_inner.remove_process(self);\n+\n+        Ok(new_session)\n+    }\n+\n+    /// Moves the process to other process group.\n+    ///\n+    /// * If the group already exists, the process and the group should belong to the same session.\n+    /// * If the group does not exist, this method creates a new group for the process and move the\n+    /// process to the group. The group is added to the session of the process.\n+    ///\n+    /// This method may return `EPERM` in following cases:\n+    /// * The process is session leader;\n+    /// * The group already exists, but the group does not belong to the same session as the process;\n+    /// * The group does not exist, but `pgid` is not equal to `pid` of the process.\n+    pub fn to_other_group(self: &Arc<Self>, pgid: Pgid) -> Result<()> {\n+        // if the process already belongs to the process group\n+        if self.pgid() == pgid {\n+            return Ok(());\n+        }\n+\n+        if self.is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"the process cannot be a session leader\");\n+        }\n+\n+        if let Some(process_group) = process_table::get_process_group(&pgid) {\n+            let session = self.session().unwrap();\n+            if !session.contains_process_group(&process_group) {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the group and process does not belong to same session\"\n+                );\n+            }\n+            self.to_specified_group(&process_group)?;\n+        } else {\n+            if pgid != self.pid() {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the new process group should have the same id as the process.\"\n+                );\n+            }\n+\n+            self.to_new_group()?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Creates a new process group and moves the process to the group.\n+    ///\n+    /// The new group will be added to the same session as the process.\n+    fn to_new_group(self: &Arc<Self>) -> Result<()> {\n+        let session = self.session().unwrap();\n+        // Lock order: group table -> group of process -> group inner -> session inner\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                // The old session won't be empty, since we will add a new group to the session.\n+                session_inner.process_groups.remove(&old_group.pgid());\n+            }\n+        }\n+\n+        // Creates a new process group. Adds the new group to group table and session.\n+        let new_group = ProcessGroup::new(self.clone());\n+\n+        let mut new_group_inner = new_group.inner.lock();\n+        let mut session_inner = session.inner.lock();\n+\n+        *self_group_mut = Arc::downgrade(&new_group);\n+\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        new_group_inner.session = Arc::downgrade(&session);\n+        session_inner\n+            .process_groups\n+            .insert(new_group.pgid(), new_group.clone());\n+\n+        Ok(())\n     }\n \n-    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n-        self.process_group.lock().upgrade()\n+    /// Moves the process to a specified group.\n+    ///\n+    /// The caller needs to ensure that the process and the group belongs to the same session.\n+    fn to_specified_group(self: &Arc<Process>, group: &Arc<ProcessGroup>) -> Result<()> {\n+        // Lock order: group table -> group of process -> group inner (small pgid -> big pgid)\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        let mut group_inner = if let Some(old_group) = self_group_mut.upgrade() {\n+            // Lock order: group with smaller pgid first\n+            let (mut old_group_inner, group_inner) = match old_group.pgid().cmp(&group.pgid()) {\n+                core::cmp::Ordering::Equal => return Ok(()),\n+                core::cmp::Ordering::Less => (old_group.inner.lock(), group.inner.lock()),\n+                core::cmp::Ordering::Greater => {\n+                    let group_inner = group.inner.lock();\n+                    let old_group_inner = old_group.inner.lock();\n+                    (old_group_inner, group_inner)\n+                }\n+            };\n+            old_group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if old_group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+            }\n+\n+            group_inner\n+        } else {\n+            group.inner.lock()\n+        };\n+\n+        // Adds the process to the specified group\n+        group_inner.processes.insert(self.pid, self.clone());\n+        *self_group_mut = Arc::downgrade(group);\n+\n+        Ok(())\n     }\n \n     // ************** Virtual Memory *************\n\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -319,3 +561,100 @@ pub fn current() -> Arc<Process> {\n         panic!(\"[Internal error]The current thread does not belong to a process\");\n     }\n }\n+\n+#[if_cfg_ktest]\n+mod test {\n+    use super::*;\n+\n+    fn new_process(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        crate::fs::rootfs::init_root_mount();\n+        let pid = allocate_tid();\n+        let parent = if let Some(parent) = parent {\n+            Arc::downgrade(&parent)\n+        } else {\n+            Weak::new()\n+        };\n+        Arc::new(Process::new(\n+            pid,\n+            parent,\n+            vec![],\n+            String::new(),\n+            ProcessVm::alloc(),\n+            Arc::new(Mutex::new(FileTable::new())),\n+            Arc::new(RwLock::new(FsResolver::new())),\n+            Arc::new(RwLock::new(FileCreationMask::default())),\n+            Arc::new(Mutex::new(SigDispositions::default())),\n+            ResourceLimits::default(),\n+        ))\n+    }\n+\n+    fn new_process_in_session(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        // Lock order: session table -> group table -> group of process -> group inner\n+        // -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+\n+        let process = new_process(parent);\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+\n+        // Creates new session\n+        let sess = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&sess);\n+        sess.inner.lock().leader = Some(process.clone());\n+\n+        group_table_mut.insert(group.pgid(), group);\n+        session_table_mut.insert(sess.sid(), sess);\n+\n+        process\n+    }\n+\n+    fn remove_session_and_group(process: Arc<Process>) {\n+        // Lock order: session table -> group table\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        if let Some(sess) = process.session() {\n+            session_table_mut.remove(&sess.sid());\n+        }\n+\n+        if let Some(group) = process.process_group() {\n+            group_table_mut.remove(&group.pgid());\n+        }\n+    }\n+\n+    #[ktest]\n+    fn init_process() {\n+        let process = new_process(None);\n+        assert!(process.process_group().is_none());\n+        assert!(process.session().is_none());\n+    }\n+\n+    #[ktest]\n+    fn init_process_in_session() {\n+        let process = new_process_in_session(None);\n+        assert!(process.is_group_leader());\n+        assert!(process.is_session_leader());\n+        remove_session_and_group(process);\n+    }\n+\n+    #[ktest]\n+    fn to_new_session() {\n+        let process = new_process_in_session(None);\n+        let sess = process.session().unwrap();\n+        sess.inner.lock().leader = None;\n+\n+        assert!(!process.is_session_leader());\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+\n+        let group = process.process_group().unwrap();\n+        group.inner.lock().leader = None;\n+        assert!(!process.is_group_leader());\n+\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+    }\n+}\n\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/process_group.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/process_group.rs\n@@ -0,0 +1,84 @@\n+use super::{Pgid, Pid, Process, Session};\n+use crate::prelude::*;\n+use crate::process::signal::signals::Signal;\n+\n+/// `ProcessGroup` represents a set of processes. Each `ProcessGroup` has a unique\n+/// identifier `pgid`.\n+pub struct ProcessGroup {\n+    pgid: Pgid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) processes: BTreeMap<Pid, Arc<Process>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) session: Weak<Session>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn remove_process(&mut self, pid: &Pid) {\n+        let Some(process) = self.processes.remove(pid) else {\n+            return;\n+        };\n+\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, &process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.processes.is_empty()\n+    }\n+}\n+\n+impl ProcessGroup {\n+    /// Creates a new process group with one process. The pgid is the same as the process\n+    /// id. The process will become the leading process of the new process group.\n+    ///\n+    /// The caller needs to ensure that the process does not belong to any group.\n+    pub(in crate::process) fn new(process: Arc<Process>) -> Arc<Self> {\n+        let pid = process.pid();\n+\n+        let inner = {\n+            let mut processes = BTreeMap::new();\n+            processes.insert(pid, process.clone());\n+            Inner {\n+                processes,\n+                leader: Some(process.clone()),\n+                session: Weak::new(),\n+            }\n+        };\n+\n+        Arc::new(ProcessGroup {\n+            pgid: pid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns whether self contains a process with `pid`.\n+    pub(in crate::process) fn contains_process(&self, pid: Pid) -> bool {\n+        self.inner.lock().processes.contains_key(&pid)\n+    }\n+\n+    /// Returns the process group identifier\n+    pub fn pgid(&self) -> Pgid {\n+        self.pgid\n+    }\n+\n+    /// Broadcasts signal to all processes in the group.\n+    pub fn broadcast_signal(&self, signal: impl Signal + Clone + 'static) {\n+        for process in self.inner.lock().processes.values() {\n+            process.enqueue_signal(Box::new(signal.clone()));\n+        }\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns the session which the group belongs to\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        self.inner.lock().session.upgrade()\n+    }\n+}\n\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/session.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/session.rs\n@@ -0,0 +1,133 @@\n+use crate::prelude::*;\n+\n+use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\n+\n+/// A `Session` is a collection of related process groups. Each session has a\n+/// unique identifier `sid`. Process groups and sessions form a two-level\n+/// hierarchical relationship between processes.\n+///\n+/// **Leader**: A *session leader* is the process that creates a new session and whose process\n+/// ID becomes the session ID.\n+///\n+/// **Controlling terminal**: The terminal can be used to manage all processes in the session. The\n+/// controlling terminal is established when the session leader first opens a terminal.\n+pub struct Session {\n+    sid: Sid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) process_groups: BTreeMap<Pgid, Arc<ProcessGroup>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) terminal: Option<Arc<dyn Terminal>>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.process_groups.is_empty()\n+    }\n+\n+    pub(in crate::process) fn remove_process(&mut self, process: &Arc<Process>) {\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn remove_process_group(&mut self, pgid: &Pgid) {\n+        self.process_groups.remove(pgid);\n+    }\n+}\n+\n+impl Session {\n+    /// Creates a new session for the process group. The process group becomes the member of\n+    /// the new session.\n+    ///\n+    /// The caller needs to ensure that the group does not belong to any session, and the caller\n+    /// should set the leader process after creating the session.\n+    pub(in crate::process) fn new(group: Arc<ProcessGroup>) -> Arc<Self> {\n+        let sid = group.pgid();\n+        let inner = {\n+            let mut process_groups = BTreeMap::new();\n+            process_groups.insert(group.pgid(), group);\n+\n+            Inner {\n+                process_groups,\n+                leader: None,\n+                terminal: None,\n+            }\n+        };\n+        Arc::new(Self {\n+            sid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns the session id\n+    pub fn sid(&self) -> Sid {\n+        self.sid\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns whether `self` contains the `process_group`\n+    pub(in crate::process) fn contains_process_group(\n+        self: &Arc<Self>,\n+        process_group: &Arc<ProcessGroup>,\n+    ) -> bool {\n+        self.inner\n+            .lock()\n+            .process_groups\n+            .contains_key(&process_group.pgid())\n+    }\n+\n+    /// Sets terminal as the controlling terminal of the session. The `get_terminal` method\n+    /// should set the session for the terminal and returns the session.\n+    ///\n+    /// If the session already has controlling terminal, this method will return `Err(EPERM)`.\n+    pub fn set_terminal<F>(&self, get_terminal: F) -> Result<()>\n+    where\n+        F: Fn() -> Result<Arc<dyn Terminal>>,\n+    {\n+        let mut inner = self.inner.lock();\n+\n+        if inner.terminal.is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"current session already has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = get_terminal()?;\n+        inner.terminal = Some(terminal);\n+        Ok(())\n+    }\n+\n+    /// Releases the controlling terminal of the session.\n+    ///\n+    /// If the session does not have controlling terminal, this method will return `ENOTTY`.\n+    pub fn release_terminal<F>(&self, release_session: F) -> Result<()>\n+    where\n+        F: Fn(&Arc<dyn Terminal>) -> Result<()>,\n+    {\n+        let mut inner = self.inner.lock();\n+        if inner.terminal.is_none() {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"current session does not has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = inner.terminal.as_ref().unwrap();\n+        release_session(terminal)?;\n+        inner.terminal = None;\n+        Ok(())\n+    }\n+\n+    /// Returns the controlling terminal of `self`.\n+    pub fn terminal(&self) -> Option<Arc<dyn Terminal>> {\n+        self.inner.lock().terminal.clone()\n+    }\n+}\n\ndiff --git /dev/null b/services/libs/jinux-std/src/process/process/terminal.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/terminal.rs\n@@ -0,0 +1,104 @@\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, ProcessGroup};\n+\n+use super::JobControl;\n+\n+/// A termial is used to interact with system. A terminal can support the shell\n+/// job control.\n+///\n+/// We currently support two kinds of terminal, the tty and pty.\n+pub trait Terminal: Send + Sync + FileIo {\n+    // *************** Foreground ***************\n+\n+    /// Returns the foreground process group\n+    fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.job_control().foreground()\n+    }\n+\n+    /// Sets the foreground process group of this terminal.\n+    ///\n+    /// If the terminal is not controlling terminal, this method returns `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn set_foreground(&self, pgid: &Pgid) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"self is not controlling terminal\");\n+        }\n+\n+        let foreground = process_table::get_process_group(pgid);\n+\n+        self.job_control().set_foreground(foreground.as_ref())\n+    }\n+\n+    // *************** Session and controlling terminal ***************\n+\n+    /// Returns whether the terminal is the controlling terminal of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn is_controlling_terminal(&self) -> bool {\n+        let session = current!().session().unwrap();\n+        let Some(terminal) = session.terminal() else {\n+            return false;\n+        };\n+\n+        let arc_self = self.arc_self();\n+        Arc::ptr_eq(&terminal, &arc_self)\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// If self is not session leader, or the terminal is controlling terminal of other session,\n+    /// or the session already has controlling terminal, this method returns `EPERM`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn set_current_session(&self) -> Result<()> {\n+        if !current!().is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"current process is not session leader\");\n+        }\n+\n+        let get_terminal = || {\n+            self.job_control().set_current_session()?;\n+            Ok(self.arc_self())\n+        };\n+\n+        let session = current!().session().unwrap();\n+        session.set_terminal(get_terminal)\n+    }\n+\n+    /// Releases the terminal from the session of current process if the terminal is the controlling\n+    /// terminal of the session.\n+    ///\n+    /// If the terminal is not the controlling terminal of the session, this method will return `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn release_current_session(&self) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"release wrong tty\");\n+        }\n+\n+        let current = current!();\n+        if !current.is_session_leader() {\n+            warn!(\"TODO: release tty for process that is not session leader\");\n+            return Ok(());\n+        }\n+\n+        let release_session = |_: &Arc<dyn Terminal>| self.job_control().release_current_session();\n+\n+        let session = current.session().unwrap();\n+        session.release_terminal(release_session)\n+    }\n+\n+    /// Returns the job control of the terminal.\n+    fn job_control(&self) -> &JobControl;\n+\n+    fn arc_self(&self) -> Arc<dyn Terminal>;\n+}\n\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs /dev/null\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ /dev/null\n@@ -1,85 +0,0 @@\n-use super::{\n-    process_table,\n-    signal::signals::{kernel::KernelSignal, user::UserSignal},\n-    Pgid, Pid, Process,\n-};\n-use crate::prelude::*;\n-\n-pub struct ProcessGroup {\n-    inner: Mutex<ProcessGroupInner>,\n-}\n-\n-struct ProcessGroupInner {\n-    pgid: Pgid,\n-    processes: BTreeMap<Pid, Arc<Process>>,\n-    leader_process: Option<Arc<Process>>,\n-}\n-\n-impl ProcessGroup {\n-    fn default() -> Self {\n-        ProcessGroup {\n-            inner: Mutex::new(ProcessGroupInner {\n-                pgid: 0,\n-                processes: BTreeMap::new(),\n-                leader_process: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new(process: Arc<Process>) -> Self {\n-        let process_group = ProcessGroup::default();\n-        let pid = process.pid();\n-        process_group.set_pgid(pid);\n-        process_group.add_process(process.clone());\n-        process_group.set_leader_process(process);\n-        process_group\n-    }\n-\n-    pub fn set_pgid(&self, pgid: Pgid) {\n-        self.inner.lock().pgid = pgid;\n-    }\n-\n-    pub fn set_leader_process(&self, leader_process: Arc<Process>) {\n-        self.inner.lock().leader_process = Some(leader_process);\n-    }\n-\n-    pub fn add_process(&self, process: Arc<Process>) {\n-        self.inner.lock().processes.insert(process.pid(), process);\n-    }\n-\n-    pub fn contains_process(&self, pid: Pid) -> bool {\n-        self.inner.lock().processes.contains_key(&pid)\n-    }\n-\n-    /// remove a process from this process group.\n-    /// If this group contains no processes now, the group itself will be deleted from global table.\n-    pub fn remove_process(&self, pid: Pid) {\n-        let mut inner_lock = self.inner.lock();\n-        inner_lock.processes.remove(&pid);\n-        let len = inner_lock.processes.len();\n-        let pgid = inner_lock.pgid;\n-        // if self contains no process, remove self from table\n-        if len == 0 {\n-            // this must be the last statement\n-            process_table::remove_process_group(pgid);\n-        }\n-    }\n-\n-    pub fn pgid(&self) -> Pgid {\n-        self.inner.lock().pgid\n-    }\n-\n-    /// send kernel signal to all processes in the group\n-    pub fn kernel_signal(&self, signal: KernelSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-\n-    /// send user signal to all processes in the group\n-    pub fn user_signal(&self, signal: UserSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-}\n\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -5,35 +5,25 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n-use super::{process_group::ProcessGroup, Pgid, Pid, Process};\n+use super::{Pgid, Pid, Process, ProcessGroup, Session, Sid};\n \n-lazy_static! {\n-    static ref PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n-    static ref PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> =\n-        Mutex::new(BTreeMap::new());\n-    static ref PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n-}\n-\n-/// add a process to global table\n-pub fn add_process(process: Arc<Process>) {\n-    let pid = process.pid();\n-    PROCESS_TABLE.lock().insert(pid, process);\n-}\n+static PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n+static SESSION_TABLE: Mutex<BTreeMap<Sid, Arc<Session>>> = Mutex::new(BTreeMap::new());\n \n-/// remove a process from global table\n-pub fn remove_process(pid: Pid) {\n-    PROCESS_TABLE.lock().remove(&pid);\n+// ************ Process *************\n \n-    let events = PidEvent::Exit(pid);\n-    PROCESS_TABLE_SUBJECT.notify_observers(&events);\n+/// Gets a process with pid\n+pub fn get_process(pid: &Pid) -> Option<Arc<Process>> {\n+    PROCESS_TABLE.lock().get(pid).cloned()\n }\n \n-/// get a process with pid\n-pub fn pid_to_process(pid: Pid) -> Option<Arc<Process>> {\n-    PROCESS_TABLE.lock().get(&pid).cloned()\n+pub(super) fn process_table_mut() -> MutexGuard<'static, BTreeMap<Pid, Arc<Process>>> {\n+    PROCESS_TABLE.lock()\n }\n \n-/// get all processes\n+/// Gets all processes\n pub fn get_all_processes() -> Vec<Arc<Process>> {\n     PROCESS_TABLE\n         .lock()\n\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -42,26 +32,41 @@ pub fn get_all_processes() -> Vec<Arc<Process>> {\n         .collect()\n }\n \n-/// add process group to global table\n-pub fn add_process_group(process_group: Arc<ProcessGroup>) {\n-    let pgid = process_group.pgid();\n-    PROCESS_GROUP_TABLE.lock().insert(pgid, process_group);\n+// ************ Process Group *************\n+\n+/// Gets a process group with `pgid`\n+pub fn get_process_group(pgid: &Pgid) -> Option<Arc<ProcessGroup>> {\n+    PROCESS_GROUP_TABLE.lock().get(pgid).cloned()\n+}\n+\n+/// Returns whether process table contains process group with pgid\n+pub fn contain_process_group(pgid: &Pgid) -> bool {\n+    PROCESS_GROUP_TABLE.lock().contains_key(pgid)\n }\n \n-/// remove process group from global table\n-pub fn remove_process_group(pgid: Pgid) {\n-    PROCESS_GROUP_TABLE.lock().remove(&pgid);\n+pub(super) fn group_table_mut() -> MutexGuard<'static, BTreeMap<Pgid, Arc<ProcessGroup>>> {\n+    PROCESS_GROUP_TABLE.lock()\n }\n \n-/// get a process group with pgid\n-pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n-    PROCESS_GROUP_TABLE.lock().get(&pgid).cloned()\n+// ************ Session *************\n+\n+/// Gets a session with `sid`.\n+pub fn get_session(sid: &Sid) -> Option<Arc<Session>> {\n+    SESSION_TABLE.lock().get(sid).map(Arc::clone)\n }\n \n+pub(super) fn session_table_mut() -> MutexGuard<'static, BTreeMap<Sid, Arc<Session>>> {\n+    SESSION_TABLE.lock()\n+}\n+\n+// ************ Observer *************\n+\n+/// Registers an observer which watches `PidEvent`.\n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n+/// Unregisters an observer which watches `PidEvent`.\n pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\n\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_queues.rs b/services/libs/jinux-std/src/process/signal/sig_queues.rs\n--- a/services/libs/jinux-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/jinux-std/src/process/signal/sig_queues.rs\n@@ -81,8 +81,11 @@ impl SigQueues {\n         // POSIX leaves unspecified which to deliver first if there are multiple\n         // pending standard signals. So we are free to define our own. The\n         // principle is to give more urgent signals higher priority (like SIGKILL).\n+\n+        // FIXME: the gvisor pty_test JobControlTest::ReleaseTTY requires that\n+        // the SIGHUP signal should be handled before SIGCONT.\n         const ORDERED_STD_SIGS: [SigNum; COUNT_STD_SIGS] = [\n-            SIGKILL, SIGTERM, SIGSTOP, SIGCONT, SIGSEGV, SIGILL, SIGHUP, SIGINT, SIGQUIT, SIGTRAP,\n+            SIGKILL, SIGTERM, SIGSTOP, SIGSEGV, SIGILL, SIGHUP, SIGCONT, SIGINT, SIGQUIT, SIGTRAP,\n             SIGABRT, SIGBUS, SIGFPE, SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGSTKFLT, SIGCHLD,\n             SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH,\n             SIGIO, SIGPWR, SIGSYS,\n\ndiff --git a/services/libs/jinux-std/src/process/wait.rs b/services/libs/jinux-std/src/process/wait.rs\n--- a/services/libs/jinux-std/src/process/wait.rs\n+++ b/services/libs/jinux-std/src/process/wait.rs\n@@ -80,9 +80,33 @@ fn reap_zombie_child(process: &Process, pid: Pid) -> u32 {\n     for thread in &*child_process.threads().lock() {\n         thread_table::remove_thread(thread.tid());\n     }\n-    process_table::remove_process(child_process.pid());\n-    if let Some(process_group) = child_process.process_group() {\n-        process_group.remove_process(child_process.pid());\n+\n+    // Lock order: session table -> group table -> process table -> group of process\n+    // -> group inner -> session inner\n+    let mut session_table_mut = process_table::session_table_mut();\n+    let mut group_table_mut = process_table::group_table_mut();\n+    let mut process_table_mut = process_table::process_table_mut();\n+\n+    let mut child_group_mut = child_process.process_group.lock();\n+\n+    let process_group = child_group_mut.upgrade().unwrap();\n+    let mut group_inner = process_group.inner.lock();\n+    let session = group_inner.session.upgrade().unwrap();\n+    let mut session_inner = session.inner.lock();\n+\n+    group_inner.remove_process(&child_process.pid());\n+    session_inner.remove_process(&child_process);\n+    *child_group_mut = Weak::new();\n+\n+    if group_inner.is_empty() {\n+        group_table_mut.remove(&process_group.pgid());\n+        session_inner.remove_process_group(&process_group.pgid());\n+\n+        if session_inner.is_empty() {\n+            session_table_mut.remove(&session.sid());\n+        }\n     }\n+\n+    process_table_mut.remove(&child_process.pid());\n     child_process.exit_code().unwrap()\n }\n\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/getsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/getsid.rs\n@@ -0,0 +1,30 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pid};\n+\n+use super::{SyscallReturn, SYS_GETSID};\n+\n+pub fn sys_getsid(pid: Pid) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_GETSID);\n+    debug!(\"pid = {}\", pid);\n+\n+    let session = current!().session().unwrap();\n+    let sid = session.sid();\n+\n+    if pid == 0 {\n+        return Ok(SyscallReturn::Return(sid as _));\n+    }\n+\n+    let Some(process) = process_table::get_process(&pid) else {\n+        return_errno_with_message!(Errno::ESRCH, \"the process does not exist\")\n+    };\n+\n+    if !Arc::ptr_eq(&session, &process.session().unwrap()) {\n+        return_errno_with_message!(\n+            Errno::EPERM,\n+            \"the process and current process does not belong to the same session\"\n+        );\n+    }\n+\n+    Ok(SyscallReturn::Return(sid as _))\n+}\n\ndiff --git a/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/jinux-std/src/syscall/kill.rs\n--- a/services/libs/jinux-std/src/syscall/kill.rs\n+++ b/services/libs/jinux-std/src/syscall/kill.rs\n@@ -34,15 +34,15 @@ pub fn do_sys_kill(filter: ProcessFilter, sig_num: SigNum) -> Result<()> {\n             }\n         }\n         ProcessFilter::WithPid(pid) => {\n-            if let Some(process) = process_table::pid_to_process(pid) {\n+            if let Some(process) = process_table::get_process(&pid) {\n                 process.enqueue_signal(Box::new(signal));\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process in process table\");\n             }\n         }\n         ProcessFilter::WithPgid(pgid) => {\n-            if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-                process_group.user_signal(signal);\n+            if let Some(process_group) = process_table::get_process_group(&pgid) {\n+                process_group.broadcast_signal(signal);\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process group in process table\");\n             }\n\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -77,12 +77,14 @@ use self::connect::sys_connect;\n use self::execve::sys_execveat;\n use self::getpeername::sys_getpeername;\n use self::getrandom::sys_getrandom;\n+use self::getsid::sys_getsid;\n use self::getsockname::sys_getsockname;\n use self::getsockopt::sys_getsockopt;\n use self::listen::sys_listen;\n use self::pread64::sys_pread64;\n use self::recvfrom::sys_recvfrom;\n use self::sendto::sys_sendto;\n+use self::setsid::sys_setsid;\n use self::setsockopt::sys_setsockopt;\n use self::shutdown::sys_shutdown;\n use self::socket::sys_socket;\n\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -119,6 +121,7 @@ mod getpgrp;\n mod getpid;\n mod getppid;\n mod getrandom;\n+mod getsid;\n mod getsockname;\n mod getsockopt;\n mod gettid;\n\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -155,6 +158,7 @@ mod sendto;\n mod set_robust_list;\n mod set_tid_address;\n mod setpgid;\n+mod setsid;\n mod setsockopt;\n mod shutdown;\n mod socket;\n\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -274,6 +278,8 @@ define_syscall_nums!(\n     SYS_SETPGID = 109,\n     SYS_GETPPID = 110,\n     SYS_GETPGRP = 111,\n+    SYS_SETSID = 112,\n+    SYS_GETSID = 124,\n     SYS_STATFS = 137,\n     SYS_FSTATFS = 138,\n     SYS_PRCTL = 157,\n\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -435,6 +441,8 @@ pub fn syscall_dispatch(\n         SYS_SETPGID => syscall_handler!(2, sys_setpgid, args),\n         SYS_GETPPID => syscall_handler!(0, sys_getppid),\n         SYS_GETPGRP => syscall_handler!(0, sys_getpgrp),\n+        SYS_SETSID => syscall_handler!(0, sys_setsid),\n+        SYS_GETSID => syscall_handler!(1, sys_getsid, args),\n         SYS_STATFS => syscall_handler!(2, sys_statfs, args),\n         SYS_FSTATFS => syscall_handler!(2, sys_fstatfs, args),\n         SYS_PRCTL => syscall_handler!(5, sys_prctl, args),\n\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -1,8 +1,6 @@\n-use crate::{\n-    log_syscall_entry,\n-    prelude::*,\n-    process::{process_table, Pgid, Pid, ProcessGroup},\n-};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, Pid};\n \n use super::{SyscallReturn, SYS_SETPGID};\n \n\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -15,7 +13,7 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     let pgid = if pgid == 0 { pid } else { pgid };\n     debug!(\"pid = {}, pgid = {}\", pid, pgid);\n \n-    if pid != current.pid() && !current.children().lock().contains_key(&pid) {\n+    if pid != current.pid() && !current.has_child(&pid) {\n         return_errno_with_message!(\n             Errno::ESRCH,\n             \"cannot set pgid for process other than current or children of current\"\n\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -25,27 +23,14 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     // How can we determine a child process has called execve?\n \n     // only can move process to an existing group or self\n-    if pgid != pid && process_table::pgid_to_process_group(pgid).is_none() {\n+    if pgid != pid && !process_table::contain_process_group(&pgid) {\n         return_errno_with_message!(Errno::EPERM, \"process group must exist\");\n     }\n \n-    let process = process_table::pid_to_process(pid)\n+    let process = process_table::get_process(&pid)\n         .ok_or(Error::with_message(Errno::ESRCH, \"process does not exist\"))?;\n \n-    // if the process already belongs to the process group\n-    if process.pgid() == pgid {\n-        return Ok(SyscallReturn::Return(0));\n-    }\n-\n-    if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-        process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&process_group));\n-    } else {\n-        let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-        // new_process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&new_process_group));\n-        process_table::add_process_group(new_process_group);\n-    }\n+    process.to_other_group(pgid)?;\n \n     Ok(SyscallReturn::Return(0))\n }\n\ndiff --git /dev/null b/services/libs/jinux-std/src/syscall/setsid.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/setsid.rs\n@@ -0,0 +1,13 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+\n+use super::{SyscallReturn, SYS_SETSID};\n+\n+pub fn sys_setsid() -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_SETSID);\n+\n+    let current = current!();\n+    let session = current.to_new_session()?;\n+\n+    Ok(SyscallReturn::Return(session.sid() as _))\n+}\n\ndiff --git a/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/jinux-std/src/syscall/tgkill.rs\n--- a/services/libs/jinux-std/src/syscall/tgkill.rs\n+++ b/services/libs/jinux-std/src/syscall/tgkill.rs\n@@ -16,8 +16,8 @@ pub fn sys_tgkill(tgid: Pid, tid: Tid, sig_num: u8) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_TGKILL);\n     let sig_num = SigNum::from_u8(sig_num);\n     info!(\"tgid = {}, pid = {}, sig_num = {:?}\", tgid, tid, sig_num);\n-    let target_thread = thread_table::tid_to_thread(tid)\n-        .ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n+    let target_thread =\n+        thread_table::get_thread(tid).ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n     let posix_thread = target_thread.as_posix_thread().unwrap();\n     let pid = posix_thread.process().pid();\n     if pid != tgid {\n\ndiff --git a/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/jinux-std/src/thread/thread_table.rs\n--- a/services/libs/jinux-std/src/thread/thread_table.rs\n+++ b/services/libs/jinux-std/src/thread/thread_table.rs\n@@ -15,6 +15,6 @@ pub fn remove_thread(tid: Tid) {\n     THREAD_TABLE.lock().remove(&tid);\n }\n \n-pub fn tid_to_thread(tid: Tid) -> Option<Arc<Thread>> {\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n     THREAD_TABLE.lock().get(&tid).cloned()\n }\n",
        "test_patch": "diff --git a/regression/syscall_test/blocklists/pty_test b/regression/syscall_test/blocklists/pty_test\n--- a/regression/syscall_test/blocklists/pty_test\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -21,22 +21,8 @@ PtyTest.SwitchNoncanonToCanonNoNewlineBig\n PtyTest.NoncanonBigWrite\n PtyTest.SwitchNoncanonToCanonMultiline\n PtyTest.SwitchTwiceMultiline\n-JobControlTest.SetTTYMaster\n-JobControlTest.SetTTY\n-JobControlTest.SetTTYNonLeader\n JobControlTest.SetTTYBadArg\n JobControlTest.SetTTYDifferentSession\n-JobControlTest.ReleaseTTY\n-JobControlTest.ReleaseUnsetTTY\n-JobControlTest.ReleaseWrongTTY\n-JobControlTest.ReleaseTTYNonLeader\n-JobControlTest.ReleaseTTYDifferentSession\n JobControlTest.ReleaseTTYSignals\n-JobControlTest.GetForegroundProcessGroup\n-JobControlTest.GetForegroundProcessGroupNonControlling\n JobControlTest.SetForegroundProcessGroup\n-JobControlTest.SetForegroundProcessGroupWrongTTY\n-JobControlTest.SetForegroundProcessGroupNegPgid\n-JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n-JobControlTest.SetForegroundProcessGroupDifferentSession\n-JobControlTest.OrphanRegression\n\\ No newline at end of file\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n\\ No newline at end of file\n",
        "problem_statement": "Implement session for shell job control\nProcess groups and sessions form a two-level hierarchical relationship between processes. A session is a collection of process groups. A process\u2019s session membership is determined by its session identifier (SID). All of the processes in a session share a single controlling terminal. \r\n\r\nThe related syscalls are getsid and setsid\n",
        "hints_text": "",
        "created_at": "2023-08-30T11:25:32Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 327,
        "instance_id": "asterinas__asterinas-327",
        "issue_numbers": [
            "340"
        ],
        "base_commit": "dbfb2e1a62a9981a67cc01ff7310981744ec2ac5",
        "patch": "diff --git /dev/null b/tools/docker/.gitignore\nnew file mode 100644\n--- /dev/null\n+++ b/tools/docker/.gitignore\n@@ -0,0 +1,1 @@\n+bom/\n\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,27 +1,47 @@\n-FROM ubuntu:22.04\n+FROM ubuntu:22.04 as ubuntu-22.04-with-bazel\n \n SHELL [\"/bin/bash\", \"-c\"]\n \n ARG DEBIAN_FRONTEND=noninteractive\n+\n+# Install all Bazel dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     build-essential \\\n     ca-certificates \\\n+    curl \\\n+    git-core \\\n+    gnupg \\\n+    python-is-python3 \\\n+    python3-pip\n+\n+# Install bazel, which is required by the system call test suite from Gvisor project\n+COPY bom/syscall_test/install_bazel.sh /tmp/\n+WORKDIR /tmp\n+RUN ./install_bazel.sh && rm -f /tmp/install_bazel.sh\n+\n+FROM ubuntu-22.04-with-bazel as syscall_test\n+\n+# Build the syscall test binaries\n+COPY bom/syscall_test /root/syscall_test\n+WORKDIR /root/syscall_test\n+RUN export BUILD_DIR=build && \\\n+    make ${BUILD_DIR}/syscall_test_bins\n+\n+FROM ubuntu-22.04-with-bazel\n+\n+# Install all Jinux dependent packages\n+RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\n-    curl \\\n     file \\\n     g++ \\\n     gdb \\\n-    git-core \\\n-    gnupg \\\n     grub-common \\\n     grub-pc \\\n     libssl-dev \\\n     net-tools \\\n     openssh-server \\\n     pkg-config \\\n-    python-is-python3 \\\n-    python3-pip \\\n     qemu-system-x86 \\\n     strace \\\n     sudo \\\n\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -31,17 +51,14 @@ RUN apt update && apt-get install -y --no-install-recommends \\\n     xorriso \\\n     zip\n \n-# Install bazel, , which is required by the system call test suite from Gvisor project\n-RUN curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor > bazel.gpg \\ \n-    && mv bazel.gpg /etc/apt/trusted.gpg.d/ \\\n-    && echo 'deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8' | tee /etc/apt/sources.list.d/bazel.list \\\n-    && apt update \\ \n-    && apt install bazel=5.4.0 -y\n-\n # Clean apt cache\n RUN apt clean \\\n     && rm -rf /var/lib/apt/lists/*\n \n+# Prepare the system call test suite\n+COPY --from=syscall_test /root/syscall_test/build/syscall_test_bins /root/syscall_test_bins\n+ENV JINUX_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n+\n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n ARG JINUX_RUST_VERSION\n\ndiff --git a/tools/docker/build_image.sh b/tools/docker/build_image.sh\n--- a/tools/docker/build_image.sh\n+++ b/tools/docker/build_image.sh\n@@ -7,10 +7,19 @@ CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n VERSION=$( grep -m1 -o '[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+' ${CARGO_TOML_PATH} | sed 's/[^0-9\\.]//g'  )\n IMAGE_NAME=jinuxdev/jinux:${VERSION}\n DOCKER_FILE=${SCRIPT_DIR}/Dockerfile.ubuntu22.04\n+BOM_DIR=${SCRIPT_DIR}/bom\n+TOP_DIR=${SCRIPT_DIR}/../../\n ARCH=linux/amd64\n RUST_TOOLCHAIN_PATH=${SCRIPT_DIR}/../../rust-toolchain.toml\n JINUX_RUST_VERSION=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' ${RUST_TOOLCHAIN_PATH} )\n \n+# Prpare the BOM (bill of materials) directory to copy files or dirs into the docker image.\n+# This is because the `docker build` can not access the parent directory of the context.\n+if [ ! -d ${BOM_DIR} ]; then\n+    mkdir -p ${BOM_DIR}\n+    cp -rf ${TOP_DIR}/regression/syscall_test ${BOM_DIR}/\n+fi\n+\n # Build docker\n cd ${SCRIPT_DIR}\n docker buildx build -f ${DOCKER_FILE} \\\n",
        "test_patch": "diff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -2,9 +2,13 @@ TESTS ?= open_test read_test statfs_test chmod_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n-BUILD_DIR := $(CUR_DIR)/../build\n-SRC_DIR := $(BUILD_DIR)/gvisor_src\n-BIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+BUILD_DIR ?= $(CUR_DIR)/../build\n+ifdef JINUX_PREBUILT_SYSCALL_TEST\n+\tBIN_DIR := $(JINUX_PREBUILT_SYSCALL_TEST)\n+else\n+\tBIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+\tSRC_DIR := $(BUILD_DIR)/gvisor_src\n+endif\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n TARGET_DIR := $(INITRAMFS)/opt/syscall_test\n RUN_BASH := $(CUR_DIR)/run_syscall_test.sh\n\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -14,20 +18,25 @@ BLOCK_LIST := $(CUR_DIR)/blocklists\n \n all: $(TESTS)\n \n-$(SRC_DIR):\n+$(TESTS): $(BIN_DIR) $(TARGET_DIR)\n+\t@cp -f $</$@ $(TARGET_DIR)/tests\n+\n+ifndef JINUX_PREBUILT_SYSCALL_TEST\n+$(BIN_DIR): $(SRC_DIR)\n \t@if ! type bazel > /dev/null; then \\\n \t\techo \"bazel is not installed, please run $(CUR_DIR)/install_bazel.sh with sudo permission to install it.\"; \\\n-\t\texit 1 ; \\\n+\t\texit 1; \\\n \tfi\n-\t@rm -rf $@ && mkdir -p $@\n-\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n-\n-$(BIN_DIR): $(SRC_DIR)\n \t@rm -rf $@ && mkdir -p $@\n \t@cd $(SRC_DIR) && bazel build --test_tag_filters=native //test/syscalls/...\n \t@cp $(SRC_DIR)/bazel-bin/test/syscalls/linux/*_test $@\n \n-$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n+$(SRC_DIR):\n+\t@rm -rf $@ && mkdir -p $@\n+\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n+endif\n+\n+$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST)\n \t@rm -rf $@ && mkdir -p $@\n \t@# Prepare tests dir for test binaries\n \t@mkdir $@/tests\n\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -36,8 +45,5 @@ $(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n \t@# Copy bash script\n \t@cp -f $(RUN_BASH) $@\n \n-$(TESTS): $(TARGET_DIR)\n-\t@cp -f $(BIN_DIR)/$@ $(TARGET_DIR)/tests\n-\n clean:\n-\t@rm -rf $(BIN_DIR) $(TARGET_DIR)\n+\t@rm -rf $(TARGET_DIR)\n\\ No newline at end of file\n",
        "problem_statement": "Precompile syscall tests in the dev docker image to accelerate CI\nCurrently the syscall tests are compiled every-time when CI triggers, which is at a cost of around 12 minutes on Github runners.\n",
        "hints_text": "",
        "created_at": "2023-07-27T07:11:21Z"
    },
    {
        "repo": "asterinas/asterinas",
        "pull_number": 334,
        "instance_id": "asterinas__asterinas-334",
        "issue_numbers": [
            "214"
        ],
        "base_commit": "25c4f0f2bcaa0bc8c650b0f4ee7b0d78e2a836b2",
        "patch": "diff --git /dev/null b/regression/apps/pty/open_pty.c\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/pty/open_pty.c\n@@ -0,0 +1,51 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <termios.h>\n+#include <pty.h>\n+\n+int main() {\n+    int master, slave;\n+    char name[256];\n+    struct termios term;\n+\n+    if (openpty(&master, &slave, name, NULL, NULL) == -1) {\n+        perror(\"openpty\");\n+        exit(EXIT_FAILURE);\n+    }\n+\n+    printf(\"slave name: %s\\n\", name);\n+\n+    // Set pty slave terminal attributes\n+    tcgetattr(slave, &term);\n+    term.c_lflag &= ~(ICANON | ECHO);\n+    term.c_cc[VMIN] = 1;\n+    term.c_cc[VTIME] = 0;\n+    tcsetattr(slave, TCSANOW, &term);\n+\n+    // Print to pty slave\n+    dprintf(slave, \"Hello world!\\n\");\n+\n+    // Read from pty slave\n+    char buf[256];\n+    ssize_t n = read(master, buf, sizeof(buf));\n+    if (n > 0) {\n+        printf(\"read %ld bytes from slave: %.*s\", n, (int)n, buf);\n+    }\n+\n+    // Write to pty master\n+    dprintf(master, \"hello world from master\\n\");\n+\n+    // Read from pty master\n+    char nbuf[256];\n+    ssize_t nn = read(slave, nbuf, sizeof(nbuf));\n+    if (nn > 0) {\n+        printf(\"read %ld bytes from master: %.*s\", nn, (int)nn, nbuf);\n+    }\n+\n+    close(master);\n+    close(slave);\n+\n+    return 0;\n+}\n\ndiff --git /dev/null b/regression/syscall_test/blocklists/pty_test\nnew file mode 100644\n--- /dev/null\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -0,0 +1,42 @@\n+PtyTrunc.Truncate\n+PtyTest.MasterTermiosUnchangable\n+PtyTest.TermiosICRNL\n+PtyTest.TermiosONLCR\n+PtyTest.TermiosINLCR\n+PtyTest.TermiosOCRNL\n+PtyTest.SwitchCanonToNonCanonNewline\n+PtyTest.TermiosICANONNewline\n+PtyTest.TermiosICANONEOF\n+PtyTest.CanonDiscard\n+PtyTest.CanonMultiline\n+PtyTest.SimpleEcho\n+PtyTest.TermiosIGNCR\n+PtyTest.TermiosONOCR\n+PtyTest.VEOLTermination\n+PtyTest.CanonBigWrite\n+PtyTest.SwitchCanonToNoncanon\n+PtyTest.SwitchNoncanonToCanonNewlineBig\n+PtyTest.SwitchNoncanonToCanonNoNewline\n+PtyTest.SwitchNoncanonToCanonNoNewlineBig\n+PtyTest.NoncanonBigWrite\n+PtyTest.SwitchNoncanonToCanonMultiline\n+PtyTest.SwitchTwiceMultiline\n+JobControlTest.SetTTYMaster\n+JobControlTest.SetTTY\n+JobControlTest.SetTTYNonLeader\n+JobControlTest.SetTTYBadArg\n+JobControlTest.SetTTYDifferentSession\n+JobControlTest.ReleaseTTY\n+JobControlTest.ReleaseUnsetTTY\n+JobControlTest.ReleaseWrongTTY\n+JobControlTest.ReleaseTTYNonLeader\n+JobControlTest.ReleaseTTYDifferentSession\n+JobControlTest.ReleaseTTYSignals\n+JobControlTest.GetForegroundProcessGroup\n+JobControlTest.GetForegroundProcessGroupNonControlling\n+JobControlTest.SetForegroundProcessGroup\n+JobControlTest.SetForegroundProcessGroupWrongTTY\n+JobControlTest.SetForegroundProcessGroupNegPgid\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n+JobControlTest.SetForegroundProcessGroupDifferentSession\n+JobControlTest.OrphanRegression\n\\ No newline at end of file\n\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -7,6 +7,8 @@ mod zero;\n \n use crate::fs::device::{add_node, Device, DeviceId, DeviceType};\n use crate::prelude::*;\n+pub use pty::new_pty_pair;\n+pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \n\ndiff --git a/services/libs/jinux-std/src/device/pty.rs /dev/null\n--- a/services/libs/jinux-std/src/device/pty.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-use crate::fs::{\n-    devpts::DevPts,\n-    fs_resolver::{FsPath, FsResolver},\n-    utils::{InodeMode, InodeType},\n-};\n-use crate::prelude::*;\n-\n-pub fn init() -> Result<()> {\n-    let fs = FsResolver::new();\n-\n-    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n-    // Create the \"pts\" directory and mount devpts on it.\n-    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n-    devpts.mount(DevPts::new())?;\n-\n-    // Create the \"ptmx\" symlink.\n-    let ptmx = dev.create(\n-        \"ptmx\",\n-        InodeType::SymLink,\n-        InodeMode::from_bits_truncate(0o777),\n-    )?;\n-    ptmx.write_link(\"pts/ptmx\")?;\n-    Ok(())\n-}\n\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -0,0 +1,38 @@\n+use crate::fs::devpts::DevPts;\n+use crate::fs::fs_resolver::{FsPath, FsResolver};\n+use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\n+use crate::prelude::*;\n+\n+mod pty;\n+\n+pub use pty::{PtyMaster, PtySlave};\n+use spin::Once;\n+\n+static DEV_PTS: Once<Arc<Dentry>> = Once::new();\n+\n+pub fn init() -> Result<()> {\n+    let fs = FsResolver::new();\n+\n+    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n+    // Create the \"pts\" directory and mount devpts on it.\n+    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n+    devpts.mount(DevPts::new())?;\n+\n+    DEV_PTS.call_once(|| devpts);\n+\n+    // Create the \"ptmx\" symlink.\n+    let ptmx = dev.create(\n+        \"ptmx\",\n+        InodeType::SymLink,\n+        InodeMode::from_bits_truncate(0o777),\n+    )?;\n+    ptmx.write_link(\"pts/ptmx\")?;\n+    Ok(())\n+}\n+\n+pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n+    debug!(\"pty index = {}\", index);\n+    let master = Arc::new(PtyMaster::new(ptmx, index));\n+    let slave = Arc::new(PtySlave::new(master.clone()));\n+    Ok((master, slave))\n+}\n\ndiff --git /dev/null b/services/libs/jinux-std/src/device/pty/pty.rs\nnew file mode 100644\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -0,0 +1,312 @@\n+use alloc::format;\n+use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n+\n+use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::fs_resolver::FsPath;\n+use crate::fs::utils::{AccessMode, Inode, InodeMode, IoEvents, IoctlCmd, Pollee, Poller};\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+const PTS_DIR: &str = \"/dev/pts\";\n+const BUFFER_CAPACITY: usize = 4096;\n+\n+/// Pesudo terminal master.\n+/// Internally, it has two buffers.\n+/// One is inside ldisc, which is written by master and read by slave,\n+/// the other is a ring buffer, which is written by slave and read by master.\n+pub struct PtyMaster {\n+    ptmx: Arc<dyn Inode>,\n+    index: u32,\n+    output: LineDiscipline,\n+    input: SpinLock<HeapRb<u8>>,\n+    /// The state of input buffer\n+    pollee: Pollee,\n+}\n+\n+impl PtyMaster {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n+        Self {\n+            ptmx,\n+            index,\n+            output: LineDiscipline::new(),\n+            input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            pollee: Pollee::new(IoEvents::OUT),\n+        }\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.index\n+    }\n+\n+    pub fn ptmx(&self) -> &Arc<dyn Inode> {\n+        &self.ptmx\n+    }\n+\n+    pub(super) fn slave_push_byte(&self, byte: u8) {\n+        let mut input = self.input.lock_irq_disabled();\n+        input.push_overwrite(byte);\n+        self.update_state(&input);\n+    }\n+\n+    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.output.read(buf)\n+    }\n+\n+    pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.output.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.pollee.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+\n+    pub(super) fn slave_buf_len(&self) -> usize {\n+        self.output.buffer_len()\n+    }\n+\n+    fn update_state(&self, buf: &HeapRb<u8>) {\n+        if buf.is_empty() {\n+            self.pollee.del_events(IoEvents::IN)\n+        } else {\n+            self.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+}\n+\n+impl FileLike for PtyMaster {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        // TODO: deal with nonblocking read\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let poller = Poller::new();\n+        loop {\n+            let mut input = self.input.lock_irq_disabled();\n+\n+            if input.is_empty() {\n+                let events = self.pollee.poll(IoEvents::IN, Some(&poller));\n+\n+                if events.contains(IoEvents::ERR) {\n+                    return_errno_with_message!(Errno::EACCES, \"unexpected err\");\n+                }\n+\n+                if events.is_empty() {\n+                    drop(input);\n+                    poller.wait();\n+                }\n+                continue;\n+            }\n+\n+            let read_len = input.len().min(buf.len());\n+            input.pop_slice(&mut buf[..read_len]);\n+            self.update_state(&input);\n+            return Ok(read_len);\n+        }\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let mut input = self.input.lock();\n+\n+        for character in buf {\n+            self.output.push_char(*character, |content| {\n+                for byte in content.as_bytes() {\n+                    input.push_overwrite(*byte);\n+                }\n+            });\n+        }\n+\n+        self.update_state(&input);\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                let termios = self.output.termios();\n+                write_val_to_user(arg, &termios)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TCSETS => {\n+                let termios = read_val_from_user(arg)?;\n+                self.output.set_termios(termios);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPTLCK => {\n+                // TODO: lock/unlock pty\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTN => {\n+                let idx = self.index();\n+                write_val_to_user(arg, &idx)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTPEER => {\n+                let current = current!();\n+\n+                // TODO: deal with open options\n+                let slave = {\n+                    let slave_name = {\n+                        let devpts_path = super::DEV_PTS.get().unwrap().abs_path();\n+                        format!(\"{}/{}\", devpts_path, self.index())\n+                    };\n+\n+                    let fs_path = FsPath::try_from(slave_name.as_str())?;\n+\n+                    let inode_handle = {\n+                        let fs = current.fs().read();\n+                        let flags = AccessMode::O_RDWR as u32;\n+                        let mode = (InodeMode::S_IRUSR | InodeMode::S_IWUSR).bits();\n+                        fs.open(&fs_path, flags, mode)?\n+                    };\n+                    Arc::new(inode_handle)\n+                };\n+\n+                let fd = {\n+                    let mut file_table = current.file_table().lock();\n+                    file_table.insert(slave)\n+                };\n+                Ok(fd)\n+            }\n+            IoctlCmd::TIOCGWINSZ => {\n+                let winsize = self.output.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.output.set_window_size(winsize);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO: reimplement when adding session.\n+                let foreground = {\n+                    let current = current!();\n+                    let process_group = current.process_group().lock();\n+                    process_group.clone()\n+                };\n+                self.output.set_fg(foreground);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPGRP => {\n+                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO: reimplement when adding session.\n+                self.output.set_fg(Weak::new());\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let len = self.input.lock().len() as i32;\n+                write_val_to_user(arg, &len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.pollee.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.output.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+}\n+\n+pub struct PtySlave(Arc<PtyMaster>);\n+\n+impl PtySlave {\n+    pub fn new(master: Arc<PtyMaster>) -> Self {\n+        PtySlave(master)\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.0.index()\n+    }\n+}\n+\n+impl Device for PtySlave {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> crate::fs::device::DeviceId {\n+        DeviceId::new(88, self.index() as u32)\n+    }\n+\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.slave_read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        for ch in buf {\n+            // do we need to add '\\r' here?\n+            if *ch == b'\\n' {\n+                self.0.slave_push_byte(b'\\r');\n+                self.0.slave_push_byte(b'\\n');\n+            } else {\n+                self.0.slave_push_byte(*ch);\n+            }\n+        }\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS\n+            | IoctlCmd::TCSETS\n+            | IoctlCmd::TIOCGPGRP\n+            | IoctlCmd::TIOCGPTN\n+            | IoctlCmd::TIOCGWINSZ\n+            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let buffer_len = self.0.slave_buf_len() as i32;\n+                write_val_to_user(arg, &buffer_len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.0.slave_poll(mask, poller)\n+    }\n+}\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -3,13 +3,13 @@ use crate::process::process_group::ProcessGroup;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n use crate::{\n     prelude::*,\n-    process::{process_table, signal::signals::kernel::KernelSignal, Pgid},\n+    process::{signal::signals::kernel::KernelSignal, Pgid},\n };\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n-use super::termio::{KernelTermios, CC_C_CHAR};\n+use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n // This implementation refers the implementation of linux\n // https://elixir.bootlin.com/linux/latest/source/include/linux/tty_ldisc.h\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -25,6 +25,8 @@ pub struct LineDiscipline {\n     foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n+    /// Windows size,\n+    winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n }\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -72,12 +74,13 @@ impl LineDiscipline {\n             read_buffer: SpinLock::new(StaticRb::default()),\n             foreground: SpinLock::new(Weak::new()),\n             termios: SpinLock::new(KernelTermios::default()),\n+            winsize: SpinLock::new(WinSize::default()),\n             pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char(&self, mut item: u8, echo_callback: fn(&str)) {\n+    pub fn push_char<F: FnMut(&str)>(&self, mut item: u8, echo_callback: F) {\n         let termios = self.termios.lock_irq_disabled();\n         if termios.contains_icrnl() && item == b'\\r' {\n             item = b'\\n'\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -162,7 +165,7 @@ impl LineDiscipline {\n     }\n \n     // TODO: respect output flags\n-    fn output_char(&self, item: u8, termios: &KernelTermios, echo_callback: fn(&str)) {\n+    fn output_char<F: FnMut(&str)>(&self, item: u8, termios: &KernelTermios, mut echo_callback: F) {\n         match item {\n             b'\\n' => echo_callback(\"\\n\"),\n             b'\\r' => echo_callback(\"\\r\\n\"),\n\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -350,6 +353,18 @@ impl LineDiscipline {\n         self.current_line.lock().drain();\n         let _: Vec<_> = self.read_buffer.lock().pop_iter().collect();\n     }\n+\n+    pub fn buffer_len(&self) -> usize {\n+        self.read_buffer.lock().len()\n+    }\n+\n+    pub fn window_size(&self) -> WinSize {\n+        self.winsize.lock().clone()\n+    }\n+\n+    pub fn set_window_size(&self, winsize: WinSize) {\n+        *self.winsize.lock() = winsize;\n+    }\n }\n \n fn meet_new_line(item: u8, termios: &KernelTermios) -> bool {\n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -6,7 +6,7 @@ use super::*;\n use crate::fs::utils::{IoEvents, IoctlCmd, Poller};\n use crate::prelude::*;\n use crate::process::process_group::ProcessGroup;\n-use crate::process::{process_table, Pgid};\n+use crate::process::process_table;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod driver;\n\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -130,7 +130,13 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGWINSZ => {\n-                // TODO:get window size\n+                let winsize = self.ldisc.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n             _ => todo!(),\n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -14,22 +14,28 @@ bitflags! {\n     #[repr(C)]\n     pub struct C_IFLAGS: u32 {\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits-common.h\n-        const IGNBRK\t= 0x001;\t\t\t/* Ignore break condition */\n-        const BRKINT\t= 0x002;\t\t\t/* Signal interrupt on break */\n-        const IGNPAR\t= 0x004;\t\t\t/* Ignore characters with parity errors */\n-        const PARMRK\t= 0x008;\t\t\t/* Mark parity and framing errors */\n-        const INPCK\t    = 0x010;\t\t\t/* Enable input parity check */\n-        const ISTRIP\t= 0x020;\t\t\t/* Strip 8th bit off characters */\n-        const INLCR\t    = 0x040;\t\t\t/* Map NL to CR on input */\n-        const IGNCR\t    = 0x080;\t\t\t/* Ignore CR */\n-        const ICRNL\t    = 0x100;\t\t\t/* Map CR to NL on input */\n-        const IXANY\t    = 0x800;\t\t\t/* Any character will restart after stop */\n+        const IGNBRK  = 0x001;\t\t\t/* Ignore break condition */\n+        const BRKINT  = 0x002;\t\t\t/* Signal interrupt on break */\n+        const IGNPAR  = 0x004;\t\t\t/* Ignore characters with parity errors */\n+        const PARMRK  = 0x008;\t\t\t/* Mark parity and framing errors */\n+        const INPCK   = 0x010;\t\t\t/* Enable input parity check */\n+        const ISTRIP  = 0x020;\t\t\t/* Strip 8th bit off characters */\n+        const INLCR   = 0x040;\t\t\t/* Map NL to CR on input */\n+        const IGNCR   = 0x080;\t\t\t/* Ignore CR */\n+        const ICRNL   = 0x100;\t\t\t/* Map CR to NL on input */\n+        const IXANY   = 0x800;\t\t\t/* Any character will restart after stop */\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits.h\n-        const IUCLC\t    = 0x0200;\n-        const IXON\t    = 0x0400;\n-        const IXOFF\t    = 0x1000;\n-        const IMAXBEL\t= 0x2000;\n-        const IUTF8\t    = 0x4000;\n+        const IUCLC   = 0x0200;\n+        const IXON    = 0x0400;\n+        const IXOFF   = 0x1000;\n+        const IMAXBEL = 0x2000;\n+        const IUTF8   = 0x4000;\n+    }\n+}\n+\n+impl Default for C_IFLAGS {\n+    fn default() -> Self {\n+        C_IFLAGS::ICRNL | C_IFLAGS::IXON\n     }\n }\n \n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -37,18 +43,68 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_OFLAGS: u32 {\n-        const OPOST\t= 0x01;\t\t\t/* Perform output processing */\n-        const OCRNL\t= 0x08;\n-        const ONOCR\t= 0x10;\n-        const ONLRET= 0x20;\n-        const OFILL\t= 0x40;\n-        const OFDEL\t= 0x80;\n+        const OPOST  = 1 << 0;\t\t\t/* Perform output processing */\n+        const OLCUC  = 1 << 1;\n+        const ONLCR  = 1 << 2;\n+        const OCRNL  = 1 << 3;\n+        const ONOCR  = 1 << 4;\n+        const ONLRET = 1 << 5;\n+        const OFILL  = 1 << 6;\n+        const OFDEL  = 1 << 7;\n     }\n }\n \n-#[repr(u32)]\n+impl Default for C_OFLAGS {\n+    fn default() -> Self {\n+        C_OFLAGS::OPOST | C_OFLAGS::ONLCR\n+    }\n+}\n+\n+#[repr(C)]\n #[derive(Debug, Clone, Copy, Pod)]\n-pub enum C_CFLAGS {\n+pub struct C_CFLAGS(u32);\n+\n+impl Default for C_CFLAGS {\n+    fn default() -> Self {\n+        let cbaud = C_CFLAGS_BAUD::B38400 as u32;\n+        let csize = C_CFLAGS_CSIZE::CS8 as u32;\n+        let c_cflags = cbaud | csize | CREAD;\n+        Self(c_cflags)\n+    }\n+}\n+\n+impl C_CFLAGS {\n+    pub fn cbaud(&self) -> Result<C_CFLAGS_BAUD> {\n+        let cbaud = self.0 & CBAUD_MASK;\n+        Ok(C_CFLAGS_BAUD::try_from(cbaud)?)\n+    }\n+\n+    pub fn csize(&self) -> Result<C_CFLAGS_CSIZE> {\n+        let csize = self.0 & CSIZE_MASK;\n+        Ok(C_CFLAGS_CSIZE::try_from(csize)?)\n+    }\n+\n+    pub fn cread(&self) -> bool {\n+        self.0 & CREAD != 0\n+    }\n+}\n+\n+const CREAD: u32 = 0x00000080;\n+const CBAUD_MASK: u32 = 0x0000100f;\n+const CSIZE_MASK: u32 = 0x00000030;\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_CSIZE {\n+    CS5 = 0x00000000,\n+    CS6 = 0x00000010,\n+    CS7 = 0x00000020,\n+    CS8 = 0x00000030,\n+}\n+\n+#[repr(u32)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_BAUD {\n     B0 = 0x00000000, /* hang up */\n     B50 = 0x00000001,\n     B75 = 0x00000002,\n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -71,28 +127,41 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_LFLAGS: u32 {\n-        const ISIG\t=   0x00001;\n-        const ICANON=   0x00002;\n-        const XCASE\t=   0x00004;\n-        const ECHO\t=   0x00008;\n-        const ECHOE\t=   0x00010;\n-        const ECHOK\t=   0x00020;\n-        const ECHONL=\t0x00040;\n-        const NOFLSH=\t0x00080;\n-        const TOSTOP=\t0x00100;\n-        const ECHOCTL=\t0x00200;\n-        const ECHOPRT=\t0x00400;\n-        const ECHOKE=   0x00800;\n-        const FLUSHO=\t0x01000;\n-        const PENDIN=\t0x04000;\n-        const IEXTEN=\t0x08000;\n-        const EXTPROC=\t0x10000;\n+        const ISIG    = 0x00001;\n+        const ICANON  = 0x00002;\n+        const XCASE   = 0x00004;\n+        const ECHO    = 0x00008;\n+        const ECHOE   = 0x00010;\n+        const ECHOK   = 0x00020;\n+        const ECHONL  = 0x00040;\n+        const NOFLSH  = 0x00080;\n+        const TOSTOP  = 0x00100;\n+        const ECHOCTL = 0x00200;\n+        const ECHOPRT = 0x00400;\n+        const ECHOKE  = 0x00800;\n+        const FLUSHO  = 0x01000;\n+        const PENDIN  = 0x04000;\n+        const IEXTEN  = 0x08000;\n+        const EXTPROC = 0x10000;\n+    }\n+}\n+\n+impl Default for C_LFLAGS {\n+    fn default() -> Self {\n+        C_LFLAGS::ICANON\n+            | C_LFLAGS::ECHO\n+            | C_LFLAGS::ISIG\n+            | C_LFLAGS::ECHOE\n+            | C_LFLAGS::ECHOK\n+            | C_LFLAGS::ECHOCTL\n+            | C_LFLAGS::ECHOKE\n+            | C_LFLAGS::IEXTEN\n     }\n }\n \n /* c_cc characters index*/\n #[repr(u32)]\n-#[derive(Debug, Clone, Copy, Pod)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum CC_C_CHAR {\n     VINTR = 0,\n     VQUIT = 1,\n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -114,61 +183,28 @@ pub enum CC_C_CHAR {\n }\n \n impl CC_C_CHAR {\n-    // The special char is the same as ubuntu\n-    pub fn char(&self) -> u8 {\n+    // The special char is from gvisor\n+    pub fn default_char(&self) -> u8 {\n         match self {\n-            CC_C_CHAR::VINTR => 3,\n-            CC_C_CHAR::VQUIT => 28,\n-            CC_C_CHAR::VERASE => 127,\n-            CC_C_CHAR::VKILL => 21,\n-            CC_C_CHAR::VEOF => 4,\n-            CC_C_CHAR::VTIME => 0,\n+            CC_C_CHAR::VINTR => control_character('C'),\n+            CC_C_CHAR::VQUIT => control_character('\\\\'),\n+            CC_C_CHAR::VERASE => '\\x7f' as u8,\n+            CC_C_CHAR::VKILL => control_character('U'),\n+            CC_C_CHAR::VEOF => control_character('D'),\n+            CC_C_CHAR::VTIME => '\\0' as u8,\n             CC_C_CHAR::VMIN => 1,\n-            CC_C_CHAR::VSWTC => 0,\n-            CC_C_CHAR::VSTART => 17,\n-            CC_C_CHAR::VSTOP => 19,\n-            CC_C_CHAR::VSUSP => 26,\n-            CC_C_CHAR::VEOL => 255,\n-            CC_C_CHAR::VREPRINT => 18,\n-            CC_C_CHAR::VDISCARD => 15,\n-            CC_C_CHAR::VWERASE => 23,\n-            CC_C_CHAR::VLNEXT => 22,\n-            CC_C_CHAR::VEOL2 => 255,\n+            CC_C_CHAR::VSWTC => '\\0' as u8,\n+            CC_C_CHAR::VSTART => control_character('Q'),\n+            CC_C_CHAR::VSTOP => control_character('S'),\n+            CC_C_CHAR::VSUSP => control_character('Z'),\n+            CC_C_CHAR::VEOL => '\\0' as u8,\n+            CC_C_CHAR::VREPRINT => control_character('R'),\n+            CC_C_CHAR::VDISCARD => control_character('O'),\n+            CC_C_CHAR::VWERASE => control_character('W'),\n+            CC_C_CHAR::VLNEXT => control_character('V'),\n+            CC_C_CHAR::VEOL2 => '\\0' as u8,\n         }\n     }\n-\n-    pub fn as_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    pub fn from_char(item: u8) -> Result<Self> {\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VQUIT.char() {\n-            return Ok(Self::VQUIT);\n-        }\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VERASE.char() {\n-            return Ok(Self::VERASE);\n-        }\n-        if item == Self::VEOF.char() {\n-            return Ok(Self::VEOF);\n-        }\n-        if item == Self::VSTART.char() {\n-            return Ok(Self::VSTART);\n-        }\n-        if item == Self::VSTOP.char() {\n-            return Ok(Self::VSTOP);\n-        }\n-        if item == Self::VSUSP.char() {\n-            return Ok(Self::VSUSP);\n-        }\n-\n-        return_errno_with_message!(Errno::EINVAL, \"Not a valid cc_char\");\n-    }\n }\n \n #[derive(Debug, Clone, Copy, Pod)]\n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -185,50 +221,39 @@ pub struct KernelTermios {\n impl KernelTermios {\n     pub fn default() -> Self {\n         let mut termios = Self {\n-            c_iflags: C_IFLAGS::ICRNL,\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::ICANON | C_LFLAGS::ECHO,\n+            c_iflags: C_IFLAGS::default(),\n+            c_oflags: C_OFLAGS::default(),\n+            c_cflags: C_CFLAGS::default(),\n+            c_lflags: C_LFLAGS::default(),\n             c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n+            c_cc: [CcT::default(); KERNEL_NCCS],\n         };\n-        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.default_char();\n         termios\n     }\n \n-    fn new() -> Self {\n-        KernelTermios {\n-            c_iflags: C_IFLAGS::empty(),\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::empty(),\n-            c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n-        }\n-    }\n-\n     pub fn get_special_char(&self, cc_c_char: CC_C_CHAR) -> &CcT {\n-        &self.c_cc[cc_c_char.as_usize()]\n+        &self.c_cc[cc_c_char as usize]\n     }\n \n     pub fn get_special_char_mut(&mut self, cc_c_char: CC_C_CHAR) -> &mut CcT {\n-        &mut self.c_cc[cc_c_char.as_usize()]\n+        &mut self.c_cc[cc_c_char as usize]\n     }\n \n     /// Canonical mode means we will handle input by lines, not by single character\n\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -265,3 +290,17 @@ impl KernelTermios {\n         self.c_lflags.contains(C_LFLAGS::IEXTEN)\n     }\n }\n+\n+const fn control_character(c: char) -> u8 {\n+    debug_assert!(c as u8 >= 'A' as u8);\n+    c as u8 - 'A' as u8 + 1u8\n+}\n+\n+#[derive(Debug, Clone, Copy, Default, Pod)]\n+#[repr(C)]\n+pub struct WinSize {\n+    ws_row: u16,\n+    ws_col: u16,\n+    ws_xpixel: u16,\n+    ws_ypixel: u16,\n+}\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -1,7 +1,9 @@\n-use crate::prelude::*;\n+use crate::{fs::file_handle::FileLike, prelude::*};\n \n use super::*;\n \n+use crate::device::PtyMaster;\n+\n /// Pty master inode for the master device.\n pub struct PtyMasterInode(Arc<PtyMaster>);\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -14,8 +16,11 @@ impl PtyMasterInode {\n impl Drop for PtyMasterInode {\n     fn drop(&mut self) {\n         // Remove the slave from fs.\n-        let index = self.0.slave_index();\n-        let _ = self.0.ptmx().devpts().remove_slave(index);\n+        let fs = self.0.ptmx().fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.0.index();\n+        devpts.remove_slave(index);\n     }\n }\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -77,52 +82,6 @@ impl Inode for PtyMasterInode {\n     }\n \n     fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().devpts()\n-    }\n-}\n-\n-// TODO: implement real pty master.\n-pub struct PtyMaster {\n-    slave_index: u32,\n-    ptmx: Arc<Ptmx>,\n-}\n-\n-impl PtyMaster {\n-    pub fn new(slave_index: u32, ptmx: Arc<Ptmx>) -> Arc<Self> {\n-        Arc::new(Self { slave_index, ptmx })\n-    }\n-\n-    pub fn slave_index(&self) -> u32 {\n-        self.slave_index\n-    }\n-\n-    fn ptmx(&self) -> &Ptmx {\n-        &self.ptmx\n-    }\n-}\n-\n-impl Device for PtyMaster {\n-    fn type_(&self) -> DeviceType {\n-        self.ptmx.device_type()\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        self.ptmx.device_id()\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n+        self.0.ptmx().fs()\n     }\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,9 +9,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::{PtyMaster, PtyMasterInode};\n+use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n-use self::slave::{PtySlave, PtySlaveInode};\n+use self::slave::PtySlaveInode;\n \n mod master;\n mod ptmx;\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -60,8 +60,7 @@ impl DevPts {\n             .alloc()\n             .ok_or_else(|| Error::with_message(Errno::EIO, \"cannot alloc index\"))?;\n \n-        let master = PtyMaster::new(index as u32, self.root.ptmx.clone());\n-        let slave = PtySlave::new(master.clone());\n+        let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n         let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -2,6 +2,8 @@ use crate::prelude::*;\n \n use super::*;\n \n+use crate::device::PtySlave;\n+\n /// Same major number with Linux, the minor number is the index of slave.\n const SLAVE_MAJOR_NUM: u32 = 3;\n \n\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -88,44 +90,3 @@ impl Inode for PtySlaveInode {\n         self.fs.upgrade().unwrap()\n     }\n }\n-\n-// TODO: implement real pty slave.\n-pub struct PtySlave {\n-    master: Arc<PtyMaster>,\n-}\n-\n-impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self { master })\n-    }\n-\n-    pub fn index(&self) -> u32 {\n-        self.master.slave_index()\n-    }\n-}\n-\n-impl Device for PtySlave {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        DeviceId::new(SLAVE_MAJOR_NUM, self.index())\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n-    }\n-}\n\ndiff --git a/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n--- a/services/libs/jinux-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n@@ -3,18 +3,30 @@ use crate::prelude::*;\n #[repr(u32)]\n #[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum IoctlCmd {\n-    // Get terminal attributes\n+    /// Get terminal attributes\n     TCGETS = 0x5401,\n     TCSETS = 0x5402,\n-    // Drain the output buffer and set attributes\n+    /// Drain the output buffer and set attributes\n     TCSETSW = 0x5403,\n-    // Drain the output buffer, and discard pending input, and set attributes\n+    /// Drain the output buffer, and discard pending input, and set attributes\n     TCSETSF = 0x5404,\n-    // Get the process group ID of the foreground process group on this terminal\n+    /// Make the given terminal the controlling terminal of the calling process.\n+    TIOCSCTTY = 0x540e,\n+    /// Get the process group ID of the foreground process group on this terminal\n     TIOCGPGRP = 0x540f,\n-    // Set the foreground process group ID of this terminal.\n+    /// Set the foreground process group ID of this terminal.\n     TIOCSPGRP = 0x5410,\n-    // Set window size\n+    /// Get the number of bytes in the input buffer.\n+    FIONREAD = 0x541B,\n+    /// Set window size\n     TIOCGWINSZ = 0x5413,\n     TIOCSWINSZ = 0x5414,\n+    /// the calling process gives up this controlling terminal\n+    TIOCNOTTY = 0x5422,\n+    /// Get Pty Number\n+    TIOCGPTN = 0x80045430,\n+    /// Lock/unlock Pty\n+    TIOCSPTLCK = 0x40045431,\n+    /// Safely open the slave\n+    TIOCGPTPEER = 0x40045441,\n }\n\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -146,6 +146,7 @@ impl Vnode {\n         if let Some(page_cache) = &inner.page_cache {\n             page_cache.evict_range(0..file_len);\n         }\n+\n         inner.inode.read_at(0, &mut buf[..file_len])\n     }\n \n\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -196,11 +197,13 @@ impl Vnode {\n     }\n \n     pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.inner.read().inode.poll(mask, poller)\n+        let inode = self.inner.read().inode.clone();\n+        inode.poll(mask, poller)\n     }\n \n     pub fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.inner.read().inode.ioctl(cmd, arg)\n+        let inode = self.inner.read().inode.clone();\n+        inode.ioctl(cmd, arg)\n     }\n \n     pub fn fs(&self) -> Arc<dyn FileSystem> {\n\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -150,12 +150,27 @@ impl VmMapping {\n     }\n     pub fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         let vmo_read_offset = self.vmo_offset() + offset;\n+\n+        // TODO: the current logic is vulnerable to TOCTTOU attack, since the permission may change after check.\n+        let page_idx_range = get_page_idx_range(&(vmo_read_offset..vmo_read_offset + buf.len()));\n+        let read_perm = VmPerm::R;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &read_perm)?;\n+        }\n+\n         self.vmo.read_bytes(vmo_read_offset, buf)?;\n         Ok(())\n     }\n \n     pub fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         let vmo_write_offset = self.vmo_offset() + offset;\n+\n+        let page_idx_range = get_page_idx_range(&(vmo_write_offset..vmo_write_offset + buf.len()));\n+        let write_perm = VmPerm::W;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &write_perm)?;\n+        }\n+\n         self.vmo.write_bytes(vmo_write_offset, buf)?;\n         Ok(())\n     }\n\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -198,7 +213,9 @@ impl VmMapping {\n         } else {\n             self.vmo.check_rights(Rights::READ)?;\n         }\n-        self.check_perm(&page_idx, write)?;\n+\n+        let required_perm = if write { VmPerm::W } else { VmPerm::R };\n+        self.check_perm(&page_idx, &required_perm)?;\n \n         let frame = self.vmo.get_committed_frame(page_idx, write)?;\n \n\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -300,8 +317,8 @@ impl VmMapping {\n         self.inner.lock().trim_right(vm_space, vaddr)\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n-        self.inner.lock().check_perm(page_idx, write)\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n+        self.inner.lock().check_perm(page_idx, perm)\n     }\n }\n \n\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -457,16 +474,14 @@ impl VmMappingInner {\n         self.map_to_addr..self.map_to_addr + self.map_size\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n         let page_perm = self\n             .page_perms\n             .get(&page_idx)\n             .ok_or(Error::with_message(Errno::EINVAL, \"invalid page idx\"))?;\n-        if !page_perm.contains(VmPerm::R) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should at least contain read\");\n-        }\n-        if write && !page_perm.contains(VmPerm::W) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should contain write for write access\");\n+\n+        if !page_perm.contains(*perm) {\n+            return_errno_with_message!(Errno::EACCES, \"perm check fails\");\n         }\n \n         Ok(())\n",
        "test_patch": "diff --git a/regression/apps/Makefile b/regression/apps/Makefile\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -3,7 +3,7 @@ MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n-TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve \n+TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve pty\n \n .PHONY: all\n \n\ndiff --git /dev/null b/regression/apps/pty/Makefile\nnew file mode 100644\n--- /dev/null\n+++ b/regression/apps/pty/Makefile\n@@ -0,0 +1,3 @@\n+include ../test_common.mk\n+\n+EXTRA_C_FLAGS :=\n\ndiff --git a/regression/apps/scripts/run_tests.sh b/regression/apps/scripts/run_tests.sh\n--- a/regression/apps/scripts/run_tests.sh\n+++ b/regression/apps/scripts/run_tests.sh\n@@ -6,7 +6,7 @@ SCRIPT_DIR=/regression\n cd ${SCRIPT_DIR}/..\n \n echo \"Running tests......\"\n-tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello\"\n+tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello pty/open_pty\"\n for testcase in ${tests}\n do \n     echo \"Running test ${testcase}......\"\n\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -1,4 +1,4 @@\n-TESTS ?= open_test read_test statfs_test chmod_test\n+TESTS ?= open_test read_test statfs_test chmod_test pty_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n",
        "problem_statement": "Implement pseudo terminals\nMaybe we need #209 for pty, since each pty will be a device under devfs.\n",
        "hints_text": "",
        "created_at": "2023-08-01T06:37:18Z"
    }
]