[
    {
        "repo": "bitflags/bitflags",
        "pull_number": 324,
        "instance_id": "bitflags__bitflags-324",
        "issue_numbers": [
            "248"
        ],
        "base_commit": "11640f19a7644f3967631733f33ec87b9f911951",
        "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -49,7 +49,7 @@ jobs:\n       run: cargo install cargo-hack\n \n     - name: Powerset\n-      run: cargo hack test --feature-powerset --lib --optional-deps \"std serde\" --depth 3 --skip rustc-dep-of-std\n+      run: cargo hack test --feature-powerset --lib --optional-deps --depth 3 --skip \"compiler_builtins core rustc-dep-of-std\"\n \n     - name: Docs\n       run: cargo doc --features example_generated\n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -21,6 +21,7 @@ exclude = [\"tests\", \".github\"]\n \n [dependencies]\n serde = { version = \"1.0\", optional = true, default-features = false }\n+arbitrary = { version = \"1.0\", optional = true }\n core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n compiler_builtins = { version = \"0.1.2\", optional = true }\n \n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -30,6 +31,7 @@ rustversion = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n+arbitrary = { version = \"1.0\", features = [\"derive\"] }\n \n [features]\n std = []\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -3,6 +3,9 @@\n #[cfg(feature = \"serde\")]\n pub mod serde_support;\n \n+#[cfg(feature = \"arbitrary\")]\n+pub mod arbitrary_support;\n+\n /// Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -27,6 +30,15 @@ macro_rules! __impl_external_bitflags {\n                 )*\n             }\n         }\n+\n+        __impl_external_bitflags_arbitrary! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n     };\n }\n \n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -80,3 +92,40 @@ macro_rules! __impl_external_bitflags_serde {\n         }\n     ) => {};\n }\n+\n+/// Implement `Arbitrary` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"arbitrary\")]\n+macro_rules! __impl_external_bitflags_arbitrary {\n+    (\n+            $InternalBitFlags:ident: $T:ty {\n+                $(\n+                    $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+            }\n+    ) => {\n+        impl<'a> $crate::__private::arbitrary::Arbitrary<'a> for $InternalBitFlags {\n+            fn arbitrary(\n+                u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n+            ) -> $crate::__private::arbitrary::Result<Self> {\n+                Self::from_bits(u.arbitrary()?).ok_or_else(|| $crate::__private::arbitrary::Error::IncorrectFormat)\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"arbitrary\"))]\n+macro_rules! __impl_external_bitflags_arbitrary {\n+    (\n+            $InternalBitFlags:ident: $T:ty {\n+                $(\n+                    $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+            }\n+    ) => {};\n+}\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -361,6 +361,9 @@ pub mod __private {\n \n     #[cfg(feature = \"serde\")]\n     pub use serde;\n+\n+    #[cfg(feature = \"arbitrary\")]\n+    pub use arbitrary;\n }\n \n /*\n",
        "problem_statement": "Implement Arbitrary for bitflags?\nWould it be worth it to have an optional implementation of [`Arbitrary`](https://docs.rs/arbitrary/1.0.1/arbitrary/trait.Arbitrary.html) (in the [arbitrary crate](https://crates.io/crates/arbitrary)) for bitflags types, to make it easier to use them in fuzzing?\r\n\r\nI'm imagining something along the lines of this, added to the macro expansion when `cfg(feature = \"arbitrary\")` or so:\r\n\r\n```rust\r\nimpl arbitrary::Arbitrary for $BitFlags {\r\n    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {\r\n         Self::from_bits(u.arbitrary()).ok_or_else(|| arbitrary::Error::IncorrectFormat)\r\n    }\r\n}\r\n```\r\n\n",
        "hints_text": "Can we think of any other implementation for `Arbitrary` that a consumer might want to add themselves? If not then this seems like a reasonable addition to me, since as I understand it, `Arbitrary` is meant to be a general API that different fuzzer implementations can lean on. Anything that makes fuzzing easier to get started with is worth doing! \ud83d\ude01 \nI've now submitted #260 implementing this.\nWe've recently published `2.0.0` that reworks the library internals to support new external trait implementations without breaking consumers. We should now be able to add an implementation for `arbitrary` following the support for `serde` as an example.",
        "created_at": "2023-03-25T01:34:21Z",
        "test_patch": "diff --git /dev/null b/src/external/arbitrary_support.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/external/arbitrary_support.rs\n@@ -0,0 +1,19 @@\n+#[cfg(test)]\n+mod tests {\n+    use arbitrary::Arbitrary;\n+\n+    bitflags! {\n+        #[derive(Arbitrary)]\n+        struct Color: u32 {\n+            const RED = 0x1;\n+            const GREEN = 0x2;\n+            const BLUE = 0x4;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_arbitrary() {\n+        let mut unstructured = arbitrary::Unstructured::new(&[0_u8; 256]);\n+        let _color = Color::arbitrary(&mut unstructured);\n+    }\n+}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 336,
        "instance_id": "bitflags__bitflags-336",
        "issue_numbers": [
            "311"
        ],
        "base_commit": "597d40749224d3eee125a6ea9d6ac4c92b898ee8",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -22,6 +22,7 @@ exclude = [\"tests\", \".github\"]\n [dependencies]\n serde = { version = \"1.0\", optional = true, default-features = false }\n arbitrary = { version = \"1.0\", optional = true }\n+bytemuck = { version = \"1.0\", optional = true }\n core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n compiler_builtins = { version = \"0.1.2\", optional = true }\n \n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -32,6 +33,7 @@ serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n arbitrary = { version = \"1.0\", features = [\"derive\"] }\n+bytemuck = { version = \"1.0\", features = [\"derive\"] }\n \n [features]\n std = []\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -1,10 +1,83 @@\n //! Conditional trait implementations for external libraries.\n \n+/*\n+How do I support a new external library?\n+\n+Let's say we want to add support for `my_library`.\n+\n+First, we define a macro like so:\n+\n+```rust\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"serde\")]\n+macro_rules! __impl_external_bitflags_my_library {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {\n+        // Implementation goes here\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"my_library\"))]\n+macro_rules! __impl_external_bitflags_my_library {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {};\n+}\n+```\n+\n+Note that the macro is actually defined twice; once for when the `my_library` feature\n+is available, and once for when it's not. This is because the `__impl_external_bitflags_my_library`\n+macro is called in an end-user's library, not in `bitflags`. In an end-user's library we don't\n+know whether or not a particular feature of `bitflags` is enabled, so we unconditionally call\n+the macro, where the body of that macro depends on the feature flag.\n+\n+Now, we add our macro call to the `__impl_external_bitflags` macro body:\n+\n+```rust\n+__impl_external_bitflags_my_library! {\n+    $InternalBitFlags: $T {\n+        $(\n+            $(#[$attr $($args)*])*\n+            $Flag;\n+        )*\n+    }\n+}\n+```\n+\n+What about libraries that _must_ be supported through `#[derive]`?\n+\n+In these cases, the attributes will need to be added to the `__declare_internal_bitflags` macro when\n+the internal type is declared.\n+*/\n+\n #[cfg(feature = \"serde\")]\n pub mod serde_support;\n+#[cfg(feature = \"serde\")]\n+pub use serde;\n \n #[cfg(feature = \"arbitrary\")]\n pub mod arbitrary_support;\n+#[cfg(feature = \"arbitrary\")]\n+pub use arbitrary;\n+\n+#[cfg(feature = \"bytemuck\")]\n+pub mod bytemuck_support;\n+#[cfg(feature = \"bytemuck\")]\n+pub use bytemuck;\n \n /// Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -39,6 +112,15 @@ macro_rules! __impl_external_bitflags {\n                 )*\n             }\n         }\n+\n+        __impl_external_bitflags_bytemuck! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n     };\n }\n \n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -129,3 +211,50 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             }\n     ) => {};\n }\n+\n+/// Implement `Pod` and `Zeroable` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"bytemuck\")]\n+macro_rules! __impl_external_bitflags_bytemuck {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+        }\n+    ) => {\n+        // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n+        // and $T implements Pod\n+        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags\n+        where\n+            $T: $crate::__private::bytemuck::Pod,\n+        {\n+\n+        }\n+\n+        // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n+        // and $T implements Zeroable\n+        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags\n+        where\n+            $T: $crate::__private::bytemuck::Zeroable,\n+        {\n+\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"bytemuck\"))]\n+macro_rules! __impl_external_bitflags_bytemuck {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                    $Flag:ident;\n+                )*\n+        }\n+    ) => {};\n+}\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -14,6 +14,9 @@ macro_rules! __declare_internal_bitflags {\n         $iter_vis:vis struct $Iter:ident;\n         $iter_names_vis:vis struct $IterNames:ident;\n     ) => {\n+        // NOTE: The ABI of this type is _guaranteed_ to be the same as `T`\n+        // This is relied on by some external libraries like `bytemuck` to make\n+        // its `unsafe` trait impls sound.\n         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         #[repr(transparent)]\n         $vis struct $InternalBitFlags {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -394,8 +394,9 @@\n //! example docs.\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n+#![cfg_attr(not(test), forbid(unsafe_code))]\n+\n #![doc(html_root_url = \"https://docs.rs/bitflags/2.1.0\")]\n-#![forbid(unsafe_code)]\n \n #[doc(inline)]\n pub use traits::BitFlags;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -408,12 +409,6 @@ pub mod __private {\n     pub use crate::{external::*, traits::*};\n \n     pub use core;\n-\n-    #[cfg(feature = \"serde\")]\n-    pub use serde;\n-\n-    #[cfg(feature = \"arbitrary\")]\n-    pub use arbitrary;\n }\n \n /*\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -14,7 +14,7 @@ macro_rules! __declare_public_bitflags {\n         $vis:vis struct $BitFlags:ident;\n     ) => {\n         $(#[$outer])*\n-        $vis struct $BitFlags(<Self as $crate::__private::PublicFlags>::Internal);\n+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::Internal);\n     };\n }\n \n",
        "problem_statement": "Support bytemuck\nFrom #310\r\n\r\nAdd a `bytemuck` Cargo feature that derives `bytemuck` traits on the generated inner flags type so end-users can then `#[derive(bytemuck::*)]` traits on their own flags types.\n",
        "hints_text": "",
        "created_at": "2023-04-11T01:30:12Z",
        "test_patch": "diff --git /dev/null b/src/external/bytemuck_support.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/external/bytemuck_support.rs\n@@ -0,0 +1,19 @@\n+#[cfg(test)]\n+mod tests {\n+    use bytemuck::{Pod, Zeroable};\n+    \n+    bitflags! {\n+        #[derive(Pod, Zeroable, Clone, Copy)]\n+        #[repr(transparent)]\n+        struct Color: u32 {\n+            const RED = 0x1;\n+            const GREEN = 0x2;\n+            const BLUE = 0x4;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bytemuck() {\n+        assert_eq!(0x1, bytemuck::cast::<Color, u32>(Color::RED));\n+    }\n+}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 321,
        "instance_id": "bitflags__bitflags-321",
        "issue_numbers": [
            "319"
        ],
        "base_commit": "8b43d2bb7efbd3d4189fdac92e411ad20c5140b5",
        "patch": "diff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -138,6 +138,7 @@ impl_bits! {\n     u32, i32,\n     u64, i64,\n     u128, i128,\n+    usize, isize,\n }\n \n /// A trait for referencing the `bitflags`-owned internal type\n",
        "problem_statement": "`usize` / `isize` aren't supported anymore in `v2.0`\nThis doesn't seem intentional at least and isn't mentioned in the changelog.\n",
        "hints_text": "In what way are they not supported? What error message do they give? Or is there some other problem with them?\nThey don't implement the new `Bits` trait, which is required to use bitflags: https://github.com/bitflags/bitflags/blob/main/src/traits.rs#L135-L141\nThanks for pointing this out @CryZe. This is a total oversight, they should implement the `Bits` trait.",
        "created_at": "2023-03-19T08:31:22Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1548,4 +1548,57 @@ mod tests {\n \n         assert_eq!(flags, rebuilt);\n     }\n+\n+    #[test]\n+    fn bits_types() {\n+        bitflags! {\n+            pub struct I8: i8 {\n+                const A = 1;\n+            }\n+\n+            pub struct I16: i16 {\n+                const A = 1;\n+            }\n+\n+            pub struct I32: i32 {\n+                const A = 1;\n+            }\n+\n+            pub struct I64: i64 {\n+                const A = 1;\n+            }\n+\n+            pub struct I128: i128 {\n+                const A = 1;\n+            }\n+\n+            pub struct Isize: isize {\n+                const A = 1;\n+            }\n+\n+            pub struct U8: u8 {\n+                const A = 1;\n+            }\n+\n+            pub struct U16: u16 {\n+                const A = 1;\n+            }\n+\n+            pub struct U32: u32 {\n+                const A = 1;\n+            }\n+\n+            pub struct U64: u64 {\n+                const A = 1;\n+            }\n+\n+            pub struct U128: u128 {\n+                const A = 1;\n+            }\n+\n+            pub struct Usize: usize {\n+                const A = 1;\n+            }\n+        }\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 316,
        "instance_id": "bitflags__bitflags-316",
        "issue_numbers": [
            "315"
        ],
        "base_commit": "ad0271116e28a79ea880334dd3d06212a224ec09",
        "patch": "diff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -89,7 +89,8 @@ macro_rules! __impl_internal_bitflags {\n \n                 // Iterate over the valid flags\n                 let mut first = true;\n-                for (name, _) in self.iter_names() {\n+                let mut iter = self.iter_names();\n+                for (name, _) in &mut iter {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -99,8 +100,7 @@ macro_rules! __impl_internal_bitflags {\n                 }\n \n                 // Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = self.bits & !Self::all().bits;\n-\n+                let extra_bits = iter.state.bits();\n                 if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n",
        "problem_statement": "Display missing extra bits for multi-bit flags\nSee: https://github.com/bitflags/bitflags/issues/310#issuecomment-1470122112\r\n\r\nGiven a flags type with two flags, `BIT = 0b0000_0001` and `MASK = 0b0001_1110`, formatting the value `3` should result in `BIT | 0x2`, but instead it gives `BIT`. That extra bit gets lost, so doesn't roundtrip. The problem seems to be in the generated `iter_names` method.\n",
        "hints_text": "",
        "created_at": "2023-03-16T00:19:13Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1154,17 +1154,39 @@ mod tests {\n \n     #[test]\n     fn test_display_from_str_roundtrip() {\n-        fn format_parse_case(flags: FmtFlags) {\n+        fn format_parse_case<T: fmt::Debug + fmt::Display + str::FromStr + PartialEq>(flags: T) where <T as str::FromStr>::Err: fmt::Display {\n             assert_eq!(flags, {\n-                match flags.to_string().parse::<FmtFlags>() {\n+                match flags.to_string().parse::<T>() {\n                     Ok(flags) => flags,\n                     Err(e) => panic!(\"failed to parse `{}`: {}\", flags, e),\n                 }\n             });\n         }\n \n-        fn parse_case(expected: FmtFlags, flags: &str) {\n-            assert_eq!(expected, flags.parse::<FmtFlags>().unwrap());\n+        fn parse_case<T: fmt::Debug + str::FromStr + PartialEq>(expected: T, flags: &str) where <T as str::FromStr>::Err: fmt::Display + fmt::Debug {\n+            assert_eq!(expected, flags.parse::<T>().unwrap());\n+        }\n+\n+        bitflags! {\n+            #[derive(Debug, Eq, PartialEq)]\n+            pub struct MultiBitFmtFlags: u8 {\n+                const A = 0b0000_0001u8;\n+                const B = 0b0001_1110u8;\n+            }\n+        }\n+\n+        impl fmt::Display for MultiBitFmtFlags {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                fmt::Display::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl str::FromStr for MultiBitFmtFlags {\n+            type Err = crate::parser::ParseError;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                Ok(MultiBitFmtFlags(s.parse()?))\n+            }\n         }\n \n         format_parse_case(FmtFlags::empty());\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1174,6 +1196,7 @@ mod tests {\n         format_parse_case(FmtFlags::\ubb3c\uace0\uae30_\uace0\uc591\uc774);\n         format_parse_case(FmtFlags::from_bits_retain(0xb8));\n         format_parse_case(FmtFlags::from_bits_retain(0x20));\n+        format_parse_case(MultiBitFmtFlags::from_bits_retain(3));\n \n         parse_case(FmtFlags::empty(), \"\");\n         parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 341,
        "instance_id": "bitflags__bitflags-341",
        "issue_numbers": [
            "308"
        ],
        "base_commit": "dc971042c8132a5381ab3e2165983ee7f9d44c63",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -558,6 +558,315 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n+    ) => {\n+        __declare_bitflags!(\n+            $(#[$outer])*\n+            $vis struct $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    const $Flag = $value;\n+                )*\n+            }\n+        );\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n+}\n+\n+/// A macro that processed the input to `bitflags!` and shuffles attributes around\n+/// based on whether or not they're \"expression-safe\".\n+///\n+/// This macro is a token-tree muncher that works on 2 levels:\n+///\n+/// 1. Each flag, like `#[cfg(true)] const A: 42`\n+/// 2. Each attribute on that flag, like `#[cfg(true)]`\n+///\n+/// Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n+/// at a time into an appropriate processed list until the unprocessed lists are empty.\n+///\n+/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+/// whether or not it should be considered expression-safe.\n+///\n+/// If you find yourself with an attribute that should be considered expression-safe\n+/// and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __declare_bitflags {\n+    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    // where they'll be munched one-at-a-time\n+    (\n+        $(#[$outer:meta])*\n+        $vis:vis struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )*\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                // All flags start here\n+                unprocessed: [\n+                    $(\n+                        {\n+                            ident: $Flag,\n+                            value: $value,\n+                            attrs: {\n+                                // All attributes start here\n+                                unprocessed: [$(#[$inner $($args)*])*],\n+                                processed: {\n+                                    // Attributes that should be added to item declarations go here\n+                                    decl: [],\n+                                    // Attributes that are safe on expressions go here\n+                                    expr: [],\n+                                }\n+                            },\n+                        },\n+                    )*\n+                ],\n+                // Flags that have had their attributes sorted are pushed here\n+                processed: [],\n+            }\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `cfg`: The next flag should be propagated to expressions\n+    // NOTE: You can copy this rules block and replace `cfg` with\n+    // your attribute name that should be considered expression-safe\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            // cfg matched here\n+                            #[cfg $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    // cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    // cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `$other`: The next flag should not be propagated to expressions\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            // $other matched here\n+                            #[$other:ident $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    // $other added here\n+                                    #[$other $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    // $other not added here\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    // Complete the current flag once there are no unprocessed attributes left\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                ],\n+            }\n+        }\n+    };\n+    // Once all attributes on all flags are processed, generate the actual code\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [],\n+            processed: [\n+                $(\n+                    {\n+                        ident: $Flag:ident,\n+                        value: $value:expr,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n+                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+                            }\n+                        },\n+                    },\n+                )*\n+            ],\n+        }\n     ) => {\n         // Declared in the scope of the `bitflags!` call\n         // This type appears in the end-user's API\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -570,7 +879,7 @@ macro_rules! bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$inner $($args)*])*\n+                    $(#[$decl $($declargs)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -603,7 +912,7 @@ macro_rules! bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -613,7 +922,7 @@ macro_rules! bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -623,12 +932,7 @@ macro_rules! bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n+    }\n }\n \n #[macro_use]\n",
        "problem_statement": "Cannot use `#[doc(alias)]`\nThe following code:\r\n```rs\r\nbitflags::bitflags! {\r\n  #[doc(alias = \"SYMBOLIC_LINK_FLAGS\")]\r\n  pub struct SymbolicLinkFlags:u32 {\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n    const DIRECTORY = 0x1;\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n    const ALLOW_UNPRIVILEGED_CREATE = 0x2;\r\n  }\r\n}\r\n```\r\nProduces the error:\r\n```\r\nerror: `#[doc(alias = \"...\")]` isn't allowed on expression\r\n  --> src\\fs.rs:67:15\r\n   |\r\n67 |         #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\n",
        "hints_text": "This is a general problem for attributes that can't be applied to expressions now. In methods like `from_name` we now generate code like this:\r\n\r\n```rust\r\n#[inline]\r\npub fn from_name(name: &str) -> ::bitflags::__private::core::option::Option<Self> {\r\n    match name {\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n        \"DIRECTORY\" => ::bitflags::__private::core::option::Option::Some(Self {\r\n            bits: SymbolicLinkFlags::DIRECTORY.bits(),\r\n        }),\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n        \"ALLOW_UNPRIVILEGED_CREATE\" => {\r\n            ::bitflags::__private::core::option::Option::Some(Self {\r\n                bits: SymbolicLinkFlags::ALLOW_UNPRIVILEGED_CREATE.bits(),\r\n            })\r\n        }\r\n        _ => ::bitflags::__private::core::option::Option::None,\r\n    }\r\n}\r\n```\r\n\r\nI think the quickest fix would be to introduce a helper macro that filtered out some attributes like `#[doc(..)]` for these match arms. Any more of these that come up in the future could be added to that macro.\nWhat kinds of attributes would be useful to apply there other than `cfg`?\nI can't really think of any besides maybe `#[allow]`, but we handle those on the item itself. I think it would be fair to flip this into an allow-list so only `cfg` attributes get propagated.",
        "created_at": "2023-04-18T00:36:26Z",
        "test_patch": "diff --git /dev/null b/tests/compile-pass/doc_alias.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/doc_alias.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    #[doc(alias = \"FLAG\")]\n+    pub struct Flags: u8 {\n+        #[doc(alias = \"FLAG_A\")]\n+        const A = 1;\n+    }\n+}\n+\n+fn main() {\n+    \n+}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 355,
        "instance_id": "bitflags__bitflags-355",
        "issue_numbers": [
            "357"
        ],
        "base_commit": "31d3e4afefc964045156d7fe3622733f48511353",
        "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -81,6 +81,23 @@ jobs:\n       - name: Default features\n         run: cross test --target mips-unknown-linux-gnu\n \n+  clippy:\n+    name: Clippy\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout sources\n+        uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n+\n+      - name: Install Clippy\n+        run: |\n+          rustup update beta\n+          rustup component add clippy --toolchain beta\n+\n+      - name: Default features\n+        run: |\n+          cd ./tests/smoke-test\n+          cargo +beta clippy\n+\n   embedded:\n     name: Build (embedded)\n     runs-on: ubuntu-latest\n\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -39,7 +39,7 @@ __impl_public_bitflags_forward! {\n }\n \n __impl_public_bitflags_iter! {\n-    Flags\n+    Flags: u32, Flags\n }\n \n __impl_public_bitflags_consts! {\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -19,7 +19,7 @@ Next, define a macro like so:\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -35,7 +35,7 @@ macro_rules! __impl_external_bitflags_my_library {\n #[cfg(not(feature = \"my_library\"))]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -55,7 +55,7 @@ Now, we add our macro call to the `__impl_external_bitflags` macro body:\n \n ```rust\n __impl_external_bitflags_my_library! {\n-    $InternalBitFlags: $T {\n+    $InternalBitFlags: $T, $PublicBitFlags {\n         $(\n             $(#[$attr $($args)*])*\n             $Flag;\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -76,6 +76,51 @@ pub(crate) mod __private {\n     pub use bytemuck;\n }\n \n+/// Implements traits from external libraries for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_external_bitflags {\n+    (\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {\n+        // Any new library traits impls should be added here\n+        // Use `serde` as an example: generate code when the feature is available,\n+        // and a no-op when it isn't\n+\n+        __impl_external_bitflags_serde! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_arbitrary! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_bytemuck! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+    };\n+}\n+\n #[cfg(feature = \"serde\")]\n pub mod serde;\n \n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -85,11 +130,11 @@ pub mod serde;\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {\n         impl $crate::__private::serde::Serialize for $InternalBitFlags {\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -98,7 +143,7 @@ macro_rules! __impl_external_bitflags_serde {\n                 serializer: S,\n             ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n                 $crate::serde::serialize(\n-                    self,\n+                    &$PublicBitFlags::from_bits_retain(self.bits()),\n                     serializer,\n                 )\n             }\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -108,9 +153,11 @@ macro_rules! __impl_external_bitflags_serde {\n             fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n                 deserializer: D,\n             ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                $crate::serde::deserialize(\n+                let flags: $PublicBitFlags = $crate::serde::deserialize(\n                     deserializer,\n-                )\n+                )?;\n+\n+                Ok(flags.0)\n             }\n         }\n     };\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -121,11 +168,11 @@ macro_rules! __impl_external_bitflags_serde {\n #[cfg(not(feature = \"serde\"))]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {};\n }\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -136,58 +183,13 @@ pub mod arbitrary;\n #[cfg(feature = \"bytemuck\")]\n mod bytemuck;\n \n-/// Implements traits from external libraries for the internal bitflags type.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_external_bitflags {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {\n-        // Any new library traits impls should be added here\n-        // Use `serde` as an example: generate code when the feature is available,\n-        // and a no-op when it isn't\n-\n-        __impl_external_bitflags_serde! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_arbitrary! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_bytemuck! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-    };\n-}\n-\n /// Implement `Arbitrary` for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n #[cfg(feature = \"arbitrary\")]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n+            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n                 $(\n                     $(#[$attr:ident $($args:tt)*])*\n                     $Flag:ident;\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -198,7 +200,7 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             fn arbitrary(\n                 u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n             ) -> $crate::__private::arbitrary::Result<Self> {\n-                $crate::arbitrary::arbitrary(u)\n+                $crate::arbitrary::arbitrary::<$PublicBitFlags>(u).map(|flags| flags.0)\n             }\n         }\n     };\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -209,12 +211,12 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(not(feature = \"arbitrary\"))]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n-                $(\n-                    $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n-            }\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {};\n }\n \n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -224,11 +226,11 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(feature = \"bytemuck\")]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {\n         // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -256,11 +258,11 @@ macro_rules! __impl_external_bitflags_bytemuck {\n #[cfg(not(feature = \"bytemuck\"))]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {};\n }\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -98,7 +98,7 @@ macro_rules! __impl_internal_bitflags {\n         // The internal flags type offers a similar API to the public one\n \n         __impl_public_bitflags! {\n-            $InternalBitFlags: $T {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n                 $(\n                     $(#[$attr $($args)*])*\n                     $Flag;\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -106,19 +106,8 @@ macro_rules! __impl_internal_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_consts! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    #[allow(\n-                        dead_code,\n-                        deprecated,\n-                        unused_attributes,\n-                        non_upper_case_globals\n-                    )]\n-                    $Flag = $value;\n-                )*\n-            }\n+        __impl_public_bitflags_iter! {\n+            $InternalBitFlags: $T, $PublicBitFlags\n         }\n \n         impl $InternalBitFlags {\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -127,18 +116,6 @@ macro_rules! __impl_internal_bitflags {\n             pub fn bits_mut(&mut self) -> &mut $T {\n                 &mut self.0\n             }\n-\n-            /// Iterate over enabled flag values.\n-            #[inline]\n-            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n-                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n-\n-            /// Iterate over enabled flag values with their stringified names.\n-            #[inline]\n-            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n-                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n         }\n     };\n }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -590,7 +590,8 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             // Declared in a \"hidden\" scope that can't be reached directly\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -610,7 +611,7 @@ macro_rules! bitflags {\n \n             // This is where new library trait implementations can be added\n             __impl_external_bitflags! {\n-                InternalBitFlags: $T {\n+                InternalBitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -623,7 +624,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -657,11 +658,12 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             __impl_public_bitflags! {\n-                $BitFlags: $T {\n+                $BitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -670,7 +672,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -57,7 +57,7 @@ macro_rules! __impl_public_bitflags_forward {\n                     Self($InternalBitFlags::from_bits_retain(bits))\n                 }\n \n-                fn from_name(name){\n+                fn from_name(name) {\n                     match $InternalBitFlags::from_name(name) {\n                         $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n                         $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -130,7 +130,7 @@ macro_rules! __impl_public_bitflags_forward {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags {\n     (\n-        $PublicBitFlags:ident: $T:ty {\n+        $BitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -138,7 +138,7 @@ macro_rules! __impl_public_bitflags {\n         }\n     ) => {\n         __impl_bitflags! {\n-            $PublicBitFlags: $T {\n+            $BitFlags: $T {\n                 fn empty() {\n                     Self(<$T as $crate::Bits>::EMPTY)\n                 }\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -260,7 +260,7 @@ macro_rules! __impl_public_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_ops!($PublicBitFlags);\n+        __impl_public_bitflags_ops!($BitFlags);\n     };\n }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -268,8 +268,8 @@ macro_rules! __impl_public_bitflags {\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_iter {\n-    ($PublicBitFlags:ident) => {\n-        impl $PublicBitFlags {\n+    ($BitFlags:ident: $T:ty, $PublicBitFlags:ident) => {\n+        impl $BitFlags {\n             /// Iterate over enabled flag values.\n             #[inline]\n             pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -283,8 +283,8 @@ macro_rules! __impl_public_bitflags_iter {\n             }\n         }\n \n-        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n-            type Item = Self;\n+        impl $crate::__private::core::iter::IntoIterator for $BitFlags {\n+            type Item = $PublicBitFlags;\n             type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n \n             fn into_iter(self) -> Self::IntoIter {\n",
        "problem_statement": "Clippy warnings around \"manual implementation of an assign operation\"\nHi.\r\n\r\nI've run into a new clippy lint warnings such as the following:\r\n\r\n> manual implementation of an assign operation\r\n> for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\r\n> `#[warn(clippy::assign_op_pattern)]` on by default\r\n\r\nI'm following the example from the docs page for the use of the macro (more or less, as below). Can you enlighten me as to why this lint notification is appearing here and if there is some way to fix it? I know I can silence the warnings, it's just annoying to see it pop up whenever I run into it.\r\n\r\n```rust\r\nbitflags! {\r\n    pub struct MemoryAccess: u8 {\r\n        /// None.\r\n        const N = 1 << 0;\r\n        /// Public read.\r\n        const R = 1 << 1;\r\n        /// Public write.\r\n        const W = 1 << 2;\r\n        /// Private read.\r\n        const PR = 1 << 3;\r\n        /// Private write.\r\n        const PW = 1 << 4;\r\n        /// Execute.\r\n        const EX = 1 << 5;\r\n    }\r\n}\r\n```\r\n\r\nThanks!\n",
        "hints_text": "",
        "created_at": "2023-05-17T11:22:15Z",
        "test_patch": "diff --git a/tests/compile-fail/bitflags_custom_bits.rs b/tests/compile-fail/bitflags_custom_bits.rs\n--- a/tests/compile-fail/bitflags_custom_bits.rs\n+++ b/tests/compile-fail/bitflags_custom_bits.rs\n@@ -19,7 +19,7 @@ use std::{\n     },\n };\n \n-use bitflags::{bitflags, Bits, parser::{ParseError, FromHex}};\n+use bitflags::{bitflags, Bits, parser::{ParseError, WriteHex, ParseHex}};\n \n // Ideally we'd actually want this to work, but currently need something like `num`'s `Zero`\n // With some design work it could be made possible\n\ndiff --git a/tests/compile-fail/bitflags_custom_bits.rs b/tests/compile-fail/bitflags_custom_bits.rs\n--- a/tests/compile-fail/bitflags_custom_bits.rs\n+++ b/tests/compile-fail/bitflags_custom_bits.rs\n@@ -117,12 +117,18 @@ impl Binary for MyInt {\n     }\n }\n \n-impl FromHex for MyInt {\n-    fn from_hex(input: &str) -> Result<Self, ParseError> {\n+impl ParseHex for MyInt {\n+    fn parse_hex(input: &str) -> Result<Self, ParseError> {\n         Ok(MyInt(u8::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))?))\n     }\n }\n \n+impl WriteHex for MyInt {\n+    fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+        LowerHex::fmt(&self.0, writer)\n+    }\n+}\n+\n bitflags! {\n     struct Flags128: MyInt {\n         const A = MyInt(0b0000_0001u8);\n\ndiff --git a/tests/compile-fail/bitflags_custom_bits.stderr b/tests/compile-fail/bitflags_custom_bits.stderr\n--- a/tests/compile-fail/bitflags_custom_bits.stderr\n+++ b/tests/compile-fail/bitflags_custom_bits.stderr\n@@ -1,7 +1,7 @@\n error[E0277]: the trait bound `MyInt: bitflags::traits::Primitive` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:127:22\n+   --> tests/compile-fail/bitflags_custom_bits.rs:133:22\n     |\n-127 |     struct Flags128: MyInt {\n+133 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `bitflags::traits::Primitive` is not implemented for `MyInt`\n     |\n     = help: the following other types implement trait `bitflags::traits::Primitive`:\n\ndiff --git a/tests/compile-fail/bitflags_custom_bits.stderr b/tests/compile-fail/bitflags_custom_bits.stderr\n--- a/tests/compile-fail/bitflags_custom_bits.stderr\n+++ b/tests/compile-fail/bitflags_custom_bits.stderr\n@@ -20,442 +20,457 @@ note: required by a bound in `PublicFlags::Primitive`\n     |     type Primitive: Primitive;\n     |                     ^^^^^^^^^ required by this bound in `PublicFlags::Primitive`\n \n+error[E0308]: mismatched types\n+   --> tests/compile-fail/bitflags_custom_bits.rs:128:32\n+    |\n+127 |     fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+    |                  - this type parameter\n+128 |         LowerHex::fmt(&self.0, writer)\n+    |         -------------          ^^^^^^ expected `&mut Formatter<'_>`, found type parameter `W`\n+    |         |\n+    |         arguments to this function are incorrect\n+    |\n+    = note: expected mutable reference `&mut Formatter<'_>`\n+                  found type parameter `W`\n+note: method defined here\n+   --> $RUST/core/src/fmt/mod.rs\n+\n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt ^ MyInt`\n     |\n     = help: the trait `~const BitXor` is not implemented for `MyInt`\n note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git /dev/null b/tests/compile-pass/bitflags_self_in_value.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_self_in_value.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const SOME_FLAG = 1 << Self::SOME_FLAG_SHIFT;\n+    }\n+}\n+\n+impl Flags {\n+    const SOME_FLAG_SHIFT: u32 = 5;\n+}\n+\n+fn main() {\n+    \n+}\n\ndiff --git a/tests/smoke-test/src/main.rs b/tests/smoke-test/src/main.rs\n--- a/tests/smoke-test/src/main.rs\n+++ b/tests/smoke-test/src/main.rs\n@@ -1,3 +1,5 @@\n+#![deny(warnings)]\n+\n use bitflags::bitflags;\n \n bitflags! {\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 268,
        "instance_id": "bitflags__bitflags-268",
        "issue_numbers": [
            "267"
        ],
        "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -494,8 +494,7 @@ macro_rules! __impl_bitflags {\n                         f.write_str(\" | \")?;\n                     }\n                     first = false;\n-                    f.write_str(\"0x\")?;\n-                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n+                    $crate::_core::write!(f, \"{:#x}\", extra_bits)?;\n                 }\n                 if first {\n                     f.write_str(\"(empty)\")?;\n",
        "problem_statement": "Bug: debug pretty-printing unknown flags display 0x0x\nmain.rs\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u8 {\r\n        const TWO = 0x2;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let value = 0b11;\r\n    let flags = unsafe { Flags::from_bits_unchecked(value) };\r\n    println!(\"{:?}\", flags);\r\n    println!(\"-----------\");\r\n    println!(\"{:#?}\", flags);\r\n}\r\n```\r\nwill print the following:\r\n```sh\r\nTWO | 0x1\r\n-----------\r\nTWO | 0x0x1\r\n```\r\n\r\nthe expected output would either be 0x1 for both, or 1, and 0x1 respectively\n",
        "hints_text": "",
        "created_at": "2022-01-02T17:22:14Z",
        "test_patch": "diff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ b/tests/compile-fail/trait/custom_impl.rs\n@@ -62,4 +62,4 @@ impl BitFlags for BootlegFlags {\n     }\n }\n \n-fn main() { }\n+fn main() {}\n\ndiff --git a/tests/compile-pass/impls/convert.rs b/tests/compile-pass/impls/convert.rs\n--- a/tests/compile-pass/impls/convert.rs\n+++ b/tests/compile-pass/impls/convert.rs\n@@ -12,6 +12,4 @@ impl From<u32> for Flags {\n     }\n }\n \n-fn main() {\n-\n-}\n+fn main() {}\n\ndiff --git /dev/null b/tests/compile-pass/impls/fmt.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    struct Flags: u8 {\n+        const TWO = 0x2;\n+    }\n+}\n+\n+fn main() {\n+    // bug #267 (https://github.com/bitflags/bitflags/issues/267)\n+    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n+    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+}\n\ndiff --git a/tests/compile-pass/redefinition/stringify.rs b/tests/compile-pass/redefinition/macros.rs\n--- a/tests/compile-pass/redefinition/stringify.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -7,6 +7,11 @@ macro_rules! stringify {\n     ($($t:tt)*) => { \"...\" };\n }\n \n+#[allow(unused_macros)]\n+macro_rules! write {\n+    ($($t:tt)*) => { \"...\" };\n+}\n+\n bitflags! {\n     struct Test: u8 {\n         const A = 1;\n\ndiff --git a/tests/compile-pass/redefinition/stringify.rs b/tests/compile-pass/redefinition/macros.rs\n--- a/tests/compile-pass/redefinition/stringify.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -14,6 +19,6 @@ bitflags! {\n }\n \n fn main() {\n-    // Just make sure we don't call the redefined `stringify` macro\n-    assert_eq!(format!(\"{:?}\", Test::A), \"A\");\n+    // Just make sure we don't call the redefined `stringify` or `write` macro\n+    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 266,
        "instance_id": "bitflags__bitflags-266",
        "issue_numbers": [
            "265"
        ],
        "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -500,7 +500,7 @@ macro_rules! __impl_bitflags {\n                 if first {\n                     f.write_str(\"(empty)\")?;\n                 }\n-                Ok(())\n+                $crate::_core::fmt::Result::Ok(())\n             }\n         }\n         impl $crate::_core::fmt::Binary for $BitFlags {\n",
        "problem_statement": "The bitflags macro is not sanitary wrt. standard library types and enumerations\nThe `bitflags` macro, expanded in the prescence of a definition of the type/value `Ok` errors.\r\nReproduction code:\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3fda3e36c7c6a57e0f7a83c84e56df20\r\n\r\nInterestingly, the relevant function, the `fmt` function from the Debug impl, does use `::bitflags::_core::fmt::Result`, however, it merely returns the value `Ok(())`. \n",
        "hints_text": "",
        "created_at": "2021-12-16T09:38:14Z",
        "test_patch": "diff --git /dev/null b/tests/compile-pass/redefinition/result.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/redefinition/result.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+// Checks for possible errors caused by overriding names used by `bitflags!` internally.\n+\n+// bug #265 (https://github.com/bitflags/bitflags/issues/265)\n+\n+pub struct Ok<T>(T);\n+\n+bitflags! {\n+    pub struct Flags: u16{\n+        const FOO = 0x0001;\n+    }\n+}\n+\n+fn main() {}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 380,
        "instance_id": "bitflags__bitflags-380",
        "issue_numbers": [
            "378"
        ],
        "base_commit": "472e392c0d082c0894b18fb31f4e68e0b145e29c",
        "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -84,18 +84,19 @@ jobs:\n           cd ./tests/smoke-test\n           cargo +$msrv build\n \n-  mips:\n-    name: Tests / MIPS (Big Endian)\n+  miri:\n+    name: \"Miri\"\n     runs-on: ubuntu-latest\n     steps:\n-      - name: Checkout sources\n-        uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n-\n-      - name: Install Cross\n-        run: cargo install cross\n-\n+      - uses: actions/checkout@v3\n+      - name: Install Miri\n+        run: |\n+          rustup toolchain install nightly --component miri\n+          cargo +nightly miri setup\n       - name: Default features\n-        run: cross test --target mips-unknown-linux-gnu\n+        run: cargo +nightly miri test\n+      - name: BE\n+        run: cargo +nightly miri test --target s390x-unknown-linux-gnu\n \n   clippy:\n     name: Clippy\n\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -46,11 +46,17 @@ use bitflags::bitflags;\n \n // The `bitflags!` macro generates `struct`s that manage a set of flags.\n bitflags! {\n+    /// Represents a set of flags.\n     #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     struct Flags: u32 {\n+        /// The value `A`, at bit position `0`.\n         const A = 0b00000001;\n+        /// The value `B`, at bit position `1`.\n         const B = 0b00000010;\n+        /// The value `C`, at bit position `2`.\n         const C = 0b00000100;\n+\n+        /// The combination of `A`, `B`, and `C`.\n         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -481,7 +481,8 @@ macro_rules! bitflags {\n             non_upper_case_globals,\n             clippy::assign_op_pattern,\n             clippy::indexing_slicing,\n-            clippy::same_name_method\n+            clippy::same_name_method,\n+            clippy::iter_without_into_iter,\n         )]\n         const _: () = {\n             // Declared in a \"hidden\" scope that can't be reached directly\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -553,7 +554,8 @@ macro_rules! bitflags {\n             unused_mut,\n             unused_imports,\n             non_upper_case_globals,\n-            clippy::assign_op_pattern\n+            clippy::assign_op_pattern,\n+            clippy::iter_without_into_iter,\n         )]\n         const _: () = {\n             __impl_public_bitflags! {\n",
        "problem_statement": "Documenting bitflags: how to get documentation for the generated bitflags\nSome code that I'm writing uses the `#![warn(missing_docs)]` macro to enforce a requirement that all public interfaces have documentation. I haven't been able to figure out how to generate documentation when using the `bitflags!` macro; I also haven't been able to turn off the linter warning using `#![allow(missing_docs)]`.\r\n\r\nIs there a convenient way to add doc comments to a set of flags?\r\n* If so, is there an example somewhere that I can reference? This would be a great thing to include in bitflags documentation.\r\n* If not, then take this as a feature request!\n",
        "hints_text": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=530756068e54aa56eb519dd66c9fdfc5\r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f782c74e49e8c4c4ae940125265eb7ed\nThanks @rusty-snake! Those would actually make some great compile-pass tests \ud83e\udd14",
        "created_at": "2023-10-09T04:48:32Z",
        "test_patch": "diff --git a/src/tests/iter.rs b/src/tests/iter.rs\n--- a/src/tests/iter.rs\n+++ b/src/tests/iter.rs\n@@ -3,6 +3,7 @@ use super::*;\n use crate::Flags;\n \n #[test]\n+#[cfg(not(miri))] // Very slow in miri\n fn roundtrip() {\n     for a in 0u8..=255 {\n         for b in 0u8..=255 {\n\ndiff --git a/src/tests/parser.rs b/src/tests/parser.rs\n--- a/src/tests/parser.rs\n+++ b/src/tests/parser.rs\n@@ -6,6 +6,7 @@ use crate::{\n };\n \n #[test]\n+#[cfg(not(miri))] // Very slow in miri\n fn roundtrip() {\n     let mut s = String::new();\n \n\ndiff --git a/tests/compile-pass/item_positions.rs b/tests/compile-pass/item_positions.rs\n--- a/tests/compile-pass/item_positions.rs\n+++ b/tests/compile-pass/item_positions.rs\n@@ -1,3 +1,5 @@\n+#![allow(clippy::let_unit_value)]\n+\n #[macro_use]\n extern crate bitflags;\n \n\ndiff --git /dev/null b/tests/compile-pass/missing_docs.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/missing_docs.rs\n@@ -0,0 +1,19 @@\n+/*!\n+Crate-level doc\n+*/\n+\n+#![deny(missing_docs)]\n+\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[allow(missing_docs)]\n+    pub struct MyFlags: u32 {\n+        #[allow(missing_docs)]\n+        const A = 1;\n+        #[allow(missing_docs)]\n+        const B = 2;\n+    }\n+}\n+\n+fn main() {}\n\ndiff --git a/tests/compile.rs b/tests/compile.rs\n--- a/tests/compile.rs\n+++ b/tests/compile.rs\n@@ -2,6 +2,7 @@\n // an impossible build between error messages emitted on various channels.\n // Since https://github.com/dtolnay/trybuild/pull/170 we always need to have a\n // `stderr` file for each test so we can't simply ignore the output on different channels.\n+#[cfg(not(miri))]\n #[rustversion::attr(beta, test)]\n #[allow(dead_code)]\n fn fail() {\n\ndiff --git a/tests/compile.rs b/tests/compile.rs\n--- a/tests/compile.rs\n+++ b/tests/compile.rs\n@@ -9,6 +10,7 @@ fn fail() {\n     t.compile_fail(\"tests/compile-fail/**/*.rs\");\n }\n \n+#[cfg(not(miri))]\n #[test]\n fn pass() {\n     let t = trybuild::TestCases::new();\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 225,
        "instance_id": "bitflags__bitflags-225",
        "issue_numbers": [
            "179"
        ],
        "base_commit": "bd24f9d8d266bfb2dfe4b8238b196ecf5e37dee1",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -360,7 +360,7 @@ macro_rules! bitflags {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\n                 const $Flag:ident = $value:expr;\n-            )+\n+            )*\n         }\n         $($t:tt)*\n     ) => {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -370,7 +370,7 @@ macro_rules! bitflags {\n                 $(\n                     $(#[$inner $($args)*])*\n                     $Flag = $value;\n-                )+\n+                )*\n             }\n         }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -414,7 +414,7 @@ macro_rules! __bitflags {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\n-            )+\n+            )*\n         }\n     ) => {\n         $(#[$outer])*\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -428,7 +428,7 @@ macro_rules! __bitflags {\n                 $(\n                     $(#[$inner $($args)*])*\n                     $Flag = $value;\n-                )+\n+                )*\n             }\n         }\n     };\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -490,7 +490,7 @@ macro_rules! __fn_bitflags {\n \n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_bitflags {\n+macro_rules! __all_bitflags {\n     (\n         $BitFlags:ident: $T:ty {\n             $(\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -498,6 +498,55 @@ macro_rules! __impl_bitflags {\n                 $Flag:ident = $value:expr;\n             )+\n         }\n+    ) => {\n+        __fn_bitflags! {\n+            /// Returns the set containing all flags.\n+            #[inline]\n+            pub const fn all() -> $BitFlags {\n+                // See `Debug::fmt` for why this approach is taken.\n+                #[allow(non_snake_case)]\n+                trait __BitFlags {\n+                    $(\n+                        const $Flag: $T = 0;\n+                    )+\n+                }\n+                impl __BitFlags for $BitFlags {\n+                    $(\n+                        __impl_bitflags! {\n+                            #[allow(deprecated)]\n+                            $(? #[$attr $($args)*])*\n+                            const $Flag: $T = Self::$Flag.bits;\n+                        }\n+                    )+\n+                }\n+                $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag)|+ }\n+            }\n+        }\n+    };\n+    (\n+        $BitFlags:ident: $T:ty {\n+        }\n+    ) => {\n+        __fn_bitflags! {\n+            /// Returns the set containing all flags.\n+            #[inline]\n+            pub const fn all() -> $BitFlags {\n+                $BitFlags { bits: 0 }\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_bitflags {\n+    (\n+        $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident = $value:expr;\n+            )*\n+        }\n     ) => {\n         impl $crate::_core::fmt::Debug for $BitFlags {\n             fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -514,7 +563,7 @@ macro_rules! __impl_bitflags {\n                     $(\n                         #[inline]\n                         fn $Flag(&self) -> bool { false }\n-                    )+\n+                    )*\n                 }\n \n                 // Conditionally override the check for just those flags that\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -533,7 +582,7 @@ macro_rules! __impl_bitflags {\n                                 }\n                             }\n                         }\n-                    )+\n+                    )*\n                 }\n \n                 let mut first = true;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -545,7 +594,7 @@ macro_rules! __impl_bitflags {\n                         first = false;\n                         f.write_str(__bitflags_stringify!($Flag))?;\n                     }\n-                )+\n+                )*\n                 let extra_bits = self.bits & !$BitFlags::all().bits();\n                 if extra_bits != 0 {\n                     if !first {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -587,7 +636,7 @@ macro_rules! __impl_bitflags {\n             $(\n                 $(#[$attr $($args)*])*\n                 pub const $Flag: $BitFlags = $BitFlags { bits: $value };\n-            )+\n+            )*\n \n             __fn_bitflags! {\n                 /// Returns an empty set of flags.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -597,29 +646,14 @@ macro_rules! __impl_bitflags {\n                 }\n             }\n \n-            __fn_bitflags! {\n-                /// Returns the set containing all flags.\n-                #[inline]\n-                pub const fn all() -> $BitFlags {\n-                    // See `Debug::fmt` for why this approach is taken.\n-                    #[allow(non_snake_case)]\n-                    trait __BitFlags {\n-                        $(\n-                            const $Flag: $T = 0;\n-                        )+\n-                    }\n-                    impl __BitFlags for $BitFlags {\n+                __all_bitflags! {\n+                    $BitFlags: $T {\n                         $(\n-                            __impl_bitflags! {\n-                                #[allow(deprecated)]\n-                                $(? #[$attr $($args)*])*\n-                                const $Flag: $T = Self::$Flag.bits;\n-                            }\n-                        )+\n+                            $(#[$attr $($args)*])*\n+                            $Flag = $value;\n+                        )*\n                     }\n-                    $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag)|+ }\n                 }\n-            }\n \n             __fn_bitflags! {\n                 /// Returns the raw value of the flags currently stored.\n",
        "problem_statement": "Empty bitflags definitions fail to parse\nThis doesn't parse:\r\n\r\n```rust\r\nbitflags::bitflags! {\r\n    pub struct BoxFlags: u8 {\r\n    }\r\n}\r\n```\n",
        "hints_text": "Hmm, it looks like we're using `+` rather than `*` as the repetition control. I can't imagine an empty set of `bitflags` would be very useful. Do you have a case where you've run into this?\nIt might useful when introducing the type and designing the API first, before you even actually add the various bitflags\nYeh that seems fair. If there\u2019s no reason to require bitflags have at least one item then we could probably just allow these to be written.\n> It might useful when introducing the type and designing the API first, before you even actually add the various bitflags\r\n\r\nYeah I was doing that, just propagating some flag value which I know I will need but didn't know yet what the flags themselves will be.\nYou can just put something like this in there:\r\n```rust\r\n#[cfg(empty_bitflag_workaround)]\r\nconst EMPTY_BITFLAG_WORKAROUND = 0;\r\n```",
        "created_at": "2020-10-01T16:10:42Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -992,6 +1026,11 @@ mod tests {\n         }\n     }\n \n+    bitflags! {\n+        struct EmptyFlags: u32 {\n+        }\n+    }\n+\n     #[test]\n     fn test_bits() {\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1000,6 +1039,8 @@ mod tests {\n \n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n         assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n+\n+        assert_eq!(EmptyFlags::empty().bits(), 0b00000000);\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1014,6 +1055,9 @@ mod tests {\n             AnotherSetOfFlags::from_bits(!0_i8),\n             Some(AnotherSetOfFlags::ANOTHER_FLAG)\n         );\n+\n+        assert_eq!(EmptyFlags::from_bits(0), Some(EmptyFlags::empty()));\n+        assert_eq!(EmptyFlags::from_bits(0b1), None);\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1029,6 +1073,9 @@ mod tests {\n             AnotherSetOfFlags::from_bits_truncate(0_i8),\n             AnotherSetOfFlags::empty()\n         );\n+\n+        assert_eq!(EmptyFlags::from_bits_truncate(0), EmptyFlags::empty());\n+        assert_eq!(EmptyFlags::from_bits_truncate(0b1), EmptyFlags::empty());\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1037,6 +1084,7 @@ mod tests {\n         assert_eq!(unsafe { Flags::from_bits_unchecked(0) }, Flags::empty());\n         assert_eq!(unsafe { Flags::from_bits_unchecked(0b1) }, Flags::A);\n         assert_eq!(unsafe { Flags::from_bits_unchecked(0b10) }, Flags::B);\n+\n         assert_eq!(\n             unsafe { Flags::from_bits_unchecked(0b11) },\n             (Flags::A | Flags::B)\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1049,6 +1097,12 @@ mod tests {\n             unsafe { Flags::from_bits_unchecked(0b1001) },\n             (extra | Flags::A)\n         );\n+      \n+        let extra = unsafe { EmptyFlags::from_bits_unchecked(0b1000) };\n+        assert_eq!(\n+          unsafe { EmptyFlags::from_bits_unchecked(0b1000) },\n+          (extra | EmptyFlags::empty())\n+      );\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1058,6 +1112,9 @@ mod tests {\n         assert!(!Flags::ABC.is_empty());\n \n         assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n+\n+        assert!(EmptyFlags::empty().is_empty());\n+        assert!(EmptyFlags::all().is_empty());\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1067,6 +1124,9 @@ mod tests {\n         assert!(Flags::ABC.is_all());\n \n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n+\n+        assert!(EmptyFlags::all().is_all());\n+        assert!(EmptyFlags::empty().is_all());\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1108,6 +1168,8 @@ mod tests {\n         assert!(Flags::ABC.contains(e2));\n \n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n+\n+        assert!(EmptyFlags::empty().contains(EmptyFlags::empty()));\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1293,10 +1355,16 @@ mod tests {\n         let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n         assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n         assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n+\n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n             \"A | B | C | ABC | 0xb8\"\n         );\n+\n+        assert_eq!(\n+          format!(\"{:?}\", EmptyFlags::empty()),\n+          \"(empty)\"\n+      );\n     }\n \n     #[test]\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 276,
        "instance_id": "bitflags__bitflags-276",
        "issue_numbers": [
            "275"
        ],
        "base_commit": "0141a07e55184304857384b0093d00959f0acfa6",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -559,10 +559,11 @@ macro_rules! __impl_bitflags {\n             /// representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n-                if (bits & !Self::all().bits()) == 0 {\n-                    $crate::_core::option::Option::Some(Self { bits })\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+                if truncated == bits {\n+                    Some(Self{ bits })\n                 } else {\n-                    $crate::_core::option::Option::None\n+                    None\n                 }\n             }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -570,7 +571,22 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                Self { bits: bits & Self::all().bits }\n+                if bits == 0 {\n+                    return Self{ bits }\n+                }\n+\n+                #[allow(unused_mut)]\n+                let mut truncated = 0;\n+\n+                $(\n+                    #[allow(unused_doc_comments, unused_attributes)]\n+                    $(#[$attr $($args)*])*\n+                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n+                        truncated |= Self::$Flag.bits\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n             }\n \n             /// Convert from underlying bit representation, preserving all\n",
        "problem_statement": "from_bits accepts non existing flags\n```rs\r\n    #[test]\r\n    fn test_from_bits_edge_cases() {\r\n        bitflags! {\r\n            struct Flags: u8 {\r\n                const A = 0b00000001;\r\n                const BC = 0b00000110;\r\n            }\r\n        }\r\n\r\n\r\n        let flags = Flags::from_bits(0b00000100);\r\n        assert!(flags.is_none());\r\n    }\r\n```\r\n\r\nUnless I'm missing something this test should pass but it fails cause from_bits accepts flags that are not declared. \r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6fd4adbddc8b8740cbd35af2306073ca\r\n\r\nThis is related to this issue in the implementation of iterators in this PR https://github.com/bitflags/bitflags/pull/204#issuecomment-950304444 Using `from_bits` instead of `from_bits_unchecked` should allow to produce any valid flags that are not a combination of other flags but at the moment `from_bits` seems to accept any flag that is included in a combination even if it's not declared. I can try to send a PR. \n",
        "hints_text": "",
        "created_at": "2022-04-19T09:54:30Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1891,6 +1907,37 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_from_bits_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+\n+        let flags = Flags::from_bits(0b00000100);\n+        assert_eq!(flags, None);\n+        let flags = Flags::from_bits(0b00000101);\n+        assert_eq!(flags, None);\n+    }\n+\n+    #[test]\n+    fn test_from_bits_truncate_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+        let flags = Flags::from_bits_truncate(0b00000100);\n+        assert_eq!(flags, Flags::empty());\n+        let flags = Flags::from_bits_truncate(0b00000101);\n+        assert_eq!(flags, Flags::A);\n+    }\n+  \n     #[test]\n     fn test_iter() {\n         bitflags! {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1924,22 +1971,4 @@ mod tests {\n         assert_eq!(iter.next().unwrap(), Flags::THREE);\n         assert_eq!(iter.next(), None);\n     }\n-\n-    #[test]\n-    fn test_iter_edge_cases() {\n-        bitflags! {\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-\n-        let flags = Flags::all();\n-        assert_eq!(flags.iter().count(), 2);\n-        let mut iter = flags.iter();\n-        assert_eq!(iter.next().unwrap(), Flags::A);\n-        assert_eq!(iter.next().unwrap(), Flags::BC);\n-        assert_eq!(iter.next(), None);\n-    }\n }\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr.beta b/tests/compile-fail/non_integer_base/all_defined.stderr.beta\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr.beta\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr.beta\n@@ -49,8 +49,41 @@ error[E0308]: mismatched types\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: try wrapping the expression in `MyInt`\n     |\n-562 |                 if (bits & !Self::all().bits()) == MyInt(0) {\n-    |                                                    ++++++ +\n+574 |                 if bits == MyInt(0) {\n+    |                            ++++++ +\n+\n+error[E0277]: no implementation for `{integer} |= MyInt`\n+   --> $DIR/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `{integer} |= MyInt`\n+    |\n+    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+   --> $DIR/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ expected struct `MyInt`, found integer\n+    |\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: try wrapping the expression in `MyInt`\n+    |\n+589 |                 Self { bits: MyInt(truncated) }\n+    |                              ++++++         +\n \n error[E0308]: mismatched types\n    --> $DIR/all_defined.rs:115:1\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 186,
        "instance_id": "bitflags__bitflags-186",
        "issue_numbers": [
            "185"
        ],
        "base_commit": "8a10bdc144bb2a4b97c63cfa76be90228954d029",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -919,12 +919,12 @@ mod tests {\n \n     bitflags! {\n         struct _CfgFlags: u32 {\n-            #[cfg(windows)]\n-            const _CFG_A = 0b01;\n             #[cfg(unix)]\n-            const _CFG_B = 0b01;\n+            const _CFG_A = 0b01;\n             #[cfg(windows)]\n-            const _CFG_C = _CFG_A.bits | 0b10;\n+            const _CFG_B = 0b01;\n+            #[cfg(unix)]\n+            const _CFG_C = Self::_CFG_A.bits | 0b10;\n         }\n     }\n \n",
        "problem_statement": "`cargo build --test` fails on Windows\n[One of the tests](https://github.com/bitflags/bitflags/blob/8a10bdc144bb2a4b97c63cfa76be90228954d029/src/lib.rs#L920) for `bitflags-1.1.0` fails to compile on Windows with a stable rustc (version 1.36.0).\r\n\r\n```\r\n[INFO] [stderr] error[E0425]: cannot find value `_CFG_A` in this scope\r\n[INFO] [stderr]    --> src\\lib.rs:927:28\r\n[INFO] [stderr]     |\r\n[INFO] [stderr] 927 |             const _CFG_C = _CFG_A.bits | 0b10;\r\n[INFO] [stderr]     |                            ^^^^^^ not found in this scope\r\n[INFO] [stderr] \r\n[INFO] [stderr] error: aborting due to previous error\r\n```\r\n\r\nThis suggests that `#[cfg]` attributes are not being properly added to `const` declarations, but I'm not quite sure exactly what's going on here.\n",
        "hints_text": "Thanks for the report @ecstatic-morse! I'm not in front of my Windows box right now, but will look into this when I am, unless somebody else checks it first.\nI would guess that swapping `#[cfg(unix)]` and `#[cfg(windows)]` in that test will result in a failure on *nix. Btw, this arose while testing out `crater` runs on Windows.\nI'm guessing this test was a holdover from before `bitflags` used associated consts? Should be `Self::_CFG_A`. This test should probably just be rewritten though.",
        "created_at": "2019-07-20T12:27:25Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1111,7 +1111,7 @@ mod tests {\n     #[cfg(bitflags_const_fn)]\n     #[test]\n     fn test_const_fn() {\n-        const M1: Flags = Flags::empty();\n+        const _M1: Flags = Flags::empty();\n \n         const M2: Flags = Flags::A;\n         assert_eq!(M2, Flags::A);\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 157,
        "instance_id": "bitflags__bitflags-157",
        "issue_numbers": [
            "151"
        ],
        "base_commit": "74aa397b0e6899c8b5131da34351e7d87d247038",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -215,6 +215,36 @@\n //!     assert_eq!(implemented_default, (Flags::A | Flags::C));\n //! }\n //! ```\n+//!\n+//! # Zero Flags\n+//!\n+//! Flags with a value equal to zero will have some strange behavior that one should be aware of.\n+//!\n+//! ```\n+//! #[macro_use]\n+//! extern crate bitflags;\n+//!\n+//! bitflags! {\n+//!     struct Flags: u32 {\n+//!         const NONE = 0b00000000;\n+//!         const SOME = 0b00000001;\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     let empty = Flags::empty();\n+//!     let none = Flags::NONE;\n+//!     let some = Flags::SOME;\n+//!\n+//!     // Zero flags are treated as always present\n+//!     assert!(empty.contains(Flags::NONE));\n+//!     assert!(none.contains(Flags::NONE));\n+//!     assert!(some.contains(Flags::NONE));\n+//!\n+//!     // Zero flags will be ignored when testing for emptiness\n+//!     assert!(none.is_empty());\n+//! }\n+//! ```\n \n #![no_std]\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -424,7 +454,11 @@ macro_rules! __impl_bitflags {\n                             #[inline]\n                             $(? #[$attr $($args)*])*\n                             fn $Flag(&self) -> bool {\n-                                self.bits & Self::$Flag.bits == Self::$Flag.bits\n+                                if Self::$Flag.bits == 0 && self.bits != 0 {\n+                                    false\n+                                } else {\n+                                    self.bits & Self::$Flag.bits == Self::$Flag.bits\n+                                }\n                             }\n                         }\n                     )+\n",
        "problem_statement": "Bitflags values of zero are considered always present\nWhen a bitflag is built with a zero valued item then it is treated as always present by bitflags functions.\r\n\r\nThis may cause bugs but it definitely causes confusion when printing such a value. See the following for an example:\r\n```\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u32 {\r\n        const NONE = 0b0;\r\n        const SOME = 0b1;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let none = Flags::NONE;\r\n    let some = Flags::SOME;\r\n    \r\n    println!(\"NONE = {:?}\", none);\r\n    println!(\"SOME = {:?}\", some);\r\n    assert!(some.contains(Flags::NONE));\r\n}\r\n```\r\nResults in an output of:\r\n```\r\nNONE = NONE\r\nSOME = NONE | SOME\r\n```\r\n\r\nI noticed this when printing some flags from git2, specifically [MergeAnalysis](https://docs.rs/git2/0.7.1/git2/struct.MergeAnalysis.html). The output of a `format(\"{:?}\", flag)` ended up being \"(ANALYSIS_NONE | ANALYSIS_NORMAL | ANALYSIS_FASTFORWARD)\" which confused me greatly. ANALYSIS_NONE is zero as that is how it is defined in [git2](https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L320)\r\n\r\nIt seems to me that way that flag is intended to be used is that NONE only shows up when there are no other things to set, or maybe as a placeholder and should only appear when nothing else is set.\n",
        "hints_text": "I agree, a zero value should only show up in Debug output if no bits are set. Would you be interested in sending a PR to fix this?\nI would definitely be interested in doing so, where should I start?\nThe Debug impls are constructed [here](https://github.com/rust-lang-nursery/bitflags/blob/1.0.2/src/lib.rs#L401).\nAfter looking some more at the code I think this is more involved than I thought. With the code considering empty flags as always present I think that changing just the debug output will make for bugs that are even more difficult to track down.\r\n\r\nFor example `some.contains(Flags::NONE)` is always true in my example above, but if we remove it from the debug it will be more difficult to realise this is happening. At least `none.is_empty()` behaves correctly.\r\n\r\nIn any case, I am happy to add this special case if I can also add to the documentation an explanation of zero flags.",
        "created_at": "2018-04-30T12:18:19Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1157,4 +1191,22 @@ mod tests {\n \n         assert_eq!(module::value(), 1)\n     }\n+\n+    #[test]\n+    fn test_zero_value_flags() {\n+        bitflags! {\n+            struct Flags: u32 {\n+                const NONE = 0b0;\n+                const SOME = 0b1;\n+            }\n+        }\n+        \n+\n+        assert!(Flags::empty().contains(Flags::NONE));\n+        assert!(Flags::SOME.contains(Flags::NONE));\n+        assert!(Flags::NONE.is_empty());\n+\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"NONE\");\n+        assert_eq!(format!(\"{:?}\", Flags::SOME), \"SOME\");\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 135,
        "instance_id": "bitflags__bitflags-135",
        "issue_numbers": [
            "72"
        ],
        "base_commit": "8e163c64ec3ce242a9fef0347c73a82f5ea84b90",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -336,6 +336,25 @@ macro_rules! bitflags {\n             }\n         }\n     };\n+    (\n+        $(#[$outer:meta])*\n+        pub ($($vis:tt)+) struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )+\n+        }\n+    ) => {\n+        __bitflags! {\n+            $(#[$outer])*\n+            (pub ($($vis)+)) $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    $Flag = $value;\n+                )+\n+            }\n+        }\n+    };\n }\n \n #[macro_export]\n",
        "problem_statement": "pub(restricted) bitflags\ncc https://github.com/rust-lang/rust/issues/32409 - maybe no action is warranted until this feature is stable.\r\n\r\n```rust\r\nbitflags! {\r\n    pub(super) flags Flags: u8 {\r\n        const A = 1\r\n    }\r\n}\r\n```\n",
        "hints_text": "pub(restricted) is now stable. But I think it is still blocked by `:vis` matcher (rust-lang/rust#41022) to allow a proper fix.\r\n\r\n----\r\n\r\nCurrently the straightforward fix using `:vis` causes an error in `example_generated.rs`\r\n\r\n```rust\r\nerror: local ambiguity: multiple parsing options: built-in NTs vis ('vis') or 1 other option.\r\n  --> src/example_generated.rs:5:5\r\n   |\r\n4  | / bitflags! {\r\n5  | |     /// This is the same `Flags` struct defined in the [crate level example](../index.html#example).\r\n   | |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n6  | |     /// Note that this struct is just for documentation purposes only, it must not be used outside\r\n7  | |     /// this crate.\r\n...  |\r\n15 | |     }\r\n16 | | }\r\n   | |_- in this macro invocation\r\n\r\nerror: Could not compile `bitflags`.\r\n```\r\n\r\n<details><summary>(diff)</summary>\r\n\r\n```diff\r\ndiff --git a/src/lib.rs b/src/lib.rs\r\nindex 1694837..356fba1 100644\r\n--- a/src/lib.rs\r\n+++ b/src/lib.rs\r\n@@ -8,6 +8,8 @@\r\n // option. This file may not be copied, modified, or distributed\r\n // except according to those terms.\r\n \r\n+#![feature(macro_vis_matcher)]\r\n+\r\n //! A typesafe bitmask flag generator useful for sets of C-style bitmask flags.\r\n //! It can be used for creating typesafe wrappers around C APIs.\r\n //!\r\n@@ -305,16 +307,16 @@ pub extern crate core as _core;\r\n /// ```\r\n #[macro_export]\r\n macro_rules! bitflags {\r\n-    ($(#[$attr:meta])* pub struct $BitFlags:ident: $T:ty {\r\n+    ($(#[$attr:meta])* $vis:vis struct $BitFlags:ident: $T:ty {\r\n         $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr;)+\r\n     }) => {\r\n         #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\r\n         $(#[$attr])*\r\n-        pub struct $BitFlags {\r\n+        $vis struct $BitFlags {\r\n             bits: $T,\r\n         }\r\n \r\n-        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\r\n+        $($(#[$Flag_attr])* $vis const $Flag: $BitFlags = $BitFlags { bits: $value };)+\r\n \r\n         __impl_bitflags! {\r\n             struct $BitFlags: $T {\r\n@@ -322,24 +324,6 @@ macro_rules! bitflags {\r\n             }\r\n         }\r\n     };\r\n-    ($(#[$attr:meta])* struct $BitFlags:ident: $T:ty {\r\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr;)+\r\n-    }) => {\r\n-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\r\n-        $(#[$attr])*\r\n-        struct $BitFlags {\r\n-            bits: $T,\r\n-        }\r\n-\r\n-        $($(#[$Flag_attr])* const $Flag: $BitFlags = $BitFlags { bits: $value };)+\r\n-\r\n-        __impl_bitflags! {\r\n-            struct $BitFlags: $T {\r\n-                $($(#[$Flag_attr])* const $Flag = $value;)+\r\n-            }\r\n-        }\r\n-\r\n-    };\r\n }\r\n```\r\n\r\n</details>\r\n\nIt looks like using `:vis` here is unblocked now, right?",
        "created_at": "2017-11-08T05:38:51Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1092,4 +1111,46 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn test_pub_crate() {\n+        mod module {\n+            bitflags! {\n+                pub (crate) struct Test: u8 {\n+                    const FOO = 1;\n+                }\n+            }\n+        }\n+\n+        assert_eq!(module::Test::FOO.bits(), 1);\n+    }\n+\n+    #[test]\n+    fn test_pub_in_module() {\n+        mod module {\n+            mod submodule {\n+                bitflags! {\n+                    // `pub (in super)` means only the module `module` will\n+                    // be able to access this.\n+                    pub (in super) struct Test: u8 {\n+                        const FOO = 1;\n+                    }\n+                }\n+            }\n+\n+            mod test {\n+                // Note: due to `pub (in super)`,\n+                // this cannot be accessed directly by the testing code.\n+                pub (in super) fn value() -> u8 {\n+                    super::submodule::Test::FOO.bits()\n+                }\n+            }\n+\n+            pub fn value() -> u8 {\n+                test::value()\n+            }\n+        }\n+\n+        assert_eq!(module::value(), 1)\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 345,
        "instance_id": "bitflags__bitflags-345",
        "issue_numbers": [
            "344"
        ],
        "base_commit": "cbcafa710fc31172511e62efa06ad9eb214e4734",
        "patch": "diff --git a/src/example_generated.rs b/src/example_generated.rs\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -33,8 +33,17 @@ __impl_public_bitflags! {\n \n __impl_public_bitflags_consts! {\n     Flags {\n+        /// Field `A`.\n+        ///\n+        /// This flag has the value `0b00000001`.\n         A = 0b00000001;\n+        /// Field `B`.\n+        ///\n+        /// This flag has the value `0b00000010`.\n         B = 0b00000010;\n+        /// Field `C`.\n+        ///\n+        /// This flag has the value `0b00000100`.\n         C = 0b00000100;\n         ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -224,10 +224,14 @@ macro_rules! __impl_internal_bitflags {\n                 let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n-                        truncated |= $BitFlags::$Flag.bits()\n-                    }\n+                    __expr_safe_flags!(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n+                                truncated |= $BitFlags::$Flag.bits()\n+                            }\n+                        }\n+                    );\n                 )*\n \n                 Self { bits: truncated }\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -240,13 +244,19 @@ macro_rules! __impl_internal_bitflags {\n \n             #[inline]\n             pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n-                match name {\n-                    $(\n+                $(\n+                    __expr_safe_flags!(\n                         $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag) => $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() }),\n-                    )*\n-                    _ => $crate::__private::core::option::Option::None,\n-                }\n+                        {\n+                            if name == $crate::__private::core::stringify!($Flag) {\n+                                return $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() });\n+                            }\n+                        }\n+                    );\n+                )*\n+\n+                let _ = name;\n+                $crate::__private::core::option::Option::None\n             }\n \n             #[inline]\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -384,10 +394,12 @@ macro_rules! __impl_internal_bitflags {\n                     let mut num_flags = 0;\n \n                     $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                { num_flags += 1; }\n+                            }\n+                        );\n                     )*\n \n                     num_flags\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -395,15 +407,23 @@ macro_rules! __impl_internal_bitflags {\n \n                 const OPTIONS: [$T; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag.bits(),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $BitFlags::$Flag.bits()\n+                            }\n+                        ),\n                     )*\n                 ];\n \n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $crate::__private::core::stringify!($Flag)\n+                            }\n+                        ),\n                     )*\n                 ];\n \n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -439,3 +459,112 @@ macro_rules! __impl_internal_bitflags {\n         }\n     };\n }\n+\n+/// A macro that processed the input to `bitflags!` and shuffles attributes around\n+/// based on whether or not they're \"expression-safe\".\n+///\n+/// This macro is a token-tree muncher that works on 2 levels:\n+///\n+/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+/// whether or not it should be considered expression-safe.\n+///\n+/// If you find yourself with an attribute that should be considered expression-safe\n+/// and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __expr_safe_flags {\n+    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    // where they'll be munched one-at-a-time\n+    (\n+        $(#[$inner:ident $($args:tt)*])*\n+        { $e:expr }\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                // All attributes start here\n+                unprocessed: [$(#[$inner $($args)*])*],\n+                processed: {\n+                    // Attributes that are safe on expressions go here\n+                    expr: [],\n+                },\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `cfg`: The next flag should be propagated to expressions\n+    // NOTE: You can copy this rules block and replace `cfg` with\n+    // your attribute name that should be considered expression-safe\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // cfg matched here\n+                #[cfg $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        $($expr)*\n+                        // cfg added here\n+                        #[cfg $($args)*]\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `$other`: The next flag should not be propagated to expressions\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // $other matched here\n+                #[$other:ident $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+                attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        // $other not added here\n+                        $($expr)*\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    // Once all attributes on all flags are processed, generate the actual code\n+    (\n+        expr: { $e:expr },\n+        attrs: {\n+            unprocessed: [],\n+            processed: {\n+                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+            },\n+        },\n+    ) => {\n+        $(#[$expr $($exprargs)*])*\n+        { $e }\n+    }\n+}\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -558,315 +558,6 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n-    ) => {\n-        __declare_bitflags!(\n-            $(#[$outer])*\n-            $vis struct $BitFlags: $T {\n-                $(\n-                    $(#[$inner $($args)*])*\n-                    const $Flag = $value;\n-                )*\n-            }\n-        );\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n-}\n-\n-/// A macro that processed the input to `bitflags!` and shuffles attributes around\n-/// based on whether or not they're \"expression-safe\".\n-///\n-/// This macro is a token-tree muncher that works on 2 levels:\n-///\n-/// 1. Each flag, like `#[cfg(true)] const A: 42`\n-/// 2. Each attribute on that flag, like `#[cfg(true)]`\n-///\n-/// Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n-/// at a time into an appropriate processed list until the unprocessed lists are empty.\n-///\n-/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n-/// whether or not it should be considered expression-safe.\n-///\n-/// If you find yourself with an attribute that should be considered expression-safe\n-/// and isn't, it can be added here.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __declare_bitflags {\n-    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n-    // where they'll be munched one-at-a-time\n-    (\n-        $(#[$outer:meta])*\n-        $vis:vis struct $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$inner:ident $($args:tt)*])*\n-                const $Flag:ident = $value:expr;\n-            )*\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                // All flags start here\n-                unprocessed: [\n-                    $(\n-                        {\n-                            ident: $Flag,\n-                            value: $value,\n-                            attrs: {\n-                                // All attributes start here\n-                                unprocessed: [$(#[$inner $($args)*])*],\n-                                processed: {\n-                                    // Attributes that should be added to item declarations go here\n-                                    decl: [],\n-                                    // Attributes that are safe on expressions go here\n-                                    expr: [],\n-                                }\n-                            },\n-                        },\n-                    )*\n-                ],\n-                // Flags that have had their attributes sorted are pushed here\n-                processed: [],\n-            }\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `cfg`: The next flag should be propagated to expressions\n-    // NOTE: You can copy this rules block and replace `cfg` with\n-    // your attribute name that should be considered expression-safe\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            // cfg matched here\n-                            #[cfg $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    // cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    // cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `$other`: The next flag should not be propagated to expressions\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            // $other matched here\n-                            #[$other:ident $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    // $other added here\n-                                    #[$other $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    // $other not added here\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    // Complete the current flag once there are no unprocessed attributes left\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                ],\n-            }\n-        }\n-    };\n-    // Once all attributes on all flags are processed, generate the actual code\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [],\n-            processed: [\n-                $(\n-                    {\n-                        ident: $Flag:ident,\n-                        value: $value:expr,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n-                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n-                            }\n-                        },\n-                    },\n-                )*\n-            ],\n-        }\n     ) => {\n         // Declared in the scope of the `bitflags!` call\n         // This type appears in the end-user's API\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -879,7 +570,7 @@ macro_rules! __declare_bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$decl $($declargs)*])*\n+                    $(#[$inner $($args)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -912,7 +603,7 @@ macro_rules! __declare_bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -922,7 +613,7 @@ macro_rules! __declare_bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -932,7 +623,12 @@ macro_rules! __declare_bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-    }\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n }\n \n #[macro_use]\n",
        "problem_statement": "Bitflags reverses order of multiline doc comments\nWhen compiling code like\r\n```\r\nbitflags! {\r\n    pub struct AdjustFlags: u32 {\r\n        /// Add buf.time to the current time. If buf.status includes the ADJ_NANO flag, then buf.time.tv_usec is interpreted as a nanosecond value;\r\n        /// otherwise it is interpreted as microseconds.\r\n        ///\r\n        /// The value of buf.time is the sum of its two fields, but the field buf.time.tv_usec must always be nonnegative.\r\n        /// The following example shows how to normalize a timeval with nanosecond resolution.\r\n        ///\r\n        /// ```C\r\n        /// while (buf.time.tv_usec < 0) {\r\n        ///     buf.time.tv_sec  -= 1;\r\n        ///     buf.time.tv_usec += 1000000000;\r\n        /// }\r\n        /// ```\r\n        const SETOFFSET = libc::ADJ_SETOFFSET;\r\n    }\r\n}\r\n```\r\n\r\nThe doc-comments order is reversed on compile, causing issues with generated docs and the doctest.\r\n\r\nThis bug only occurs on bitflags 2.2.0 and not on earlier versions\n",
        "hints_text": "This should be trivially fixed by swapping the order attributes are \"pushed\" in `__declare_bitflags`. We've already yanked `2.2.0` because it requires a lot more recursion, but will keep this open to make sure any new approach doesn't reverse the order of attributes.",
        "created_at": "2023-04-24T04:29:26Z",
        "test_patch": "diff --git /dev/null b/tests/compile-pass/large.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/large.rs\n@@ -0,0 +1,311 @@\n+/*\n+Copyright (c) 2016 Anatoly Ikorsky\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    /// Client capability flags\n+    #[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+    pub struct CapabilityFlags: u32 {\n+        /// Use the improved version of Old Password Authentication. Assumed to be set since 4.1.1.\n+        const CLIENT_LONG_PASSWORD                  = 0x0000_0001;\n+    \n+        /// Send found rows instead of affected rows in EOF_Packet.\n+        const CLIENT_FOUND_ROWS                     = 0x0000_0002;\n+    \n+        /// Get all column flags.\n+        /// Longer flags in Protocol::ColumnDefinition320.\n+        ///\n+        /// ### Server\n+        /// Supports longer flags.\n+        ///\n+        /// ### Client\n+        /// Expects longer flags.\n+        const CLIENT_LONG_FLAG                      = 0x0000_0004;\n+    \n+        /// Database (schema) name can be specified on connect in Handshake Response Packet.\n+        /// ### Server\n+        /// Supports schema-name in Handshake Response Packet.\n+        ///\n+        /// ### Client\n+        /// Handshake Response Packet contains a schema-name.\n+        const CLIENT_CONNECT_WITH_DB                = 0x0000_0008;\n+    \n+        /// Don't allow database.table.column.\n+        const CLIENT_NO_SCHEMA                      = 0x0000_0010;\n+    \n+        /// Compression protocol supported.\n+        ///\n+        /// ### Server\n+        /// Supports compression.\n+        ///\n+        /// ### Client\n+        /// Switches to Compression compressed protocol after successful authentication.\n+        const CLIENT_COMPRESS                       = 0x0000_0020;\n+    \n+        /// Special handling of ODBC behavior.\n+        const CLIENT_ODBC                           = 0x0000_0040;\n+    \n+        /// Can use LOAD DATA LOCAL.\n+        ///\n+        /// ### Server\n+        /// Enables the LOCAL INFILE request of LOAD DATA|XML.\n+        ///\n+        /// ### Client\n+        /// Will handle LOCAL INFILE request.\n+        const CLIENT_LOCAL_FILES                    = 0x0000_0080;\n+    \n+        /// Ignore spaces before '('.\n+        ///\n+        /// ### Server\n+        /// Parser can ignore spaces before '('.\n+        ///\n+        /// ### Client\n+        /// Let the parser ignore spaces before '('.\n+        const CLIENT_IGNORE_SPACE                   = 0x0000_0100;\n+    \n+        const CLIENT_PROTOCOL_41                    = 0x0000_0200;\n+    \n+        /// This is an interactive client.\n+        /// Use System_variables::net_wait_timeout versus System_variables::net_interactive_timeout.\n+        ///\n+        /// ### Server\n+        /// Supports interactive and noninteractive clients.\n+        ///\n+        /// ### Client\n+        /// Client is interactive.\n+        const CLIENT_INTERACTIVE                    = 0x0000_0400;\n+    \n+        /// Use SSL encryption for the session.\n+        ///\n+        /// ### Server\n+        /// Supports SSL\n+        ///\n+        /// ### Client\n+        /// Switch to SSL after sending the capability-flags.\n+        const CLIENT_SSL                            = 0x0000_0800;\n+    \n+        /// Client only flag. Not used.\n+        ///\n+        /// ### Client\n+        /// Do not issue SIGPIPE if network failures occur (libmysqlclient only).\n+        const CLIENT_IGNORE_SIGPIPE                 = 0x0000_1000;\n+    \n+        /// Client knows about transactions.\n+        ///\n+        /// ### Server\n+        /// Can send status flags in OK_Packet / EOF_Packet.\n+        ///\n+        /// ### Client\n+        /// Expects status flags in OK_Packet / EOF_Packet.\n+        ///\n+        /// ### Note\n+        /// This flag is optional in 3.23, but always set by the server since 4.0.\n+        const CLIENT_TRANSACTIONS                   = 0x0000_2000;\n+    \n+        const CLIENT_RESERVED                       = 0x0000_4000;\n+    \n+        const CLIENT_SECURE_CONNECTION              = 0x0000_8000;\n+    \n+        /// Enable/disable multi-stmt support.\n+        /// Also sets CLIENT_MULTI_RESULTS. Currently not checked anywhere.\n+        ///\n+        /// ### Server\n+        /// Can handle multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        ///\n+        /// ### Client\n+        /// May send multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        const CLIENT_MULTI_STATEMENTS               = 0x0001_0000;\n+    \n+        /// Enable/disable multi-results.\n+        ///\n+        /// ### Server\n+        /// Can send multiple resultsets for COM_QUERY. Error if the server needs to send\n+        /// them and client does not support them.\n+        ///\n+        /// ### Client\n+        /// Can handle multiple resultsets for COM_QUERY.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_MULTI_RESULTS                  = 0x0002_0000;\n+    \n+        /// Multi-results and OUT parameters in PS-protocol.\n+        ///\n+        /// ### Server\n+        /// Can send multiple resultsets for COM_STMT_EXECUTE.\n+        ///\n+        /// ### Client\n+        /// Can handle multiple resultsets for COM_STMT_EXECUTE.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_PS_MULTI_RESULTS               = 0x0004_0000;\n+    \n+        /// Client supports plugin authentication.\n+        ///\n+        /// ### Server\n+        /// Sends extra data in Initial Handshake Packet and supports the pluggable\n+        /// authentication protocol.\n+        ///\n+        /// ### Client\n+        /// Supports authentication plugins.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_PLUGIN_AUTH                    = 0x0008_0000;\n+    \n+        /// Client supports connection attributes.\n+        ///\n+        /// ### Server\n+        /// Permits connection attributes in Protocol::HandshakeResponse41.\n+        ///\n+        /// ### Client\n+        /// Sends connection attributes in Protocol::HandshakeResponse41.\n+        const CLIENT_CONNECT_ATTRS                  = 0x0010_0000;\n+    \n+        /// Enable authentication response packet to be larger than 255 bytes.\n+        /// When the ability to change default plugin require that the initial password\n+        /// field in the Protocol::HandshakeResponse41 paclet can be of arbitrary size.\n+        /// However, the 4.1 client-server protocol limits the length of the auth-data-field\n+        /// sent from client to server to 255 bytes. The solution is to change the type of\n+        /// the field to a true length encoded string and indicate the protocol change with\n+        /// this client capability flag.\n+        ///\n+        /// ### Server\n+        /// Understands length-encoded integer for auth response data in\n+        /// Protocol::HandshakeResponse41.\n+        ///\n+        /// ### Client\n+        /// Length of auth response data in Protocol::HandshakeResponse41 is a\n+        /// length-encoded integer.\n+        ///\n+        /// ### Note\n+        /// The flag was introduced in 5.6.6, but had the wrong value.\n+        const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x0020_0000;\n+    \n+        /// Don't close the connection for a user account with expired password.\n+        ///\n+        /// ### Server\n+        /// Announces support for expired password extension.\n+        ///\n+        /// ### Client\n+        /// Can handle expired passwords.\n+        const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS   = 0x0040_0000;\n+    \n+        /// Capable of handling server state change information.\n+        /// Its a hint to the server to include the state change information in OK_Packet.\n+        ///\n+        /// ### Server\n+        /// Can set SERVER_SESSION_STATE_CHANGED in the SERVER_STATUS_flags_enum and send\n+        /// Session State Information in a OK_Packet.\n+        ///\n+        /// ### Client\n+        /// Expects the server to send Session State Information in a OK_Packet.\n+        const CLIENT_SESSION_TRACK                  = 0x0080_0000;\n+    \n+        /// Client no longer needs EOF_Packet and will use OK_Packet instead.\n+        ///\n+        /// ### Server\n+        /// Can send OK after a Text Resultset.\n+        ///\n+        /// ### Client\n+        /// Expects an OK_Packet (instead of EOF_Packet) after the resultset\n+        /// rows of a Text Resultset.\n+        ///\n+        /// ### Background\n+        /// To support CLIENT_SESSION_TRACK, additional information must be sent after all\n+        /// successful commands. Although the OK_Packet is extensible, the EOF_Packet is\n+        /// not due to the overlap of its bytes with the content of the Text Resultset Row.\n+        ///\n+        /// Therefore, the EOF_Packet in the Text Resultset is replaced with an OK_Packet.\n+        /// EOF_Packet is deprecated as of MySQL 5.7.5.\n+        const CLIENT_DEPRECATE_EOF                  = 0x0100_0000;\n+    \n+        /// The client can handle optional metadata information in the resultset.\n+        const CLIENT_OPTIONAL_RESULTSET_METADATA    = 0x0200_0000;\n+    \n+        /// Compression protocol extended to support zstd compression method.\n+        ///\n+        /// This capability flag is used to send zstd compression level between client and server\n+        /// provided both client and server are enabled with this flag.\n+        ///\n+        /// # Server\n+        ///\n+        /// Server sets this flag when global variable protocol-compression-algorithms has zstd\n+        /// in its list of supported values.\n+        ///\n+        /// # Client\n+        ///\n+        /// Client sets this flag when it is configured to use zstd compression method.\n+        const CLIENT_ZSTD_COMPRESSION_ALGORITHM     = 0x0400_0000;\n+    \n+        /// Support optional extension for query parameters into the COM_QUERY\n+        /// and COM_STMT_EXECUTE packets.\n+        ///\n+        /// # Server\n+        ///\n+        /// Expects an optional part containing the query parameter set(s).\n+        /// Executes the query for each set of parameters or returns an error if more than 1 set\n+        /// of parameters is sent and the server can't execute it.\n+        ///\n+        /// # Client\n+        ///\n+        /// Can send the optional part containing the query parameter set(s).\n+        const CLIENT_QUERY_ATTRIBUTES               = 0x0800_0000;\n+    \n+        /// Support Multi factor authentication.\n+        ///\n+        /// # Server\n+        ///\n+        /// Server sends AuthNextFactor packet after every nth factor\n+        /// authentication method succeeds, except the last factor authentication.\n+        ///\n+        /// # Client\n+        ///\n+        /// Client reads AuthNextFactor packet sent by server\n+        /// and initiates next factor authentication method.\n+        const MULTI_FACTOR_AUTHENTICATION           = 0x1000_0000;\n+    \n+        /// Client or server supports progress reports within error packet.\n+        const CLIENT_PROGRESS_OBSOLETE              = 0x2000_0000;\n+    \n+        /// Verify server certificate. Client only flag.\n+        ///\n+        /// Deprecated in favor of \u2013ssl-mode.\n+        const CLIENT_SSL_VERIFY_SERVER_CERT         = 0x4000_0000;\n+    \n+        /// Don't reset the options after an unsuccessful connect. Client only flag.\n+        const CLIENT_REMEMBER_OPTIONS               = 0x8000_0000;\n+    }\n+}\n+\n+fn main() {\n+\n+}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 125,
        "instance_id": "bitflags__bitflags-125",
        "issue_numbers": [
            "108"
        ],
        "base_commit": "29e60b23708123121a540fa9bde3254260952511",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -28,5 +28,8 @@ example_generated = []\n [dev-dependencies]\n # Trick Cargo into testing this crate when we run `cargo test --all`.\n bitflags-compiletest = { path = \"compiletest\" }\n+serde = \"1.0\"\n+serde_derive = \"1.0\"\n+serde_json = \"1.0\"\n \n [workspace]\n",
        "problem_statement": "serde support\nAre there any plans to support `Serialize` and `Deserialize` for generated types? I'm writing the impls manually in my code, but this falls apart once there's a ton of `bitflags` generated types. If others are interested in such a feature, maybe I can find the time to implement it myself and submit a pull request :)\n",
        "hints_text": "During the libs blitz evaluation we saw that a grand total of 8 crates have dependencies on both bitflags and Serde, so we decided not to pursue it at the time. I would welcome a PR that adds Serialize and Deserialize impls behind a cfg.\nAdding `#[derive(Serialize, Deserialize)]` to the struct seems to work fine, I'm not sure it's really necessary to add this to the library itself.",
        "created_at": "2017-10-11T15:27:55Z",
        "test_patch": "diff --git /dev/null b/tests/serde.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/serde.rs\n@@ -0,0 +1,35 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde;\n+extern crate serde_json;\n+\n+bitflags! {\n+    #[derive(Serialize, Deserialize)]\n+    struct Flags: u32 {\n+        const A = 1;\n+        const B = 2;\n+        const C = 4;\n+        const D = 8;\n+    }\n+}\n+\n+#[test]\n+fn serialize() {\n+    let flags = Flags::A | Flags::B;\n+\n+    let serialized = serde_json::to_string(&flags).unwrap();\n+\n+    assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n+}\n+\n+#[test]\n+fn deserialize() {\n+    let deserialized: Flags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n+\n+    let expected = Flags::C | Flags::D;\n+\n+    assert_eq!(deserialized.bits, expected.bits);\n+}\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 211,
        "instance_id": "bitflags__bitflags-211",
        "issue_numbers": [
            "208"
        ],
        "base_commit": "15e911c304d5bd8805af55d7e4f8c5324ed798ee",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -664,7 +664,7 @@ macro_rules! __impl_bitflags {\n                 /// Returns `true` if all flags are currently set.\n                 #[inline]\n                 pub const fn is_all(&self) -> bool {\n-                    self.bits == $BitFlags::all().bits\n+                    $BitFlags::all().bits | self.bits == self.bits\n                 }\n             }\n \n",
        "problem_statement": "is_all() vs. from_bits_unchecked()\n[`unsafe from_bits_unchecked()`](https://docs.rs/bitflags/1.2.1/bitflags/example_generated/struct.Flags.html#method.from_bits_unchecked) allows creating instances with extra bits. The caller of the `bitflags!` macro can decide if this is allowed for their type. Let's assume it is for `Example`. I checked the provided methods for surprising interactions with extra bits, and found (only) this:\r\n\r\n`is_all()` returns **false** when there are *more* than \"all\" flags. This does not match the documentation:\r\n\r\n> Returns true if all flags are currently set.\r\n\r\nShould we update the documentation or the implementation?\r\n\r\n---\r\n\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    struct Example: u32 {\r\n        const A = 1;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    unsafe {\r\n        assert!(Example::from_bits_unchecked(1).is_all()); // true\r\n        assert!(Example::from_bits_unchecked(3).is_all()); // false\r\n    }\r\n}\r\n```\r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=cda2672387dd0ff4ba629b1317a9c57c\n",
        "hints_text": "",
        "created_at": "2020-02-04T10:52:16Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1048,6 +1048,11 @@ mod tests {\n         assert!(!Flags::A.is_all());\n         assert!(Flags::ABC.is_all());\n \n+        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        assert!(!extra.is_all());\n+        assert!(!(Flags::A | extra).is_all());\n+        assert!((Flags::ABC | extra).is_all());\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n     }\n \n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 127,
        "instance_id": "bitflags__bitflags-127",
        "issue_numbers": [
            "68"
        ],
        "base_commit": "862582d107bb74ce4c7b505b2490eb815bc3a8c2",
        "patch": "diff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,2 +1,2 @@\n-/target\n-/Cargo.lock\n+target\n+Cargo.lock\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -2,6 +2,7 @@ os:\n   - linux\n   - osx\n language: rust\n+cache: cargo\n rust:\n   # This version is tested to avoid unintentional bumping of the minimum supported Rust version\n   - 1.20.0\n\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -22,14 +22,4 @@ travis-ci = { repository = \"rust-lang-nursery/bitflags\" }\n \n [features]\n default = [\"example_generated\"]\n-unstable_testing = []\n example_generated = []\n-\n-[dev-dependencies]\n-# Trick Cargo into testing this crate when we run `cargo test --all`.\n-bitflags-compiletest = { path = \"compiletest\" }\n-serde = \"1.0\"\n-serde_derive = \"1.0\"\n-serde_json = \"1.0\"\n-\n-[workspace]\n\ndiff --git a/compiletest/Cargo.toml /dev/null\n--- a/compiletest/Cargo.toml\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-[project]\n-name = \"bitflags-compiletest\"\n-version = \"0.0.0\"\n-\n-[dev-dependencies]\n-bitflags = { path = \"../\" }\n-compiletest_rs = { version = \"0.2\" }\n",
        "problem_statement": "Create a test suite crate\n#61 adds an `unstable_testing` feature that is only considered by tests. It seems unfortunate to leak this into the public API.\r\n\r\nHaving a separate crate for tests ([like in Serde](https://github.com/serde-rs/serde/tree/master/test_suite)) would avoid this.\n",
        "hints_text": "",
        "created_at": "2017-10-17T16:27:59Z",
        "test_patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -9,23 +10,14 @@ rust:\n   - beta\n   - nightly\n sudo: false\n-before_script:\n-  - pip install -v 'travis-cargo<0.2' --user && export PATH=$HOME/.local/bin:$PATH\n-  - if [[ -e ~/Library/Python/2.7/bin ]]; then export PATH=~/Library/Python/2.7/bin:$PATH; fi\n script:\n-  - travis-cargo build\n-  - travis-cargo test\n-  - travis-cargo --only nightly test -- --all\n-  - travis-cargo --only stable doc\n-after_success:\n-  - travis-cargo --only nightly doc-upload\n+  - cargo test\n+  - if [ \"$TRAVIS_RUST_VERSION\" = nightly ]; then (cd ./test_suite && cargo test --features unstable); fi\n env:\n   global:\n-    - TRAVIS_CARGO_NIGHTLY_FEATURE=unstable_testing\n     - secure: \"DoZ8g8iPs+X3xEEucke0Ae02JbkQ1qd1SSv/L2aQqxULmREtRcbzRauhiT+ToQO5Ft1Lul8uck14nPfs4gMr/O3jFFBhEBVpSlbkJx7eNL3kwUdp95UNroA8I43xPN/nccJaHDN6TMTD3+uajTQTje2SyzOQP+1gvdKg17kguvE=\"\n \n \n-\n notifications:\n   email:\n     on_success: never\n\ndiff --git a/compiletest/tests/tests.rs /dev/null\n--- a/compiletest/tests/tests.rs\n+++ /dev/null\n@@ -1,30 +0,0 @@\n-extern crate compiletest_rs as compiletest;\n-\n-use std::fs;\n-use std::path::PathBuf;\n-use compiletest::common::Mode;\n-\n-fn run_mode(mode: Mode) {\n-    let config = compiletest::Config {\n-        mode: mode,\n-        src_base: PathBuf::from(format!(\"tests/{}\", mode)),\n-        target_rustcflags: fs::read_dir(\"../target/debug/deps\").unwrap().filter_map(|entry| {\n-            let path = entry.unwrap().path();\n-            path.file_name().map(|file_name| file_name.to_string_lossy()).and_then(|file_name| {\n-                if file_name.starts_with(\"libbitflags-\") && file_name.ends_with(\".rlib\") {\n-                    Some(format!(\"--extern bitflags={}\", path.to_string_lossy()))\n-                } else {\n-                    None\n-                }\n-            })\n-        }).next(),\n-        ..Default::default()\n-    };\n-\n-    compiletest::run_tests(&config);\n-}\n-\n-#[test]\n-fn compile_test() {\n-    run_mode(Mode::CompileFail);\n-}\n\ndiff --git /dev/null b/test_suite/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/test_suite/Cargo.toml\n@@ -0,0 +1,13 @@\n+[project]\n+name = \"test_suite\"\n+version = \"0.0.0\"\n+\n+[features]\n+unstable = [\"compiletest_rs\"]\n+\n+[dependencies]\n+bitflags = { path = \"../\" }\n+compiletest_rs = { version = \"*\", optional = true }\n+serde = \"1.0\"\n+serde_derive = \"1.0\"\n+serde_json = \"1.0\"\n\ndiff --git /dev/null b/test_suite/tests/compiletest.rs\nnew file mode 100644\n--- /dev/null\n+++ b/test_suite/tests/compiletest.rs\n@@ -0,0 +1,32 @@\n+#![cfg(feature = \"unstable\")]\n+\n+extern crate compiletest_rs as compiletest;\n+\n+use std::result::Result;\n+use std::fs;\n+\n+use compiletest::common::Mode;\n+\n+fn run_mode(mode: Mode) {\n+    let config = compiletest::Config {\n+        mode: mode,\n+        src_base: format!(\"tests/{}\", mode).into(),\n+        target_rustcflags: fs::read_dir(\"target/debug/deps\").unwrap().map(Result::unwrap).filter(|entry| {\n+\t    let file_name = entry.file_name();\n+\t    let file_name = file_name.to_string_lossy();\n+\t    file_name.starts_with(\"libbitflags-\") && file_name.ends_with(\".rlib\")\n+        }).max_by_key(|entry| {\n+            entry.metadata().unwrap().modified().unwrap()\n+        }).map(|entry| {\n+            format!(\"--extern bitflags={}\", entry.path().to_string_lossy())\n+        }),\n+        ..Default::default()\n+    };\n+\n+    compiletest::run_tests(&config);\n+}\n+\n+#[test]\n+fn compile_test() {\n+    run_mode(Mode::CompileFail);\n+}\n\ndiff --git a/tests/i128_bitflags.rs b/test_suite/tests/i128_bitflags.rs\n--- a/tests/i128_bitflags.rs\n+++ b/test_suite/tests/i128_bitflags.rs\n@@ -1,4 +1,4 @@\n-#![cfg(feature = \"unstable_testing\")]\n+#![cfg(feature = \"unstable\")]\n \n #![feature(i128_type)]\n \n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 281,
        "instance_id": "bitflags__bitflags-281",
        "issue_numbers": [
            "215"
        ],
        "base_commit": "f38ce72d11ef3e264d4b62f360bd8a5597b916d9",
        "patch": "diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -1,3 +1,5 @@\n+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+\n #[doc(hidden)]\n pub trait ImplementedByBitFlagsMacro {}\n \n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -5,7 +7,8 @@ pub trait ImplementedByBitFlagsMacro {}\n ///\n /// It should not be implemented manually.\n pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    type Bits;\n+    type Bits: Bits;\n+\n     /// Returns an empty set of flags.\n     fn empty() -> Self;\n     /// Returns the set containing all flags.\n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -15,7 +18,8 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Convert from underlying bit representation, unless that\n     /// representation contains bits that do not correspond to a flag.\n     fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where Self: Sized;\n+    where\n+        Self: Sized;\n     /// Convert from underlying bit representation, dropping any bits\n     /// that do not correspond to flags.\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -48,3 +52,58 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Inserts or removes the specified flags depending on the passed value.\n     fn set(&mut self, other: Self, value: bool);\n }\n+\n+// Not re-exported\n+pub trait Sealed {}\n+\n+/// A private trait that encodes the requirements of underlying bits types that can hold flags.\n+///\n+/// This trait may be made public at some future point, but it presents a compatibility hazard\n+/// so is left internal for now.\n+#[doc(hidden)]\n+pub trait Bits:\n+    Clone\n+    + Copy\n+    + BitAnd\n+    + BitAndAssign\n+    + BitOr\n+    + BitOrAssign\n+    + BitXor\n+    + BitXorAssign\n+    + Not\n+    + Sized\n+    + Sealed\n+{\n+    /// The value of `Self` where no bits are set.\n+    const EMPTY: Self;\n+\n+    /// The value of `Self` where all bits are set.\n+    const ALL: Self;\n+}\n+\n+macro_rules! impl_bits {\n+    ($($u:ty, $i:ty,)*) => {\n+        $(\n+            impl Bits for $u {\n+                const EMPTY: $u = 0;\n+                const ALL: $u = <$u>::MAX;\n+            }\n+\n+            impl Bits for $i {\n+                const EMPTY: $i = 0;\n+                const ALL: $i = <$u>::MAX as $i;\n+            }\n+\n+            impl Sealed for $u {}\n+            impl Sealed for $i {}\n+        )*\n+    }\n+}\n+\n+impl_bits! {\n+    u8, i8,\n+    u16, i16,\n+    u32, i32,\n+    u64, i64,\n+    u128, i128,\n+}\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -285,8 +285,8 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n     pub use core;\n-    pub use crate::bitflags_trait::ImplementedByBitFlagsMacro;\n }\n \n /// The macro used to generate the flag structure.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -389,45 +389,6 @@ macro_rules! bitflags {\n     () => {};\n }\n \n-// A helper macro to implement the `all` function.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_all_bitflags {\n-    (\n-        $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident = $value:expr;\n-            )+\n-        }\n-    ) => {\n-        // See `Debug::fmt` for why this approach is taken.\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            $(\n-                #[allow(deprecated)]\n-                const $Flag: $T = 0;\n-            )+\n-        }\n-        #[allow(non_snake_case)]\n-        impl __BitFlags for $BitFlags {\n-            $(\n-                __impl_bitflags! {\n-                    #[allow(deprecated)]\n-                    $(? #[$attr $($args)*])*\n-                    const $Flag: $T = Self::$Flag.bits;\n-                }\n-            )+\n-        }\n-        Self { bits: $(<Self as __BitFlags>::$Flag)|+ }\n-    };\n-    (\n-        $BitFlags:ident: $T:ty { }\n-    ) => {\n-        Self { bits: 0 }\n-    };\n-}\n-\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -455,7 +416,7 @@ macro_rules! __impl_bitflags {\n                 // Append any extra bits that correspond to flags to the end of the format\n                 let extra_bits = self.bits & !Self::all().bits();\n \n-                if extra_bits != 0 {\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -495,7 +456,14 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        #[allow(dead_code)]\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n         impl $BitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -505,20 +473,13 @@ macro_rules! __impl_bitflags {\n             /// Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: 0 }\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n             }\n \n             /// Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                __impl_all_bitflags! {\n-                    $BitFlags: $T {\n-                        $(\n-                            $(#[$attr $($args)*])*\n-                            $Flag = $value;\n-                        )*\n-                    }\n-                }\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n             }\n \n             /// Returns the raw value of the flags currently stored.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -532,8 +493,9 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n                 let truncated = Self::from_bits_truncate(bits).bits;\n+\n                 if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self{ bits })\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n                 } else {\n                     $crate::__private::core::option::Option::None\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -543,15 +505,13 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == 0 {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n                     return Self { bits }\n                 }\n \n-                #[allow(unused_mut)]\n-                let mut truncated = 0;\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    #[allow(unused_doc_comments, unused_attributes)]\n                     $(#[$attr $($args)*])*\n                     if bits & Self::$Flag.bits == Self::$Flag.bits {\n                         truncated |= Self::$Flag.bits\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -719,15 +679,13 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Returns an iterator over set flags and their names.\n-            pub fn iter(mut self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n                 const NUM_FLAGS: usize = {\n-                    #[allow(unused_mut)]\n                     let mut num_flags = 0;\n \n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         {\n                             num_flags += 1;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -739,13 +697,11 @@ macro_rules! __impl_bitflags {\n \n                 const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         $BitFlags::$Flag,\n                     )*\n                 ];\n \n-                #[allow(unused_doc_comments, unused_attributes)]\n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n                         $(#[$attr $($args)*])*\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -754,17 +710,29 @@ macro_rules! __impl_bitflags {\n                 ];\n \n                 let mut start = 0;\n+                let mut state = self;\n \n                 $crate::__private::core::iter::from_fn(move || {\n-                    if self.is_empty() || NUM_FLAGS == 0 {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n                         $crate::__private::core::option::Option::None\n                     } else {\n                         for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n                             .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n                         {\n                             start += 1;\n+\n+                            // NOTE: We check whether the flag exists in self, but remove it from\n+                            // a different value. This ensure that overlapping flags are handled\n+                            // properly. Take the following example:\n+                            //\n+                            // const A: 0b00000001;\n+                            // const B: 0b00000101;\n+                            //\n+                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            // as we encountered it we'd be left with 0b00000100, which doesn't\n+                            // correspond to a valid flag on its own.\n                             if self.contains(flag) {\n-                                self.remove(flag);\n+                                state.remove(flag);\n \n                                 return $crate::__private::core::option::Option::Some((flag_name, flag))\n                             }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1854,7 +1828,6 @@ mod tests {\n             }\n         }\n \n-\n         let flags = Flags::from_bits(0b00000100);\n         assert_eq!(flags, None);\n         let flags = Flags::from_bits(0b00000101);\n\ndiff --git a/tests/compile-fail/cfg/multi.stderr /dev/null\n--- a/tests/compile-fail/cfg/multi.stderr\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-error[E0428]: the name `FOO` is defined multiple times\n-  --> tests/compile-fail/cfg/multi.rs:6:1\n-   |\n-6  | / bitflags! {\n-7  | |     pub struct Flags: u32 {\n-8  | |         #[cfg(target_os = \"linux\")]\n-9  | |         const FOO = 1;\n-...  |\n-12 | |     }\n-13 | | }\n-   | | ^\n-   | | |\n-   | |_`FOO` redefined here\n-   |   previous definition of the value `FOO` here\n-   |\n-   = note: `FOO` must be defined only once in the value namespace of this trait\n-   = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -1,22 +1,16 @@\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:116:22\n     |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+116 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n+note: required by a bound in `bitflags::BitFlags::Bits`\n+   --> src/bitflags_trait.rs\n     |\n-458 |                 if extra_bits != MyInt(0) {\n-    |                                  ++++++ +\n+    |     type Bits: Bits;\n+    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -26,15 +20,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-508 |                 Self { bits: MyInt(0) }\n-    |                              ++++++ +\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -44,15 +34,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-546 |                 if bits == MyInt(0) {\n-    |                            ++++++ +\n \n-error[E0277]: no implementation for `{integer} |= MyInt`\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -62,12 +48,11 @@ error[E0277]: no implementation for `{integer} |= MyInt`\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ no implementation for `{integer} |= MyInt`\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -77,28 +62,6 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-561 |                 Self { bits: MyInt(truncated) }\n-    |                              ++++++         +\n-\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n-    |\n-    = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-409 |                 const $Flag: $T = MyInt(0);\n-    |                                   ++++++ +\n\ndiff --git a/tests/compile-fail/trait/custom_impl.stderr b/tests/compile-fail/trait/custom_impl.stderr\n--- a/tests/compile-fail/trait/custom_impl.stderr\n+++ b/tests/compile-fail/trait/custom_impl.stderr\n@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> $DIR/custom_impl.rs:5:6\n+ --> tests/compile-fail/trait/custom_impl.rs:5:6\n   |\n 5 | impl BitFlags for BootlegFlags {\n   |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n   |\n note: required by a bound in `BitFlags`\n- --> $DIR/bitflags_trait.rs:7:21\n+ --> src/bitflags_trait.rs\n   |\n-7 | pub trait BitFlags: ImplementedByBitFlagsMacro {\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\n\ndiff --git a/tests/compile-fail/cfg/multi.rs b/tests/compile-pass/cfg/redefined-value.rs\n--- a/tests/compile-fail/cfg/multi.rs\n+++ b/tests/compile-pass/cfg/redefined-value.rs\n@@ -1,12 +1,11 @@\n #[macro_use]\n extern crate bitflags;\n \n-// NOTE: Ideally this would work, but our treatment of CFGs\n-// assumes flags may be missing but not redefined\n bitflags! {\n     pub struct Flags: u32 {\n         #[cfg(target_os = \"linux\")]\n         const FOO = 1;\n+\n         #[cfg(not(target_os = \"linux\"))]\n         const FOO = 2;\n     }\n\ndiff --git a/tests/compile-fail/cfg/multi.rs b/tests/compile-pass/cfg/redefined-value.rs\n--- a/tests/compile-fail/cfg/multi.rs\n+++ b/tests/compile-pass/cfg/redefined-value.rs\n@@ -20,6 +19,6 @@ fn main() {\n \n     #[cfg(not(target_os = \"linux\"))]\n     {\n-        assert_eq!(1, Flags::FOO.bits());\n+        assert_eq!(2, Flags::FOO.bits());\n     }\n }\n\ndiff --git /dev/null b/tests/compile-pass/deprecated.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/deprecated.rs\n@@ -0,0 +1,14 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        #[deprecated = \"Use something else\"]\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\n\ndiff --git /dev/null b/tests/compile-pass/non_snake_case.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/non_snake_case.rs\n@@ -0,0 +1,13 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const CamelCase = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\n",
        "problem_statement": "Debug formatting leads to less desireable output\n[Link to rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bmacro_use%5D%0Aextern%20crate%20bitflags%3B%0A%0Abitflags!%20%7B%0A%20%20%20%20struct%20Flags%3A%20u32%20%7B%0A%20%20%20%20%20%20%20%20const%20A%20%3D%200b00000001%3B%0A%20%20%20%20%20%20%20%20const%20B%20%3D%200b00000010%3B%0A%20%20%20%20%20%20%20%20const%20C%20%3D%200b00000100%3B%0A%20%20%20%20%20%20%20%20const%20ABC%20%3D%20Self%3A%3AA.bits%20%7C%20Self%3A%3AB.bits%20%7C%20Self%3A%3AC.bits%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20Flags%3A%3AA%20%7C%20Flags%3A%3AB%20%7C%20Flags%3A%3AC%20)%3B%0A%7D)\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n        const C = 0b00000100;\r\n        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::A | Flags::B | Flags::C );\r\n}\r\n```\r\n\r\nprints:\r\n\r\n```bash\r\nA | B | C | ABC\r\n```\r\n\r\nI find it somewhat less helpful that both the expanded (`A | B | C`) and \"compressed\" form (`ABC`) are reported...\r\n\r\nIs there a reason behind this? Is this considered more correct for some reason?\n",
        "hints_text": "I think the current algorithm used for debug output is to loop over all flags and append identifiers that correspond to set bits. I think an alternative here that could work would be to short-circuit when we\u2019ve built a format that covers all the set bits. As an implementation note we wouldn\u2019t be able to work off a single source and just mask out bits as we see them, we\u2019ll need to use the whole set of bits to see if a flag is applicable and then a second set that\u2019s masked to see when we\u2019ve catered for all set bits. Otherwise something like this wouldn\u2019t work:\r\n\r\n```\r\nconst A: 0b00000100\r\nconst B: 0b00001100\r\n\r\nlet input = B;\r\n```\r\n\r\nwe\u2019d mask out bit 3 for `A` but then have one leftover for `B` that doesn\u2019t correspond to it. In that example we\u2019d end up writing `A | B` still, but wouldn\u2019t duplicate compound identifiers the same.\r\n\r\nIn general, I\u2019m not sure if there\u2019s a reasonable algorithm that would produce the smallest possible format for any given set of bits.",
        "created_at": "2022-05-03T06:59:46Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1353,7 +1321,10 @@ mod tests {\n         assert_eq!(UNION, Flags::A | Flags::C);\n         assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n         assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(SYM_DIFFERENCE, (Flags::A | Flags::C) ^ (Flags::all() - Flags::A));\n+        assert_eq!(\n+            SYM_DIFFERENCE,\n+            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n+        );\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1609,13 +1580,15 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n         assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n         assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+\n         let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+\n         assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n         assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | 0xb8\"\n+            \"A | B | C | ABC | 0xb8\"\n         );\n \n         assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1830,7 +1803,8 @@ mod tests {\n     fn test_serde_bitflags_roundtrip() {\n         let flags = SerdeFlags::A | SerdeFlags::B;\n \n-        let deserialized: SerdeFlags = serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n \n         assert_eq!(deserialized.bits, flags.bits);\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1875,7 +1848,7 @@ mod tests {\n         let flags = Flags::from_bits_truncate(0b00000101);\n         assert_eq!(flags, Flags::A);\n     }\n-  \n+\n     #[test]\n     fn test_iter() {\n         bitflags! {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1887,24 +1860,31 @@ mod tests {\n                 const FOUR_WIN = 0b1000;\n                 #[cfg(unix)]\n                 const FOUR_UNIX = 0b10000;\n+                const FIVE = 0b01000100;\n             }\n         }\n \n         let count = {\n             #[cfg(any(unix, windows))]\n             {\n-                4\n+                5\n             }\n \n             #[cfg(not(any(unix, windows)))]\n             {\n-                3\n+                4\n             }\n         };\n \n         let flags = Flags::all();\n         assert_eq!(flags.iter().count(), count);\n+\n+        for (_, flag) in flags.iter() {\n+            assert!(flags.contains(flag));\n+        }\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1918,6 +1898,8 @@ mod tests {\n             assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n         }\n \n+        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n+\n         assert_eq!(iter.next(), None);\n \n         let flags = Flags::empty();\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1925,7 +1907,9 @@ mod tests {\n \n         let flags = Flags::ONE | Flags::THREE;\n         assert_eq!(flags.iter().count(), 2);\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n         assert_eq!(iter.next(), None);\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 85,
        "instance_id": "bitflags__bitflags-85",
        "issue_numbers": [
            "64"
        ],
        "base_commit": "7acacb4e869a6a0c8b427c25ade53086e5f024a1",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -252,8 +252,7 @@ macro_rules! bitflags {\n                     }\n                 )+\n                 if first {\n-                    // TODO: should not be the empty string\n-                    // https://github.com/rust-lang-nursery/bitflags/issues/64\n+                    try!(f.write_str(\"(empty)\"));\n                 }\n                 Ok(())\n             }\n",
        "problem_statement": "Empty bitflags has unhelpful Debug representation\nThe Debug representation is the empty string. This is not very debuggable. I think \"(empty)\" would be more helpful.\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    pub flags Flags: u8 {\r\n        const A = 0,\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::empty());\r\n}\r\n```\n",
        "hints_text": "Do as suggested in the op.",
        "created_at": "2017-03-22T12:28:53Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -765,6 +764,7 @@ mod tests {\n     #[test]\n     fn test_debug() {\n         assert_eq!(format!(\"{:?}\", FlagA | FlagB), \"FlagA | FlagB\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n         assert_eq!(format!(\"{:?}\", FlagABC), \"FlagA | FlagB | FlagC | FlagABC\");\n     }\n \n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 38,
        "instance_id": "bitflags__bitflags-38",
        "issue_numbers": [
            "25"
        ],
        "base_commit": "95a521ddd2d4ae36df7a91d22be8b5f89c620e59",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -101,6 +101,35 @@ pub use std as __core;\n /// }\n /// ```\n ///\n+/// # Visibility\n+///\n+/// The generated struct and its associated flag constants are not exported\n+/// out of the current module by default. A definition can be exported out of\n+/// the current module by adding `pub` before `flags`:\n+///\n+/// ```{.rust},ignore\n+/// #[macro_use]\n+/// extern crate bitflags;\n+///\n+/// mod example {\n+///     bitflags! {\n+///         pub flags Flags1: u32 {\n+///             const FLAG_A   = 0b00000001,\n+///         }\n+///     }\n+///     bitflags! {\n+///         flags Flags2: u32 {\n+///             const FLAG_B   = 0b00000010,\n+///         }\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let flag1 = example::FLAG_A;\n+///     let flag2 = example::FLAG_B; // error: const `FLAG_B` is private\n+/// }\n+/// ```\n+///\n /// # Attributes\n ///\n /// Attributes can be attached to the generated `struct` by placing them\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -153,7 +182,7 @@ pub use std as __core;\n ///             if they are.\n #[macro_export]\n macro_rules! bitflags {\n-    ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n+    ($(#[$attr:meta])* pub flags $BitFlags:ident: $T:ty {\n         $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+\n     }) => {\n         #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -164,35 +193,73 @@ macro_rules! bitflags {\n \n         $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n \n+        bitflags! {\n+            @_impl flags $BitFlags: $T {\n+                $($(#[$Flag_attr])* const $Flag = $value),+\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n+        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+\n+    }) => {\n+        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n+        $(#[$attr])*\n+        struct $BitFlags {\n+            bits: $T,\n+        }\n+\n+        $($(#[$Flag_attr])* const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n+        bitflags! {\n+            @_impl flags $BitFlags: $T {\n+                $($(#[$Flag_attr])* const $Flag = $value),+\n+            }\n+        }\n+    };\n+    (@_impl flags $BitFlags:ident: $T:ty {\n+        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+\n+    }) => {\n         impl $crate::__core::fmt::Debug for $BitFlags {\n             fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n                 // This convoluted approach is to handle #[cfg]-based flag\n                 // omission correctly. Some of the $Flag variants may not be\n                 // defined in this module so we create an inner module which\n-                // defines *all* flags to the value of 0. Afterwards when the\n-                // glob import variants from the outer module, shadowing all\n+                // defines *all* flags to the value of 0. We then create a\n+                // second inner module that defines all of the flags with #[cfg]\n+                // to their real values. Afterwards the glob will import\n+                // variants from the second inner module, shadowing all\n                 // defined variants, leaving only the undefined ones with the\n                 // bit value of 0.\n                 #[allow(dead_code)]\n                 #[allow(unused_assignments)]\n                 mod dummy {\n+                    // We can't use the real $BitFlags struct because it may be\n+                    // private, which prevents us from using it to define\n+                    // public constants.\n+                    pub struct $BitFlags {\n+                        bits: $T,\n+                    }\n+                    mod real_flags {\n+                        use super::$BitFlags;\n+                        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+                    }\n                     // Now we define the \"undefined\" versions of the flags.\n                     // This way, all the names exist, even if some are #[cfg]ed\n                     // out.\n-                    $(const $Flag: super::$BitFlags = super::$BitFlags { bits: 0 };)+\n+                    $(const $Flag: $BitFlags = $BitFlags { bits: 0 };)+\n \n                     #[inline]\n-                    pub fn fmt(self_: &super::$BitFlags,\n+                    pub fn fmt(self_: $T,\n                                f: &mut $crate::__core::fmt::Formatter)\n                                -> $crate::__core::fmt::Result {\n                         // Now we import the real values for the flags.\n                         // Only ones that are #[cfg]ed out will be 0.\n-                        use super::*;\n+                        use self::real_flags::*;\n \n                         let mut first = true;\n                         $(\n                             // $Flag.bits == 0 means that $Flag doesn't exist\n-                            if $Flag.bits != 0 && self_.contains($Flag) {\n+                            if $Flag.bits != 0 && self_ & $Flag.bits == $Flag.bits {\n                                 if !first {\n                                     try!(f.write_str(\" | \"));\n                                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -203,7 +270,7 @@ macro_rules! bitflags {\n                         Ok(())\n                     }\n                 }\n-                dummy::fmt(self, f)\n+                dummy::fmt(self.bits, f)\n             }\n         }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -221,15 +288,22 @@ macro_rules! bitflags {\n                 // See above `dummy` module for why this approach is taken.\n                 #[allow(dead_code)]\n                 mod dummy {\n-                    $(const $Flag: super::$BitFlags = super::$BitFlags { bits: 0 };)+\n+                    pub struct $BitFlags {\n+                        bits: $T,\n+                    }\n+                    mod real_flags {\n+                        use super::$BitFlags;\n+                        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+                    }\n+                    $(const $Flag: $BitFlags = $BitFlags { bits: 0 };)+\n \n                     #[inline]\n-                    pub fn all() -> super::$BitFlags {\n-                        use super::*;\n-                        $BitFlags { bits: $($Flag.bits)|+ }\n+                    pub fn all() -> $T {\n+                        use self::real_flags::*;\n+                        $($Flag.bits)|+\n                     }\n                 }\n-                dummy::all()\n+                $BitFlags { bits: dummy::all() }\n             }\n \n             /// Returns the raw value of the flags currently stored.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -399,6 +473,16 @@ macro_rules! bitflags {\n             }\n         }\n     };\n+    ($(#[$attr:meta])* pub flags $BitFlags:ident: $T:ty {\n+        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+,\n+    }) => {\n+        bitflags! {\n+            $(#[$attr])*\n+            pub flags $BitFlags: $T {\n+                $($(#[$Flag_attr])* const $Flag = $value),+\n+            }\n+        }\n+    };\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n         $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+,\n     }) => {\n",
        "problem_statement": "Bitflags should be private by default\nBitflags should match the semantics of structs, which are private by default unless explicitly exported using `pub`.\n\nSince this is a compat-breaking change, it would make sense to do it at the same time as the switch to associated constants and namespaced flags (#24).\n\nExample:\n\n``` rust\nbitflags! {\n    pub flags Flags: u32 {\n        const FLAG_A   = 0b00000001,\n        const FLAG_B   = 0b00000010,\n    }\n}\n```\n\n",
        "hints_text": "",
        "created_at": "2016-01-16T10:00:58Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -661,4 +745,27 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", FlagA | FlagB), \"FlagA | FlagB\");\n         assert_eq!(format!(\"{:?}\", FlagABC), \"FlagA | FlagB | FlagC | FlagABC\");\n     }\n+\n+    mod submodule {\n+        bitflags! {\n+            pub flags PublicFlags: i8 {\n+                const FlagX = 0,\n+            }\n+        }\n+        bitflags! {\n+            flags PrivateFlags: i8 {\n+                const FlagY = 0,\n+            }\n+        }\n+\n+        #[test]\n+        fn test_private() {\n+            let _ = FlagY;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_public() {\n+        let _ = submodule::FlagX;\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 74,
        "instance_id": "bitflags__bitflags-74",
        "issue_numbers": [
            "71"
        ],
        "base_commit": "2fecde2b33c34659bd37d82f64b9c07f002d6a30",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -216,63 +216,46 @@ macro_rules! bitflags {\n         impl $crate::__core::fmt::Debug for $BitFlags {\n             fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n                 // This convoluted approach is to handle #[cfg]-based flag\n-                // omission correctly. Some of the $Flag variants may not be\n-                // defined in this module so we create an inner module which\n-                // defines *all* flags to the value of 0. We then create a\n-                // second inner module that defines all of the flags with #[cfg]\n-                // to their real values. Afterwards the glob will import\n-                // variants from the second inner module, shadowing all\n-                // defined variants, leaving only the undefined ones with the\n-                // bit value of 0.\n-                #[allow(dead_code)]\n-                #[allow(unused_assignments)]\n-                mod dummy {\n-                    // We can't use the real $BitFlags struct because it may be\n-                    // private, which prevents us from using it to define\n-                    // public constants.\n-                    pub struct __Pub(super::$BitFlags);\n-                    impl $crate::__core::convert::From<super::$BitFlags> for __Pub {\n-                        fn from(original: super::$BitFlags) -> Self {\n-                            __Pub(original)\n-                        }\n-                    }\n-                    mod real_flags {\n-                        use super::__Pub;\n-                        $(\n-                            $(#[$Flag_attr])*\n-                            pub const $Flag: __Pub = __Pub(super::super::$Flag);\n-                        )+\n-                    }\n-                    // Now we define the \"undefined\" versions of the flags.\n-                    // This way, all the names exist, even if some are #[cfg]ed\n-                    // out.\n+                // omission correctly. For example it needs to support:\n+                //\n+                //    #[cfg(unix)] const A: Flag = /* ... */;\n+                //    #[cfg(windows)] const B: Flag = /* ... */;\n+\n+                // Unconditionally define a check for every flag, even disabled\n+                // ones.\n+                #[allow(non_snake_case)]\n+                trait __BitFlags {\n+                    $(\n+                        fn $Flag(&self) -> bool { false }\n+                    )+\n+                }\n+\n+                // Conditionally override the check for just those flags that\n+                // are not #[cfg]ed away.\n+                impl __BitFlags for $BitFlags {\n                     $(\n-                        const $Flag: __Pub = __Pub(super::$BitFlags { bits: 0 });\n+                        $(#[$Flag_attr])*\n+                        fn $Flag(&self) -> bool {\n+                            self.bits & $Flag.bits == $Flag.bits\n+                        }\n                     )+\n+                }\n \n-                    #[inline]\n-                    pub fn fmt(self_: __Pub,\n-                               f: &mut $crate::__core::fmt::Formatter)\n-                               -> $crate::__core::fmt::Result {\n-                        // Now we import the real values for the flags.\n-                        // Only ones that are #[cfg]ed out will be 0.\n-                        use self::real_flags::*;\n-\n-                        let mut first = true;\n-                        $(\n-                            // $Flag.bits == 0 means that $Flag doesn't exist\n-                            if $Flag.0.bits != 0 && self_.0.bits & $Flag.0.bits == $Flag.0.bits {\n-                                if !first {\n-                                    try!(f.write_str(\" | \"));\n-                                }\n-                                first = false;\n-                                try!(f.write_str(stringify!($Flag)));\n-                            }\n-                        )+\n-                        Ok(())\n+                let mut first = true;\n+                $(\n+                    if <$BitFlags as __BitFlags>::$Flag(self) {\n+                        if !first {\n+                            try!(f.write_str(\" | \"));\n+                        }\n+                        first = false;\n+                        try!(f.write_str(stringify!($Flag)));\n                     }\n+                )+\n+                if first {\n+                    // TODO: should not be the empty string\n+                    // https://github.com/rust-lang-nursery/bitflags/issues/64\n                 }\n-                dummy::fmt($crate::__core::convert::From::from(*self), f)\n+                Ok(())\n             }\n         }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -287,33 +270,20 @@ macro_rules! bitflags {\n             /// Returns the set containing all flags.\n             #[inline]\n             pub fn all() -> $BitFlags {\n-                // See above `dummy` module for why this approach is taken.\n-                #[allow(dead_code)]\n-                mod dummy {\n-                    pub struct __Pub(super::$BitFlags);\n-                    impl $crate::__core::convert::From<__Pub> for super::$BitFlags {\n-                        fn from(wrapper: __Pub) -> Self {\n-                            wrapper.0\n-                        }\n-                    }\n-                    mod real_flags {\n-                        use super::__Pub;\n-                        $(\n-                            $(#[$Flag_attr])*\n-                            pub const $Flag: __Pub = __Pub(super::super::$Flag);\n-                        )+\n-                    }\n+                // See `Debug::fmt` for why this approach is taken.\n+                #[allow(non_snake_case)]\n+                trait __BitFlags {\n                     $(\n-                        const $Flag: __Pub = __Pub(super::$BitFlags { bits: 0 });\n+                        fn $Flag() -> $T { 0 }\n+                    )+\n+                }\n+                impl __BitFlags for $BitFlags {\n+                    $(\n+                        $(#[$Flag_attr])*\n+                        fn $Flag() -> $T { $Flag.bits }\n                     )+\n-\n-                    #[inline]\n-                    pub fn all() -> __Pub {\n-                        use self::real_flags::*;\n-                        __Pub(super::$BitFlags { bits: $($Flag.0.bits)|+ })\n-                    }\n                 }\n-                $crate::__core::convert::From::from(dummy::all())\n+                $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag())|+ }\n             }\n \n             /// Returns the raw value of the flags currently stored.\n",
        "problem_statement": "Function-local bitflags\nIs there any hope of supporting usage like this? The error here is inconsistent with being able to declare structs and other types of items local to a function.\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nfn main() {\r\n    bitflags! {\r\n        flags Flags: u8 {\r\n            const A = 1,\r\n            const B = 2,\r\n        }\r\n    }\r\n    println!(\"{:?}\", A);\r\n}\r\n```\r\n\r\n```\r\nerror[E0425]: cannot find value `A` in module `super::super`\r\n  --> src/main.rs:5:5\r\n   |\r\n5  |       bitflags! {\r\n   |  _____^ starting here...\r\n6  | |         flags Flags: u8 {\r\n7  | |             const A = 1,\r\n8  | |             const B = 2,\r\n9  | |         }\r\n10 | |     }\r\n   | |_____^ ...ending here: not found in `super::super`\r\n   |\r\n   = note: this error originates in a macro outside of the current crate\r\n```\n",
        "hints_text": "",
        "created_at": "2017-03-08T02:00:24Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -837,4 +807,17 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn test_in_function() {\n+        bitflags! {\n+            flags Flags: u8 {\n+                const A = 1,\n+                #[cfg(any())] // false\n+                const B = 2,\n+            }\n+        }\n+        assert_eq!(Flags::all(), A);\n+        assert_eq!(format!(\"{:?}\", A), \"A\");\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 112,
        "instance_id": "bitflags__bitflags-112",
        "issue_numbers": [
            "109"
        ],
        "base_commit": "8ee624463bb29c3a749ef134fda7cc0fa1192552",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -305,49 +305,77 @@ pub extern crate core as _core;\n /// ```\n #[macro_export]\n macro_rules! bitflags {\n-    ($(#[$attr:meta])* pub struct $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr;)+\n-    }) => {\n+    (\n+        $(#[$outer:meta])*\n+        pub struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )+\n+        }\n+    ) => {\n         #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $(#[$attr])*\n+        $(#[$outer])*\n         pub struct $BitFlags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+        $(\n+            $(#[$inner $($args)*])*\n+            pub const $Flag: $BitFlags = $BitFlags { bits: $value };\n+        )+\n \n         __impl_bitflags! {\n             struct $BitFlags: $T {\n-                $($(#[$Flag_attr])* const $Flag = $value;)+\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    const $Flag = $value;\n+                )+\n             }\n         }\n     };\n-    ($(#[$attr:meta])* struct $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr;)+\n-    }) => {\n+    (\n+        $(#[$outer:meta])*\n+        struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )+\n+        }\n+    ) => {\n         #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $(#[$attr])*\n+        $(#[$outer])*\n         struct $BitFlags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+        $(\n+            $(#[$inner $($args)*])*\n+            const $Flag: $BitFlags = $BitFlags { bits: $value };\n+        )+\n \n         __impl_bitflags! {\n             struct $BitFlags: $T {\n-                $($(#[$Flag_attr])* const $Flag = $value;)+\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    const $Flag = $value;\n+                )+\n             }\n         }\n-\n     };\n }\n \n #[macro_export]\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n-    (struct $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr;)+\n-    }) => {\n+    (\n+        struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )+\n+        }\n+    ) => {\n         impl $crate::_core::fmt::Debug for $BitFlags {\n             fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {\n                 // This convoluted approach is to handle #[cfg]-based flag\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -369,9 +397,12 @@ macro_rules! __impl_bitflags {\n                 // are not #[cfg]ed away.\n                 impl __BitFlags for $BitFlags {\n                     $(\n-                        $(#[$Flag_attr])*\n-                        fn $Flag(&self) -> bool {\n-                            self.bits & $Flag.bits == $Flag.bits\n+                        __impl_bitflags! {\n+                            #[allow(deprecated)]\n+                            $(? #[$attr $($args)*])*\n+                            fn $Flag(&self) -> bool {\n+                                self.bits & $Flag.bits == $Flag.bits\n+                            }\n                         }\n                     )+\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -433,8 +464,11 @@ macro_rules! __impl_bitflags {\n                 }\n                 impl __BitFlags for $BitFlags {\n                     $(\n-                        $(#[$Flag_attr])*\n-                        fn $Flag() -> $T { $Flag.bits }\n+                        __impl_bitflags! {\n+                            #[allow(deprecated)]\n+                            $(? #[$attr $($args)*])*\n+                            fn $Flag() -> $T { $Flag.bits }\n+                        }\n                     )+\n                 }\n                 $BitFlags { bits: $(<$BitFlags as __BitFlags>::$Flag())|+ }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -619,6 +653,59 @@ macro_rules! __impl_bitflags {\n             }\n         }\n     };\n+\n+    // Every attribute that the user writes on a const is applied to the\n+    // corresponding const that we generate, but within the implementation of\n+    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n+    // particular, including a #[deprecated] attribute on those items would fail\n+    // to compile.\n+    // https://github.com/rust-lang-nursery/bitflags/issues/109\n+    //\n+    // Input:\n+    //\n+    //     ? #[cfg(feature = \"advanced\")]\n+    //     ? #[deprecated(note = \"Use somthing else.\")]\n+    //     ? #[doc = r\"High quality documentation.\"]\n+    //     fn f() -> i32 { /* ... */ }\n+    //\n+    // Output:\n+    //\n+    //     #[cfg(feature = \"advanced\")]\n+    //     fn f() -> i32 { /* ... */ }\n+    (\n+        $(#[$filtered:meta])*\n+        ? #[cfg $($cfgargs:tt)*]\n+        $(? #[$rest:ident $($restargs:tt)*])*\n+        fn $($item:tt)*\n+    ) => {\n+        __impl_bitflags! {\n+            $(#[$filtered])*\n+            #[cfg $($cfgargs)*]\n+            $(? #[$rest $($restargs)*])*\n+            fn $($item)*\n+        }\n+    };\n+    (\n+        $(#[$filtered:meta])*\n+        // $next != `cfg`\n+        ? #[$next:ident $($nextargs:tt)*]\n+        $(? #[$rest:ident $($restargs:tt)*])*\n+        fn $($item:tt)*\n+    ) => {\n+        __impl_bitflags! {\n+            $(#[$filtered])*\n+            // $next filtered out\n+            $(? #[$rest $($restargs)*])*\n+            fn $($item)*\n+        }\n+    };\n+    (\n+        $(#[$filtered:meta])*\n+        fn $($item:tt)*\n+    ) => {\n+        $(#[$filtered])*\n+        fn $($item)*\n+    };\n }\n \n #[cfg(feature = \"example_generated\")]\n",
        "problem_statement": "Possibly unintended breakage between 0.8 and 0.9 involving use of the `#[deprecated]` attribute\nGiven the following snippet of code compiled with bitflags 0.8:\r\n\r\n```rust\r\n#![allow(deprecated)]\r\n\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    pub flags TestFlags: u32 {\r\n        #[deprecated(note = \"test note\")]\r\n        const FLAG_ONE = 1,\r\n    }\r\n}\r\n```\r\nEverything works fine:\r\n\r\n```bash\r\nCompiling bitflags_breakage_test v0.1.0 (file:///home/cldfire/programming_projects/bitflags_breakage_test)\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10 secs\r\n```\r\n\r\nAnd everything looks fine in the docs as well:\r\n\r\n![spectacle h29900](https://user-images.githubusercontent.com/13814214/26940771-faeeefac-4c49-11e7-9cb0-76ad068732e0.png)\r\n\r\n![spectacle t29900](https://user-images.githubusercontent.com/13814214/26940787-07d93376-4c4a-11e7-915a-214261986bbd.png)\r\n\r\nHowever, given the same snippet of code (ignoring syntax changes) compiled with bitflags 0.9:\r\n\r\n```rust\r\n#![allow(deprecated)]\r\n\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    pub struct TestFlags: u32 {\r\n        #[deprecated(note = \"test note\")]\r\n        const FLAG_ONE = 1;\r\n    }\r\n}\r\n```\r\nIt does not compile:\r\n\r\n```bash\r\n   Updating registry `https://github.com/rust-lang/crates.io-index`\r\n   Compiling bitflags_breakage_test v0.1.0 (file:///home/cldfire/programming_projects/bitflags_breakage_test)\r\nerror: This deprecation annotation is useless\r\n  --> src/lib.rs:6:1\r\n   |\r\n6  | / bitflags! {\r\n7  | |     pub struct TestFlags: u32 {\r\n8  | |         #[deprecated(note = \"test note\")]\r\n9  | |         const FLAG_ONE = 1;\r\n10 | |     }\r\n11 | | }\r\n   | |_^\r\n   |\r\n   = note: this error originates in a macro outside of the current crate\r\n\r\nerror: This deprecation annotation is useless\r\n  --> src/lib.rs:6:1\r\n   |\r\n6  | / bitflags! {\r\n7  | |     pub struct TestFlags: u32 {\r\n8  | |         #[deprecated(note = \"test note\")]\r\n9  | |         const FLAG_ONE = 1;\r\n10 | |     }\r\n11 | | }\r\n   | |_^\r\n   |\r\n   = note: this error originates in a macro outside of the current crate\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nerror: Could not compile `bitflags_breakage_test`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\nI am not sure if this behavior is intended or not, or if use of attributes such as `#[deprecated]` was supported in the first place. If this is correct behavior it would be nice to mention it in the release notes (I encountered this issue while bumping bitflags from 0.8 -> 0.9 in my own crate).\n",
        "hints_text": "",
        "created_at": "2017-08-06T08:33:36Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -988,4 +1075,14 @@ mod tests {\n         assert_eq!(Flags::all(), A);\n         assert_eq!(format!(\"{:?}\", A), \"A\");\n     }\n+\n+    #[test]\n+    fn test_deprecated() {\n+        bitflags! {\n+            pub struct TestFlags: u32 {\n+                #[deprecated(note = \"Use something else.\")]\n+                const FLAG_ONE = 1;\n+            }\n+        }\n+    }\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 282,
        "instance_id": "bitflags__bitflags-282",
        "issue_numbers": [
            "228"
        ],
        "base_commit": "810dc35aba3df7314de01b93c7aa137968e925d4",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -16,16 +16,16 @@ categories = [\"no-std\"]\n description = \"\"\"\n A macro to generate structures which behave like bitflags.\n \"\"\"\n-exclude = [\"bors.toml\"]\n+exclude = [\"tests\", \".github\"]\n \n [dependencies]\n-core = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-core' }\n-compiler_builtins = { version = '0.1.2', optional = true }\n+serde = { version = \"1.0\", optional = true }\n+core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n+compiler_builtins = { version = \"0.1.2\", optional = true }\n \n [dev-dependencies]\n trybuild = \"1.0\"\n rustversion = \"1.0\"\n-serde = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n \n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -1,8 +1,5 @@\n use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n \n-#[doc(hidden)]\n-pub trait ImplementedByBitFlagsMacro {}\n-\n /// A trait that is automatically implemented for all bitflags.\n ///\n /// It should not be implemented manually.\n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -25,16 +22,7 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n     /// Convert from underlying bit representation, preserving all\n     /// bits (even those not corresponding to a defined flag).\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller of the `bitflags!` macro can chose to allow or\n-    /// disallow extra bits for their bitflags type.\n-    ///\n-    /// The caller of `from_bits_unchecked()` has to ensure that\n-    /// all bits correspond to a defined flag or that extra bits\n-    /// are valid for this bitflags type.\n-    unsafe fn from_bits_unchecked(bits: Self::Bits) -> Self;\n+    fn from_bits_retain(bits: Self::Bits) -> Self;\n     /// Returns `true` if no flags are currently stored.\n     fn is_empty(&self) -> bool;\n     /// Returns `true` if all flags are currently set.\n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -53,9 +41,22 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn set(&mut self, other: Self, value: bool);\n }\n \n+/// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n+///\n+/// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n+/// manual implementations won't break between non-breaking releases.\n+#[doc(hidden)]\n+pub trait ImplementedByBitFlagsMacro {}\n+\n // Not re-exported\n pub trait Sealed {}\n \n+// Private implementation details\n+//\n+// The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`\n+// macro that we're free to change here. They work with the `bitflags!` macro to separate the generated\n+// code that belongs to end-users, and the generated code that belongs to this library.\n+\n /// A private trait that encodes the requirements of underlying bits types that can hold flags.\n ///\n /// This trait may be made public at some future point, but it presents a compatibility hazard\n\ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -107,3 +108,11 @@ impl_bits! {\n     u64, i64,\n     u128, i128,\n }\n+\n+pub trait PublicFlags {\n+    type InternalFlags;\n+}\n+\n+pub trait InternalFlags {\n+    type PublicFlags;\n+}\n\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -9,6 +9,35 @@ bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n+\n+/// This is the same internal field available as `self.0` on bitflags types.\n+/// These types aren't reachable by callers of `bitflags!`, they don't appear in the API of your\n+/// crate, but you can still interact with them through `self.0` in the module that defines the\n+/// bitflags type.\n+///\n+/// You can use this example as a reference for what methods are available to all internal bitflags\n+/// fields if you want to add custom functionality to your bitflags types.\n+///\n+/// Note that this struct is just for documentation purposes only, it must not be used outside\n+/// this crate.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct FlagsField {\n+    bits: u32,\n+}\n+\n+__impl_internal_bitflags! {\n+    FlagsField: u32 {\n+        A;\n+        B;\n+        C;\n+        ABC;\n+    }\n+}\n+\n+impl crate::__private::InternalFlags for FlagsField {\n+    type PublicFlags = Flags;\n+}\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -21,11 +21,12 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n //!         const C = 0b00000100;\n-//!         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+//!         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n //!     }\n //! }\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -51,6 +52,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -59,14 +61,7 @@\n //!\n //! impl Flags {\n //!     pub fn clear(&mut self) {\n-//!         self.bits = 0;  // The `bits` field can be accessed from within the\n-//!                         // same module where the `bitflags!` macro was invoked.\n-//!     }\n-//! }\n-//!\n-//! impl fmt::Display for Flags {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f, \"hi!\")\n+//!         *self.0.bits_mut() = 0;\n //!     }\n //! }\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -74,9 +69,8 @@\n //!     let mut flags = Flags::A | Flags::B;\n //!     flags.clear();\n //!     assert!(flags.is_empty());\n-//!     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-//!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-//!     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n //! }\n //! ```\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -91,10 +85,12 @@\n //!     use bitflags::bitflags;\n //!\n //!     bitflags! {\n+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!         pub struct Flags1: u32 {\n //!             const A = 0b00000001;\n //!         }\n //!\n+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //! #       pub\n //!         struct Flags2: u32 {\n //!             const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -123,6 +119,7 @@\n //!\n //! bitflags! {\n //!     #[repr(transparent)]\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -133,13 +130,8 @@\n //!\n //! # Trait implementations\n //!\n-//! The `Copy`, `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and `Hash`\n-//! traits are automatically derived for the `struct`s using the `derive` attribute.\n-//! Additional traits can be derived by providing an explicit `derive`\n-//! attribute on `struct`.\n-//!\n-//! The `Extend` and `FromIterator` traits are implemented for the `struct`s,\n-//! too: `Extend` adds the union of the instances of the `struct` iterated over,\n+//! The `Extend` and `FromIterator` traits are implemented for the `struct`s.\n+//! `Extend` adds the union of the instances of the `struct` iterated over,\n //! while `FromIterator` calculates the union.\n //!\n //! The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` traits are also\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -167,7 +159,7 @@\n //!                defined flag\n //! - `from_bits_truncate`: convert from underlying bit representation, dropping\n //!                         any bits that do not correspond to defined flags\n-//! - `from_bits_unchecked`: convert from underlying bit representation, keeping\n+//! - `from_bits_retain`: convert from underlying bit representation, keeping\n //!                          all bits (even those not corresponding to defined\n //!                          flags)\n //! - `is_empty`: `true` if no flags are currently stored\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -204,7 +196,7 @@\n //!\n //! bitflags! {\n //!     // Results in default value with bits: 0\n-//!     #[derive(Default)]\n+//!     #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -224,6 +216,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -252,6 +245,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const NONE = 0b00000000;\n //!         const SOME = 0b00000001;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -285,10 +279,62 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n-    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro, InternalFlags, PublicFlags};\n     pub use core;\n+\n+    #[cfg(feature = \"serde\")]\n+    pub use serde;\n }\n \n+/*\n+How does the bitflags crate work?\n+\n+This library generates `struct`s in the end-user's crate with a bunch of constants on it that represent flags.\n+The difference between `bitflags` and a lot of other libraries is that we don't actually control the generated `struct` in the end.\n+It's part of the end-user's crate, so it belongs to them. That makes it difficult to extend `bitflags` with new functionality\n+because we could end up breaking valid code that was already written.\n+\n+Our solution is to split the type we generate into two: the public struct owned by the end-user, and an internal struct owned by `bitflags` (us).\n+To give you an example, let's say we had a crate that called `bitflags!`:\n+\n+```rust\n+bitflags! {\n+    pub struct MyFlags: u32 {\n+        const A = 1;\n+        const B = 2;\n+    }\n+}\n+```\n+\n+What they'd end up with looks something like this:\n+\n+```rust\n+pub struct MyFlags(<MyFlags as PublicFlags>::InternalFlags);\n+\n+const _: () = {\n+    #[repr(transparent)]\n+    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+    pub struct MyInternalFlags {\n+        bits: u32,\n+    }\n+\n+    impl PublicFlags for MyFlags {\n+        type InternalFlags = InternalFlags;\n+    }\n+\n+    impl InternalFlags for MyInternalFlags {\n+        type PublicFlags = MyFlags;\n+    }\n+};\n+```\n+\n+If we want to expose something like a new trait impl for generated flags types, we add it to our generated `MyInternalFlags`,\n+and let `#[derive]` on `MyFlags` pick up that implementation, if an end-user chooses to add one.\n+\n+The public API is generated in the `__impl_bitflags_public!` macro, and the internal API is generated in\n+the `__impl_bitflags_internal!` macro.\n+*/\n+\n /// The macro used to generate the flag structure.\n ///\n /// See the [crate level docs](../bitflags/index.html) for complete documentation.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -299,11 +345,12 @@ pub mod __private {\n /// use bitflags::bitflags;\n ///\n /// bitflags! {\n+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n ///     struct Flags: u32 {\n ///         const A = 0b00000001;\n ///         const B = 0b00000010;\n ///         const C = 0b00000100;\n-///         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+///         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n ///     }\n /// }\n ///\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -326,6 +373,7 @@ pub mod __private {\n /// use bitflags::bitflags;\n ///\n /// bitflags! {\n+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n ///     struct Flags: u32 {\n ///         const A = 0b00000001;\n ///         const B = 0b00000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -334,14 +382,7 @@ pub mod __private {\n ///\n /// impl Flags {\n ///     pub fn clear(&mut self) {\n-///         self.bits = 0;  // The `bits` field can be accessed from within the\n-///                         // same module where the `bitflags!` macro was invoked.\n-///     }\n-/// }\n-///\n-/// impl fmt::Display for Flags {\n-///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-///         write!(f, \"hi!\")\n+///         *self.0.bits_mut() = 0;\n ///     }\n /// }\n ///\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -349,9 +390,8 @@ pub mod __private {\n ///     let mut flags = Flags::A | Flags::B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n-///     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-///     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-///     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+///     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+///     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n /// }\n /// ```\n #[macro_export(local_inner_macros)]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -368,12 +408,9 @@ macro_rules! bitflags {\n         $($t:tt)*\n     ) => {\n         $(#[$outer])*\n-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $vis struct $BitFlags {\n-            bits: $T,\n-        }\n+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::InternalFlags);\n \n-        __impl_bitflags! {\n+        __impl_public_bitflags! {\n             $BitFlags: $T {\n                 $(\n                     $(#[$inner $($args)*])*\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -382,6 +419,31 @@ macro_rules! bitflags {\n             }\n         }\n \n+        const _: () = {\n+            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+            #[repr(transparent)]\n+            $vis struct InternalFlags {\n+                bits: $T,\n+            }\n+\n+            __impl_internal_bitflags! {\n+                InternalFlags: $T {\n+                    $(\n+                        $(#[$inner $($args)*])*\n+                        $Flag;\n+                    )*\n+                }\n+            }\n+\n+            impl $crate::__private::InternalFlags for InternalFlags {\n+                type PublicFlags = $BitFlags;\n+            }\n+\n+            impl $crate::__private::PublicFlags for $BitFlags {\n+                type InternalFlags = InternalFlags;\n+            }\n+        };\n+\n         bitflags! {\n             $($t)*\n         }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -389,70 +451,42 @@ macro_rules! bitflags {\n     () => {};\n }\n \n+/// Implement functions on the public (user-facing) bitflags type.\n+///\n+/// We need to be careful about adding new methods and trait implementations here because they\n+/// could conflict with items added by the end-user.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_bitflags {\n+macro_rules! __impl_public_bitflags {\n     (\n-        $BitFlags:ident: $T:ty {\n+        $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\n             )*\n         }\n     ) => {\n-        impl $crate::__private::core::fmt::Debug for $BitFlags {\n+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                // Iterate over the valid flags\n-                let mut first = true;\n-                for (name, _) in self.iter() {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    first = false;\n-                    f.write_str(name)?;\n-                }\n-\n-                // Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = self.bits & !Self::all().bits();\n-\n-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-                    first = false;\n-                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n-                }\n-\n-                if first {\n-                    f.write_str(\"(empty)\")?;\n-                }\n-\n-                $crate::__private::core::fmt::Result::Ok(())\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::Binary for $BitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::Octal for $BitFlags {\n+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::LowerHex for $BitFlags {\n+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $BitFlags {\n+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -464,40 +498,37 @@ macro_rules! __impl_bitflags {\n             unused_mut,\n             non_upper_case_globals\n         )]\n-        impl $BitFlags {\n+        impl $PublicBitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n-                pub const $Flag: Self = Self { bits: $value };\n+                pub const $Flag: Self = Self::from_bits_retain($value);\n             )*\n \n             /// Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::empty())\n             }\n \n             /// Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::all())\n             }\n \n             /// Returns the raw value of the flags currently stored.\n             #[inline]\n             pub const fn bits(&self) -> $T {\n-                self.bits\n+                self.0.bits()\n             }\n \n             /// Convert from underlying bit representation, unless that\n             /// representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                let truncated = Self::from_bits_truncate(bits).bits;\n-\n-                if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self { bits })\n-                } else {\n-                    $crate::__private::core::option::Option::None\n+                match <$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits(bits) {\n+                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n                 }\n             }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -505,20 +536,7 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == <$T as $crate::__private::Bits>::EMPTY {\n-                    return Self { bits }\n-                }\n-\n-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n-\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n-                        truncated |= Self::$Flag.bits\n-                    }\n-                )*\n-\n-                Self { bits: truncated }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_truncate(bits))\n             }\n \n             /// Convert from underlying bit representation, preserving all\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -529,64 +547,60 @@ macro_rules! __impl_bitflags {\n             /// The caller of the `bitflags!` macro can choose to allow or\n             /// disallow extra bits for their bitflags type.\n             ///\n-            /// The caller of `from_bits_unchecked()` has to ensure that\n+            /// The caller of `from_bits_retain()` has to ensure that\n             /// all bits correspond to a defined flag or that extra bits\n             /// are valid for this bitflags type.\n             #[inline]\n-            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n-                Self { bits }\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_retain(bits))\n             }\n \n             /// Returns `true` if no flags are currently stored.\n             #[inline]\n             pub const fn is_empty(&self) -> bool {\n-                self.bits() == Self::empty().bits()\n+                self.0.is_empty()\n             }\n \n             /// Returns `true` if all flags are currently set.\n             #[inline]\n             pub const fn is_all(&self) -> bool {\n-                Self::all().bits | self.bits == self.bits\n+                self.0.is_all()\n             }\n \n             /// Returns `true` if there are flags common to both `self` and `other`.\n             #[inline]\n             pub const fn intersects(&self, other: Self) -> bool {\n-                !(Self { bits: self.bits & other.bits}).is_empty()\n+                self.0.intersects(other.0)\n             }\n \n             /// Returns `true` if all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub const fn contains(&self, other: Self) -> bool {\n-                (self.bits & other.bits) == other.bits\n+                self.0.contains(other.0)\n             }\n \n             /// Inserts the specified flags in-place.\n             #[inline]\n             pub fn insert(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0.insert(other.0)\n             }\n \n             /// Removes the specified flags in-place.\n             #[inline]\n             pub fn remove(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0.remove(other.0)\n             }\n \n             /// Toggles the specified flags in-place.\n             #[inline]\n             pub fn toggle(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0.toggle(other.0)\n             }\n \n             /// Inserts or removes the specified flags depending on the passed value.\n             #[inline]\n             pub fn set(&mut self, other: Self, value: bool) {\n-                if value {\n-                    self.insert(other);\n-                } else {\n-                    self.remove(other);\n-                }\n+                self.0.set(other.0, value)\n             }\n \n             /// Returns the intersection between the flags in `self` and\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -602,7 +616,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn intersection(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                Self(self.0.intersection(other.0))\n             }\n \n             /// Returns the union of between the flags in `self` and `other`.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -619,7 +633,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn union(self, other: Self) -> Self {\n-                Self { bits: self.bits | other.bits }\n+                Self(self.0.union(other.0))\n             }\n \n             /// Returns the difference between the flags in `self` and `other`.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -637,7 +651,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn difference(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                Self(self.0.difference(other.0))\n             }\n \n             /// Returns the [symmetric difference][sym-diff] between the flags\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -656,7 +670,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                Self(self.0.symmetric_difference(other.0))\n             }\n \n             /// Returns the complement of this set of flags.\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -675,159 +689,101 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn complement(self) -> Self {\n-                Self::from_bits_truncate(!self.bits)\n+                Self(self.0.complement())\n             }\n \n             /// Returns an iterator over set flags and their names.\n             pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n-                const NUM_FLAGS: usize = {\n-                    let mut num_flags = 0;\n-\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n-                    )*\n-\n-                    num_flags\n-                };\n-\n-                const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag,\n-                    )*\n-                ];\n-\n-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n-                    )*\n-                ];\n-\n-                let mut start = 0;\n-                let mut state = self;\n-\n-                $crate::__private::core::iter::from_fn(move || {\n-                    if state.is_empty() || NUM_FLAGS == 0 {\n-                        $crate::__private::core::option::Option::None\n-                    } else {\n-                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n-                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n-                        {\n-                            start += 1;\n-\n-                            // NOTE: We check whether the flag exists in self, but remove it from\n-                            // a different value. This ensure that overlapping flags are handled\n-                            // properly. Take the following example:\n-                            //\n-                            // const A: 0b00000001;\n-                            // const B: 0b00000101;\n-                            //\n-                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n-                            // as we encountered it we'd be left with 0b00000100, which doesn't\n-                            // correspond to a valid flag on its own.\n-                            if self.contains(flag) {\n-                                state.remove(flag);\n-\n-                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n-                            }\n-                        }\n-\n-                        $crate::__private::core::option::Option::None\n-                    }\n-                })\n+                self.0.iter().map(|(name, bits)| (name, Self::from_bits_retain(bits)))\n             }\n \n         }\n \n-        impl $crate::__private::core::ops::BitOr for $BitFlags {\n+        impl $crate::__private::core::ops::BitOr for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the union of the two sets of flags.\n             #[inline]\n-            fn bitor(self, other: $BitFlags) -> Self {\n-                Self { bits: self.bits | other.bits }\n+            fn bitor(self, other: $PublicBitFlags) -> Self {\n+                self.union(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitOrAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {\n             /// Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0 = self.0.union(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXor for $BitFlags {\n+        impl $crate::__private::core::ops::BitXor for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n             fn bitxor(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                self.symmetric_difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXorAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {\n             /// Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0 = self.0.symmetric_difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAnd for $BitFlags {\n+        impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n             fn bitand(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                self.intersection(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAndAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {\n             /// Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.bits &= other.bits;\n+                self.0 = self.0.intersection(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Sub for $BitFlags {\n+        impl $crate::__private::core::ops::Sub for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n             fn sub(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                self.difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::SubAssign for $BitFlags {\n+        impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {\n             /// Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0 = self.0.difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Not for $BitFlags {\n+        impl $crate::__private::core::ops::Not for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the complement of this set of flags.\n             #[inline]\n             fn not(self) -> Self {\n-                Self { bits: !self.bits } & Self::all()\n+                self.complement()\n             }\n         }\n \n-        impl $crate::__private::core::iter::Extend<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n             fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                 for item in iterator {\n                     self.insert(item)\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -835,7 +791,7 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::__private::core::iter::FromIterator<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                 use $crate::__private::core::iter::Extend;\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -845,181 +801,421 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::BitFlags for $BitFlags {\n+        impl $crate::BitFlags for $PublicBitFlags {\n             type Bits = $T;\n \n             fn empty() -> Self {\n-                $BitFlags::empty()\n+                $PublicBitFlags::empty()\n             }\n \n             fn all() -> Self {\n-                $BitFlags::all()\n+                $PublicBitFlags::all()\n             }\n \n             fn bits(&self) -> $T {\n-                $BitFlags::bits(self)\n+                $PublicBitFlags::bits(self)\n             }\n \n-            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$BitFlags> {\n-                $BitFlags::from_bits(bits)\n+            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n+                $PublicBitFlags::from_bits(bits)\n             }\n \n-            fn from_bits_truncate(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_truncate(bits)\n+            fn from_bits_truncate(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_truncate(bits)\n             }\n \n-            unsafe fn from_bits_unchecked(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_unchecked(bits)\n+            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_retain(bits)\n             }\n \n             fn is_empty(&self) -> bool {\n-                $BitFlags::is_empty(self)\n+                $PublicBitFlags::is_empty(self)\n             }\n \n             fn is_all(&self) -> bool {\n-                $BitFlags::is_all(self)\n+                $PublicBitFlags::is_all(self)\n             }\n \n-            fn intersects(&self, other: $BitFlags) -> bool {\n-                $BitFlags::intersects(self, other)\n+            fn intersects(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::intersects(self, other)\n             }\n \n-            fn contains(&self, other: $BitFlags) -> bool {\n-                $BitFlags::contains(self, other)\n+            fn contains(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::contains(self, other)\n             }\n \n-            fn insert(&mut self, other: $BitFlags) {\n-                $BitFlags::insert(self, other)\n+            fn insert(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::insert(self, other)\n             }\n \n-            fn remove(&mut self, other: $BitFlags) {\n-                $BitFlags::remove(self, other)\n+            fn remove(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::remove(self, other)\n             }\n \n-            fn toggle(&mut self, other: $BitFlags) {\n-                $BitFlags::toggle(self, other)\n+            fn toggle(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::toggle(self, other)\n             }\n \n-            fn set(&mut self, other: $BitFlags, value: bool) {\n-                $BitFlags::set(self, other, value)\n+            fn set(&mut self, other: $PublicBitFlags, value: bool) {\n+                $PublicBitFlags::set(self, other, value)\n             }\n         }\n \n-        impl $crate::__private::ImplementedByBitFlagsMacro for $BitFlags {}\n+        impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}\n     };\n+}\n \n-    // Every attribute that the user writes on a const is applied to the\n-    // corresponding const that we generate, but within the implementation of\n-    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    // particular, including a #[deprecated] attribute on those items would fail\n-    // to compile.\n-    // https://github.com/bitflags/bitflags/issues/109\n-    //\n-    // Input:\n-    //\n-    //     ? #[cfg(feature = \"advanced\")]\n-    //     ? #[deprecated(note = \"Use something else.\")]\n-    //     ? #[doc = r\"High quality documentation.\"]\n-    //     fn f() -> i32 { /* ... */ }\n-    //\n-    // Output:\n-    //\n-    //     #[cfg(feature = \"advanced\")]\n-    //     fn f() -> i32 { /* ... */ }\n+/// Implement functions on the private (bitflags-facing) bitflags type.\n+///\n+/// Methods and trait implementations can be freely added here without breaking end-users.\n+/// If we want to expose new functionality to `#[derive]`, this is the place to do it.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_internal_bitflags {\n     (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        // $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            // $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        // Any new library traits impls should be added here\n+        __impl_internal_bitflags_serde! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        fn $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        fn $($item)*\n-    };\n \n-    // Every attribute that the user writes on a const is applied to the\n-    // corresponding const that we generate, but within the implementation of\n-    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    // particular, including a #[deprecated] attribute on those items would fail\n-    // to compile.\n-    // https://github.com/bitflags/bitflags/issues/109\n-    //\n-    // const version\n-    //\n-    // Input:\n-    //\n-    //     ? #[cfg(feature = \"advanced\")]\n-    //     ? #[deprecated(note = \"Use something else.\")]\n-    //     ? #[doc = r\"High quality documentation.\"]\n-    //     const f: i32 { /* ... */ }\n-    //\n-    // Output:\n-    //\n-    //     #[cfg(feature = \"advanced\")]\n-    //     const f: i32 { /* ... */ }\n-    (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::core::default::Default for $InternalBitFlags {\n+            #[inline]\n+            fn default() -> Self {\n+                $InternalBitFlags::empty()\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Debug for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                // Iterate over the valid flags\n+                let mut first = true;\n+                for (name, _) in self.iter() {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+\n+                    first = false;\n+                    f.write_str(name)?;\n+                }\n+\n+                // Append any extra bits that correspond to flags to the end of the format\n+                let extra_bits = self.bits & !Self::all().bits;\n+\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+                    first = false;\n+                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n+                }\n+\n+                if first {\n+                    f.write_str(\"empty\")?;\n+                }\n+\n+                $crate::__private::core::fmt::Result::Ok(())\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Binary for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Octal for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n+        impl $InternalBitFlags {\n+            #[inline]\n+            pub const fn empty() -> Self {\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+            }\n+\n+            #[inline]\n+            pub const fn all() -> Self {\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+            }\n+\n+            #[inline]\n+            pub const fn bits(&self) -> $T {\n+                self.bits\n+            }\n+\n+            #[inline]\n+            pub fn bits_mut(&mut self) -> &mut $T {\n+                &mut self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+\n+                if truncated == bits {\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n+                } else {\n+                    $crate::__private::core::option::Option::None\n+                }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_truncate(bits: $T) -> Self {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n+                    return Self { bits }\n+                }\n+\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n+\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    if bits & <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() == <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() {\n+                        truncated |= <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits()\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self { bits }\n+            }\n+\n+            #[inline]\n+            pub const fn is_empty(&self) -> bool {\n+                self.bits == Self::empty().bits\n+            }\n+\n+            #[inline]\n+            pub const fn is_all(&self) -> bool {\n+                Self::all().bits | self.bits == self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn intersects(&self, other: Self) -> bool {\n+                !(Self { bits: self.bits & other.bits}).is_empty()\n+            }\n+\n+            #[inline]\n+            pub const fn contains(&self, other: Self) -> bool {\n+                (self.bits & other.bits) == other.bits\n+            }\n+\n+            #[inline]\n+            pub fn insert(&mut self, other: Self) {\n+                self.bits |= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn remove(&mut self, other: Self) {\n+                self.bits &= !other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn toggle(&mut self, other: Self) {\n+                self.bits ^= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn set(&mut self, other: Self, value: bool) {\n+                if value {\n+                    self.insert(other);\n+                } else {\n+                    self.remove(other);\n+                }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn intersection(self, other: Self) -> Self {\n+                Self { bits: self.bits & other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn union(self, other: Self) -> Self {\n+                Self { bits: self.bits | other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn difference(self, other: Self) -> Self {\n+                Self { bits: self.bits & !other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn symmetric_difference(self, other: Self) -> Self {\n+                Self { bits: self.bits ^ other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn complement(self) -> Self {\n+                Self::from_bits_truncate(!self.bits)\n+            }\n+\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, $T)> {\n+                use $crate::__private::core::iter::Iterator as _;\n+\n+                const NUM_FLAGS: usize = {\n+                    let mut num_flags = 0;\n+\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            num_flags += 1;\n+                        }\n+                    )*\n+\n+                    num_flags\n+                };\n+\n+                const OPTIONS: [$T; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits(),\n+                    )*\n+                ];\n+\n+                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        $crate::__private::core::stringify!($Flag),\n+                    )*\n+                ];\n+\n+                let mut start = 0;\n+                let mut state = self;\n+\n+                $crate::__private::core::iter::from_fn(move || {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n+                        $crate::__private::core::option::Option::None\n+                    } else {\n+                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n+                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n+                        {\n+                            start += 1;\n+\n+                            // NOTE: We check whether the flag exists in self, but remove it from\n+                            // a different value. This ensure that overlapping flags are handled\n+                            // properly. Take the following example:\n+                            //\n+                            // const A: 0b00000001;\n+                            // const B: 0b00000101;\n+                            //\n+                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            // as we encountered it we'd be left with 0b00000100, which doesn't\n+                            // correspond to a valid flag on its own.\n+                            if self.contains(Self { bits: flag }) {\n+                                state.remove(Self { bits: flag });\n+\n+                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n+                            }\n+                        }\n+\n+                        $crate::__private::core::option::Option::None\n+                    }\n+                })\n+            }\n         }\n     };\n+}\n+\n+// Optional features\n+//\n+// These macros implement additional library traits for the internal bitflags type so that\n+// the end-user can either implement or derive those same traits based on the implementation\n+// we provide in `bitflags`.\n+//\n+// These macros all follow a  similar pattern. If an optional feature of `bitflags` is enabled\n+// they'll expand to some impl blocks based on a re-export of the library. If the optional feature\n+// is not enabled then they expand to a no-op.\n+\n+/// Implement `Serialize` and `Deserialize` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"serde\")]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        // $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            // $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n+            fn serialize<S: $crate::__private::serde::Serializer>(&self, serializer: S) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n+                $crate::serde_support::serialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), &self.bits, serializer)\n+            }\n         }\n-    };\n+\n+        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n+            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(deserializer: D) -> $crate::__private::core::result::Result<Self, D::Error> {\n+                let bits = $crate::serde_support::deserialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), deserializer)?;\n+\n+                $crate::__private::core::result::Result::Ok($InternalBitFlags::from_bits_retain(bits))\n+            }\n+        }\n+    }\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"serde\"))]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        const $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        const $($item)*\n-    };\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => { }\n }\n \n #[cfg(feature = \"example_generated\")]\n pub mod example_generated;\n \n+#[cfg(feature = \"serde\")]\n+pub mod serde_support;\n+\n #[cfg(test)]\n mod tests {\n     use std::collections::hash_map::DefaultHasher;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1030,7 +1226,7 @@ mod tests {\n         #[doc = \"> you are the easiest person to fool.\"]\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n-        #[derive(Default)]\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct Flags: u32 {\n             const A = 0b00000001;\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1039,28 +1235,32 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct _CfgFlags: u32 {\n             #[cfg(unix)]\n             const _CFG_A = 0b01;\n             #[cfg(windows)]\n             const _CFG_B = 0b01;\n             #[cfg(unix)]\n-            const _CFG_C = Self::_CFG_A.bits | 0b10;\n+            const _CFG_C = Self::_CFG_A.bits() | 0b10;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct AnotherSetOfFlags: i8 {\n             const ANOTHER_FLAG = -1_i8;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct LongFlags: u32 {\n             const LONG_A = 0b1111111111111111;\n         }\n     }\n \n     bitflags! {\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct EmptyFlags: u32 {\n         }\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1113,28 +1313,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_bits_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0) }, Flags::empty());\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1) }, Flags::A);\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b10) }, Flags::B);\n+    fn test_from_bits_retain() {\n+        let extra = Flags::from_bits_retain(0b1000);\n+        assert_eq!(Flags::from_bits_retain(0), Flags::empty());\n+        assert_eq!(Flags::from_bits_retain(0b1), Flags::A);\n+        assert_eq!(Flags::from_bits_retain(0b10), Flags::B);\n \n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b11) },\n+            Flags::from_bits_retain(0b11),\n             (Flags::A | Flags::B)\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1000) },\n+            Flags::from_bits_retain(0b1000),\n             (extra | Flags::empty())\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1001) },\n+            Flags::from_bits_retain(0b1001),\n             (extra | Flags::A)\n         );\n \n-        let extra = unsafe { EmptyFlags::from_bits_unchecked(0b1000) };\n+        let extra = EmptyFlags::from_bits_retain(0b1000);\n         assert_eq!(\n-            unsafe { EmptyFlags::from_bits_unchecked(0b1000) },\n+            EmptyFlags::from_bits_retain(0b1000),\n             (extra | EmptyFlags::empty())\n         );\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1157,7 +1357,7 @@ mod tests {\n         assert!(!Flags::A.is_all());\n         assert!(Flags::ABC.is_all());\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         assert!(!extra.is_all());\n         assert!(!(Flags::A | extra).is_all());\n         assert!((Flags::ABC | extra).is_all());\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1255,7 +1455,7 @@ mod tests {\n \n     #[test]\n     fn test_operators_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A | Flags::C | extra;\n         let e2 = Flags::B | Flags::C;\n         assert_eq!((e1 | e2), (Flags::ABC | extra)); // union\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1274,9 +1474,9 @@ mod tests {\n         let ab = Flags::A.union(Flags::B);\n         let ac = Flags::A.union(Flags::C);\n         let bc = Flags::B.union(Flags::C);\n-        assert_eq!(ab.bits, 0b011);\n-        assert_eq!(bc.bits, 0b110);\n-        assert_eq!(ac.bits, 0b101);\n+        assert_eq!(ab.bits(), 0b011);\n+        assert_eq!(bc.bits(), 0b110);\n+        assert_eq!(ac.bits(), 0b101);\n \n         assert_eq!(ab, Flags::B.union(Flags::A));\n         assert_eq!(ac, Flags::C.union(Flags::A));\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1329,10 +1529,10 @@ mod tests {\n \n     #[test]\n     fn test_set_ops_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A.union(Flags::C).union(extra);\n         let e2 = Flags::B.union(Flags::C);\n-        assert_eq!(e1.bits, 0b1101);\n+        assert_eq!(e1.bits(), 0b1101);\n         assert_eq!(e1.union(e2), (Flags::ABC | extra));\n         assert_eq!(e1.intersection(e2), Flags::C);\n         assert_eq!(e1.difference(e2), Flags::A | extra);\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1346,11 +1546,12 @@ mod tests {\n     fn test_set_ops_exhaustive() {\n         // Define a flag that contains gaps to help exercise edge-cases,\n         // especially around \"unknown\" flags (e.g. ones outside of `all()`\n-        // `from_bits_unchecked`).\n+        // `from_bits_retain`).\n         // - when lhs and rhs both have different sets of unknown flags.\n         // - unknown flags at both ends, and in the middle\n         // - cases with \"gaps\".\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Test: u16 {\n                 // Intentionally no `A`\n                 const B = 0b000000010;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1364,12 +1565,12 @@ mod tests {\n             }\n         }\n         let iter_test_flags =\n-            || (0..=0b111_1111_1111).map(|bits| unsafe { Test::from_bits_unchecked(bits) });\n+            || (0..=0b111_1111_1111).map(|bits| Test::from_bits_retain(bits));\n \n         for a in iter_test_flags() {\n             assert_eq!(\n                 a.complement(),\n-                Test::from_bits_truncate(!a.bits),\n+                Test::from_bits_truncate(!a.bits()),\n                 \"wrong result: !({:?})\",\n                 a,\n             );\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1378,37 +1579,37 @@ mod tests {\n                 // Check that the named operations produce the expected bitwise\n                 // values.\n                 assert_eq!(\n-                    a.union(b).bits,\n-                    a.bits | b.bits,\n+                    a.union(b).bits(),\n+                    a.bits() | b.bits(),\n                     \"wrong result: `{:?}` | `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.intersection(b).bits,\n-                    a.bits & b.bits,\n+                    a.intersection(b).bits(),\n+                    a.bits() & b.bits(),\n                     \"wrong result: `{:?}` & `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.symmetric_difference(b).bits,\n-                    a.bits ^ b.bits,\n+                    a.symmetric_difference(b).bits(),\n+                    a.bits() ^ b.bits(),\n                     \"wrong result: `{:?}` ^ `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.difference(b).bits,\n-                    a.bits & !b.bits,\n+                    a.difference(b).bits(),\n+                    a.bits() & !b.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     a,\n                     b,\n                 );\n                 // Note: Difference is checked as both `a - b` and `b - a`\n                 assert_eq!(\n-                    b.difference(a).bits,\n-                    b.bits & !a.bits,\n+                    b.difference(a).bits(),\n+                    b.bits() & !a.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     b,\n                     a,\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1577,28 +1778,28 @@ mod tests {\n \n     #[test]\n     fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+        let extra = Flags::from_bits_retain(0xb8);\n \n-        assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n-        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n+        assert_eq!(format!(\"{:?}\", extra), \"Flags(0xb8)\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"Flags(A | 0xb8)\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | ABC | 0xb8\"\n+            \"Flags(A | B | C | ABC | 0xb8)\"\n         );\n \n-        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n+        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"EmptyFlags(empty)\");\n     }\n \n     #[test]\n     fn test_binary() {\n         assert_eq!(format!(\"{:b}\", Flags::ABC), \"111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC), \"0b111\");\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1010000) };\n+        let extra = Flags::from_bits_retain(0b1010000);\n         assert_eq!(format!(\"{:b}\", Flags::ABC | extra), \"1010111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC | extra), \"0b1010111\");\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1607,7 +1808,7 @@ mod tests {\n     fn test_octal() {\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A), \"177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A), \"0o177777\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0o5000000) };\n+        let extra = LongFlags::from_bits_retain(0o5000000);\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A | extra), \"5177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A | extra), \"0o5177777\");\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1616,7 +1817,7 @@ mod tests {\n     fn test_lowerhex() {\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A), \"ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A), \"0xffff\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A | extra), \"e0ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A | extra), \"0xe0ffff\");\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1625,17 +1826,19 @@ mod tests {\n     fn test_upperhex() {\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A), \"FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A), \"0xFFFF\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A | extra), \"E0FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A | extra), \"0xE0FFFF\");\n     }\n \n     mod submodule {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct PublicFlags: i8 {\n                 const X = 0;\n             }\n \n+            #[derive(Clone, Copy)]\n             struct PrivateFlags: i8 {\n                 const Y = 0;\n             }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1659,6 +1862,7 @@ mod tests {\n \n         bitflags! {\n             /// baz\n+            #[derive(Clone, Copy)]\n             struct Flags: foo::Bar {\n                 const A = 0b00000001;\n                 #[cfg(foo)]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1672,19 +1876,21 @@ mod tests {\n     #[test]\n     fn test_in_function() {\n         bitflags! {\n-           struct Flags: u8 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u8 {\n                 const A = 1;\n                 #[cfg(any())] // false\n                 const B = 2;\n             }\n         }\n         assert_eq!(Flags::all(), Flags::A);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"A\");\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n     }\n \n     #[test]\n     fn test_deprecated() {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct TestFlags: u32 {\n                 #[deprecated(note = \"Use something else.\")]\n                 const ONE = 1;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1696,6 +1902,7 @@ mod tests {\n     fn test_pub_crate() {\n         mod module {\n             bitflags! {\n+                #[derive(Clone, Copy)]\n                 pub (crate) struct Test: u8 {\n                     const FOO = 1;\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1712,6 +1919,7 @@ mod tests {\n                 bitflags! {\n                     // `pub (in super)` means only the module `module` will\n                     // be able to access this.\n+                    #[derive(Clone, Copy)]\n                     pub (in super) struct Test: u8 {\n                         const FOO = 1;\n                     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1737,6 +1945,7 @@ mod tests {\n     #[test]\n     fn test_zero_value_flags() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const NONE = 0b0;\n                 const SOME = 0b1;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1747,8 +1956,8 @@ mod tests {\n         assert!(Flags::SOME.contains(Flags::NONE));\n         assert!(Flags::NONE.is_empty());\n \n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::SOME), \"NONE | SOME\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::SOME), \"Flags(NONE | SOME)\");\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1759,69 +1968,33 @@ mod tests {\n     #[test]\n     fn test_u128_bitflags() {\n         bitflags! {\n-            struct Flags128: u128 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u128 {\n                 const A = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n                 const B = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n                 const C = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-                const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+                const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n             }\n         }\n \n-        assert_eq!(Flags128::ABC, Flags128::A | Flags128::B | Flags128::C);\n-        assert_eq!(Flags128::A.bits, 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-        assert_eq!(Flags128::B.bits, 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-        assert_eq!(Flags128::C.bits, 0x8000_0000_0000_0000_0000_0000_0000_0000);\n+        assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n+        assert_eq!(Flags::A.bits(), 0x0000_0000_0000_0000_0000_0000_0000_0001);\n+        assert_eq!(Flags::B.bits(), 0x0000_0000_0000_1000_0000_0000_0000_0000);\n+        assert_eq!(Flags::C.bits(), 0x8000_0000_0000_0000_0000_0000_0000_0000);\n         assert_eq!(\n-            Flags128::ABC.bits,\n+            Flags::ABC.bits(),\n             0x8000_0000_0000_1000_0000_0000_0000_0001\n         );\n-        assert_eq!(format!(\"{:?}\", Flags128::A), \"A\");\n-        assert_eq!(format!(\"{:?}\", Flags128::B), \"B\");\n-        assert_eq!(format!(\"{:?}\", Flags128::C), \"C\");\n-        assert_eq!(format!(\"{:?}\", Flags128::ABC), \"A | B | C\");\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_serialize() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let serialized = serde_json::to_string(&flags).unwrap();\n-\n-        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_deserialize() {\n-        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n-\n-        let expected = SerdeFlags::C | SerdeFlags::D;\n-\n-        assert_eq!(deserialized.bits, expected.bits);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_roundtrip() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let deserialized: SerdeFlags =\n-            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n-\n-        assert_eq!(deserialized.bits, flags.bits);\n-    }\n-\n-    bitflags! {\n-        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n-        struct SerdeFlags: u32 {\n-            const A = 1;\n-            const B = 2;\n-            const C = 4;\n-            const D = 8;\n-        }\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n+        assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::C), \"Flags(C)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n     }\n \n     #[test]\n     fn test_from_bits_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1837,6 +2010,7 @@ mod tests {\n     #[test]\n     fn test_from_bits_truncate_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1852,6 +2026,7 @@ mod tests {\n     #[test]\n     fn test_iter() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const ONE  = 0b001;\n                 const TWO  = 0b010;\n\ndiff --git /dev/null b/src/serde_support.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/serde_support.rs\n@@ -0,0 +1,84 @@\n+use core::fmt;\n+use serde::{Serializer, Deserializer, Serialize, Deserialize, ser::SerializeStruct, de::{Error, MapAccess, Visitor}};\n+\n+// These methods are compatible with the result of `#[derive(Serialize, Deserialize)]` on bitflags `1.0` types\n+\n+pub fn serialize_bits_default<B: Serialize, S: Serializer>(name: &'static str, bits: &B, serializer: S) -> Result<S::Ok, S::Error> {\n+    let mut serialize_struct = serializer.serialize_struct(name, 1)?;\n+    serialize_struct.serialize_field(\"bits\", bits)?;\n+    serialize_struct.end()\n+}\n+\n+pub fn deserialize_bits_default<'de, B: Deserialize<'de>, D: Deserializer<'de>>(name: &'static str, deserializer: D) -> Result<B, D::Error> {\n+    struct BitsVisitor<T>(core::marker::PhantomData<T>);\n+\n+    impl<'de, T: Deserialize<'de>> Visitor<'de> for BitsVisitor<T> {\n+        type Value = T;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"a primitive bitflags value wrapped in a struct\")\n+        }\n+\n+        fn visit_map<A: MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {\n+            let mut bits = None;\n+\n+            while let Some(key) = map.next_key()? {\n+                match key {\n+                    \"bits\" => {\n+                        if bits.is_some() {\n+                            return Err(Error::duplicate_field(\"bits\"));\n+                        }\n+\n+                        bits = Some(map.next_value()?);\n+                    }\n+                    v => return Err(Error::unknown_field(v, &[\"bits\"]))\n+                }\n+            }\n+\n+            bits.ok_or_else(|| Error::missing_field(\"bits\"))\n+        }\n+    }\n+\n+    deserializer.deserialize_struct(name, &[\"bits\"], BitsVisitor(Default::default()))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    bitflags! {\n+        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n+        struct SerdeFlags: u32 {\n+            const A = 1;\n+            const B = 2;\n+            const C = 4;\n+            const D = 8;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_serialize() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let serialized = serde_json::to_string(&flags).unwrap();\n+\n+        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_deserialize() {\n+        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n+\n+        let expected = SerdeFlags::C | SerdeFlags::D;\n+\n+        assert_eq!(deserialized.bits(), expected.bits());\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_roundtrip() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+\n+        assert_eq!(deserialized.bits(), flags.bits());\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/tests/compile-fail/impls/copy.stderr /dev/null\n--- a/tests/compile-fail/impls/copy.stderr\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `Flags`\n- --> $DIR/copy.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |                     ---- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::clone::Clone` for type `Flags`\n- --> $DIR/copy.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |              ----- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git a/tests/compile-fail/impls/eq.stderr /dev/null\n--- a/tests/compile-fail/impls/eq.stderr\n+++ /dev/null\n@@ -1,55 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralPartialEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::PartialEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::Eq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -4,6 +4,16 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 116 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n note: required by a bound in `bitflags::BitFlags::Bits`\n    --> src/bitflags_trait.rs\n     |\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -22,7 +32,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -36,7 +56,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -50,7 +80,69 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -64,4 +156,142 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n+    |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git a/tests/compile-fail/non_integer_base/all_missing.stderr b/tests/compile-fail/non_integer_base/all_missing.stderr\n--- a/tests/compile-fail/non_integer_base/all_missing.stderr\n+++ b/tests/compile-fail/non_integer_base/all_missing.stderr\n@@ -1,5 +1,5 @@\n error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/all_missing.rs:5:1\n+  --> tests/compile-fail/non_integer_base/all_missing.rs:5:1\n    |\n 5  | / bitflags! {\n 6  | |     struct Flags128: MyInt {\n\ndiff --git a/tests/compile-fail/non_integer_base/all_missing.stderr b/tests/compile-fail/non_integer_base/all_missing.stderr\n--- a/tests/compile-fail/non_integer_base/all_missing.stderr\n+++ b/tests/compile-fail/non_integer_base/all_missing.stderr\n@@ -10,4 +10,4 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 11 | | }\n    | |_^ this field does not implement `Copy`\n    |\n-   = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Copy` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\ndiff --git /dev/null b/tests/compile-fail/redefined.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/redefined.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\n\ndiff --git /dev/null b/tests/compile-fail/redefined.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/redefined.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/redefined.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error: no rules expected the token `{`\n+  --> tests/compile-fail/redefined.rs:11:23\n+   |\n+11 |     pub struct Flags1 {\n+   |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+  --> tests/compile-fail/redefined.rs:14:2\n+   |\n+14 | }\n+   |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/redefined.rs`\n\ndiff --git /dev/null b/tests/compile-fail/syntax/missing_type.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_type.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\n\ndiff --git /dev/null b/tests/compile-fail/syntax/missing_type.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_type.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/syntax/missing_type.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/syntax/missing_type.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_type.rs`\n\ndiff --git /dev/null b/tests/compile-fail/syntax/missing_value.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_value.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A;\n+    }\n+}\n\ndiff --git /dev/null b/tests/compile-fail/syntax/missing_value.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_value.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/syntax/missing_value.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/syntax/missing_value.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_value.rs`\n\ndiff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ b/tests/compile-fail/trait/custom_impl.rs\n@@ -25,7 +25,7 @@ impl BitFlags for BootlegFlags {\n         unimplemented!()\n     }\n \n-    unsafe fn from_bits_unchecked(_: u32) -> BootlegFlags {\n+    fn from_bits_retain(_: u32) -> BootlegFlags {\n         unimplemented!()\n     }\n \n\ndiff --git a/tests/compile-fail/visibility/private_field.rs /dev/null\n--- a/tests/compile-fail/visibility/private_field.rs\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-mod example {\n-    use bitflags::bitflags;\n-\n-    bitflags! {\n-        pub struct Flags1: u32 {\n-            const FLAG_A = 0b00000001;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let flag1 = example::Flags1::FLAG_A.bits;\n-}\n\ndiff --git a/tests/compile-fail/visibility/private_field.stderr /dev/null\n--- a/tests/compile-fail/visibility/private_field.stderr\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-error[E0616]: field `bits` of struct `Flags1` is private\n-  --> $DIR/private_field.rs:12:41\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits;\n-   |                                         ^^^^ private field\n-   |\n-help: a method `bits` also exists, call it with parentheses\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits();\n-   |                                             ++\n\ndiff --git a/tests/compile-fail/visibility/private_flags.rs b/tests/compile-fail/visibility/private_flags.rs\n--- a/tests/compile-fail/visibility/private_flags.rs\n+++ b/tests/compile-fail/visibility/private_flags.rs\n@@ -13,6 +13,6 @@ mod example {\n }\n \n fn main() {\n-    let flag1 = example::Flags1::FLAG_A;\n-    let flag2 = example::Flags2::FLAG_B;\n+    let _ = example::Flags1::FLAG_A;\n+    let _ = example::Flags2::FLAG_B;\n }\n\ndiff --git a/tests/compile-fail/visibility/private_flags.stderr b/tests/compile-fail/visibility/private_flags.stderr\n--- a/tests/compile-fail/visibility/private_flags.stderr\n+++ b/tests/compile-fail/visibility/private_flags.stderr\n@@ -1,11 +1,11 @@\n error[E0603]: struct `Flags2` is private\n-  --> $DIR/private_flags.rs:17:26\n+  --> tests/compile-fail/visibility/private_flags.rs:17:22\n    |\n-17 |     let flag2 = example::Flags2::FLAG_B;\n-   |                          ^^^^^^ private struct\n+17 |     let _ = example::Flags2::FLAG_B;\n+   |                      ^^^^^^ private struct\n    |\n note: the struct `Flags2` is defined here\n-  --> $DIR/private_flags.rs:4:5\n+  --> tests/compile-fail/visibility/private_flags.rs:4:5\n    |\n 4  | /     bitflags! {\n 5  | |         pub struct Flags1: u32 {\n\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impls/fmt.rs\n--- a/tests/compile-pass/impls/fmt.rs\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -1,6 +1,7 @@\n use bitflags::bitflags;\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Flags: u8 {\n         const TWO = 0x2;\n     }\n\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impls/fmt.rs\n--- a/tests/compile-pass/impls/fmt.rs\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -8,7 +9,7 @@ bitflags! {\n \n fn main() {\n     // bug #267 (https://github.com/bitflags/bitflags/issues/267)\n-    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n-    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n-    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+    let flags = Flags::from_bits_retain(0b11);\n+    assert_eq!(format!(\"{:?}\", flags), \"Flags(TWO | 0x1)\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"Flags(\\n    TWO | 0x1,\\n)\");\n }\n\ndiff --git /dev/null b/tests/compile-pass/item_positions.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/compile-pass/item_positions.rs\n@@ -0,0 +1,52 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags2: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+pub mod nested {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    bitflags! {\n+        pub struct Flags2: u32 {\n+            const A = 1;\n+        }\n+    }\n+}\n+\n+pub const _: () = {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+};\n+\n+fn main() {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    let _ = {\n+        bitflags! {\n+            pub struct Flags2: u32 {\n+                const A = 1;\n+            }\n+        }\n+    };\n+}\n\ndiff --git a/tests/compile-pass/no_prelude.rs b/tests/compile-pass/no_prelude.rs\n--- a/tests/compile-pass/no_prelude.rs\n+++ b/tests/compile-pass/no_prelude.rs\n@@ -7,7 +7,7 @@ bitflags::bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \n\ndiff --git a/tests/compile-pass/redefinition/macros.rs b/tests/compile-pass/redefinition/macros.rs\n--- a/tests/compile-pass/redefinition/macros.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -13,6 +13,7 @@ macro_rules! write {\n }\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Test: u8 {\n         const A = 1;\n     }\n\ndiff --git a/tests/compile-pass/redefinition/macros.rs b/tests/compile-pass/redefinition/macros.rs\n--- a/tests/compile-pass/redefinition/macros.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -20,5 +21,5 @@ bitflags! {\n \n fn main() {\n     // Just make sure we don't call the redefined `stringify` or `write` macro\n-    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n+    assert_eq!(format!(\"{:?}\", Test::from_bits_retain(0b11)), \"Test(A | 0x2)\");\n }\n\ndiff --git a/tests/compile-pass/visibility/bits_field.rs b/tests/compile-pass/visibility/bits_field.rs\n--- a/tests/compile-pass/visibility/bits_field.rs\n+++ b/tests/compile-pass/visibility/bits_field.rs\n@@ -7,5 +7,5 @@ bitflags! {\n }\n \n fn main() {\n-    assert_eq!(0b00000001, Flags1::FLAG_A.bits);\n+    assert_eq!(0b00000001, Flags1::FLAG_A.bits());\n }\n\ndiff --git /dev/null b/tests/smoke-test/src/main.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/smoke-test/src/main.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[derive(Debug)]\n+    pub struct Flags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", Flags::ABC);\n+}\n",
        "problem_statement": "Add an option for checking for valid bits is in the getter rather than constructor\nHi, I want to use bitflags for generated code that interacts with data in other languages, some of which are bitflags (https://github.com/google/flatbuffers/pull/6098). I don't want to drop data so I'd like to use `from_bits_unchecked`. However, it is marked as unsafe. I'd like to submit a PR to add an option to get around this. I have two ideas:\r\n\r\n1) Move the valid-bits-check to the getter: There'll be only one constructor: `from_bits` and the `bits()` getter becomes `bits() -> Result<...>`, `unsafe bits_unchecked()`, and `bits_truncated()`\r\n\r\n2) #200 documents that this crate uses `unsafe` to mean a usage issue rather than a memory issue, so maybe I could make an option to remove the unsafe altogether, and update the generated documentation appropriately?\r\n\r\nWhat are your thoughts on these ideas? Does bitflags depend on the \"bits are truncated to defined flags\" invariant?\n",
        "hints_text": "Related: #188, #200, #207, #208, #211\n@niklasf @KodrAus worked on #200 \nBump!\r\n\r\nI'll do the PR if needed\nHi @CasperN! :wave:\r\n\r\nWe can't consider any changes to the `bits()` method, because the library is already stable.\r\n\r\nThe way we modeled this originally was that the flags represents a closed enum, where the set specified in the definition is the complete set of possible flags the enum could combine. Since not all valid bit patterns of the underlying integer type are valid bit patterns of the flags it's not safe for us to simply accept any integer and treat it as valid flags. So we made the `unchecked` method unsafe.\r\n\r\nIf we wanted to clean up the semantics we could consider allowing an `#[open]` attribute or something on the `bitflags!` definition itself, so you'd declare an open bitflags that could happily accept any integer, assuming it's not the source-of-truth for what flags exist:\r\n\r\n```rust\r\nbitflags! {\r\n    #[open]\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n    }\r\n}\r\n```\r\n\r\nThen let these `#[open]` bitflags have `#[repr(transparent)]` and so can be soundly transmuted to and from the given integer type, making `from_bits_unchecked` safe.\r\n\r\nWhat do you think?\nWe could also use `#[repr(transparent)]` for this. I don\u2019t think that\u2019s too much of a semantic hijacking, so long as it also does apply the attribute.",
        "created_at": "2022-05-25T04:14:38Z",
        "test_patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -46,8 +46,17 @@ jobs:\n         profile: minimal\n         toolchain: ${{ matrix.channel }}-${{ matrix.rust_target }}\n \n-    - name: Tests\n-      run: cargo test --features example_generated\n+    - name: Install cargo-hack\n+      run: cargo install cargo-hack\n+\n+    - name: Powerset\n+      run: cargo hack test --feature-powerset --lib --optional-deps \"serde\" --depth 3 --skip rustc-dep-of-std\n+\n+    - name: Docs\n+      run: cargo doc --features example_generated\n+\n+    - name: Smoke test\n+      run: cargo run --manifest-path tests/smoke-test/Cargo.toml\n \n   embedded:\n     name: Build (embedded)\n\ndiff --git a/tests/basic.rs b/tests/basic.rs\n--- a/tests/basic.rs\n+++ b/tests/basic.rs\n@@ -4,13 +4,14 @@ use bitflags::bitflags;\n \n bitflags! {\n     /// baz\n+    #[derive(Debug, PartialEq, Eq)]\n     struct Flags: u32 {\n         const A = 0b00000001;\n         #[doc = \"bar\"]\n         const B = 0b00000010;\n         const C = 0b00000100;\n         #[doc = \"foo\"]\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \n\ndiff --git /dev/null b/tests/smoke-test/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/tests/smoke-test/Cargo.toml\n@@ -0,0 +1,8 @@\n+[package]\n+name = \"bitflags-smoke-test\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+publish = false\n+\n+[dependencies.bitflags]\n+path = \"../../\"\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 86,
        "instance_id": "bitflags__bitflags-86",
        "issue_numbers": [
            "82"
        ],
        "base_commit": "7acacb4e869a6a0c8b427c25ade53086e5f024a1",
        "patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -139,8 +139,8 @@ pub use core as __core;\n /// too: `Extend` adds the union of the instances of the `struct` iterated over,\n /// while `FromIterator` calculates the union.\n ///\n-/// The `Debug` trait is also implemented by displaying the bits value of the\n-/// internal struct.\n+/// The `Binary`, `Debug`, `LowerExp`, `Octal` and `UpperExp` trait is also\n+/// implemented by displaying the bits value of the internal struct.\n ///\n /// ## Operators\n ///\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -258,6 +258,26 @@ macro_rules! bitflags {\n                 Ok(())\n             }\n         }\n+        impl $crate::__core::fmt::Binary for $BitFlags {\n+            fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n+                self.bits.fmt(f)\n+            }\n+        }\n+        impl $crate::__core::fmt::Octal for $BitFlags {\n+            fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n+                self.bits.fmt(f)\n+            }\n+        }\n+        impl $crate::__core::fmt::LowerHex for $BitFlags {\n+            fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n+                self.bits.fmt(f)\n+            }\n+        }\n+        impl $crate::__core::fmt::UpperHex for $BitFlags {\n+            fn fmt(&self, f: &mut $crate::__core::fmt::Formatter) -> $crate::__core::fmt::Result {\n+                self.bits.fmt(f)\n+            }\n+        }\n \n         #[allow(dead_code)]\n         impl $BitFlags {\n",
        "problem_statement": "Implement Hex, Octal, and Binary\nThese formatting options should be available.\n",
        "hints_text": "",
        "created_at": "2017-03-22T15:50:46Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -529,6 +549,12 @@ mod tests {\n         }\n     }\n \n+    bitflags! {\n+        flags LongFlags: u32 {\n+            const LongFlagA = 0b1111111111111111,\n+        }\n+    }\n+\n     #[test]\n     fn test_bits(){\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -768,6 +794,30 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", FlagABC), \"FlagA | FlagB | FlagC | FlagABC\");\n     }\n \n+    #[test]\n+    fn test_binary() {\n+        assert_eq!(format!(\"{:b}\", FlagABC), \"111\");\n+        assert_eq!(format!(\"{:#b}\", FlagABC), \"0b111\");\n+    }\n+\n+    #[test]\n+    fn test_octal() {\n+        assert_eq!(format!(\"{:o}\", LongFlagA), \"177777\");\n+        assert_eq!(format!(\"{:#o}\", LongFlagA), \"0o177777\");\n+    }\n+\n+    #[test]\n+    fn test_lowerhex() {\n+        assert_eq!(format!(\"{:x}\", LongFlagA), \"ffff\");\n+        assert_eq!(format!(\"{:#x}\", LongFlagA), \"0xffff\");\n+    }\n+\n+    #[test]\n+    fn test_upperhex() {\n+        assert_eq!(format!(\"{:X}\", LongFlagA), \"FFFF\");\n+        assert_eq!(format!(\"{:#X}\", LongFlagA), \"0xFFFF\");\n+    }\n+\n     mod submodule {\n         bitflags! {\n             pub flags PublicFlags: i8 {\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 24,
        "instance_id": "bitflags__bitflags-24",
        "issue_numbers": [
            "20",
            "21"
        ],
        "base_commit": "d0884fa853eadd800fef198d9e71c8758b292db5",
        "patch": "diff --git a/src/example_generated.rs b/src/example_generated.rs\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -9,8 +9,8 @@ bitflags! {\n         const FLAG_A       = 0b00000001;\n         const FLAG_B       = 0b00000010;\n         const FLAG_C       = 0b00000100;\n-        const FLAG_ABC     = FLAG_A.bits\n-                           | FLAG_B.bits\n-                           | FLAG_C.bits;\n+        const FLAG_ABC     = Self::FLAG_A.bits\n+                           | Self::FLAG_B.bits\n+                           | Self::FLAG_C.bits;\n     }\n }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -26,19 +26,19 @@\n //!         const FLAG_A       = 0b00000001;\n //!         const FLAG_B       = 0b00000010;\n //!         const FLAG_C       = 0b00000100;\n-//!         const FLAG_ABC     = FLAG_A.bits\n-//!                            | FLAG_B.bits\n-//!                            | FLAG_C.bits;\n+//!         const FLAG_ABC     = Self::FLAG_A.bits\n+//!                            | Self::FLAG_B.bits\n+//!                            | Self::FLAG_C.bits;\n //!     }\n //! }\n //!\n //! fn main() {\n-//!     let e1 = FLAG_A | FLAG_C;\n-//!     let e2 = FLAG_B | FLAG_C;\n-//!     assert_eq!((e1 | e2), FLAG_ABC);   // union\n-//!     assert_eq!((e1 & e2), FLAG_C);     // intersection\n-//!     assert_eq!((e1 - e2), FLAG_A);     // set difference\n-//!     assert_eq!(!e2, FLAG_A);           // set complement\n+//!     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+//!     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+//!     assert_eq!((e1 | e2), Flags::FLAG_ABC);   // union\n+//!     assert_eq!((e1 & e2), Flags::FLAG_C);     // intersection\n+//!     assert_eq!((e1 - e2), Flags::FLAG_A);     // set difference\n+//!     assert_eq!(!e2, Flags::FLAG_A);           // set complement\n //! }\n //! ```\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -75,12 +75,12 @@\n //! }\n //!\n //! fn main() {\n-//!     let mut flags = FLAG_A | FLAG_B;\n+//!     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n //!     flags.clear();\n //!     assert!(flags.is_empty());\n //!     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-//!     assert_eq!(format!(\"{:?}\", FLAG_A | FLAG_B), \"FLAG_A | FLAG_B\");\n-//!     assert_eq!(format!(\"{:?}\", FLAG_B), \"FLAG_B\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::FLAG_A | Flags::FLAG_B), \"FLAG_A | FLAG_B\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::FLAG_B), \"FLAG_B\");\n //! }\n //! ```\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -108,8 +108,8 @@\n //! }\n //!\n //! fn main() {\n-//!     let flag1 = example::FLAG_A;\n-//!     let flag2 = example::FLAG_B; // error: const `FLAG_B` is private\n+//!     let flag1 = example::Flags1::FLAG_A;\n+//!     let flag2 = example::Flags2::FLAG_B; // error: const `FLAG_B` is private\n //! }\n //! ```\n //!\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -207,13 +207,13 @@\n //! // explicit `Default` implementation\n //! impl Default for Flags {\n //!     fn default() -> Flags {\n-//!         FLAG_A | FLAG_C\n+//!         Flags::FLAG_A | Flags::FLAG_C\n //!     }\n //! }\n //!\n //! fn main() {\n //!     let implemented_default: Flags = Default::default();\n-//!     assert_eq!(implemented_default, (FLAG_A | FLAG_C));\n+//!     assert_eq!(implemented_default, (Flags::FLAG_A | Flags::FLAG_C));\n //! }\n //! ```\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -249,19 +249,19 @@ pub extern crate core as _core;\n ///         const FLAG_A       = 0b00000001;\n ///         const FLAG_B       = 0b00000010;\n ///         const FLAG_C       = 0b00000100;\n-///         const FLAG_ABC     = FLAG_A.bits\n-///                            | FLAG_B.bits\n-///                            | FLAG_C.bits;\n+///         const FLAG_ABC     = Self::FLAG_A.bits\n+///                            | Self::FLAG_B.bits\n+///                            | Self::FLAG_C.bits;\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FLAG_A | FLAG_C;\n-///     let e2 = FLAG_B | FLAG_C;\n-///     assert_eq!((e1 | e2), FLAG_ABC);   // union\n-///     assert_eq!((e1 & e2), FLAG_C);     // intersection\n-///     assert_eq!((e1 - e2), FLAG_A);     // set difference\n-///     assert_eq!(!e2, FLAG_A);           // set complement\n+///     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+///     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+///     assert_eq!((e1 | e2), Flags::FLAG_ABC);   // union\n+///     assert_eq!((e1 & e2), Flags::FLAG_C);     // intersection\n+///     assert_eq!((e1 - e2), Flags::FLAG_A);     // set difference\n+///     assert_eq!(!e2, Flags::FLAG_A);           // set complement\n /// }\n /// ```\n ///\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -295,12 +295,12 @@ pub extern crate core as _core;\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FLAG_A | FLAG_B;\n+///     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-///     assert_eq!(format!(\"{:?}\", FLAG_A | FLAG_B), \"FLAG_A | FLAG_B\");\n-///     assert_eq!(format!(\"{:?}\", FLAG_B), \"FLAG_B\");\n+///     assert_eq!(format!(\"{:?}\", Flags::FLAG_A | Flags::FLAG_B), \"FLAG_A | FLAG_B\");\n+///     assert_eq!(format!(\"{:?}\", Flags::FLAG_B), \"FLAG_B\");\n /// }\n /// ```\n #[macro_export]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -320,11 +320,6 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $(\n-            $(#[$inner $($args)*])*\n-            pub const $Flag: $BitFlags = $BitFlags { bits: $value };\n-        )+\n-\n         __impl_bitflags! {\n             struct $BitFlags: $T {\n                 $(\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -349,11 +344,6 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $(\n-            $(#[$inner $($args)*])*\n-            const $Flag: $BitFlags = $BitFlags { bits: $value };\n-        )+\n-\n         __impl_bitflags! {\n             struct $BitFlags: $T {\n                 $(\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -401,7 +391,7 @@ macro_rules! __impl_bitflags {\n                             #[allow(deprecated)]\n                             $(? #[$attr $($args)*])*\n                             fn $Flag(&self) -> bool {\n-                                self.bits & $Flag.bits == $Flag.bits\n+                                self.bits & Self::$Flag.bits == Self::$Flag.bits\n                             }\n                         }\n                     )+\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -446,6 +436,11 @@ macro_rules! __impl_bitflags {\n \n         #[allow(dead_code)]\n         impl $BitFlags {\n+            $(\n+                $(#[$attr $($args)*])*\n+                pub const $Flag: $BitFlags = $BitFlags { bits: $value };\n+            )+\n+\n             /// Returns an empty set of flags.\n             #[inline]\n             pub fn empty() -> $BitFlags {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -467,7 +462,7 @@ macro_rules! __impl_bitflags {\n                         __impl_bitflags! {\n                             #[allow(deprecated)]\n                             $(? #[$attr $($args)*])*\n-                            fn $Flag() -> $T { $Flag.bits }\n+                            fn $Flag() -> $T { Self::$Flag.bits }\n                         }\n                     )+\n                 }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -712,7 +707,6 @@ macro_rules! __impl_bitflags {\n pub mod example_generated;\n \n #[cfg(test)]\n-#[allow(non_upper_case_globals, dead_code)]\n mod tests {\n     use std::hash::{Hash, Hasher};\n     use std::collections::hash_map::DefaultHasher;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -795,19 +789,19 @@ mod tests {\n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());\n-        assert!(!FlagA.is_empty());\n-        assert!(!FlagABC.is_empty());\n+        assert!(!Flags::FLAG_A.is_empty());\n+        assert!(!Flags::FLAG_ABC.is_empty());\n \n-        assert!(!AnotherFlag.is_empty());\n+        assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n     }\n \n     #[test]\n     fn test_is_all() {\n         assert!(Flags::all().is_all());\n-        assert!(!FlagA.is_all());\n-        assert!(FlagABC.is_all());\n+        assert!(!Flags::FLAG_A.is_all());\n+        assert!(Flags::FLAG_ABC.is_all());\n \n-        assert!(AnotherFlag.is_all());\n+        assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -816,77 +810,77 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n-        assert!(AnotherFlag.intersects(AnotherFlag));\n+        assert!(AnotherSetOfFlags::ANOTHER_FLAG.intersects(AnotherSetOfFlags::ANOTHER_FLAG));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n         let e1 = Flags::empty();\n-        let e2 = FlagABC;\n+        let e2 = Flags::FLAG_ABC;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagB;\n+        let e1 = Flags::FLAG_A;\n+        let e2 = Flags::FLAG_B;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FLAG_A;\n+        let e2 = Flags::FLAG_A | Flags::FLAG_B;\n         assert!(e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_contains() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FLAG_A;\n+        let e2 = Flags::FLAG_A | Flags::FLAG_B;\n         assert!(!e1.contains(e2));\n         assert!(e2.contains(e1));\n-        assert!(FlagABC.contains(e2));\n+        assert!(Flags::FLAG_ABC.contains(e2));\n \n-        assert!(AnotherFlag.contains(AnotherFlag));\n+        assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n     }\n \n     #[test]\n     fn test_insert(){\n-        let mut e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let mut e1 = Flags::FLAG_A;\n+        let e2 = Flags::FLAG_A | Flags::FLAG_B;\n         e1.insert(e2);\n         assert_eq!(e1, e2);\n \n         let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherFlag);\n-        assert_eq!(e3, AnotherFlag);\n+        e3.insert(AnotherSetOfFlags::ANOTHER_FLAG);\n+        assert_eq!(e3, AnotherSetOfFlags::ANOTHER_FLAG);\n     }\n \n     #[test]\n     fn test_remove(){\n-        let mut e1 = FlagA | FlagB;\n-        let e2 = FlagA | FlagC;\n+        let mut e1 = Flags::FLAG_A | Flags::FLAG_B;\n+        let e2 = Flags::FLAG_A | Flags::FLAG_C;\n         e1.remove(e2);\n-        assert_eq!(e1, FlagB);\n+        assert_eq!(e1, Flags::FLAG_B);\n \n-        let mut e3 = AnotherFlag;\n-        e3.remove(AnotherFlag);\n+        let mut e3 = AnotherSetOfFlags::ANOTHER_FLAG;\n+        e3.remove(AnotherSetOfFlags::ANOTHER_FLAG);\n         assert_eq!(e3, AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_operators() {\n-        let e1 = FlagA | FlagC;\n-        let e2 = FlagB | FlagC;\n-        assert_eq!((e1 | e2), FlagABC);     // union\n-        assert_eq!((e1 & e2), FlagC);       // intersection\n-        assert_eq!((e1 - e2), FlagA);       // set difference\n-        assert_eq!(!e2, FlagA);             // set complement\n-        assert_eq!(e1 ^ e2, FlagA | FlagB); // toggle\n+        let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+        let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+        assert_eq!((e1 | e2), Flags::FLAG_ABC);     // union\n+        assert_eq!((e1 & e2), Flags::FLAG_C);       // intersection\n+        assert_eq!((e1 - e2), Flags::FLAG_A);       // set difference\n+        assert_eq!(!e2, Flags::FLAG_A);             // set complement\n+        assert_eq!(e1 ^ e2, Flags::FLAG_A | Flags::FLAG_B); // toggle\n         let mut e3 = e1;\n         e3.toggle(e2);\n-        assert_eq!(e3, FlagA | FlagB);\n+        assert_eq!(e3, Flags::FLAG_A | Flags::FLAG_B);\n \n         let mut m4 = AnotherSetOfFlags::empty();\n         m4.toggle(AnotherSetOfFlags::empty());\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -895,23 +889,23 @@ mod tests {\n \n     #[test]\n     fn test_set() {\n-        let mut e1 = FlagA | FlagC;\n-        e1.set(FlagB, true);\n-        e1.set(FlagC, false);\n+        let mut e1 = Flags::FLAG_A | Flags::FLAG_C;\n+        e1.set(Flags::FLAG_B, true);\n+        e1.set(Flags::FLAG_C, false);\n \n-        assert_eq!(e1, FlagA | FlagB);\n+        assert_eq!(e1, Flags::FLAG_A | Flags::FLAG_B);\n     }\n \n     #[test]\n     fn test_assignment_operators() {\n         let mut m1 = Flags::empty();\n-        let e1 = FlagA | FlagC;\n+        let e1 = Flags::FLAG_A | Flags::FLAG_C;\n         // union\n-        m1 |= FlagA;\n-        assert_eq!(m1, FlagA);\n+        m1 |= Flags::FLAG_A;\n+        assert_eq!(m1, Flags::FLAG_A);\n         // intersection\n         m1 &= e1;\n-        assert_eq!(m1, FlagA);\n+        assert_eq!(m1, Flags::FLAG_A);\n         // set difference\n         m1 -= m1;\n         assert_eq!(m1, Flags::empty());\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -929,23 +923,25 @@ mod tests {\n         assert_eq!(flags, Flags::empty());\n \n         flags = Flags::empty();\n-        flags.extend([FlagA, FlagB].iter().cloned());\n-        assert_eq!(flags, FlagA | FlagB);\n+        flags.extend([Flags::FLAG_A, Flags::FLAG_B].iter().cloned());\n+        assert_eq!(flags, Flags::FLAG_A | Flags::FLAG_B);\n \n-        flags = FlagA;\n-        flags.extend([FlagA, FlagB].iter().cloned());\n-        assert_eq!(flags, FlagA | FlagB);\n+        flags = Flags::FLAG_A;\n+        flags.extend([Flags::FLAG_A, Flags::FLAG_B].iter().cloned());\n+        assert_eq!(flags, Flags::FLAG_A | Flags::FLAG_B);\n \n-        flags = FlagB;\n-        flags.extend([FlagA, FlagABC].iter().cloned());\n-        assert_eq!(flags, FlagABC);\n+        flags = Flags::FLAG_B;\n+        flags.extend([Flags::FLAG_A, Flags::FLAG_ABC].iter().cloned());\n+        assert_eq!(flags, Flags::FLAG_ABC);\n     }\n \n     #[test]\n     fn test_from_iterator() {\n         assert_eq!([].iter().cloned().collect::<Flags>(), Flags::empty());\n-        assert_eq!([FlagA, FlagB].iter().cloned().collect::<Flags>(), FlagA | FlagB);\n-        assert_eq!([FlagA, FlagABC].iter().cloned().collect::<Flags>(), FlagABC);\n+        assert_eq!([Flags::FLAG_A, Flags::FLAG_B].iter().cloned().collect::<Flags>(),\n+                   Flags::FLAG_A | Flags::FLAG_B);\n+        assert_eq!([Flags::FLAG_A, Flags::FLAG_ABC].iter().cloned().collect::<Flags>(),\n+                   Flags::FLAG_ABC);\n     }\n \n     #[test]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -954,11 +950,11 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(!(a < b) && !(b < a));\n-        b = FlagB;\n+        b = Flags::FLAG_B;\n         assert!(a < b);\n-        a = FlagC;\n+        a = Flags::FLAG_C;\n         assert!(!(a < b) && b < a);\n-        b = FlagC | FlagB;\n+        b = Flags::FLAG_C | Flags::FLAG_B;\n         assert!(a < b);\n     }\n \n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -968,10 +964,10 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(a <= b && a >= b);\n-        a = FlagA;\n+        a = Flags::FLAG_A;\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        b = FlagB;\n+        b = Flags::FLAG_B;\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -988,62 +984,63 @@ mod tests {\n         let mut y = Flags::empty();\n         assert_eq!(hash(&x), hash(&y));\n         x = Flags::all();\n-        y = FlagABC;\n+        y = Flags::FLAG_ABC;\n         assert_eq!(hash(&x), hash(&y));\n     }\n \n     #[test]\n     fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", FlagA | FlagB), \"FlagA | FlagB\");\n+        assert_eq!(format!(\"{:?}\", Flags::FLAG_A | Flags::FLAG_B), \"FLAG_A | FLAG_B\");\n         assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", FlagABC), \"FlagA | FlagB | FlagC | FlagABC\");\n+        assert_eq!(format!(\"{:?}\", Flags::FLAG_ABC), \"FLAG_A | FLAG_B | FLAG_C | FLAG_ABC\");\n     }\n \n     #[test]\n     fn test_binary() {\n-        assert_eq!(format!(\"{:b}\", FlagABC), \"111\");\n-        assert_eq!(format!(\"{:#b}\", FlagABC), \"0b111\");\n+        assert_eq!(format!(\"{:b}\", Flags::FLAG_ABC), \"111\");\n+        assert_eq!(format!(\"{:#b}\", Flags::FLAG_ABC), \"0b111\");\n     }\n \n     #[test]\n     fn test_octal() {\n-        assert_eq!(format!(\"{:o}\", LongFlagA), \"177777\");\n-        assert_eq!(format!(\"{:#o}\", LongFlagA), \"0o177777\");\n+        assert_eq!(format!(\"{:o}\", LongFlags::LONG_FLAG_A), \"177777\");\n+        assert_eq!(format!(\"{:#o}\", LongFlags::LONG_FLAG_A), \"0o177777\");\n     }\n \n     #[test]\n     fn test_lowerhex() {\n-        assert_eq!(format!(\"{:x}\", LongFlagA), \"ffff\");\n-        assert_eq!(format!(\"{:#x}\", LongFlagA), \"0xffff\");\n+        assert_eq!(format!(\"{:x}\", LongFlags::LONG_FLAG_A), \"ffff\");\n+        assert_eq!(format!(\"{:#x}\", LongFlags::LONG_FLAG_A), \"0xffff\");\n     }\n \n     #[test]\n     fn test_upperhex() {\n-        assert_eq!(format!(\"{:X}\", LongFlagA), \"FFFF\");\n-        assert_eq!(format!(\"{:#X}\", LongFlagA), \"0xFFFF\");\n+        assert_eq!(format!(\"{:X}\", LongFlags::LONG_FLAG_A), \"FFFF\");\n+        assert_eq!(format!(\"{:#X}\", LongFlags::LONG_FLAG_A), \"0xFFFF\");\n     }\n \n     mod submodule {\n         bitflags! {\n             pub struct PublicFlags: i8 {\n-                const FlagX = 0;\n+                const FLAG_X = 0;\n             }\n         }\n         bitflags! {\n             struct PrivateFlags: i8 {\n-                const FlagY = 0;\n+                const FLAG_Y = 0;\n             }\n         }\n \n         #[test]\n         fn test_private() {\n-            let _ = FlagY;\n+\n+            let _ = PrivateFlags::FLAG_Y;\n         }\n     }\n \n     #[test]\n     fn test_public() {\n-        let _ = submodule::FlagX;\n+        let _ = submodule::PublicFlags::FLAG_X;\n     }\n \n     mod t1 {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1072,8 +1069,8 @@ mod tests {\n                 const B = 2;\n             }\n         }\n-        assert_eq!(Flags::all(), A);\n-        assert_eq!(format!(\"{:?}\", A), \"A\");\n+        assert_eq!(Flags::all(), Flags::A);\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"A\");\n     }\n \n     #[test]\n",
        "problem_statement": "Allow namespaced flags\nIt would be nice to have `FlagType::FlagName` be the pattern rather than dumping the flag values into the top-level namespace. Is this possible?\n\nassociated constants\nThis crate really wants to use associated constants (see https://github.com/rust-lang/rust/pull/24921) but the tricks introduced in #14 are incompatible with associated constants (because associated constants can't be `use`d to shadow locally scoped constants).\n\nWhat do?\n\n",
        "hints_text": "\n",
        "created_at": "2015-11-28T01:15:59Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -723,71 +717,71 @@ mod tests {\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n         struct Flags: u32 {\n-            const FlagA       = 0b00000001;\n+            const FLAG_A       = 0b00000001;\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const FlagB       = 0b00000010;\n-            const FlagC       = 0b00000100;\n+            const FLAG_B       = 0b00000010;\n+            const FLAG_C       = 0b00000100;\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const FlagABC     = FlagA.bits\n-                               | FlagB.bits\n-                               | FlagC.bits;\n+            const FLAG_ABC     = Self::FLAG_A.bits\n+                               | Self::FLAG_B.bits\n+                               | Self::FLAG_C.bits;\n         }\n     }\n \n     bitflags! {\n         struct _CfgFlags: u32 {\n             #[cfg(windows)]\n-            const _CfgA = 0b01;\n+            const _CFG_A = 0b01;\n             #[cfg(unix)]\n-            const _CfgB = 0b01;\n+            const _CFG_B = 0b01;\n             #[cfg(windows)]\n-            const _CfgC = _CfgA.bits | 0b10;\n+            const _CFG_C = _CFG_A.bits | 0b10;\n         }\n     }\n \n     bitflags! {\n         struct AnotherSetOfFlags: i8 {\n-            const AnotherFlag = -1_i8;\n+            const ANOTHER_FLAG = -1_i8;\n         }\n     }\n \n     bitflags! {\n         struct LongFlags: u32 {\n-            const LongFlagA = 0b1111111111111111;\n+            const LONG_FLAG_A = 0b1111111111111111;\n         }\n     }\n \n     #[test]\n     fn test_bits(){\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(FlagA.bits(), 0b00000001);\n-        assert_eq!(FlagABC.bits(), 0b00000111);\n+        assert_eq!(Flags::FLAG_A.bits(), 0b00000001);\n+        assert_eq!(Flags::FLAG_ABC.bits(), 0b00000111);\n \n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherFlag.bits(), !0_i8);\n+        assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n     }\n \n     #[test]\n     fn test_from_bits() {\n         assert_eq!(Flags::from_bits(0), Some(Flags::empty()));\n-        assert_eq!(Flags::from_bits(0b1), Some(FlagA));\n-        assert_eq!(Flags::from_bits(0b10), Some(FlagB));\n-        assert_eq!(Flags::from_bits(0b11), Some(FlagA | FlagB));\n+        assert_eq!(Flags::from_bits(0b1), Some(Flags::FLAG_A));\n+        assert_eq!(Flags::from_bits(0b10), Some(Flags::FLAG_B));\n+        assert_eq!(Flags::from_bits(0b11), Some(Flags::FLAG_A | Flags::FLAG_B));\n         assert_eq!(Flags::from_bits(0b1000), None);\n \n-        assert_eq!(AnotherSetOfFlags::from_bits(!0_i8), Some(AnotherFlag));\n+        assert_eq!(AnotherSetOfFlags::from_bits(!0_i8), Some(AnotherSetOfFlags::ANOTHER_FLAG));\n     }\n \n     #[test]\n     fn test_from_bits_truncate() {\n         assert_eq!(Flags::from_bits_truncate(0), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1), FlagA);\n-        assert_eq!(Flags::from_bits_truncate(0b10), FlagB);\n-        assert_eq!(Flags::from_bits_truncate(0b11), (FlagA | FlagB));\n+        assert_eq!(Flags::from_bits_truncate(0b1), Flags::FLAG_A);\n+        assert_eq!(Flags::from_bits_truncate(0b10), Flags::FLAG_B);\n+        assert_eq!(Flags::from_bits_truncate(0b11), (Flags::FLAG_A | Flags::FLAG_B));\n         assert_eq!(Flags::from_bits_truncate(0b1000), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1001), FlagA);\n+        assert_eq!(Flags::from_bits_truncate(0b1001), Flags::FLAG_A);\n \n         assert_eq!(AnotherSetOfFlags::from_bits_truncate(0_i8), AnotherSetOfFlags::empty());\n     }\n\ndiff --git a/tests/conflicting_trait_impls.rs b/tests/conflicting_trait_impls.rs\n--- a/tests/conflicting_trait_impls.rs\n+++ b/tests/conflicting_trait_impls.rs\n@@ -1,4 +1,3 @@\n-#![allow(dead_code)]\n #![no_std]\n \n #[macro_use]\n\ndiff --git a/tests/external.rs b/tests/external.rs\n--- a/tests/external.rs\n+++ b/tests/external.rs\n@@ -1,5 +1,3 @@\n-#![allow(dead_code)]\n-\n #[macro_use]\n extern crate bitflags;\n \n\ndiff --git a/tests/external.rs b/tests/external.rs\n--- a/tests/external.rs\n+++ b/tests/external.rs\n@@ -11,11 +9,11 @@ bitflags! {\n         const B       = 0b00000010;\n         const C       = 0b00000100;\n         #[doc = \"foo\"]\n-        const ABC     = A.bits | B.bits | C.bits;\n+        const ABC     = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n     }\n }\n \n #[test]\n fn smoke() {\n-    assert_eq!(ABC, A | B | C);\n+    assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n }\n\ndiff --git a/tests/external_no_std.rs b/tests/external_no_std.rs\n--- a/tests/external_no_std.rs\n+++ b/tests/external_no_std.rs\n@@ -1,4 +1,3 @@\n-#![allow(dead_code)]\n #![no_std]\n \n #[macro_use]\n\ndiff --git a/tests/external_no_std.rs b/tests/external_no_std.rs\n--- a/tests/external_no_std.rs\n+++ b/tests/external_no_std.rs\n@@ -12,11 +11,11 @@ bitflags! {\n         const B       = 0b00000010;\n         const C       = 0b00000100;\n         #[doc = \"foo\"]\n-        const ABC     = A.bits | B.bits | C.bits;\n+        const ABC     = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n     }\n }\n \n #[test]\n fn smoke() {\n-    assert_eq!(ABC, A | B | C);\n+    assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n }\n\ndiff --git a/tests/i128_bitflags.rs b/tests/i128_bitflags.rs\n--- a/tests/i128_bitflags.rs\n+++ b/tests/i128_bitflags.rs\n@@ -1,6 +1,5 @@\n #![cfg(feature = \"unstable_testing\")]\n \n-#![allow(dead_code, unused_imports)]\n #![feature(i128_type)]\n \n #[macro_use]\n\ndiff --git a/tests/i128_bitflags.rs b/tests/i128_bitflags.rs\n--- a/tests/i128_bitflags.rs\n+++ b/tests/i128_bitflags.rs\n@@ -12,19 +11,19 @@ bitflags! {\n         const A       = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n         const B       = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n         const C       = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-        const ABC     = A.bits | B.bits | C.bits;\n+        const ABC     = Self::A.bits | Self::B.bits | Self::C.bits;\n     }\n }\n \n #[test]\n fn test_i128_bitflags() {\n-    assert_eq!(ABC, A | B | C);\n-    assert_eq!(A.bits, 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-    assert_eq!(B.bits, 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-    assert_eq!(C.bits, 0x8000_0000_0000_0000_0000_0000_0000_0000);\n-    assert_eq!(ABC.bits, 0x8000_0000_0000_1000_0000_0000_0000_0001);\n-    assert_eq!(format!(\"{:?}\", A), \"A\");\n-    assert_eq!(format!(\"{:?}\", B), \"B\");\n-    assert_eq!(format!(\"{:?}\", C), \"C\");\n-    assert_eq!(format!(\"{:?}\", ABC), \"A | B | C | ABC\");\n+    assert_eq!(Flags128::ABC, Flags128::A | Flags128::B | Flags128::C);\n+    assert_eq!(Flags128::A.bits, 0x0000_0000_0000_0000_0000_0000_0000_0001);\n+    assert_eq!(Flags128::B.bits, 0x0000_0000_0000_1000_0000_0000_0000_0000);\n+    assert_eq!(Flags128::C.bits, 0x8000_0000_0000_0000_0000_0000_0000_0000);\n+    assert_eq!(Flags128::ABC.bits, 0x8000_0000_0000_1000_0000_0000_0000_0001);\n+    assert_eq!(format!(\"{:?}\", Flags128::A), \"A\");\n+    assert_eq!(format!(\"{:?}\", Flags128::B), \"B\");\n+    assert_eq!(format!(\"{:?}\", Flags128::C), \"C\");\n+    assert_eq!(format!(\"{:?}\", Flags128::ABC), \"A | B | C | ABC\");\n }\n"
    },
    {
        "repo": "bitflags/bitflags",
        "pull_number": 366,
        "instance_id": "bitflags__bitflags-366",
        "issue_numbers": [
            "364"
        ],
        "base_commit": "09f71f492d0f76d63cd286c3869c70676297e204",
        "patch": "diff --git a/examples/custom_bits_type.rs b/examples/custom_bits_type.rs\n--- a/examples/custom_bits_type.rs\n+++ b/examples/custom_bits_type.rs\n@@ -1,6 +1,6 @@\n use std::ops::{BitAnd, BitOr, BitXor, Not};\n \n-use bitflags::{Flags, Flag, Bits};\n+use bitflags::{Bits, Flag, Flags};\n \n // Define a custom container that can be used in flags types\n // Note custom bits types can't be used in `bitflags!`\n\ndiff --git a/examples/custom_bits_type.rs b/examples/custom_bits_type.rs\n--- a/examples/custom_bits_type.rs\n+++ b/examples/custom_bits_type.rs\n@@ -25,7 +25,11 @@ impl BitAnd for CustomBits {\n     type Output = Self;\n \n     fn bitand(self, other: Self) -> Self {\n-        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+        CustomBits([\n+            self.0[0] & other.0[0],\n+            self.0[1] & other.0[1],\n+            self.0[2] & other.0[2],\n+        ])\n     }\n }\n \n\ndiff --git a/examples/custom_bits_type.rs b/examples/custom_bits_type.rs\n--- a/examples/custom_bits_type.rs\n+++ b/examples/custom_bits_type.rs\n@@ -33,7 +37,11 @@ impl BitOr for CustomBits {\n     type Output = Self;\n \n     fn bitor(self, other: Self) -> Self {\n-        CustomBits([self.0[0] | other.0[0], self.0[1] | other.0[1], self.0[2] | other.0[2]])\n+        CustomBits([\n+            self.0[0] | other.0[0],\n+            self.0[1] | other.0[1],\n+            self.0[2] | other.0[2],\n+        ])\n     }\n }\n \n\ndiff --git a/examples/custom_bits_type.rs b/examples/custom_bits_type.rs\n--- a/examples/custom_bits_type.rs\n+++ b/examples/custom_bits_type.rs\n@@ -41,7 +49,11 @@ impl BitXor for CustomBits {\n     type Output = Self;\n \n     fn bitxor(self, other: Self) -> Self {\n-        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+        CustomBits([\n+            self.0[0] & other.0[0],\n+            self.0[1] & other.0[1],\n+            self.0[2] & other.0[2],\n+        ])\n     }\n }\n \n\ndiff --git a/examples/macro_free.rs b/examples/macro_free.rs\n--- a/examples/macro_free.rs\n+++ b/examples/macro_free.rs\n@@ -4,7 +4,7 @@\n \n use std::{fmt, str};\n \n-use bitflags::{Flags, Flag};\n+use bitflags::{Flag, Flags};\n \n // First: Define your flags type. It just needs to be `Sized + 'static`.\n pub struct ManualFlags(u32);\n\ndiff --git a/examples/macro_free.rs b/examples/macro_free.rs\n--- a/examples/macro_free.rs\n+++ b/examples/macro_free.rs\n@@ -54,5 +54,8 @@ impl fmt::Display for ManualFlags {\n }\n \n fn main() {\n-    println!(\"{}\", ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C));\n+    println!(\n+        \"{}\",\n+        ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C)\n+    );\n }\n\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -38,6 +38,10 @@ __impl_public_bitflags_forward! {\n     Flags: u32, Field0\n }\n \n+__impl_public_bitflags_ops! {\n+    Flags\n+}\n+\n __impl_public_bitflags_iter! {\n     Flags: u32, Flags\n }\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -153,9 +153,7 @@ macro_rules! __impl_external_bitflags_serde {\n             fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n                 deserializer: D,\n             ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                let flags: $PublicBitFlags = $crate::serde::deserialize(\n-                    deserializer,\n-                )?;\n+                let flags: $PublicBitFlags = $crate::serde::deserialize(deserializer)?;\n \n                 Ok(flags.0)\n             }\n\ndiff --git a/src/external.rs b/src/external.rs\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -235,20 +233,16 @@ macro_rules! __impl_external_bitflags_bytemuck {\n     ) => {\n         // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n         // and $T implements Pod\n-        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags\n-        where\n-            $T: $crate::__private::bytemuck::Pod,\n+        unsafe impl $crate::__private::bytemuck::Pod for $InternalBitFlags where\n+            $T: $crate::__private::bytemuck::Pod\n         {\n-\n         }\n \n         // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n         // and $T implements Zeroable\n-        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags\n-        where\n-            $T: $crate::__private::bytemuck::Zeroable,\n+        unsafe impl $crate::__private::bytemuck::Zeroable for $InternalBitFlags where\n+            $T: $crate::__private::bytemuck::Zeroable\n         {\n-\n         }\n     };\n }\n\ndiff --git a/src/external/arbitrary.rs b/src/external/arbitrary.rs\n--- a/src/external/arbitrary.rs\n+++ b/src/external/arbitrary.rs\n@@ -3,11 +3,9 @@\n use crate::Flags;\n \n /// Get a random known flags value.\n-pub fn arbitrary<'a, B: Flags>(\n-    u: &mut arbitrary::Unstructured<'a>,\n-) -> arbitrary::Result<B>\n+pub fn arbitrary<'a, B: Flags>(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<B>\n where\n-    B::Bits: arbitrary::Arbitrary<'a>\n+    B::Bits: arbitrary::Arbitrary<'a>,\n {\n     B::from_bits(u.arbitrary()?).ok_or_else(|| arbitrary::Error::IncorrectFormat)\n }\n\ndiff --git a/src/external/bytemuck.rs b/src/external/bytemuck.rs\n--- a/src/external/bytemuck.rs\n+++ b/src/external/bytemuck.rs\n@@ -1,7 +1,7 @@\n #[cfg(test)]\n mod tests {\n     use bytemuck::{Pod, Zeroable};\n-    \n+\n     bitflags! {\n         #[derive(Pod, Zeroable, Clone, Copy)]\n         #[repr(transparent)]\n\ndiff --git a/src/external/serde.rs b/src/external/serde.rs\n--- a/src/external/serde.rs\n+++ b/src/external/serde.rs\n@@ -1,17 +1,17 @@\n //! Specialized serialization for flags types using `serde`.\n \n+use crate::{\n+    parser::{self, ParseHex, WriteHex},\n+    Flags,\n+};\n use core::{fmt, str};\n-use crate::{Flags, parser::{self, ParseHex, WriteHex}};\n use serde::{\n     de::{Error, Visitor},\n     Deserialize, Deserializer, Serialize, Serializer,\n };\n \n /// Serialize a set of flags as a human-readable string or their underlying bits.\n-pub fn serialize<B: Flags, S: Serializer>(\n-    flags: &B,\n-    serializer: S,\n-) -> Result<S::Ok, S::Error>\n+pub fn serialize<B: Flags, S: Serializer>(flags: &B, serializer: S) -> Result<S::Ok, S::Error>\n where\n     B::Bits: WriteHex + Serialize,\n {\n\ndiff --git a/src/external/serde.rs b/src/external/serde.rs\n--- a/src/external/serde.rs\n+++ b/src/external/serde.rs\n@@ -26,13 +26,7 @@ where\n }\n \n /// Deserialize a set of flags from a human-readable string or their underlying bits.\n-pub fn deserialize<\n-    'de,\n-    B: Flags,\n-    D: Deserializer<'de>,\n->(\n-    deserializer: D,\n-) -> Result<B, D::Error>\n+pub fn deserialize<'de, B: Flags, D: Deserializer<'de>>(deserializer: D) -> Result<B, D::Error>\n where\n     B::Bits: ParseHex + Deserialize<'de>,\n {\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -56,7 +56,7 @@ macro_rules! __impl_internal_bitflags {\n                 if self.is_empty() {\n                     // If no flags are set then write an empty hex flag to avoid\n                     // writing an empty string. In some contexts, like serialization,\n-                    // an empty string is preferrable, but it may be unexpected in\n+                    // an empty string is preferable, but it may be unexpected in\n                     // others for a format not to produce any output.\n                     //\n                     // We can remove this `0x0` and remain compatible with `FromStr`,\n\ndiff --git a/src/internal.rs b/src/internal.rs\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -106,6 +106,10 @@ macro_rules! __impl_internal_bitflags {\n             }\n         }\n \n+        __impl_public_bitflags_ops! {\n+            $InternalBitFlags\n+        }\n+\n         __impl_public_bitflags_iter! {\n             $InternalBitFlags: $T, $PublicBitFlags\n         }\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -1,6 +1,6 @@\n //! Iterating over set flag values.\n \n-use crate::{Flags, Flag};\n+use crate::{Flag, Flags};\n \n /// An iterator over a set of flags.\n ///\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -23,9 +23,9 @@ impl<B: Flags> Iter<B> {\n \n impl<B: 'static> Iter<B> {\n     #[doc(hidden)]\n-    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {\n         Iter {\n-            inner: IterNames::__private_const_new(flags, source, state),\n+            inner: IterNames::__private_const_new(flags, source, remaining),\n             done: false,\n         }\n     }\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -33,18 +33,18 @@ impl<B: 'static> Iter<B> {\n \n impl<B: Flags> Iterator for Iter<B> {\n     type Item = B;\n-    \n+\n     fn next(&mut self) -> Option<Self::Item> {\n         match self.inner.next() {\n             Some((_, flag)) => Some(flag),\n             None if !self.done => {\n                 self.done = true;\n-                \n+\n                 // After iterating through valid names, if there are any bits left over\n                 // then return one final value that includes them. This makes `into_iter`\n                 // and `from_iter` roundtrip\n                 if !self.inner.remaining().is_empty() {\n-                    Some(B::from_bits_retain(self.inner.state.bits()))\n+                    Some(B::from_bits_retain(self.inner.remaining.bits()))\n                 } else {\n                     None\n                 }\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -61,7 +61,7 @@ pub struct IterNames<B: 'static> {\n     flags: &'static [Flag<B>],\n     idx: usize,\n     source: B,\n-    state: B,\n+    remaining: B,\n }\n \n impl<B: Flags> IterNames<B> {\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -70,7 +70,7 @@ impl<B: Flags> IterNames<B> {\n         IterNames {\n             flags: B::FLAGS,\n             idx: 0,\n-            state: B::from_bits_retain(flags.bits()),\n+            remaining: B::from_bits_retain(flags.bits()),\n             source: B::from_bits_retain(flags.bits()),\n         }\n     }\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -78,11 +78,11 @@ impl<B: Flags> IterNames<B> {\n \n impl<B: 'static> IterNames<B> {\n     #[doc(hidden)]\n-    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {\n         IterNames {\n             flags,\n             idx: 0,\n-            state,\n+            remaining,\n             source,\n         }\n     }\n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -93,17 +93,17 @@ impl<B: 'static> IterNames<B> {\n     /// check whether or not there are any bits that didn't correspond\n     /// to a valid flag remaining.\n     pub fn remaining(&self) -> &B {\n-        &self.state\n+        &self.remaining\n     }\n }\n \n impl<B: Flags> Iterator for IterNames<B> {\n     type Item = (&'static str, B);\n-    \n+\n     fn next(&mut self) -> Option<Self::Item> {\n         while let Some(flag) = self.flags.get(self.idx) {\n             // Short-circuit if our state is empty\n-            if self.state.is_empty() {\n+            if self.remaining.is_empty() {\n                 return None;\n             }\n \n\ndiff --git a/src/iter.rs b/src/iter.rs\n--- a/src/iter.rs\n+++ b/src/iter.rs\n@@ -111,23 +111,23 @@ impl<B: Flags> Iterator for IterNames<B> {\n \n             let bits = flag.value().bits();\n \n-            // NOTE: We check whether the flag exists in self, but remove it from\n-            // a different value. This ensure that overlapping flags are handled\n-            // properly. Take the following example:\n+            // If the flag is set in the original source _and_ it has bits that haven't\n+            // been covered by a previous flag yet then yield it. These conditions cover\n+            // two cases for multi-bit flags:\n             //\n-            // const A: 0b00000001;\n-            // const B: 0b00000101;\n-            //\n-            // Given the bits 0b00000101, both A and B are set. But if we removed A\n-            // as we encountered it we'd be left with 0b00000100, which doesn't\n-            // correspond to a valid flag on its own.\n-            if self.source.contains(B::from_bits_retain(bits)) {\n-                self.state.remove(B::from_bits_retain(bits));\n+            // 1. When flags partially overlap, such as `0b00000001` and `0b00000101`, we'll\n+            // yield both flags.\n+            // 2. When flags fully overlap, such as in convenience flags that are a shorthand for others,\n+            // we won't yield both flags.\n+            if self.source.contains(B::from_bits_retain(bits))\n+                && self.remaining.intersects(B::from_bits_retain(bits))\n+            {\n+                self.remaining.remove(B::from_bits_retain(bits));\n \n                 return Some((flag.name(), B::from_bits_retain(bits)));\n             }\n         }\n-        \n+\n         None\n     }\n }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -422,10 +422,11 @@\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n #![cfg_attr(not(test), forbid(unsafe_code))]\n+#![cfg_attr(test, allow(mixed_script_confusables))]\n #![doc(html_root_url = \"https://docs.rs/bitflags/2.3.2\")]\n \n #[doc(inline)]\n-pub use traits::{Flags, Flag, Bits};\n+pub use traits::{Bits, Flag, Flags};\n \n pub mod iter;\n pub mod parser;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -623,6 +624,10 @@ macro_rules! bitflags {\n                 $BitFlags: $T, InternalBitFlags\n             }\n \n+            __impl_public_bitflags_ops! {\n+                $BitFlags\n+            }\n+\n             __impl_public_bitflags_iter! {\n                 $BitFlags: $T, $BitFlags\n             }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -671,6 +676,10 @@ macro_rules! bitflags {\n                 }\n             }\n \n+            __impl_public_bitflags_ops! {\n+                $BitFlags\n+            }\n+\n             __impl_public_bitflags_iter! {\n                 $BitFlags: $T, $BitFlags\n             }\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -714,11 +723,7 @@ macro_rules! __impl_bitflags {\n             fn complement($complement0:ident) $complement:block\n         }\n     ) => {\n-        #[allow(\n-            dead_code,\n-            deprecated,\n-            unused_attributes\n-        )]\n+        #[allow(dead_code, deprecated, unused_attributes)]\n         impl $PublicBitFlags {\n             /// Returns an empty set of flags.\n             #[inline]\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -804,6 +809,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Inserts the specified flags in-place.\n+            ///\n+            /// This method is equivalent to `union`.\n             #[inline]\n             pub fn insert(&mut self, other: Self) {\n                 let $insert0 = self;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -812,6 +819,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Removes the specified flags in-place.\n+            ///\n+            /// This method is equivalent to `difference`.\n             #[inline]\n             pub fn remove(&mut self, other: Self) {\n                 let $remove0 = self;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -820,6 +829,8 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Toggles the specified flags in-place.\n+            ///\n+            /// This method is equivalent to `symmetric_difference`.\n             #[inline]\n             pub fn toggle(&mut self, other: Self) {\n                 let $toggle0 = self;\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -839,13 +850,8 @@ macro_rules! __impl_bitflags {\n             /// Returns the intersection between the flags in `self` and\n             /// `other`.\n             ///\n-            /// Specifically, the returned set contains only the flags which are\n-            /// present in *both* `self` *and* `other`.\n-            ///\n-            /// This is equivalent to using the `&` operator (e.g.\n-            /// [`ops::BitAnd`]), as in `flags & other`.\n-            ///\n-            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n+            /// Calculating `self` bitwise and (`&`) other, including\n+            /// any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn intersection(self, other: Self) -> Self {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -856,15 +862,8 @@ macro_rules! __impl_bitflags {\n \n             /// Returns the union of between the flags in `self` and `other`.\n             ///\n-            /// Specifically, the returned set contains all flags which are\n-            /// present in *either* `self` *or* `other`, including any which are\n-            /// present in both (see [`Self::symmetric_difference`] if that\n-            /// is undesirable).\n-            ///\n-            /// This is equivalent to using the `|` operator (e.g.\n-            /// [`ops::BitOr`]), as in `flags | other`.\n-            ///\n-            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n+            /// Calculates `self` bitwise or (`|`) `other`, including\n+            /// any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn union(self, other: Self) -> Self {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -875,16 +874,13 @@ macro_rules! __impl_bitflags {\n \n             /// Returns the difference between the flags in `self` and `other`.\n             ///\n-            /// Specifically, the returned set contains all flags present in\n-            /// `self`, except for the ones present in `other`.\n-            ///\n-            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n-            /// `flags & !other` (and this syntax is also supported).\n-            ///\n-            /// This is equivalent to using the `-` operator (e.g.\n-            /// [`ops::Sub`]), as in `flags - other`.\n+            /// Calculates `self` bitwise and (`&!`) the bitwise negation of `other`,\n+            /// including any bits that don't correspond to a defined flag.\n             ///\n-            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n+            /// This method is _not_ equivalent to `a & !b` when there are bits set that\n+            /// don't correspond to a defined flag. The `!` operator will unset any\n+            /// bits that don't correspond to a flag, so they'll always be unset by `a &! b`,\n+            /// but respected by `a.difference(b)`.\n             #[inline]\n             #[must_use]\n             pub const fn difference(self, other: Self) -> Self {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -893,19 +889,11 @@ macro_rules! __impl_bitflags {\n                 $difference\n             }\n \n-            /// Returns the [symmetric difference][sym-diff] between the flags\n+            /// Returns the symmetric difference between the flags\n             /// in `self` and `other`.\n             ///\n-            /// Specifically, the returned set contains the flags present which\n-            /// are present in `self` or `other`, but that are not present in\n-            /// both. Equivalently, it contains the flags present in *exactly\n-            /// one* of the sets `self` and `other`.\n-            ///\n-            /// This is equivalent to using the `^` operator (e.g.\n-            /// [`ops::BitXor`]), as in `flags ^ other`.\n-            ///\n-            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n-            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n+            /// Calculates `self` bitwise exclusive or (`^`) `other`,\n+            /// including any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn symmetric_difference(self, other: Self) -> Self {\n\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -916,17 +904,8 @@ macro_rules! __impl_bitflags {\n \n             /// Returns the complement of this set of flags.\n             ///\n-            /// Specifically, the returned set contains all the flags which are\n-            /// not set in `self`, but which are allowed for this type.\n-            ///\n-            /// Alternatively, it can be thought of as the set difference\n-            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n-            ///\n-            /// This is equivalent to using the `!` operator (e.g.\n-            /// [`ops::Not`]), as in `!flags`.\n-            ///\n-            /// [`Self::all()`]: Self::all\n-            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n+            /// Calculates the bitwise negation (`!`) of `self`,\n+            /// **unsetting** any bits that don't correspond to a defined flag.\n             #[inline]\n             #[must_use]\n             pub const fn complement(self) -> Self {\n\ndiff --git a/src/parser.rs b/src/parser.rs\n--- a/src/parser.rs\n+++ b/src/parser.rs\n@@ -30,7 +30,7 @@\n \n use core::fmt::{self, Write};\n \n-use crate::{Flags, Bits};\n+use crate::{Bits, Flags};\n \n /// Write a set of flags to a writer.\n ///\n\ndiff --git a/src/parser.rs b/src/parser.rs\n--- a/src/parser.rs\n+++ b/src/parser.rs\n@@ -48,7 +48,7 @@ where\n     // followed by a hex number of any remaining bits that are set\n     // but don't correspond to any flags.\n \n-    // Iterate over the valid flags\n+    // Iterate over known flag values\n     let mut first = true;\n     let mut iter = flags.iter_names();\n     for (name, _) in &mut iter {\n\ndiff --git a/src/parser.rs b/src/parser.rs\n--- a/src/parser.rs\n+++ b/src/parser.rs\n@@ -110,7 +110,8 @@ where\n         // If the flag starts with `0x` then it's a hex number\n         // Parse it directly to the underlying bits type\n         let parsed_flag = if let Some(flag) = flag.strip_prefix(\"0x\") {\n-            let bits = <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n+            let bits =\n+                <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n \n             B::from_bits_retain(bits)\n         }\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -117,8 +117,6 @@ macro_rules! __impl_public_bitflags_forward {\n                 }\n             }\n         }\n-\n-        __impl_public_bitflags_ops!($PublicBitFlags);\n     };\n }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -203,31 +201,33 @@ macro_rules! __impl_public_bitflags {\n                 }\n \n                 fn is_empty(f) {\n-                    f.0 == Self::empty().0\n+                    f.bits() == <$T as $crate::Bits>::EMPTY\n                 }\n \n                 fn is_all(f) {\n-                    Self::all().0 | f.0 == f.0\n+                    // NOTE: We check against `Self::all` here, not `Self::Bits::ALL`\n+                    // because the set of all flags may not use all bits\n+                    Self::all().bits() | f.bits() == f.bits()\n                 }\n \n                 fn intersects(f, other) {\n-                    !(Self(f.0 & other.0)).is_empty()\n+                    f.bits() & other.bits() != <$T as $crate::Bits>::EMPTY\n                 }\n \n                 fn contains(f, other) {\n-                    (f.0 & other.0) == other.0\n+                    f.bits() & other.bits() == other.bits()\n                 }\n \n                 fn insert(f, other) {\n-                    f.0 = f.0 | other.0;\n+                    *f = Self::from_bits_retain(f.bits() | other.bits());\n                 }\n \n                 fn remove(f, other) {\n-                    f.0 = f.0 & !other.0;\n+                    *f = Self::from_bits_retain(f.bits() & !other.bits());\n                 }\n \n                 fn toggle(f, other) {\n-                    f.0 = f.0 ^ other.0;\n+                    *f = Self::from_bits_retain(f.bits() ^ other.bits());\n                 }\n \n                 fn set(f, other, value) {\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -239,28 +239,26 @@ macro_rules! __impl_public_bitflags {\n                 }\n \n                 fn intersection(f, other) {\n-                    Self(f.0 & other.0)\n+                    Self::from_bits_retain(f.bits() & other.bits())\n                 }\n \n                 fn union(f, other) {\n-                    Self(f.0 | other.0)\n+                    Self::from_bits_retain(f.bits() | other.bits())\n                 }\n \n                 fn difference(f, other) {\n-                    Self(f.0 & !other.0)\n+                    Self::from_bits_retain(f.bits() & !other.bits())\n                 }\n \n                 fn symmetric_difference(f, other) {\n-                    Self(f.0 ^ other.0)\n+                    Self::from_bits_retain(f.bits() ^ other.bits())\n                 }\n \n                 fn complement(f) {\n-                    Self::from_bits_truncate(!f.0)\n+                    Self::from_bits_truncate(!f.bits())\n                 }\n             }\n         }\n-\n-        __impl_public_bitflags_ops!($BitFlags);\n     };\n }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -273,13 +271,21 @@ macro_rules! __impl_public_bitflags_iter {\n             /// Iterate over enabled flag values.\n             #[inline]\n             pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n-                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n+                $crate::iter::Iter::__private_const_new(\n+                    <$PublicBitFlags as $crate::Flags>::FLAGS,\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                )\n             }\n \n             /// Iterate over enabled flag values with their stringified names.\n             #[inline]\n             pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n-                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n+                $crate::iter::IterNames::__private_const_new(\n+                    <$PublicBitFlags as $crate::Flags>::FLAGS,\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                    $PublicBitFlags::from_bits_retain(self.bits()),\n+                )\n             }\n         }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -300,25 +306,37 @@ macro_rules! __impl_public_bitflags_iter {\n macro_rules! __impl_public_bitflags_ops {\n     ($PublicBitFlags:ident) => {\n         impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n         impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+            fn fmt(\n+                &self,\n+                f: &mut $crate::__private::core::fmt::Formatter,\n+            ) -> $crate::__private::core::fmt::Result {\n                 $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -337,7 +355,7 @@ macro_rules! __impl_public_bitflags_ops {\n             /// Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.0 = self.0 | other.0;\n+                *self = Self::from_bits_retain(self.bits()).union(other);\n             }\n         }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -355,7 +373,7 @@ macro_rules! __impl_public_bitflags_ops {\n             /// Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.0 = self.0 ^ other.0\n+                *self = Self::from_bits_retain(self.bits()).symmetric_difference(other);\n             }\n         }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -373,7 +391,7 @@ macro_rules! __impl_public_bitflags_ops {\n             /// Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.0 = self.0 & other.0;\n+                *self = Self::from_bits_retain(self.bits()).intersection(other);\n             }\n         }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -391,7 +409,7 @@ macro_rules! __impl_public_bitflags_ops {\n             /// Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.0 = self.0 & !other.0;\n+                *self = Self::from_bits_retain(self.bits()).difference(other);\n             }\n         }\n \n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -406,7 +424,10 @@ macro_rules! __impl_public_bitflags_ops {\n         }\n \n         impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n-            fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n+            fn extend<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n+                &mut self,\n+                iterator: T,\n+            ) {\n                 for item in iterator {\n                     self.insert(item)\n                 }\n\ndiff --git a/src/public.rs b/src/public.rs\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -414,7 +435,9 @@ macro_rules! __impl_public_bitflags_ops {\n         }\n \n         impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n-            fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n+            fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n+                iterator: T,\n+            ) -> Self {\n                 use $crate::__private::core::iter::Extend;\n \n                 let mut result = Self::empty();\n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -1,6 +1,12 @@\n-use core::{fmt, ops::{BitAnd, BitOr, BitXor, Not}};\n+use core::{\n+    fmt,\n+    ops::{BitAnd, BitOr, BitXor, Not},\n+};\n \n-use crate::{parser::{ParseError, ParseHex, WriteHex}, iter};\n+use crate::{\n+    iter,\n+    parser::{ParseError, ParseHex, WriteHex},\n+};\n \n /// Metadata for an individual flag.\n pub struct Flag<B> {\n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -97,7 +103,7 @@ pub trait Flags: Sized + 'static {\n     fn from_name(name: &str) -> Option<Self> {\n         for flag in Self::FLAGS {\n             if flag.name() == name {\n-                return Some(Self::from_bits_retain(flag.value().bits()))\n+                return Some(Self::from_bits_retain(flag.value().bits()));\n             }\n         }\n \n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -143,6 +149,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     /// Inserts the specified flags in-place.\n+    ///\n+    /// This method is equivalent to `union`.\n     fn insert(&mut self, other: Self)\n     where\n         Self: Sized,\n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -151,6 +159,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     /// Removes the specified flags in-place.\n+    ///\n+    /// This method is equivalent to `difference`.\n     fn remove(&mut self, other: Self)\n     where\n         Self: Sized,\n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -159,6 +169,8 @@ pub trait Flags: Sized + 'static {\n     }\n \n     /// Toggles the specified flags in-place.\n+    ///\n+    /// This method is equivalent to `symmetric_difference`.\n     fn toggle(&mut self, other: Self)\n     where\n         Self: Sized,\n\ndiff --git a/src/traits.rs b/src/traits.rs\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -178,57 +190,32 @@ pub trait Flags: Sized + 'static {\n         }\n     }\n \n-    /// Returns the intersection between the flags in `self` and\n-    /// `other`.\n-    ///\n-    /// Specifically, the returned set contains only the flags which are\n-    /// present in *both* `self` *and* `other`.\n+    /// Returns the intersection between the flags in `self` and `other`.\n     #[must_use]\n     fn intersection(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() & other.bits())\n     }\n \n     /// Returns the union of between the flags in `self` and `other`.\n-    ///\n-    /// Specifically, the returned set contains all flags which are\n-    /// present in *either* `self` *or* `other`, including any which are\n-    /// present in both (see [`Self::symmetric_difference`] if that\n-    /// is undesirable).\n     #[must_use]\n     fn union(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() | other.bits())\n     }\n \n     /// Returns the difference between the flags in `self` and `other`.\n-    ///\n-    /// Specifically, the returned set contains all flags present in\n-    /// `self`, except for the ones present in `other`.\n-    ///\n-    /// It is also conceptually equivalent to the \"bit-clear\" operation:\n-    /// `flags & !other` (and this syntax is also supported).\n     #[must_use]\n     fn difference(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() & !other.bits())\n     }\n \n-    /// Returns the [symmetric difference][sym-diff] between the flags\n+    /// Returns the symmetric difference between the flags\n     /// in `self` and `other`.\n-    ///\n-    /// Specifically, the returned set contains the flags present which\n-    /// are present in `self` or `other`, but that are not present in\n-    /// both. Equivalently, it contains the flags present in *exactly\n-    /// one* of the sets `self` and `other`.\n-    ///\n-    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n     #[must_use]\n     fn symmetric_difference(self, other: Self) -> Self {\n         Self::from_bits_retain(self.bits() ^ other.bits())\n     }\n \n     /// Returns the complement of this set of flags.\n-    ///\n-    /// Specifically, the returned set contains all the flags which are\n-    /// not set in `self`, but which are allowed for this type.\n     #[must_use]\n     fn complement(self) -> Self {\n         Self::from_bits_truncate(!self.bits())\n\ndiff --git a/tests/basic.rs b/tests/basic.rs\n--- a/tests/basic.rs\n+++ b/tests/basic.rs\n@@ -3,19 +3,77 @@\n use bitflags::bitflags;\n \n bitflags! {\n-    /// baz\n-    #[derive(Debug, PartialEq, Eq)]\n-    struct Flags: u32 {\n+    pub struct I8: i8 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I16: i16 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I32: i32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I64: i64 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct I128: i128 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct Isize: isize {\n         const A = 0b00000001;\n-        #[doc = \"bar\"]\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        #[doc = \"foo\"]\n-        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \n-#[test]\n-fn basic() {\n-    assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n+bitflags! {\n+    pub struct U8: u8 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U16: u16 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U32: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U64: u64 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct U128: u128 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+\n+    pub struct Usize: usize {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n }\n\ndiff --git a/tests/compile-fail/bitflags_custom_bits.stderr b/tests/compile-fail/bitflags_custom_bits.stderr\n--- a/tests/compile-fail/bitflags_custom_bits.stderr\n+++ b/tests/compile-fail/bitflags_custom_bits.stderr\n@@ -34,443 +34,3 @@ error[E0308]: mismatched types\n                   found type parameter `W`\n note: method defined here\n    --> $RUST/core/src/fmt/mod.rs\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt | MyInt`\n-    |\n-    = help: the trait `~const BitOr` is not implemented for `MyInt`\n-note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt & MyInt`\n-    |\n-    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n-note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ the trait `~const Not` is not implemented for `MyInt`\n-    |\n-note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ no implementation for `MyInt ^ MyInt`\n-    |\n-    = help: the trait `~const BitXor` is not implemented for `MyInt`\n-note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^ the trait `~const Not` is not implemented for `MyInt`\n-    |\n-note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n-    |\n-132 | / bitflags! {\n-133 | |     struct Flags128: MyInt {\n-134 | |         const A = MyInt(0b0000_0001u8);\n-135 | |         const B = MyInt(0b0000_0010u8);\n-136 | |         const C = MyInt(0b0000_0100u8);\n-137 | |     }\n-138 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n",
        "problem_statement": "Inconsistent debug output for flag with no bits\nIn a bitflags type where one of the named value has the value 0, the debug output for the type sometimes includes that value by name, and sometimes doesn't, apparently depending on whether any unrecognized bits are present. For example, this:\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    #[derive(Debug)]\r\n    pub struct Flags: u32 {\r\n        const RDONLY = 0;\r\n        const WRONLY = 1;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::RDONLY);\r\n    println!(\"{:?}\", Flags::from_bits_retain(0x100));\r\n}\r\n```\r\nprints\r\n```\r\nFlags(0x0)\r\nFlags(RDONLY | 0x100)\r\n```\r\nI don't have an opinion about whether it should print `RDONLY` in both or neither, but printing it in just one is confusing.\n",
        "hints_text": "The value `0` isn\u2019t recommended as a flag value because it behaves surprisingly with formatting, and with `is_any`.\nIf you do want to define a zero-valued flag I\u2019d suggest defining the constant outside of the `bitflags!` macro.",
        "created_at": "2023-06-26T07:21:41Z",
        "test_patch": "diff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1045,1105 +1024,4 @@ mod external;\n pub mod example_generated;\n \n #[cfg(test)]\n-mod tests {\n-    use std::{\n-        collections::hash_map::DefaultHasher,\n-        fmt,\n-        hash::{Hash, Hasher},\n-        str,\n-    };\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    pub struct ManualFlags(u32);\n-\n-    bitflags! {\n-        #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n-        #[doc = \"> you are the easiest person to fool.\"]\n-        #[doc = \"> \"]\n-        #[doc = \"> - Richard Feynman\"]\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct Flags: u32 {\n-            const A = 0b00000001;\n-            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const B = 0b00000010;\n-            const C = 0b00000100;\n-            #[doc = \"* cmr bed\"]\n-            #[doc = \"* strcat table\"]\n-            #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct _CfgFlags: u32 {\n-            #[cfg(unix)]\n-            const _CFG_A = 0b01;\n-            #[cfg(windows)]\n-            const _CFG_B = 0b01;\n-            #[cfg(unix)]\n-            const _CFG_C = Self::_CFG_A.bits() | 0b10;\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct AnotherSetOfFlags: i8 {\n-            const ANOTHER_FLAG = -1_i8;\n-        }\n-\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct LongFlags: u32 {\n-            const LONG_A = 0b1111111111111111;\n-        }\n-\n-        impl ManualFlags: u32 {\n-            const A = 0b00000001;\n-            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const B = 0b00000010;\n-            const C = 0b00000100;\n-            #[doc = \"* cmr bed\"]\n-            #[doc = \"* strcat table\"]\n-            #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-        }\n-    }\n-\n-    bitflags! {\n-        #[derive(Debug, PartialEq, Eq)]\n-        struct FmtFlags: u16 {\n-            const \uace0\uc591\uc774 = 0b0000_0001;\n-            const \uac1c = 0b0000_0010;\n-            const \ubb3c\uace0\uae30 = 0b0000_0100;\n-            const \ubb3c\uace0\uae30_\uace0\uc591\uc774 = Self::\uace0\uc591\uc774.bits() | Self::\ubb3c\uace0\uae30.bits();\n-        }\n-    }\n-\n-    impl str::FromStr for FmtFlags {\n-        type Err = crate::parser::ParseError;\n-\n-        fn from_str(flags: &str) -> Result<Self, Self::Err> {\n-            Ok(Self(flags.parse()?))\n-        }\n-    }\n-\n-    impl fmt::Display for FmtFlags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Display::fmt(&self.0, f)\n-        }\n-    }\n-\n-    bitflags! {\n-        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-        struct EmptyFlags: u32 {\n-        }\n-    }\n-\n-    #[test]\n-    fn test_bits() {\n-        assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(Flags::A.bits(), 0b00000001);\n-        assert_eq!(Flags::ABC.bits(), 0b00000111);\n-\n-        assert_eq!(<Flags as crate::Flags>::bits(&Flags::ABC), 0b00000111);\n-\n-        assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n-\n-        assert_eq!(EmptyFlags::empty().bits(), 0b00000000);\n-    }\n-\n-    #[test]\n-    fn test_from_bits() {\n-        assert_eq!(Flags::from_bits(0), Some(Flags::empty()));\n-        assert_eq!(Flags::from_bits(0b1), Some(Flags::A));\n-        assert_eq!(Flags::from_bits(0b10), Some(Flags::B));\n-        assert_eq!(Flags::from_bits(0b11), Some(Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits(0b1000), None);\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits(0b11), Some(Flags::A | Flags::B));\n-\n-        assert_eq!(\n-            AnotherSetOfFlags::from_bits(!0_i8),\n-            Some(AnotherSetOfFlags::ANOTHER_FLAG)\n-        );\n-\n-        assert_eq!(EmptyFlags::from_bits(0), Some(EmptyFlags::empty()));\n-        assert_eq!(EmptyFlags::from_bits(0b1), None);\n-    }\n-\n-    #[test]\n-    fn test_from_bits_truncate() {\n-        assert_eq!(Flags::from_bits_truncate(0), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1), Flags::A);\n-        assert_eq!(Flags::from_bits_truncate(0b10), Flags::B);\n-        assert_eq!(Flags::from_bits_truncate(0b11), (Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits_truncate(0b1000), Flags::empty());\n-        assert_eq!(Flags::from_bits_truncate(0b1001), Flags::A);\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits_truncate(0b11), (Flags::A | Flags::B));\n-\n-        assert_eq!(\n-            AnotherSetOfFlags::from_bits_truncate(0_i8),\n-            AnotherSetOfFlags::empty()\n-        );\n-\n-        assert_eq!(EmptyFlags::from_bits_truncate(0), EmptyFlags::empty());\n-        assert_eq!(EmptyFlags::from_bits_truncate(0b1), EmptyFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_from_bits_retain() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        assert_eq!(Flags::from_bits_retain(0), Flags::empty());\n-        assert_eq!(Flags::from_bits_retain(0b1), Flags::A);\n-        assert_eq!(Flags::from_bits_retain(0b10), Flags::B);\n-\n-        assert_eq!(Flags::from_bits_retain(0b11), (Flags::A | Flags::B));\n-        assert_eq!(Flags::from_bits_retain(0b1000), (extra | Flags::empty()));\n-        assert_eq!(Flags::from_bits_retain(0b1001), (extra | Flags::A));\n-\n-        assert_eq!(<Flags as crate::Flags>::from_bits_retain(0b11), (Flags::A | Flags::B));\n-\n-        let extra = EmptyFlags::from_bits_retain(0b1000);\n-        assert_eq!(\n-            EmptyFlags::from_bits_retain(0b1000),\n-            (extra | EmptyFlags::empty())\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        assert!(Flags::empty().is_empty());\n-        assert!(!Flags::A.is_empty());\n-        assert!(!Flags::ABC.is_empty());\n-\n-        assert!(!<Flags as crate::Flags>::is_empty(&Flags::ABC));\n-\n-        assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n-\n-        assert!(EmptyFlags::empty().is_empty());\n-        assert!(EmptyFlags::all().is_empty());\n-    }\n-\n-    #[test]\n-    fn test_is_all() {\n-        assert!(Flags::all().is_all());\n-        assert!(!Flags::A.is_all());\n-        assert!(Flags::ABC.is_all());\n-\n-        let extra = Flags::from_bits_retain(0b1000);\n-        assert!(!extra.is_all());\n-        assert!(!(Flags::A | extra).is_all());\n-        assert!((Flags::ABC | extra).is_all());\n-\n-        assert!(<Flags as crate::Flags>::is_all(&Flags::all()));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n-\n-        assert!(EmptyFlags::all().is_all());\n-        assert!(EmptyFlags::empty().is_all());\n-    }\n-\n-    #[test]\n-    fn test_two_empties_do_not_intersect() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::empty();\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.intersects(AnotherSetOfFlags::ANOTHER_FLAG));\n-    }\n-\n-    #[test]\n-    fn test_empty_does_not_intersect_with_full() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::ABC;\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_disjoint_intersects() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::B;\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_overlapping_intersects() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        assert!(e1.intersects(e2));\n-\n-        assert!(<Flags as crate::Flags>::intersects(&e1, e2));\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        assert!(!e1.contains(e2));\n-        assert!(e2.contains(e1));\n-        assert!(Flags::ABC.contains(e2));\n-\n-        assert!(<Flags as crate::Flags>::contains(&Flags::ABC, e2));\n-\n-        assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n-\n-        assert!(EmptyFlags::empty().contains(EmptyFlags::empty()));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        e1.insert(e2);\n-        assert_eq!(e1, e2);\n-\n-        let mut e1 = Flags::A;\n-        let e2 = Flags::A | Flags::B;\n-        <Flags as crate::Flags>::insert(&mut e1, e2);\n-        assert_eq!(e1, e2);\n-\n-        let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherSetOfFlags::ANOTHER_FLAG);\n-        assert_eq!(e3, AnotherSetOfFlags::ANOTHER_FLAG);\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut e1 = Flags::A | Flags::B;\n-        let e2 = Flags::A | Flags::C;\n-        e1.remove(e2);\n-        assert_eq!(e1, Flags::B);\n-\n-        let mut e1 = Flags::A | Flags::B;\n-        let e2 = Flags::A | Flags::C;\n-        <Flags as crate::Flags>::remove(&mut e1, e2);\n-        assert_eq!(e1, Flags::B);\n-\n-        let mut e3 = AnotherSetOfFlags::ANOTHER_FLAG;\n-        e3.remove(AnotherSetOfFlags::ANOTHER_FLAG);\n-        assert_eq!(e3, AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_operators() {\n-        let e1 = Flags::A | Flags::C;\n-        let e2 = Flags::B | Flags::C;\n-        assert_eq!((e1 | e2), Flags::ABC); // union\n-        assert_eq!((e1 & e2), Flags::C); // intersection\n-        assert_eq!((e1 - e2), Flags::A); // set difference\n-        assert_eq!(!e2, Flags::A); // set complement\n-        assert_eq!(e1 ^ e2, Flags::A | Flags::B); // toggle\n-        let mut e3 = e1;\n-        e3.toggle(e2);\n-        assert_eq!(e3, Flags::A | Flags::B);\n-\n-        let mut m4 = AnotherSetOfFlags::empty();\n-        m4.toggle(AnotherSetOfFlags::empty());\n-        assert_eq!(m4, AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_operators_unchecked() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        let e1 = Flags::A | Flags::C | extra;\n-        let e2 = Flags::B | Flags::C;\n-        assert_eq!((e1 | e2), (Flags::ABC | extra)); // union\n-        assert_eq!((e1 & e2), Flags::C); // intersection\n-        assert_eq!((e1 - e2), (Flags::A | extra)); // set difference\n-        assert_eq!(!e2, Flags::A); // set complement\n-        assert_eq!(!e1, Flags::B); // set complement\n-        assert_eq!(e1 ^ e2, Flags::A | Flags::B | extra); // toggle\n-        let mut e3 = e1;\n-        e3.toggle(e2);\n-        assert_eq!(e3, Flags::A | Flags::B | extra);\n-    }\n-\n-    #[test]\n-    fn test_set_ops_basic() {\n-        let ab = Flags::A.union(Flags::B);\n-        let ac = Flags::A.union(Flags::C);\n-        let bc = Flags::B.union(Flags::C);\n-        assert_eq!(ab.bits(), 0b011);\n-        assert_eq!(bc.bits(), 0b110);\n-        assert_eq!(ac.bits(), 0b101);\n-\n-        assert_eq!(ab, Flags::B.union(Flags::A));\n-        assert_eq!(ac, Flags::C.union(Flags::A));\n-        assert_eq!(bc, Flags::C.union(Flags::B));\n-\n-        assert_eq!(ac, <Flags as crate::Flags>::union(Flags::A, Flags::C));\n-\n-        assert_eq!(ac, Flags::A | Flags::C);\n-        assert_eq!(bc, Flags::B | Flags::C);\n-        assert_eq!(ab.union(bc), Flags::ABC);\n-\n-        assert_eq!(ac, Flags::A | Flags::C);\n-        assert_eq!(bc, Flags::B | Flags::C);\n-\n-        assert_eq!(ac.union(bc), ac | bc);\n-        assert_eq!(ac.union(bc), Flags::ABC);\n-        assert_eq!(bc.union(ac), Flags::ABC);\n-\n-        assert_eq!(ac.intersection(bc), ac & bc);\n-        assert_eq!(ac.intersection(bc), Flags::C);\n-        assert_eq!(bc.intersection(ac), Flags::C);\n-\n-        assert_eq!(Flags::C, <Flags as crate::Flags>::intersection(ac, bc));\n-\n-        assert_eq!(ac.difference(bc), ac - bc);\n-        assert_eq!(bc.difference(ac), bc - ac);\n-        assert_eq!(ac.difference(bc), Flags::A);\n-        assert_eq!(bc.difference(ac), Flags::B);\n-\n-        assert_eq!(bc, <Flags as crate::Flags>::difference(bc, Flags::A));\n-\n-        assert_eq!(bc.complement(), !bc);\n-        assert_eq!(bc.complement(), Flags::A);\n-\n-        assert_eq!(Flags::A, <Flags as crate::Flags>::complement(bc));\n-\n-        assert_eq!(ac.symmetric_difference(bc), Flags::A.union(Flags::B));\n-        assert_eq!(bc.symmetric_difference(ac), Flags::A.union(Flags::B));\n-\n-        assert_eq!(ab, <Flags as crate::Flags>::symmetric_difference(ac, bc));\n-    }\n-\n-    #[test]\n-    fn test_set_ops_const() {\n-        // These just test that these compile and don't cause use-site panics\n-        // (would be possible if we had some sort of UB)\n-        const INTERSECT: Flags = Flags::all().intersection(Flags::C);\n-        const UNION: Flags = Flags::A.union(Flags::C);\n-        const DIFFERENCE: Flags = Flags::all().difference(Flags::A);\n-        const COMPLEMENT: Flags = Flags::C.complement();\n-        const SYM_DIFFERENCE: Flags = UNION.symmetric_difference(DIFFERENCE);\n-        assert_eq!(INTERSECT, Flags::C);\n-        assert_eq!(UNION, Flags::A | Flags::C);\n-        assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n-        assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(\n-            SYM_DIFFERENCE,\n-            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n-        );\n-    }\n-\n-    #[test]\n-    fn test_set_ops_unchecked() {\n-        let extra = Flags::from_bits_retain(0b1000);\n-        let e1 = Flags::A.union(Flags::C).union(extra);\n-        let e2 = Flags::B.union(Flags::C);\n-        assert_eq!(e1.bits(), 0b1101);\n-        assert_eq!(e1.union(e2), (Flags::ABC | extra));\n-        assert_eq!(e1.intersection(e2), Flags::C);\n-        assert_eq!(e1.difference(e2), Flags::A | extra);\n-        assert_eq!(e2.difference(e1), Flags::B);\n-        assert_eq!(e2.complement(), Flags::A);\n-        assert_eq!(e1.complement(), Flags::B);\n-        assert_eq!(e1.symmetric_difference(e2), Flags::A | Flags::B | extra); // toggle\n-    }\n-\n-    #[test]\n-    fn test_set_ops_exhaustive() {\n-        // Define a flag that contains gaps to help exercise edge-cases,\n-        // especially around \"unknown\" flags (e.g. ones outside of `all()`\n-        // `from_bits_retain`).\n-        // - when lhs and rhs both have different sets of unknown flags.\n-        // - unknown flags at both ends, and in the middle\n-        // - cases with \"gaps\".\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Test: u16 {\n-                // Intentionally no `A`\n-                const B = 0b000000010;\n-                // Intentionally no `C`\n-                const D = 0b000001000;\n-                const E = 0b000010000;\n-                const F = 0b000100000;\n-                const G = 0b001000000;\n-                // Intentionally no `H`\n-                const I = 0b100000000;\n-            }\n-        }\n-        let iter_test_flags = || (0..=0b111_1111_1111).map(|bits| Test::from_bits_retain(bits));\n-\n-        for a in iter_test_flags() {\n-            assert_eq!(\n-                a.complement(),\n-                Test::from_bits_truncate(!a.bits()),\n-                \"wrong result: !({:?})\",\n-                a,\n-            );\n-            assert_eq!(a.complement(), !a, \"named != op: !({:?})\", a);\n-            for b in iter_test_flags() {\n-                // Check that the named operations produce the expected bitwise\n-                // values.\n-                assert_eq!(\n-                    a.union(b).bits(),\n-                    a.bits() | b.bits(),\n-                    \"wrong result: `{:?}` | `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.intersection(b).bits(),\n-                    a.bits() & b.bits(),\n-                    \"wrong result: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b).bits(),\n-                    a.bits() ^ b.bits(),\n-                    \"wrong result: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.difference(b).bits(),\n-                    a.bits() & !b.bits(),\n-                    \"wrong result: `{:?}` - `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                // Note: Difference is checked as both `a - b` and `b - a`\n-                assert_eq!(\n-                    b.difference(a).bits(),\n-                    b.bits() & !a.bits(),\n-                    \"wrong result: `{:?}` - `{:?}`\",\n-                    b,\n-                    a,\n-                );\n-                // Check that the named set operations are equivalent to the\n-                // bitwise equivalents\n-                assert_eq!(a.union(b), a | b, \"named != op: `{:?}` | `{:?}`\", a, b,);\n-                assert_eq!(\n-                    a.intersection(b),\n-                    a & b,\n-                    \"named != op: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b),\n-                    a ^ b,\n-                    \"named != op: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(a.difference(b), a - b, \"named != op: `{:?}` - `{:?}`\", a, b,);\n-                // Note: Difference is checked as both `a - b` and `b - a`\n-                assert_eq!(b.difference(a), b - a, \"named != op: `{:?}` - `{:?}`\", b, a,);\n-                // Verify that the operations which should be symmetric are\n-                // actually symmetric.\n-                assert_eq!(a.union(b), b.union(a), \"asymmetry: `{:?}` | `{:?}`\", a, b,);\n-                assert_eq!(\n-                    a.intersection(b),\n-                    b.intersection(a),\n-                    \"asymmetry: `{:?}` & `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-                assert_eq!(\n-                    a.symmetric_difference(b),\n-                    b.symmetric_difference(a),\n-                    \"asymmetry: `{:?}` ^ `{:?}`\",\n-                    a,\n-                    b,\n-                );\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_set() {\n-        let mut e1 = Flags::A | Flags::C;\n-        e1.set(Flags::B, true);\n-        e1.set(Flags::C, false);\n-\n-        assert_eq!(e1, Flags::A | Flags::B);\n-    }\n-\n-    #[test]\n-    fn test_assignment_operators() {\n-        let mut m1 = Flags::empty();\n-        let e1 = Flags::A | Flags::C;\n-        // union\n-        m1 |= Flags::A;\n-        assert_eq!(m1, Flags::A);\n-        // intersection\n-        m1 &= e1;\n-        assert_eq!(m1, Flags::A);\n-        // set difference\n-        m1 -= m1;\n-        assert_eq!(m1, Flags::empty());\n-        // toggle\n-        m1 ^= e1;\n-        assert_eq!(m1, e1);\n-    }\n-\n-    #[test]\n-    fn test_const_fn() {\n-        const _M1: Flags = Flags::empty();\n-\n-        const M2: Flags = Flags::A;\n-        assert_eq!(M2, Flags::A);\n-\n-        const M3: Flags = Flags::C;\n-        assert_eq!(M3, Flags::C);\n-    }\n-\n-    #[test]\n-    fn test_extend() {\n-        let mut flags;\n-\n-        flags = Flags::empty();\n-        flags.extend([].iter().cloned());\n-        assert_eq!(flags, Flags::empty());\n-\n-        flags = Flags::empty();\n-        flags.extend([Flags::A, Flags::B].iter().cloned());\n-        assert_eq!(flags, Flags::A | Flags::B);\n-\n-        flags = Flags::A;\n-        flags.extend([Flags::A, Flags::B].iter().cloned());\n-        assert_eq!(flags, Flags::A | Flags::B);\n-\n-        flags = Flags::B;\n-        flags.extend([Flags::A, Flags::ABC].iter().cloned());\n-        assert_eq!(flags, Flags::ABC);\n-    }\n-\n-    #[test]\n-    fn test_from_iterator() {\n-        assert_eq!([].iter().cloned().collect::<Flags>(), Flags::empty());\n-        assert_eq!(\n-            [Flags::A, Flags::B].iter().cloned().collect::<Flags>(),\n-            Flags::A | Flags::B\n-        );\n-        assert_eq!(\n-            [Flags::A, Flags::ABC].iter().cloned().collect::<Flags>(),\n-            Flags::ABC\n-        );\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(!(a < b) && !(b < a));\n-        b = Flags::B;\n-        assert!(a < b);\n-        a = Flags::C;\n-        assert!(!(a < b) && b < a);\n-        b = Flags::C | Flags::B;\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(a <= b && a >= b);\n-        a = Flags::A;\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b = Flags::B;\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    fn hash<T: Hash>(t: &T) -> u64 {\n-        let mut s = DefaultHasher::new();\n-        t.hash(&mut s);\n-        s.finish()\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let mut x = Flags::empty();\n-        let mut y = Flags::empty();\n-        assert_eq!(hash(&x), hash(&y));\n-        x = Flags::all();\n-        y = Flags::ABC;\n-        assert_eq!(hash(&x), hash(&y));\n-    }\n-\n-    #[test]\n-    fn test_default() {\n-        assert_eq!(Flags::empty(), Flags::default());\n-    }\n-\n-    #[test]\n-    fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(0x0)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n-\n-        let extra = Flags::from_bits_retain(0xb8);\n-\n-        assert_eq!(format!(\"{:?}\", extra), \"Flags(0xb8)\");\n-        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"Flags(A | 0xb8)\");\n-\n-        assert_eq!(\n-            format!(\"{:?}\", Flags::ABC | extra),\n-            \"Flags(A | B | C | ABC | 0xb8)\"\n-        );\n-\n-        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"EmptyFlags(0x0)\");\n-    }\n-\n-    #[test]\n-    fn test_display_from_str_roundtrip() {\n-        fn format_parse_case<T: fmt::Debug + fmt::Display + str::FromStr + PartialEq>(flags: T) where <T as str::FromStr>::Err: fmt::Display {\n-            assert_eq!(flags, {\n-                match flags.to_string().parse::<T>() {\n-                    Ok(flags) => flags,\n-                    Err(e) => panic!(\"failed to parse `{}`: {}\", flags, e),\n-                }\n-            });\n-        }\n-\n-        fn parse_case<T: fmt::Debug + str::FromStr + PartialEq>(expected: T, flags: &str) where <T as str::FromStr>::Err: fmt::Display + fmt::Debug {\n-            assert_eq!(expected, flags.parse::<T>().unwrap());\n-        }\n-\n-        bitflags! {\n-            #[derive(Debug, Eq, PartialEq)]\n-            pub struct MultiBitFmtFlags: u8 {\n-                const A = 0b0000_0001u8;\n-                const B = 0b0001_1110u8;\n-            }\n-        }\n-\n-        impl fmt::Display for MultiBitFmtFlags {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::Display::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl str::FromStr for MultiBitFmtFlags {\n-            type Err = crate::parser::ParseError;\n-\n-            fn from_str(s: &str) -> Result<Self, Self::Err> {\n-                Ok(MultiBitFmtFlags(s.parse()?))\n-            }\n-        }\n-\n-        format_parse_case(FmtFlags::empty());\n-        format_parse_case(FmtFlags::all());\n-        format_parse_case(FmtFlags::\uace0\uc591\uc774);\n-        format_parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c);\n-        format_parse_case(FmtFlags::\ubb3c\uace0\uae30_\uace0\uc591\uc774);\n-        format_parse_case(FmtFlags::from_bits_retain(0xb8));\n-        format_parse_case(FmtFlags::from_bits_retain(0x20));\n-        format_parse_case(MultiBitFmtFlags::from_bits_retain(3));\n-\n-        parse_case(FmtFlags::empty(), \"\");\n-        parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n-        parse_case(FmtFlags::empty(), \"0x0\");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"  \uace0\uc591\uc774  \");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774 | \uace0\uc591\uc774 | \uace0\uc591\uc774\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774, \"0x01\");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\uace0\uc591\uc774 | \uac1c\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\uace0\uc591\uc774|\uac1c\");\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\uac1c, \"\\n\uace0\uc591\uc774|\uac1c \");\n-\n-        parse_case(FmtFlags::\uace0\uc591\uc774 | FmtFlags::\ubb3c\uace0\uae30, \"\ubb3c\uace0\uae30_\uace0\uc591\uc774\");\n-    }\n-\n-    #[test]\n-    fn test_from_str_err() {\n-        fn parse_case(pat: &str, flags: &str) {\n-            let err = flags.parse::<FmtFlags>().unwrap_err().to_string();\n-            assert!(err.contains(pat), \"`{}` not found in error `{}`\", pat, err);\n-        }\n-\n-        parse_case(\"empty flag\", \"|\");\n-        parse_case(\"empty flag\", \"|||\");\n-        parse_case(\"empty flag\", \"\uace0\uc591\uc774 |\");\n-        parse_case(\"unrecognized named flag\", \"NOT_A_FLAG\");\n-        parse_case(\"unrecognized named flag\", \"\uace0\uc591\uc774 \uac1c\");\n-        parse_case(\"unrecognized named flag\", \"\uace0\uc591\uc774 | NOT_A_FLAG\");\n-        parse_case(\"invalid hex flag\", \"0xhi\");\n-        parse_case(\"invalid hex flag\", \"\uace0\uc591\uc774 | 0xhi\");\n-    }\n-\n-    #[test]\n-    fn test_binary() {\n-        assert_eq!(format!(\"{:b}\", Flags::ABC), \"111\");\n-        assert_eq!(format!(\"{:#b}\", Flags::ABC), \"0b111\");\n-        let extra = Flags::from_bits_retain(0b1010000);\n-        assert_eq!(format!(\"{:b}\", Flags::ABC | extra), \"1010111\");\n-        assert_eq!(format!(\"{:#b}\", Flags::ABC | extra), \"0b1010111\");\n-    }\n-\n-    #[test]\n-    fn test_octal() {\n-        assert_eq!(format!(\"{:o}\", LongFlags::LONG_A), \"177777\");\n-        assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A), \"0o177777\");\n-        let extra = LongFlags::from_bits_retain(0o5000000);\n-        assert_eq!(format!(\"{:o}\", LongFlags::LONG_A | extra), \"5177777\");\n-        assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A | extra), \"0o5177777\");\n-    }\n-\n-    #[test]\n-    fn test_lowerhex() {\n-        assert_eq!(format!(\"{:x}\", LongFlags::LONG_A), \"ffff\");\n-        assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A), \"0xffff\");\n-        let extra = LongFlags::from_bits_retain(0xe00000);\n-        assert_eq!(format!(\"{:x}\", LongFlags::LONG_A | extra), \"e0ffff\");\n-        assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A | extra), \"0xe0ffff\");\n-    }\n-\n-    #[test]\n-    fn test_upperhex() {\n-        assert_eq!(format!(\"{:X}\", LongFlags::LONG_A), \"FFFF\");\n-        assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A), \"0xFFFF\");\n-        let extra = LongFlags::from_bits_retain(0xe00000);\n-        assert_eq!(format!(\"{:X}\", LongFlags::LONG_A | extra), \"E0FFFF\");\n-        assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A | extra), \"0xE0FFFF\");\n-    }\n-\n-    mod submodule {\n-        bitflags! {\n-            #[derive(Clone, Copy)]\n-            pub struct PublicFlags: i8 {\n-                const X = 0;\n-            }\n-\n-            #[derive(Clone, Copy)]\n-            struct PrivateFlags: i8 {\n-                const Y = 0;\n-            }\n-        }\n-\n-        #[test]\n-        fn test_private() {\n-            let _ = PrivateFlags::Y;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_public() {\n-        let _ = submodule::PublicFlags::X;\n-    }\n-\n-    mod t1 {\n-        mod foo {\n-            pub type Bar = i32;\n-        }\n-\n-        bitflags! {\n-            /// baz\n-            #[derive(Clone, Copy)]\n-            struct Flags: foo::Bar {\n-                const A = 0b00000001;\n-                #[cfg(foo)]\n-                const B = 0b00000010;\n-                #[cfg(foo)]\n-                const C = 0b00000010;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_in_function() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 1;\n-                #[cfg(any())] // false\n-                const B = 2;\n-            }\n-        }\n-        assert_eq!(Flags::all(), Flags::A);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n-    }\n-\n-    #[test]\n-    fn test_deprecated() {\n-        bitflags! {\n-            #[derive(Clone, Copy)]\n-            pub struct TestFlags: u32 {\n-                #[deprecated(note = \"Use something else.\")]\n-                const ONE = 1;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_pub_crate() {\n-        mod module {\n-            bitflags! {\n-                #[derive(Clone, Copy)]\n-                pub (crate) struct Test: u8 {\n-                    const FOO = 1;\n-                }\n-            }\n-        }\n-\n-        assert_eq!(module::Test::FOO.bits(), 1);\n-    }\n-\n-    #[test]\n-    fn test_pub_in_module() {\n-        mod module {\n-            mod submodule {\n-                bitflags! {\n-                    // `pub (in super)` means only the module `module` will\n-                    // be able to access this.\n-                    #[derive(Clone, Copy)]\n-                    pub (in super) struct Test: u8 {\n-                        const FOO = 1;\n-                    }\n-                }\n-            }\n-\n-            mod test {\n-                // Note: due to `pub (in super)`,\n-                // this cannot be accessed directly by the testing code.\n-                pub(super) fn value() -> u8 {\n-                    super::submodule::Test::FOO.bits()\n-                }\n-            }\n-\n-            pub fn value() -> u8 {\n-                test::value()\n-            }\n-        }\n-\n-        assert_eq!(module::value(), 1)\n-    }\n-\n-    #[test]\n-    fn test_zero_value_flags() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u32 {\n-                const NONE = 0b0;\n-                const SOME = 0b1;\n-            }\n-        }\n-\n-        assert!(Flags::empty().contains(Flags::NONE));\n-        assert!(Flags::SOME.contains(Flags::NONE));\n-        assert!(Flags::NONE.is_empty());\n-\n-        assert_eq!(format!(\"{:?}\", Flags::SOME), \"Flags(NONE | SOME)\");\n-    }\n-\n-    #[test]\n-    fn test_empty_bitflags() {\n-        bitflags! {}\n-    }\n-\n-    #[test]\n-    fn test_u128_bitflags() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u128 {\n-                const A = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n-                const B = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n-                const C = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-                const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n-            }\n-        }\n-\n-        assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n-        assert_eq!(Flags::A.bits(), 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-        assert_eq!(Flags::B.bits(), 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-        assert_eq!(Flags::C.bits(), 0x8000_0000_0000_0000_0000_0000_0000_0000);\n-        assert_eq!(Flags::ABC.bits(), 0x8000_0000_0000_1000_0000_0000_0000_0001);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n-        assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n-        assert_eq!(format!(\"{:?}\", Flags::C), \"Flags(C)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n-    }\n-\n-    #[test]\n-    fn test_from_bits_edge_cases() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-        let flags = Flags::from_bits(0b00000100);\n-        assert_eq!(flags, None);\n-        let flags = Flags::from_bits(0b00000101);\n-        assert_eq!(flags, None);\n-    }\n-\n-    #[test]\n-    fn test_from_bits_truncate_edge_cases() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-        let flags = Flags::from_bits_truncate(0b00000100);\n-        assert_eq!(flags, Flags::empty());\n-        let flags = Flags::from_bits_truncate(0b00000101);\n-        assert_eq!(flags, Flags::A);\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        bitflags! {\n-            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-            struct Flags: u32 {\n-                const ONE  = 0b001;\n-                const TWO  = 0b010;\n-                const THREE = 0b100;\n-                #[cfg(windows)]\n-                const FOUR_WIN = 0b1000;\n-                #[cfg(unix)]\n-                const FOUR_UNIX = 0b10000;\n-                const FIVE = 0b01000100;\n-            }\n-        }\n-\n-        let count = {\n-            #[cfg(any(unix, windows))]\n-            {\n-                5\n-            }\n-\n-            #[cfg(not(any(unix, windows)))]\n-            {\n-                4\n-            }\n-        };\n-\n-        let flags = Flags::all();\n-        assert_eq!(flags.into_iter().count(), count);\n-\n-        for flag in flags.into_iter() {\n-            assert!(flags.contains(flag));\n-        }\n-\n-        let mut iter = flags.iter_names();\n-\n-        assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n-        assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n-        assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n-\n-        #[cfg(unix)]\n-        {\n-            assert_eq!(iter.next().unwrap(), (\"FOUR_UNIX\", Flags::FOUR_UNIX));\n-        }\n-        #[cfg(windows)]\n-        {\n-            assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n-        }\n-\n-        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n-\n-        assert_eq!(iter.next(), None);\n-\n-        let flags = Flags::empty();\n-        assert_eq!(flags.into_iter().count(), 0);\n-\n-        let flags = Flags::ONE | Flags::THREE;\n-        assert_eq!(flags.into_iter().count(), 2);\n-\n-        let mut iter = flags.iter_names();\n-\n-        assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n-        assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n-        assert_eq!(iter.next(), None);\n-\n-        let flags = Flags::from_bits_retain(0b1000_0000);\n-        assert_eq!(flags.into_iter().count(), 1);\n-        assert_eq!(flags.iter_names().count(), 0);\n-    }\n-\n-    #[test]\n-    fn into_iter_from_iter_roundtrip() {\n-        let flags = Flags::ABC | Flags::from_bits_retain(0b1000_0000);\n-\n-        assert_eq!(flags, flags.into_iter().collect::<Flags>());\n-    }\n-\n-    #[test]\n-    fn test_from_name() {\n-        let flags = Flags::all();\n-\n-        let mut rebuilt = Flags::empty();\n-\n-        for (name, value) in flags.iter_names() {\n-            assert_eq!(value, Flags::from_name(name).unwrap());\n-\n-            rebuilt |= Flags::from_name(name).unwrap();\n-        }\n-\n-        assert_eq!(flags, rebuilt);\n-    }\n-\n-    #[test]\n-    fn bits_types() {\n-        bitflags! {\n-            pub struct I8: i8 {\n-                const A = 1;\n-            }\n-\n-            pub struct I16: i16 {\n-                const A = 1;\n-            }\n-\n-            pub struct I32: i32 {\n-                const A = 1;\n-            }\n-\n-            pub struct I64: i64 {\n-                const A = 1;\n-            }\n-\n-            pub struct I128: i128 {\n-                const A = 1;\n-            }\n-\n-            pub struct Isize: isize {\n-                const A = 1;\n-            }\n-\n-            pub struct U8: u8 {\n-                const A = 1;\n-            }\n-\n-            pub struct U16: u16 {\n-                const A = 1;\n-            }\n-\n-            pub struct U32: u32 {\n-                const A = 1;\n-            }\n-\n-            pub struct U64: u64 {\n-                const A = 1;\n-            }\n-\n-            pub struct U128: u128 {\n-                const A = 1;\n-            }\n-\n-            pub struct Usize: usize {\n-                const A = 1;\n-            }\n-        }\n-    }\n-}\n+mod tests;\n\ndiff --git /dev/null b/src/tests.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests.rs\n@@ -0,0 +1,107 @@\n+mod all;\n+mod bits;\n+mod complement;\n+mod contains;\n+mod difference;\n+mod empty;\n+mod eq;\n+mod extend;\n+mod flags;\n+mod fmt;\n+mod from_bits;\n+mod from_bits_retain;\n+mod from_bits_truncate;\n+mod from_name;\n+mod insert;\n+mod intersection;\n+mod intersects;\n+mod is_all;\n+mod is_empty;\n+mod iter;\n+mod parser;\n+mod remove;\n+mod symmetric_difference;\n+mod union;\n+\n+bitflags! {\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestFlags: u8 {\n+        /// 1\n+        const A = 1;\n+\n+        /// 1 << 1\n+        const B = 1 << 1;\n+\n+        /// 1 << 2\n+        const C = 1 << 2;\n+\n+        /// 1 | (1 << 1) | (1 << 2)\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestFlagsInvert: u8 {\n+        /// 1 | (1 << 1) | (1 << 2)\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+\n+        /// 1\n+        const A = 1;\n+\n+        /// 1 << 1\n+        const B = 1 << 1;\n+\n+        /// 1 << 2\n+        const C = 1 << 2;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestZero: u8 {\n+        /// 0\n+        const ZERO = 0;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestZeroOne: u8 {\n+        /// 0\n+        const ZERO = 0;\n+\n+        /// 1\n+        const ONE = 1;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestUnicode: u8 {\n+        /// 1\n+        const \u4e00 = 1;\n+\n+        /// 2\n+        const \u4e8c = 1 << 1;\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestEmpty: u8 {}\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestOverlapping: u8 {\n+        /// 1 | (1 << 1)\n+        const AB = 1 | (1 << 1);\n+\n+        /// (1 << 1) | (1 << 2)\n+        const BC = (1 << 1) | (1 << 2);\n+    }\n+\n+    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct TestOverlappingFull: u8 {\n+        /// 1\n+        const A = 1;\n+\n+        /// 1\n+        const B = 1;\n+\n+        /// 1\n+        const C = 1;\n+\n+        /// 2\n+        const D = 1 << 1;\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/all.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/all.rs\n@@ -0,0 +1,21 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::all);\n+\n+    case(0, TestZero::all);\n+\n+    case(0, TestEmpty::all);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, inherent: impl FnOnce() -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent().bits(), \"T::all()\");\n+    assert_eq!(expected, T::all().bits(), \"Flags::all()\");\n+}\n\ndiff --git /dev/null b/src/tests/bits.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/bits.rs\n@@ -0,0 +1,30 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::empty(), TestFlags::bits);\n+\n+    case(1, TestFlags::A, TestFlags::bits);\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::ABC, TestFlags::bits);\n+\n+    case(!0, TestFlags::from_bits_retain(u8::MAX), TestFlags::bits);\n+    case(1 << 3, TestFlags::from_bits_retain(1 << 3), TestFlags::bits);\n+\n+    case(1 << 3, TestZero::from_bits_retain(1 << 3), TestZero::bits);\n+\n+    case(1 << 3, TestEmpty::from_bits_retain(1 << 3), TestEmpty::bits);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(\n+    expected: T::Bits,\n+    value: T,\n+    inherent: impl FnOnce(&T) -> T::Bits,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent(&value), \"{:?}.bits()\", value);\n+    assert_eq!(expected, Flags::bits(&value), \"Flags::bits({:?})\", value);\n+}\n\ndiff --git /dev/null b/src/tests/complement.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/complement.rs\n@@ -0,0 +1,52 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::all(), TestFlags::complement);\n+    case(0, TestFlags::from_bits_retain(!0), TestFlags::complement);\n+\n+    case(1 | 1 << 1, TestFlags::C, TestFlags::complement);\n+    case(\n+        1 | 1 << 1,\n+        TestFlags::C | TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::complement,\n+    );\n+\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::empty(),\n+        TestFlags::complement,\n+    );\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::complement,\n+    );\n+\n+    case(0, TestZero::empty(), TestZero::complement);\n+\n+    case(0, TestEmpty::empty(), TestEmpty::complement);\n+\n+    // Complement doesn't detect overlapping bits in multi-bit flags\n+    case(0, TestOverlapping::AB, TestOverlapping::complement);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::Not<Output = T> + Copy>(\n+    expected: T::Bits,\n+    value: T,\n+    inherent: impl FnOnce(T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent(value).bits(), \"{:?}.complement()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::complement(value).bits(),\n+        \"Flags::complement({:?})\",\n+        value\n+    );\n+    assert_eq!(expected, (!value).bits(), \"!{:?}\", value);\n+}\n\ndiff --git /dev/null b/src/tests/contains.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/contains.rs\n@@ -0,0 +1,97 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, true),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::ABC, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+            (TestFlags::from_bits_retain(1 | (1 << 3)), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, true),\n+            (TestFlags::B, true),\n+            (TestFlags::C, true),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::empty(), true),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), true),\n+        ],\n+        TestFlags::contains,\n+    );\n+\n+    case(\n+        TestZero::ZERO,\n+        &[(TestZero::ZERO, true)],\n+        TestZero::contains,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[\n+            (TestOverlapping::AB, true),\n+            (TestOverlapping::BC, false),\n+            (TestOverlapping::from_bits_retain(1 << 1), true),\n+        ],\n+        TestOverlapping::contains,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, bool)],\n+    mut inherent: impl FnMut(&T, T) -> bool,\n+) {\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(&value, *input),\n+            \"{:?}.contains({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::contains(&value, *input),\n+            \"Flags::contains({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/difference.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/difference.rs\n@@ -0,0 +1,81 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::A | TestFlags::B,\n+        &[\n+            (TestFlags::A, 1 << 1),\n+            (TestFlags::B, 1),\n+            (TestFlags::from_bits_retain(1 << 3), 1 | 1 << 1),\n+        ],\n+        TestFlags::difference,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 | 1 << 3),\n+        &[\n+            (TestFlags::A, 1 << 3),\n+            (TestFlags::from_bits_retain(1 << 3), 1),\n+        ],\n+        TestFlags::difference,\n+    );\n+\n+    assert_eq!(\n+        0b1111_1110,\n+        (TestFlags::from_bits_retain(!0).difference(TestFlags::A)).bits()\n+    );\n+\n+    // The `!` operator unsets bits that don't correspond to known flags\n+    assert_eq!(\n+        1 << 1 | 1 << 2,\n+        (TestFlags::from_bits_retain(!0) & !TestFlags::A).bits()\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::Sub<Output = T> + std::ops::SubAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.difference({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::difference(value, *input).bits(),\n+            \"Flags::difference({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value - *input).bits(),\n+            \"{:?} - {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value -= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} -= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/empty.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/empty.rs\n@@ -0,0 +1,21 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::empty);\n+\n+    case(0, TestZero::empty);\n+\n+    case(0, TestEmpty::empty);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, inherent: impl FnOnce() -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(expected, inherent().bits(), \"T::empty()\");\n+    assert_eq!(expected, T::empty().bits(), \"Flags::empty()\");\n+}\n\ndiff --git /dev/null b/src/tests/eq.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/eq.rs\n@@ -0,0 +1,10 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    assert_eq!(TestFlags::empty(), TestFlags::empty());\n+    assert_eq!(TestFlags::all(), TestFlags::all());\n+\n+    assert!(TestFlags::from_bits_retain(1) < TestFlags::from_bits_retain(2));\n+    assert!(TestFlags::from_bits_retain(2) > TestFlags::from_bits_retain(1));\n+}\n\ndiff --git /dev/null b/src/tests/extend.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/extend.rs\n@@ -0,0 +1,18 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    let mut flags = TestFlags::empty();\n+\n+    flags.extend(TestFlags::A);\n+\n+    assert_eq!(TestFlags::A, flags);\n+\n+    flags.extend(TestFlags::A | TestFlags::B | TestFlags::C);\n+\n+    assert_eq!(TestFlags::ABC, flags);\n+\n+    flags.extend(TestFlags::from_bits_retain(1 << 5));\n+\n+    assert_eq!(TestFlags::ABC | TestFlags::from_bits_retain(1 << 5), flags);\n+}\n\ndiff --git /dev/null b/src/tests/flags.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/flags.rs\n@@ -0,0 +1,23 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    let flags = TestFlags::FLAGS\n+        .iter()\n+        .map(|flag| (flag.name(), flag.value().bits()))\n+        .collect::<Vec<_>>();\n+\n+    assert_eq!(\n+        vec![\n+            (\"A\", 1u8),\n+            (\"B\", 1 << 1),\n+            (\"C\", 1 << 2),\n+            (\"ABC\", 1 | 1 << 1 | 1 << 2),\n+        ],\n+        flags,\n+    );\n+\n+    assert_eq!(0, TestEmpty::FLAGS.iter().count());\n+}\n\ndiff --git /dev/null b/src/tests/fmt.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/fmt.rs\n@@ -0,0 +1,70 @@\n+use super::*;\n+\n+#[test]\n+fn cases() {\n+    case(TestFlags::empty(), \"TestFlags(0x0)\", \"0\", \"0\", \"0\", \"0\");\n+    case(TestFlags::A, \"TestFlags(A)\", \"1\", \"1\", \"1\", \"1\");\n+    case(\n+        TestFlags::all(),\n+        \"TestFlags(A | B | C)\",\n+        \"7\",\n+        \"7\",\n+        \"7\",\n+        \"111\",\n+    );\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        \"TestFlags(0x8)\",\n+        \"8\",\n+        \"8\",\n+        \"10\",\n+        \"1000\",\n+    );\n+    case(\n+        TestFlags::A | TestFlags::from_bits_retain(1 << 3),\n+        \"TestFlags(A | 0x8)\",\n+        \"9\",\n+        \"9\",\n+        \"11\",\n+        \"1001\",\n+    );\n+\n+    case(TestZero::ZERO, \"TestZero(0x0)\", \"0\", \"0\", \"0\", \"0\");\n+    case(\n+        TestZero::ZERO | TestZero::from_bits_retain(1),\n+        \"TestZero(0x1)\",\n+        \"1\",\n+        \"1\",\n+        \"1\",\n+        \"1\",\n+    );\n+\n+    case(TestZeroOne::ONE, \"TestZeroOne(ONE)\", \"1\", \"1\", \"1\", \"1\");\n+\n+    case(\n+        TestOverlapping::from_bits_retain(1 << 1),\n+        \"TestOverlapping(0x2)\",\n+        \"2\",\n+        \"2\",\n+        \"2\",\n+        \"10\",\n+    );\n+}\n+\n+#[track_caller]\n+fn case<\n+    T: std::fmt::Debug + std::fmt::UpperHex + std::fmt::LowerHex + std::fmt::Octal + std::fmt::Binary,\n+>(\n+    value: T,\n+    debug: &str,\n+    uhex: &str,\n+    lhex: &str,\n+    oct: &str,\n+    bin: &str,\n+) {\n+    assert_eq!(debug, format!(\"{:?}\", value));\n+    assert_eq!(uhex, format!(\"{:X}\", value));\n+    assert_eq!(lhex, format!(\"{:x}\", value));\n+    assert_eq!(oct, format!(\"{:o}\", value));\n+    assert_eq!(bin, format!(\"{:b}\", value));\n+}\n\ndiff --git /dev/null b/src/tests/from_bits.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/from_bits.rs\n@@ -0,0 +1,43 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(Some(0), 0, TestFlags::from_bits);\n+    case(Some(1), 1, TestFlags::from_bits);\n+    case(\n+        Some(1 | 1 << 1 | 1 << 2),\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits,\n+    );\n+\n+    case(None, 1 << 3, TestFlags::from_bits);\n+    case(None, 1 | 1 << 3, TestFlags::from_bits);\n+\n+    case(Some(1 | 1 << 1), 1 | 1 << 1, TestOverlapping::from_bits);\n+\n+    case(None, 1 << 1, TestOverlapping::from_bits);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(\n+    expected: Option<T::Bits>,\n+    input: T::Bits,\n+    inherent: impl FnOnce(T::Bits) -> Option<T>,\n+) where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).map(|f| f.bits()),\n+        \"T::from_bits({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_bits(input).map(|f| f.bits()),\n+        \"Flags::from_bits({:?})\",\n+        input\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/from_bits_retain.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/from_bits_retain.rs\n@@ -0,0 +1,36 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, TestFlags::from_bits_retain);\n+    case(1, TestFlags::from_bits_retain);\n+    case(1 | 1 << 1 | 1 << 2, TestFlags::from_bits_retain);\n+\n+    case(1 << 3, TestFlags::from_bits_retain);\n+    case(1 | 1 << 3, TestFlags::from_bits_retain);\n+\n+    case(1 | 1 << 1, TestOverlapping::from_bits_retain);\n+\n+    case(1 << 1, TestOverlapping::from_bits_retain);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(input: T::Bits, inherent: impl FnOnce(T::Bits) -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        input,\n+        inherent(input).bits(),\n+        \"T::from_bits_retain({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        input,\n+        T::from_bits_retain(input).bits(),\n+        \"Flags::from_bits_retain({:?})\",\n+        input\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/from_bits_truncate.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/from_bits_truncate.rs\n@@ -0,0 +1,40 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(0, 0, TestFlags::from_bits_truncate);\n+    case(1, 1, TestFlags::from_bits_truncate);\n+    case(\n+        1 | 1 << 1 | 1 << 2,\n+        1 | 1 << 1 | 1 << 2,\n+        TestFlags::from_bits_truncate,\n+    );\n+\n+    case(0, 1 << 3, TestFlags::from_bits_truncate);\n+    case(1, 1 | 1 << 3, TestFlags::from_bits_truncate);\n+\n+    case(1 | 1 << 1, 1 | 1 << 1, TestOverlapping::from_bits_truncate);\n+\n+    case(0, 1 << 1, TestOverlapping::from_bits_truncate);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: T::Bits, input: T::Bits, inherent: impl FnOnce(T::Bits) -> T)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).bits(),\n+        \"T::from_bits_truncate({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_bits_truncate(input).bits(),\n+        \"Flags::from_bits_truncate({:?})\",\n+        input\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/from_name.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/from_name.rs\n@@ -0,0 +1,38 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(Some(1), \"A\", TestFlags::from_name);\n+    case(Some(1 << 1), \"B\", TestFlags::from_name);\n+    case(Some(1 | 1 << 1 | 1 << 2), \"ABC\", TestFlags::from_name);\n+\n+    case(None, \"\", TestFlags::from_name);\n+    case(None, \"a\", TestFlags::from_name);\n+    case(None, \"0x1\", TestFlags::from_name);\n+    case(None, \"A | B\", TestFlags::from_name);\n+\n+    case(Some(0), \"ZERO\", TestZero::from_name);\n+\n+    case(Some(2), \"\u4e8c\", TestUnicode::from_name);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags>(expected: Option<T::Bits>, input: &str, inherent: impl FnOnce(&str) -> Option<T>)\n+where\n+    <T as Flags>::Bits: std::fmt::Debug + PartialEq,\n+{\n+    assert_eq!(\n+        expected,\n+        inherent(input).map(|f| f.bits()),\n+        \"T::from_name({:?})\",\n+        input\n+    );\n+    assert_eq!(\n+        expected,\n+        T::from_name(input).map(|f| f.bits()),\n+        \"Flags::from_name({:?})\",\n+        input\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/insert.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/insert.rs\n@@ -0,0 +1,91 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::A | TestFlags::B, 1 | 1 << 1),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::insert,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::empty(), 1),\n+            (TestFlags::B, 1 | 1 << 1),\n+        ],\n+        TestFlags::insert,\n+        TestFlags::set,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_insert: impl FnMut(&mut T, T),\n+    mut inherent_set: impl FnMut(&mut T, T, bool),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_insert(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.insert({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::insert(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::insert({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_set(&mut value, *input, true);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.set({:?}, true)\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::set(&mut value, *input, true);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::set({:?}, {:?}, true)\",\n+            value,\n+            input\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/intersection.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/intersection.rs\n@@ -0,0 +1,79 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[(TestFlags::empty(), 0), (TestFlags::all(), 0)],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestFlags::all(),\n+        &[\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::A, 1),\n+            (TestFlags::from_bits_retain(1 << 3), 0),\n+        ],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[(TestFlags::from_bits_retain(1 << 3), 1 << 3)],\n+        TestFlags::intersection,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[(TestOverlapping::BC, 1 << 1)],\n+        TestOverlapping::intersection,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitAnd<Output = T> + std::ops::BitAndAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.intersection({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::intersection(value, *input).bits(),\n+            \"Flags::intersection({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value & *input).bits(),\n+            \"{:?} & {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value &= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} &= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/intersects.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/intersects.rs\n@@ -0,0 +1,91 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, true),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+            (TestFlags::from_bits_retain(1 | (1 << 3)), true),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, true),\n+            (TestFlags::B, true),\n+            (TestFlags::C, true),\n+            (TestFlags::ABC, true),\n+            (TestFlags::from_bits_retain(1 << 3), false),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::empty(), false),\n+            (TestFlags::A, false),\n+            (TestFlags::B, false),\n+            (TestFlags::C, false),\n+            (TestFlags::from_bits_retain(1 << 3), true),\n+        ],\n+        TestFlags::intersects,\n+    );\n+\n+    case(\n+        TestOverlapping::AB,\n+        &[\n+            (TestOverlapping::AB, true),\n+            (TestOverlapping::BC, true),\n+            (TestOverlapping::from_bits_retain(1 << 1), true),\n+        ],\n+        TestOverlapping::intersects,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, bool)],\n+    mut inherent: impl FnMut(&T, T) -> bool,\n+) {\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(&value, *input),\n+            \"{:?}.intersects({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::intersects(&value, *input),\n+            \"Flags::intersects({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/is_all.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/is_all.rs\n@@ -0,0 +1,32 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(false, TestFlags::empty(), TestFlags::is_all);\n+    case(false, TestFlags::A, TestFlags::is_all);\n+\n+    case(true, TestFlags::ABC, TestFlags::is_all);\n+\n+    case(\n+        true,\n+        TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::is_all,\n+    );\n+\n+    case(true, TestZero::empty(), TestZero::is_all);\n+\n+    case(true, TestEmpty::empty(), TestEmpty::is_all);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(expected: bool, value: T, inherent: impl FnOnce(&T) -> bool) {\n+    assert_eq!(expected, inherent(&value), \"{:?}.is_all()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::is_all(&value),\n+        \"Flags::is_all({:?})\",\n+        value\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/is_empty.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/is_empty.rs\n@@ -0,0 +1,31 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(true, TestFlags::empty(), TestFlags::is_empty);\n+\n+    case(false, TestFlags::A, TestFlags::is_empty);\n+    case(false, TestFlags::ABC, TestFlags::is_empty);\n+    case(\n+        false,\n+        TestFlags::from_bits_retain(1 << 3),\n+        TestFlags::is_empty,\n+    );\n+\n+    case(true, TestZero::empty(), TestZero::is_empty);\n+\n+    case(true, TestEmpty::empty(), TestEmpty::is_empty);\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug>(expected: bool, value: T, inherent: impl FnOnce(&T) -> bool) {\n+    assert_eq!(expected, inherent(&value), \"{:?}.is_empty()\", value);\n+    assert_eq!(\n+        expected,\n+        Flags::is_empty(&value),\n+        \"Flags::is_empty({:?})\",\n+        value\n+    );\n+}\n\ndiff --git /dev/null b/src/tests/iter.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/iter.rs\n@@ -0,0 +1,186 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn roundtrip() {\n+    for a in 0u8..=255 {\n+        for b in 0u8..=255 {\n+            let f = TestFlags::from_bits_retain(a | b);\n+\n+            assert_eq!(f, f.iter().collect::<TestFlags>());\n+            assert_eq!(\n+                TestFlags::from_bits_truncate(f.bits()),\n+                f.iter_names().map(|(_, f)| f).collect::<TestFlags>()\n+            );\n+        }\n+    }\n+}\n+\n+mod collect {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        assert_eq!(0, [].into_iter().collect::<TestFlags>().bits());\n+\n+        assert_eq!(1, [TestFlags::A,].into_iter().collect::<TestFlags>().bits());\n+\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            [TestFlags::A, TestFlags::B | TestFlags::C,]\n+                .into_iter()\n+                .collect::<TestFlags>()\n+                .bits()\n+        );\n+\n+        assert_eq!(\n+            1 | 1 << 3,\n+            [\n+                TestFlags::from_bits_retain(1 << 3),\n+                TestFlags::empty(),\n+                TestFlags::A,\n+            ]\n+            .into_iter()\n+            .collect::<TestFlags>()\n+            .bits()\n+        );\n+    }\n+}\n+\n+mod iter {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        case(&[], TestFlags::empty(), TestFlags::iter);\n+\n+        case(&[1], TestFlags::A, TestFlags::iter);\n+        case(&[1, 1 << 1], TestFlags::A | TestFlags::B, TestFlags::iter);\n+        case(\n+            &[1, 1 << 1, 1 << 3],\n+            TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter,\n+        );\n+\n+        case(&[1, 1 << 1, 1 << 2], TestFlags::ABC, TestFlags::iter);\n+        case(\n+            &[1, 1 << 1, 1 << 2, 1 << 3],\n+            TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter,\n+        );\n+\n+        case(\n+            &[1 | 1 << 1 | 1 << 2],\n+            TestFlagsInvert::ABC,\n+            TestFlagsInvert::iter,\n+        );\n+\n+        case(&[], TestZero::ZERO, TestZero::iter);\n+    }\n+\n+    #[track_caller]\n+    fn case<T: Flags + std::fmt::Debug + IntoIterator<Item = T> + Copy>(\n+        expected: &[T::Bits],\n+        value: T,\n+        inherent: impl FnOnce(&T) -> crate::iter::Iter<T>,\n+    ) where\n+        T::Bits: std::fmt::Debug + PartialEq,\n+    {\n+        assert_eq!(\n+            expected,\n+            inherent(&value).map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"{:?}.iter()\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            Flags::iter(&value).map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"Flags::iter({:?})\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            value.into_iter().map(|f| f.bits()).collect::<Vec<_>>(),\n+            \"{:?}.into_iter()\",\n+            value\n+        );\n+    }\n+}\n+\n+mod iter_names {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        case(&[], TestFlags::empty(), TestFlags::iter_names);\n+\n+        case(&[(\"A\", 1)], TestFlags::A, TestFlags::iter_names);\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1)],\n+            TestFlags::A | TestFlags::B,\n+            TestFlags::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1)],\n+            TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter_names,\n+        );\n+\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1), (\"C\", 1 << 2)],\n+            TestFlags::ABC,\n+            TestFlags::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"B\", 1 << 1), (\"C\", 1 << 2)],\n+            TestFlags::ABC | TestFlags::from_bits_retain(1 << 3),\n+            TestFlags::iter_names,\n+        );\n+\n+        case(\n+            &[(\"ABC\", 1 | 1 << 1 | 1 << 2)],\n+            TestFlagsInvert::ABC,\n+            TestFlagsInvert::iter_names,\n+        );\n+\n+        case(&[], TestZero::ZERO, TestZero::iter_names);\n+\n+        case(\n+            &[(\"A\", 1)],\n+            TestOverlappingFull::A,\n+            TestOverlappingFull::iter_names,\n+        );\n+        case(\n+            &[(\"A\", 1), (\"D\", 1 << 1)],\n+            TestOverlappingFull::A | TestOverlappingFull::D,\n+            TestOverlappingFull::iter_names,\n+        );\n+    }\n+\n+    #[track_caller]\n+    fn case<T: Flags + std::fmt::Debug>(\n+        expected: &[(&'static str, T::Bits)],\n+        value: T,\n+        inherent: impl FnOnce(&T) -> crate::iter::IterNames<T>,\n+    ) where\n+        T::Bits: std::fmt::Debug + PartialEq,\n+    {\n+        assert_eq!(\n+            expected,\n+            inherent(&value)\n+                .map(|(n, f)| (n, f.bits()))\n+                .collect::<Vec<_>>(),\n+            \"{:?}.iter_names()\",\n+            value\n+        );\n+        assert_eq!(\n+            expected,\n+            Flags::iter_names(&value)\n+                .map(|(n, f)| (n, f.bits()))\n+                .collect::<Vec<_>>(),\n+            \"Flags::iter_names({:?})\",\n+            value\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/parser.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/parser.rs\n@@ -0,0 +1,115 @@\n+use super::*;\n+\n+use crate::{\n+    parser::{from_str, to_writer},\n+    Flags,\n+};\n+\n+#[test]\n+fn roundtrip() {\n+    let mut s = String::new();\n+\n+    for a in 0u8..=255 {\n+        for b in 0u8..=255 {\n+            let f = TestFlags::from_bits_retain(a | b);\n+\n+            s.clear();\n+            to_writer(&f, &mut s).unwrap();\n+\n+            assert_eq!(f, from_str::<TestFlags>(&s).unwrap());\n+        }\n+    }\n+}\n+\n+mod from_str {\n+    use super::*;\n+\n+    #[test]\n+    fn valid() {\n+        assert_eq!(0, from_str::<TestFlags>(\"\").unwrap().bits());\n+\n+        assert_eq!(1, from_str::<TestFlags>(\"A\").unwrap().bits());\n+        assert_eq!(1, from_str::<TestFlags>(\" A \").unwrap().bits());\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A | B | C\").unwrap().bits()\n+        );\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A\\n|\\tB\\r\\n|   C \").unwrap().bits()\n+        );\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 2,\n+            from_str::<TestFlags>(\"A|B|C\").unwrap().bits()\n+        );\n+\n+        assert_eq!(1 << 3, from_str::<TestFlags>(\"0x8\").unwrap().bits());\n+        assert_eq!(1 | 1 << 3, from_str::<TestFlags>(\"A | 0x8\").unwrap().bits());\n+        assert_eq!(\n+            1 | 1 << 1 | 1 << 3,\n+            from_str::<TestFlags>(\"0x1 | 0x8 | B\").unwrap().bits()\n+        );\n+\n+        assert_eq!(\n+            1 | 1 << 1,\n+            from_str::<TestUnicode>(\"\u4e00 | \u4e8c\").unwrap().bits()\n+        );\n+    }\n+\n+    #[test]\n+    fn invalid() {\n+        assert!(from_str::<TestFlags>(\"a\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"unrecognized named flag\"));\n+        assert!(from_str::<TestFlags>(\"A & B\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"unrecognized named flag\"));\n+\n+        assert!(from_str::<TestFlags>(\"0xg\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"invalid hex flag\"));\n+        assert!(from_str::<TestFlags>(\"0xffffffffffff\")\n+            .unwrap_err()\n+            .to_string()\n+            .starts_with(\"invalid hex flag\"));\n+    }\n+}\n+\n+mod to_writer {\n+    use super::*;\n+\n+    #[test]\n+    fn cases() {\n+        assert_eq!(\"\", write(TestFlags::empty()));\n+        assert_eq!(\"A\", write(TestFlags::A));\n+        assert_eq!(\"A | B | C\", write(TestFlags::all()));\n+        assert_eq!(\"0x8\", write(TestFlags::from_bits_retain(1 << 3)));\n+        assert_eq!(\n+            \"A | 0x8\",\n+            write(TestFlags::A | TestFlags::from_bits_retain(1 << 3))\n+        );\n+\n+        assert_eq!(\"\", write(TestZero::ZERO));\n+\n+        assert_eq!(\"ABC\", write(TestFlagsInvert::all()));\n+\n+        assert_eq!(\"A\", write(TestOverlappingFull::C));\n+        assert_eq!(\n+            \"A | D\",\n+            write(TestOverlappingFull::C | TestOverlappingFull::D)\n+        );\n+    }\n+\n+    fn write<F: Flags>(value: F) -> String\n+    where\n+        F::Bits: crate::parser::WriteHex,\n+    {\n+        let mut s = String::new();\n+\n+        to_writer(&value, &mut s).unwrap();\n+        s\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/remove.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/remove.rs\n@@ -0,0 +1,100 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 0),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 0),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::A, 0),\n+            (TestFlags::empty(), 1),\n+            (TestFlags::B, 1),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+\n+    case(\n+        TestFlags::ABC,\n+        &[\n+            (TestFlags::A, 1 << 1 | 1 << 2),\n+            (TestFlags::A | TestFlags::C, 1 << 1),\n+        ],\n+        TestFlags::remove,\n+        TestFlags::set,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_remove: impl FnMut(&mut T, T),\n+    mut inherent_set: impl FnMut(&mut T, T, bool),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_remove(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.remove({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::remove(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::remove({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_set(&mut value, *input, false);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.set({:?}, false)\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::set(&mut value, *input, false);\n+                value\n+            }\n+            .bits(),\n+            \"Flags::set({:?}, {:?}, false)\",\n+            value,\n+            input\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/symmetric_difference.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/symmetric_difference.rs\n@@ -0,0 +1,110 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::empty(), 0),\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+\n+    case(\n+        TestFlags::A,\n+        &[\n+            (TestFlags::empty(), 1),\n+            (TestFlags::A, 0),\n+            (TestFlags::all(), 1 << 1 | 1 << 2),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+\n+    case(\n+        TestFlags::A | TestFlags::B | TestFlags::from_bits_retain(1 << 3),\n+        &[\n+            (TestFlags::ABC, 1 << 2 | 1 << 3),\n+            (TestFlags::from_bits_retain(1 << 3), 1 | 1 << 1),\n+        ],\n+        TestFlags::symmetric_difference,\n+        TestFlags::toggle,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitXor<Output = T> + std::ops::BitXorAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent_sym_diff: impl FnMut(T, T) -> T,\n+    mut inherent_toggle: impl FnMut(&mut T, T),\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent_sym_diff(value, *input).bits(),\n+            \"{:?}.symmetric_difference({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::symmetric_difference(value, *input).bits(),\n+            \"Flags::symmetric_difference({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value ^ *input).bits(),\n+            \"{:?} ^ {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value ^= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} ^= {:?}\",\n+            value,\n+            input,\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                inherent_toggle(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.toggle({:?})\",\n+            value,\n+            input,\n+        );\n+\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                Flags::toggle(&mut value, *input);\n+                value\n+            }\n+            .bits(),\n+            \"{:?}.toggle({:?})\",\n+            value,\n+            input,\n+        );\n+    }\n+}\n\ndiff --git /dev/null b/src/tests/union.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/tests/union.rs\n@@ -0,0 +1,71 @@\n+use super::*;\n+\n+use crate::Flags;\n+\n+#[test]\n+fn cases() {\n+    case(\n+        TestFlags::empty(),\n+        &[\n+            (TestFlags::A, 1),\n+            (TestFlags::all(), 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::empty(), 0),\n+            (TestFlags::from_bits_retain(1 << 3), 1 << 3),\n+        ],\n+        TestFlags::union,\n+    );\n+\n+    case(\n+        TestFlags::A | TestFlags::C,\n+        &[\n+            (TestFlags::A | TestFlags::B, 1 | 1 << 1 | 1 << 2),\n+            (TestFlags::A, 1 | 1 << 2),\n+        ],\n+        TestFlags::union,\n+    );\n+}\n+\n+#[track_caller]\n+fn case<T: Flags + std::fmt::Debug + std::ops::BitOr<Output = T> + std::ops::BitOrAssign + Copy>(\n+    value: T,\n+    inputs: &[(T, T::Bits)],\n+    mut inherent: impl FnMut(T, T) -> T,\n+) where\n+    T::Bits: std::fmt::Debug + PartialEq + Copy,\n+{\n+    for (input, expected) in inputs {\n+        assert_eq!(\n+            *expected,\n+            inherent(value, *input).bits(),\n+            \"{:?}.union({:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            Flags::union(value, *input).bits(),\n+            \"Flags::union({:?}, {:?})\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            (value | *input).bits(),\n+            \"{:?} | {:?}\",\n+            value,\n+            input\n+        );\n+        assert_eq!(\n+            *expected,\n+            {\n+                let mut value = value;\n+                value |= *input;\n+                value\n+            }\n+            .bits(),\n+            \"{:?} |= {:?}\",\n+            value,\n+            input,\n+        );\n+    }\n+}\n"
    }
]